/* This file was generated by the Hex-Rays decompiler version 8.0.0.220729.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <stdarg.h>
#include <csetjmp>
#include <direct.h>
#include <dsound.h>
#include <dinput.h>

#include <immintrin.h>
#include <stdint.h>
#include <stdio.h>

#pragma once
/*

   This file contains definitions used by the Hex-Rays decompiler output.
   It has type definitions and convenience macros to make the
   output more readable.

   Copyright (c) 2007 Hex-Rays

*/

#define __noreturn  __declspec(noreturn)
#if defined(__GNUC__)
#define __noreturn  __attribute__((noreturn))
typedef          long long ll;
typedef unsigned long long ull;
#define __int64 long long
#define __int32 int
#define __int16 short
#define __int8  char
#define MAKELL(num) num ## LL
#define FMT_64 "ll"
#elif defined(_MSC_VER)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "I64"
#elif defined (__BORLANDC__)
typedef          __int64 ll;
typedef unsigned __int64 ull;
#define MAKELL(num) num ## i64
#define FMT_64 "L"
#else
#error "unknown compiler"
#endif

typedef unsigned int uint;
typedef unsigned char uchar;
typedef unsigned short ushort;
//typedef unsigned long ulong;

typedef          char   int8;
typedef   signed char   sint8;
typedef unsigned char   uint8;
typedef          short  int16;
typedef   signed short  sint16;
typedef unsigned short  uint16;
typedef          int    int32;
typedef   signed int    sint32;
typedef unsigned int    uint32;
typedef ll              int64;
typedef ll              sint64;
typedef ull             uint64;

// Partially defined types:
#define _BYTE  uint8
#define _WORD  uint16
#define _DWORD uint32
#define _QWORD uint64
#if !defined(_MSC_VER)
#define _LONGLONG __int128
#endif

#ifndef _WINDOWS_
typedef int8 BYTE;
typedef int16 WORD;
typedef int32 DWORD;
typedef int32 LONG;
#endif
typedef int64 QWORD;
#ifndef __cplusplus
typedef int bool;       // we want to use bool in our C programs
#endif

// Some convenience macros to make partial accesses nicer
// first unsigned macros:
#define LOBYTE(x)   (*((_BYTE*)&(x)))   // low byte
#define LOWORD(x)   (*((_WORD*)&(x)))   // low word
#define LODWORD(x)  (*((_DWORD*)&(x)))  // low dword
#define HIBYTE(x)   (*((_BYTE*)&(x)+1))
#define HIWORD(x)   (*((_WORD*)&(x)+1))
#define HIDWORD(x)  (*((_DWORD*)&(x)+1))
#define BYTEn(x, n)   (*((_BYTE*)&(x)+n))
#define WORDn(x, n)   (*((_WORD*)&(x)+n))
#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)
#define BYTE2(x)   BYTEn(x,  2)
#define BYTE3(x)   BYTEn(x,  3)
#define BYTE4(x)   BYTEn(x,  4)
#define BYTE5(x)   BYTEn(x,  5)
#define BYTE6(x)   BYTEn(x,  6)
#define BYTE7(x)   BYTEn(x,  7)
#define BYTE8(x)   BYTEn(x,  8)
#define BYTE9(x)   BYTEn(x,  9)
#define BYTE10(x)  BYTEn(x, 10)
#define BYTE11(x)  BYTEn(x, 11)
#define BYTE12(x)  BYTEn(x, 12)
#define BYTE13(x)  BYTEn(x, 13)
#define BYTE14(x)  BYTEn(x, 14)
#define BYTE15(x)  BYTEn(x, 15)
#define WORD1(x)   WORDn(x,  1)
#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned
#define WORD3(x)   WORDn(x,  3)
#define WORD4(x)   WORDn(x,  4)
#define WORD5(x)   WORDn(x,  5)
#define WORD6(x)   WORDn(x,  6)
#define WORD7(x)   WORDn(x,  7)

// now signed macros (the same but with sign extension)
#define SLOBYTE(x)   (*((int8*)&(x)))
#define SLOWORD(x)   (*((int16*)&(x)))
#define SLODWORD(x)  (*((int32*)&(x)))
#define SHIBYTE(x)   (*((int8*)&(x)+1))
#define SHIWORD(x)   (*((int16*)&(x)+1))
#define SHIDWORD(x)  (*((int32*)&(x)+1))
#define SBYTEn(x, n)   (*((int8*)&(x)+n))
#define SWORDn(x, n)   (*((int16*)&(x)+n))
#define SBYTE1(x)   SBYTEn(x,  1)
#define SBYTE2(x)   SBYTEn(x,  2)
#define SBYTE3(x)   SBYTEn(x,  3)
#define SBYTE4(x)   SBYTEn(x,  4)
#define SBYTE5(x)   SBYTEn(x,  5)
#define SBYTE6(x)   SBYTEn(x,  6)
#define SBYTE7(x)   SBYTEn(x,  7)
#define SBYTE8(x)   SBYTEn(x,  8)
#define SBYTE9(x)   SBYTEn(x,  9)
#define SBYTE10(x)  SBYTEn(x, 10)
#define SBYTE11(x)  SBYTEn(x, 11)
#define SBYTE12(x)  SBYTEn(x, 12)
#define SBYTE13(x)  SBYTEn(x, 13)
#define SBYTE14(x)  SBYTEn(x, 14)
#define SBYTE15(x)  SBYTEn(x, 15)
#define SWORD1(x)   SWORDn(x,  1)
#define SWORD2(x)   SWORDn(x,  2)
#define SWORD3(x)   SWORDn(x,  3)
#define SWORD4(x)   SWORDn(x,  4)
#define SWORD5(x)   SWORDn(x,  5)
#define SWORD6(x)   SWORDn(x,  6)
#define SWORD7(x)   SWORDn(x,  7)

// Helper functions to represent some assembly instructions.

#ifdef __cplusplus

// Fill memory block with an integer value
inline void memset32(void* ptr, uint32 value, int count) {
    uint32* p = (uint32*) ptr;
    for(int i = 0; i < count; i++)
        *p++ = value;
}

// Generate a reference to pair of operands
template<class T>  int16 __PAIR__(int8  high, T low) { return (((int16) high) << sizeof(high) * 8) | uint8(low); }
template<class T>  int32 __PAIR__(int16 high, T low) { return (((int32) high) << sizeof(high) * 8) | uint16(low); }
template<class T>  int64 __PAIR__(int32 high, T low) { return (((int64) high) << sizeof(high) * 8) | uint32(low); }
template<class T> uint16 __PAIR__(uint8  high, T low) { return (((uint16) high) << sizeof(high) * 8) | uint8(low); }
template<class T> uint32 __PAIR__(uint16 high, T low) { return (((uint32) high) << sizeof(high) * 8) | uint16(low); }
template<class T> uint64 __PAIR__(uint32 high, T low) { return (((uint64) high) << sizeof(high) * 8) | uint32(low); }

// rotate left
template<class T> T __ROL__(T value, uint count) {
    const uint nbits = sizeof(T) * 8;
    count %= nbits;

    T high = value >> (nbits - count);
    value <<= count;
    value |= high;
    return value;
}

// rotate right
template<class T> T __ROR__(T value, uint count) {
    const uint nbits = sizeof(T) * 8;
    count %= nbits;

    T low = value << (nbits - count);
    value >>= count;
    value |= low;
    return value;
}

// carry flag of left shift
template<class T> int8 __MKCSHL__(T value, uint count) {
    const uint nbits = sizeof(T) * 8;
    count %= nbits;

    return (value >> (nbits - count)) & 1;
}

// carry flag of right shift
template<class T> int8 __MKCSHR__(T value, uint count) {
    return (value >> (count - 1)) & 1;
}

// sign flag
template<class T> int8 __SETS__(T x) {
    if(sizeof(T) == 1)
        return int8(x) < 0;
    if(sizeof(T) == 2)
        return int16(x) < 0;
    if(sizeof(T) == 4)
        return int32(x) < 0;
    return int64(x) < 0;
}

// overflow flag of subtraction (x-y)
template<class T, class U> int8 __OFSUB__(T x, U y) {
    if(sizeof(T) < sizeof(U)) {
        U x2 = x;
        int8 sx = __SETS__(x2);
        return (sx ^ __SETS__(y)) & (sx ^ __SETS__(x2 - y));
    }
    else {
        T y2 = y;
        int8 sx = __SETS__(x);
        return (sx ^ __SETS__(y2)) & (sx ^ __SETS__(x - y2));
    }
}

// overflow flag of addition (x+y)
template<class T, class U> int8 __OFADD__(T x, U y) {
    if(sizeof(T) < sizeof(U)) {
        U x2 = x;
        int8 sx = __SETS__(x2);
        return ((1 ^ sx) ^ __SETS__(y)) & (sx ^ __SETS__(x2 + y));
    }
    else {
        T y2 = y;
        int8 sx = __SETS__(x);
        return ((1 ^ sx) ^ __SETS__(y2)) & (sx ^ __SETS__(x + y2));
    }
}

// carry flag of subtraction (x-y)
template<class T, class U> int8 __CFSUB__(T x, U y) {
    int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
    if(size == 1)
        return uint8(x) < uint8(y);
    if(size == 2)
        return uint16(x) < uint16(y);
    if(size == 4)
        return uint32(x) < uint32(y);
    return uint64(x) < uint64(y);
}

// carry flag of addition (x+y)
template<class T, class U> int8 __CFADD__(T x, U y) {
    int size = sizeof(T) > sizeof(U) ? sizeof(T) : sizeof(U);
    if(size == 1)
        return uint8(x) > uint8(x + y);
    if(size == 2)
        return uint16(x) > uint16(x + y);
    if(size == 4)
        return uint32(x) > uint32(x + y);
    return uint64(x) > uint64(x + y);
}

#else
// The following definition is not quite correct because it always returns
// uint64. The above C++ functions are good, though.
#define __PAIR__(high, low) (((uint64)(high)<<sizeof(high)*8) | low)
// For C, we just provide macros, they are not quite correct.
#define __ROL__(x, y) __rotl__(x, y)      // Rotate left
#define __ROR__(x, y) __rotr__(x, y)      // Rotate right
#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x<<y)
#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x>>y)
#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)
#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)
#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)
#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)
#endif

// No definition for rcl/rcr because the carry flag is unknown
#define __RCL__(x, y)    invalid_operation // Rotate left thru carry
#define __RCR__(x, y)    invalid_operation // Rotate right thru carry
#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL
#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR
#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)

// In the decompilation listing there are some objects declarared as _UNKNOWN
// because we could not determine their types. Since the C compiler does not
// accept void item declarations, we replace them by anything of our choice,
// for example a char:

#define _UNKNOWN char

#ifdef _MSC_VER
#define snprintf _snprintf
#define vsnprintf _vsnprintf
#endif

//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

int __thiscall sub_401000(int this);
void* __thiscall sub_4010E0(void* this);
int __cdecl sub_401140(int a1);
int __cdecl sub_401250(_DWORD* a1);
int __cdecl sub_401290(int a1);
int sub_4012C0();
int __cdecl sub_4013A0(_DWORD* a1);
_DWORD* __thiscall sub_401410(_DWORD* this);
int sub_4014D0();
void sub_401500();
int __fastcall sub_401530(_DWORD* a1, int a2, _DWORD* a3, char* a4);
int sub_401650(_DWORD* a1, _DWORD* a2, char* Format, ...);
_DWORD* __thiscall sub_4016B0(_DWORD* this);
_DWORD* __thiscall sub_401940(_DWORD* this, _DWORD* a2, int a3, int a4);
_DWORD* __thiscall sub_401A60(_DWORD* this, _DWORD* a2, int a3, int a4);
int __thiscall sub_401B80(_WORD* this);
int __thiscall sub_402740(_DWORD* this);
int __thiscall sub_402870(_WORD* this);
int __thiscall sub_403060(int* this);
int __thiscall sub_4031E0(int this);
int __thiscall sub_4033B0(int this);
_DWORD* __thiscall sub_403580(_DWORD* this);
_DWORD* __cdecl sub_403670(_DWORD* a1);
int __thiscall sub_403720(int this);
_DWORD* __thiscall sub_403790(_DWORD* this);
int __cdecl sub_403810(int a1);
int __cdecl sub_4040D0(int a1);
int __cdecl sub_404180(int a1);
int __cdecl sub_404300(int a1);
int __cdecl sub_4044C0(int a1);
int __cdecl sub_4045E0(void** a1);
void sub_404650();
int __thiscall sub_404690(void** this, char* a2, char* Str);
int __thiscall sub_404860(_DWORD* this);
int __thiscall sub_404970(void* this, int a2);
int __thiscall sub_4051B0(int* this, int a2, int a3);
void __cdecl sub_405260(int a1);
int __cdecl sub_405C10(int a1);
int __cdecl sub_406020(int a1);
void __cdecl sub_406160(int a1);
int __cdecl sub_4065E0(int a1);
void __cdecl sub_4066F0(int a1);
int __cdecl sub_406B10(int a1);
void __cdecl sub_406E70(int a1);
int __cdecl sub_4071B0(_DWORD* a1);
int __thiscall sub_407340(__int16** this, char* Str);
void __thiscall sub_407400(void** this);
int __thiscall sub_407440(_DWORD* this, int a2, __int16 a3);
int __stdcall sub_4074A0(_DWORD* a1);
int __cdecl sub_40ABE0(int a1, int a2);
int __cdecl sub_40AD10(int a1, int a2);
int __cdecl sub_40AE80(int a1, int a2);
float* __cdecl sub_40AFB0(float* a1, float* a2, _DWORD* a3);
int* __cdecl sub_40B380(float* a1, float* a2, _DWORD* a3);
float* __cdecl sub_40B3C0(float* a1, float a2, float* a3);
float* __cdecl sub_40B420(float* a1, float a2, float* a3, float* a4);
float* __cdecl sub_40B4D0(float* a1, float a2, float* a3, float* a4);
float* __cdecl sub_40B580(float* a1, float a2, float* a3, float* a4);
float* __cdecl sub_40B650(float* a1, float a2, float* a3, float* a4);
float* __cdecl sub_40B700(float* a1, float a2, float* a3, float* a4);
float* __cdecl sub_40B7D0(float* a1, float a2, float* a3, float* a4, float* a5, float* a6);
double __cdecl sub_40B890(float* a1);
_DWORD* __cdecl sub_40B8E0(int a1, int a2);
int __cdecl sub_40BA80(float* a1, int a2);
int __cdecl sub_40BB80(int a1);
int __cdecl sub_40C100(_DWORD* a1);
int __cdecl sub_40C180(int a1, int a2);
int __cdecl sub_40C5B0(int a1);
void __cdecl sub_40CAF0(int a1);
void __cdecl sub_40D040(float* a1, int a2);
int __cdecl sub_40D400(int a1);
void __cdecl sub_40D530(int a1);
void __cdecl sub_40D770(int a1);
void __cdecl sub_40D930(int a1);
int __cdecl sub_40DAA0(int a1);
int __cdecl sub_40DBC0(int a1, int a2);
int __cdecl sub_40DCC0(int a1);
int __cdecl sub_40DE00(__int64 a1);
void __cdecl sub_40E1B0(int a1, int a2);
void* __thiscall sub_40E2D0(void* this);
int __thiscall sub_40E340(void* this);
_DWORD* __thiscall sub_40EF50(_DWORD* this, int a2, _DWORD* a3, int a4, int a5);
int __cdecl sub_40F100(int a1);
int __cdecl sub_40F1F0(int a1);
int __cdecl sub_40F280(void* a1);
int sub_40F3D0();
int sub_40F3F0();
void sub_40F4A0();
int __thiscall sub_40F4D0(const char** this);
int __thiscall sub_40F550(int* this);
// int __usercall sub_40F7C0@<eax>(int a1@<ecx>, int a2@<ebx>);
int __thiscall sub_4106D0(_DWORD* this, char* Str);
int sub_4107B0();
_DWORD* __thiscall sub_4108B0(_DWORD* this);
// int __usercall sub_4109C0@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_410A70(int a1);
int __cdecl sub_410B10(_DWORD* a1);
int __cdecl sub_410D80(int a1);
int __thiscall sub_410E30(int this);
_DWORD* __thiscall sub_411190(_DWORD* this);
_DWORD* __thiscall sub_411240(_DWORD* this);
int __thiscall sub_411390(int this, __int16 a2, _DWORD* a3, __int16 a4, char a5, int a6);
int __cdecl sub_4114C0(int a1);
void __thiscall sub_411530(int* this);
int __thiscall sub_411DA0(int this);
int __thiscall sub_411F40(int this);
int __thiscall sub_4121B0(int this);
int __fastcall sub_412240(int a1);
int __cdecl sub_412320(int a1, int a2);
int __cdecl sub_4123E0(int a1);
int __cdecl sub_412E50(int a1);
int __cdecl sub_412F10(int a1);
int __cdecl sub_413220(int a1);
int sub_413320();
void sub_413350();
int __thiscall sub_413380(int this);
int __thiscall sub_413430(void* this);
_DWORD* __thiscall sub_413450(_DWORD* this);
void* __thiscall sub_413560(void* this);
int __thiscall sub_4135B0(_DWORD* this, float* a2, int a3, int a4, float a5);
int __thiscall sub_414160(char* this, int a2);
int __thiscall sub_414340(char* this);
int __thiscall sub_414360(char* this, int a2, int a3);
int __thiscall sub_4145C0(_DWORD* this, int a2);
int __thiscall sub_414670(void* this, __int16* a2);
int __cdecl sub_4148F0(int a1);
int __cdecl sub_4149D0(int a1);
int __cdecl sub_416500(int a1);
int __cdecl sub_416B50(unsigned int a1);
int __cdecl sub_416C50(unsigned int a1);
int __cdecl sub_416D60(int a1);
int sub_417270();
void sub_4172B0();
BOOL __thiscall sub_4172D3(_DWORD* this);
int __thiscall sub_417314(_DWORD* this);
int __thiscall sub_41732C(_DWORD* this);
int __thiscall sub_417344(_DWORD* this);
int __thiscall sub_41735A(_DWORD* this, int a2);
int __thiscall sub_4173D9(_DWORD* this, int a2);
int __thiscall sub_417458(_DWORD* this, int a2);
// int __usercall sub_4174D7@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_417502(int a1);
int* __thiscall sub_417ACD(int this, int a2, char* Format);
int* __thiscall sub_417BFD(int this, int a2, char* Format);
int __thiscall sub_417D29(int* this);
int __thiscall sub_418665(_DWORD* this, char* Str);
int __thiscall sub_41872A(_DWORD* this);
int __fastcall sub_418768(int a1, int a2, int a3);
int __fastcall sub_41878B(int a1, int a2, int a3);
// int __usercall sub_4188C9@<eax>(int a1@<ecx>, int a2@<ebx>);
int __thiscall sub_4190EC(int this);
BOOL __thiscall sub_419572(_DWORD* this);
BOOL __thiscall sub_4195A2(_DWORD* this);
int __thiscall sub_4195BF(int this);
int __thiscall sub_419C99(float* this);
int __thiscall sub_41ADF3(int this);
int __cdecl sub_41B1A4(int* a1);
int __cdecl sub_41B1B1(int a1);
int sub_41B252();
_DWORD* __thiscall sub_41B34B(_DWORD* this);
_DWORD* __thiscall sub_41B4C4(_DWORD* this);
void sub_41B58C();
int __thiscall sub_41B5AF(void* this);
BOOL __stdcall sub_41B5E1(float a1, float a2, float a3, float a4);
int __cdecl sub_41B663(int a1);
int __cdecl sub_41BA4A(int a1);
int sub_41BA6A();
// int __usercall sub_41BB02@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_41C1F7(int a1);
void sub_41C269();
int __cdecl sub_41C28C(float); // idb
int __cdecl sub_41C3F3(float); // idb
_DWORD* __fastcall sub_41C57E(_DWORD* a1, int a2, int a3);
_DWORD* __fastcall sub_41C5FA(_DWORD* a1, int a2, int a3);
float* __thiscall sub_41C676(float* this);
int __thiscall sub_41C6D0(void* this);
_DWORD* __thiscall sub_41C720(_DWORD* this);
int __thiscall sub_41C790(int this);
_DWORD* __thiscall sub_41C7F0(_DWORD* this);
int __thiscall sub_41C860(_DWORD* this, int a2, int a3);
int __thiscall sub_41C940(__int16* this, int a2, int a3);
int __thiscall sub_41CA10(char* this);
int __thiscall sub_41CAD0(char* this);
int __thiscall sub_41CB90(char* this, int a2);
int __thiscall sub_41CD10(char* this);
_DWORD* __stdcall sub_41CD40(int a1);
void __thiscall sub_41CDE0(char* this, int a2);
__int16 sub_41CF60();
__int16 __cdecl sub_41CFC0(__int16 a1);
int __cdecl sub_41D580(_WORD* a1, __int16 a2, unsigned __int16 a3, int a4);
int __cdecl sub_41D600(_WORD* a1, __int16 a2, unsigned __int16 a3, int a4);
char* sub_41D680();
__int16 sub_41D820();
BOOL sub_41E0C0();
HFONT __thiscall sub_41E150(_DWORD* this, int a2, int cWidth, int cHeight);
int __thiscall sub_41E210(_DWORD** this, int a2, int a3, int a4, int a5);
_DWORD** __thiscall sub_41E260(_DWORD** this);
void* __cdecl sub_41E290(char* Str, int a2);
int __cdecl sub_41E460(char* FileName, void* Buffer, size_t ElementCount); // idb
char* sub_41E4D0(int a1, char* Format, ...);
char* sub_41E620(int a1, char* Format, ...);
__int16 __thiscall sub_41E780(_DWORD* this);
int __thiscall sub_41E7F0(_DWORD* this);
double __thiscall sub_41E820(_DWORD* this);
double __cdecl sub_41E850(float a1, float a2);
float* __cdecl sub_41E8D0(float* a1, float* a2, float a3);
void sub_41E940();
_DWORD* __thiscall sub_41E945(_DWORD* this);
char __thiscall sub_41E981(void* this);
char __thiscall sub_41E992(void* this);
char __thiscall sub_41EA04(int* this, int a2, int a3, int a4);
char __thiscall sub_41EA63(int* this, int a2, int a3, int a4);
int* __stdcall sub_41EC22(int a1);
char __thiscall sub_41EC72(int* this, int a2, int a3, int a4, int a5);
char __thiscall sub_41EF11(void* this, int a2);
int sub_41F008();
int sub_41F02B();
char __cdecl sub_41F050(int a1, int a2, int a3, int a4, int a5, int a6, COLORREF a7, COLORREF color, LPCSTR lpString, int a10);
void* __thiscall sub_41F230(void* this);
int __thiscall sub_41F290(_DWORD* this, _DWORD* a2, int a3, int a4);
int __fastcall sub_41F4A0(int a1);
void* __thiscall sub_420130(char* this);
int __thiscall sub_420190(void* this);
int __stdcall sub_420330(HINSTANCE hInstance, int, int, int); // idb
int __thiscall sub_4206E0(int this);
int __thiscall sub_420B50(void* this);
int sub_420BD0();
HWND __cdecl sub_420C10(HINSTANCE hInstance);
LRESULT __stdcall sub_420D40(HWND hWnd, UINT Msg, int wParam, struct midihdr_tag* lParam);
int sub_420E60();
int sub_421420();
int sub_421900();
int __thiscall sub_421950(int this);
int __thiscall sub_4219D0(_DWORD** this);
int __thiscall sub_421A40(int this);
// int __thiscall unknown_libname_1(_DWORD); weak
int __thiscall sub_421AD0(HMIDIOUT* this);
BOOL __thiscall sub_421AF0(int this, UINT uDeviceID);
int __thiscall sub_421B50(HMIDIOUT* this);
BOOL __thiscall sub_421B90(HMIDIOUT* this, LPMIDIHDR pmh);
BOOL __thiscall sub_421BE0(HMIDIOUT* this, char a2, char a3, char a4);
struct timecaps_tag* __thiscall sub_421C30(struct timecaps_tag* this);
MMRESULT __thiscall sub_421C60(UINT* this);
UINT __thiscall sub_421C90(UINT* this, UINT uDelay, LPTIMECALLBACK fptc, DWORD_PTR dwUser);
int __thiscall sub_421D10(UINT* this);
void __stdcall fptc(UINT uTimerID, UINT uMsg, void(__thiscall*** dwUser)(_DWORD, _DWORD), DWORD_PTR dw1, DWORD_PTR dw2);
__int16 __cdecl sub_421D70(__int16 a1);
int __cdecl sub_421D90(_DWORD* a1);
int __thiscall sub_421DF0(int this);
MMRESULT __thiscall sub_421F50(int this);
int __thiscall sub_421FF0(void** this, int a2, char* Str);
int __thiscall sub_422070(void** this, int a2);
int __thiscall sub_4220B0(int this);
int __thiscall sub_422140(int this, int a2);
int __thiscall sub_422380(void** this, char* Str);
_DWORD* __thiscall sub_4223C0(_DWORD* this);
int __thiscall sub_422490(UINT* this);
int __thiscall sub_4224E0(int this);
int __thiscall sub_422560(HMIDIOUT* this, LPMIDIHDR pmh);
int __thiscall sub_422630(_DWORD* this, int a2);
_DWORD* __thiscall sub_422680(int this);
int __thiscall sub_422900(int this, int a2);
BOOL __thiscall sub_423260(int this, int a2);
// int __thiscall unknown_libname_2(_DWORD, _DWORD); weak
int __cdecl sub_42333B(_DWORD* a1);
int sub_423785();
BOOL __stdcall sub_423801(int a1, int a2);
int sub_42386B();
int __cdecl sub_42390A(int a1);
int __cdecl sub_423B14(int a1);
BOOL __stdcall sub_423DA0(int a1, int a2);
int __cdecl sub_423DDF(int a1);
void sub_423F3F();
_DWORD** __thiscall sub_4240F0(_DWORD** this);
_DWORD* __thiscall sub_424127(_DWORD* this);
void __thiscall sub_424145(float* this, int a2);
void __thiscall sub_4241E5(int this, int a2);
void __thiscall sub_424285(float* this, _DWORD* a2, float* a3);
int __thiscall sub_4242F3(int** this, int a2);
int __thiscall sub_424375(int** this, int a2, LPCSTR lpFileName);
int __thiscall sub_42464D(_DWORD* this, char* FileName);
int __stdcall sub_424AAC(int, char* Str); // idb
int __stdcall sub_424AE4(int a1);
int __stdcall sub_424B2F(int a1);
// int __userpurge sub_424B5D@<eax>(int a1@<ebx>, char *a2);
int sub_424D38();
int __thiscall sub_424D82(float* this, float a2);
_DWORD* __thiscall sub_424E41(_DWORD* this, float a2);
int __thiscall sub_424E8F(int* this);
// int __usercall sub_424EAD@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>);
int sub_42523A();
void* __thiscall sub_425318(void* this);
// int __usercall sub_4253DD@<eax>(int a1@<ebx>, int *a2);
int __cdecl sub_42545A(int a1);
int __cdecl sub_42564C(int a1);
int __cdecl sub_425D97(int a1);
_DWORD* __thiscall sub_425E10(_DWORD* this);
_DWORD* __thiscall sub_426000(_DWORD* this);
int __cdecl sub_426100(_DWORD* a1, int a2, int a3, int a4, _DWORD* a5);
int __thiscall sub_4264B0(int this, float* a2, float* a3, _DWORD* a4);
int __thiscall sub_426C40(int this, float* a2, float* a3);
int __thiscall sub_426DF0(int this, float* a2, float* a3);
int __thiscall sub_426FD0(int this, float* a2, float* a3);
int __thiscall sub_427190(int this, float* a2, float* a3, float* a4, float a5, int a6);
int* __thiscall sub_427630(float* this, float* a2);
int* __thiscall sub_427770(int this);
int __thiscall sub_427860(int this);
_DWORD* __cdecl sub_428630(_DWORD* a1);
double __thiscall sub_428680(float* this, float* a2);
double __thiscall sub_428700(float* this, float* a2);
int __cdecl sub_428780(char a1);
int __cdecl sub_4288C0(int a1);
void __cdecl sub_4291B0(int a1);
int __cdecl sub_429710(int a1);
int __cdecl sub_429820(int a1, int a2);
int __cdecl sub_429930(unsigned int a1);
int __cdecl sub_429B00(int a1);
int __cdecl sub_429B90(int a1);
int __cdecl sub_429BB0(int a1);
int __cdecl sub_429C50(int a1);
int sub_42A0B0();
void sub_42A0E0();
int __cdecl sub_42A140(int a1, int a2);
int __cdecl sub_42A240(int a1, int a2);
int __cdecl sub_42A470(_DWORD* a1);
int __cdecl sub_42A510(_DWORD* a1);
int __cdecl sub_42A570(_DWORD* a1);
// int unknown_libname_3(); weak
int __cdecl sub_42A680(int a1);
int __cdecl sub_42A840(int a1);
int __cdecl sub_42AA20(int a1);
int sub_42AAB0();
void __cdecl sub_42AB30(char* FileName, char* a2);
_DWORD* __cdecl sub_42B0D9(char* Str);
int __cdecl sub_42B280(_DWORD* a1, int a2, int a3, int a4);
int __cdecl sub_42B3A6(int a1, int a2);
_DWORD* __cdecl sub_42B437(_DWORD* Block);
int __cdecl sub_42B466(int a1, int a2);
int __cdecl sub_42B502(int a1, int a2);
int __cdecl sub_42B65E(int a1, _DWORD* a2);
void __cdecl sub_42B7DC(void* a1);
void __cdecl sub_42B809(int a1);
int __thiscall sub_42BC2D(void* this, int a2, int a3, int a4);
_DWORD* __thiscall sub_42BC5B(_DWORD* this, int a2, int a3);
int __thiscall sub_42BC85(int this);
int __thiscall sub_42C2D4(int this);
int __cdecl sub_42D0A4(int a1, int a2);
int __cdecl sub_42D18F(int a1, int a2);
int __thiscall sub_42D292(int this);
int __thiscall sub_42D35A(float* this);
int __cdecl sub_42D773(int a1);
_DWORD* __thiscall sub_42D8A1(_DWORD* this);
int __cdecl sub_42D98E(_DWORD* a1);
int __cdecl sub_42E446(int a1);
int __cdecl sub_42F060(float* a1);
int __cdecl sub_42F5BC(int a1);
void sub_42F6C4();
int __cdecl sub_42F6D0(int a1);
int __cdecl sub_42F790(int a1);
int __cdecl sub_42F800(int a1);
int __cdecl sub_42F8B0(int* a1, int a2);
int __cdecl sub_42FC80(int a1);
_DWORD* __cdecl sub_42FD30(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_42FEE0(int a1);
int __cdecl sub_42FF70(int a1);
int __cdecl sub_42FFC0(int a1);
int __cdecl sub_4301F0(_DWORD* a1);
int __cdecl sub_430220(_DWORD* a1);
int __thiscall sub_430270(_DWORD* this, HWND hWnd);
int __thiscall sub_430510(int this);
int __thiscall sub_4306E0(_DWORD* this, int a2, char* Str);
char* __cdecl sub_4309F0(char* Str1, char* Str2, _DWORD* a3, int a4);
// int __userpurge sub_430A50@<eax>(int a1@<ecx>, int a2@<ebx>, LPSTR pszFileName);
int __thiscall sub_430E10(_DWORD* this, char* Str);
// int __userpurge sub_430EC0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3);
void __thiscall sub_430F80(int this);
int __thiscall sub_431080(_DWORD* this);
int* __thiscall sub_4311E0(int* this, int* a2, int a3);
int __thiscall sub_431270(_DWORD* this);
// DWORD __userpurge StartAddress@<eax>(int a1@<ebx>, LPVOID lpThreadParameter);
void* __thiscall sub_431420(void* this);
int __thiscall sub_431470(int this);
int __thiscall sub_431660(int this);
int __thiscall sub_431920(_DWORD** this, int a2, char* Str, int a4, int a5);
int __thiscall sub_431A10(_DWORD** this, int a2, char* Str, int a4, int a5);
int __thiscall sub_431D70(void* this, int a2, int a3, int a4, int a5);
int __thiscall sub_431DC0(_DWORD* this, int a2, char* Str, int a4);
int __thiscall sub_432030(int this, int a2);
int __thiscall sub_4321E0(_DWORD** this, int a2);
_DWORD* __thiscall sub_432260(_DWORD* this, int a2, const void* a3);
int __thiscall sub_4323A0(int* this, int a2, int a3);
int __thiscall sub_432430(int* this, _DWORD* a2, int a3);
unsigned int __thiscall sub_4324D0(int this, unsigned int a2);
int __thiscall sub_432730(int this, unsigned int a2, int a3);
int __thiscall sub_432AD0(void* this, unsigned int a2);
float* __stdcall sub_432C80(float* a1, float a2, float a3, float a4, float a5, float a6, float a7);
int __thiscall sub_432CC0(void* this, unsigned int a2);
int __thiscall sub_432FA0(void* this, unsigned int a2);
int __thiscall sub_433150(int this, unsigned int a2);
int __thiscall sub_433590(int this, unsigned int a2);
int __thiscall sub_433960(int* this, int a2);
char __thiscall sub_434AF0(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, COLORREF a9, COLORREF color, LPCSTR lpString);
int sub_434B60(_DWORD* a1, int a2, COLORREF a3, COLORREF color, char* Format, ...);
int __cdecl sub_434C40(int, int, COLORREF, COLORREF color, char* Format, char); // idb
int sub_434E20(_DWORD* a1, int a2, COLORREF a3, COLORREF color, char* Format, ...);
int __thiscall sub_435010(_DWORD** this, int a2, char* Str);
int __thiscall sub_435270(_DWORD** this, int a2);
int __thiscall sub_435300(_DWORD* this, int a2, int a3, int a4, int a5, int a6);
int __thiscall sub_4354C0(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8);
int __thiscall sub_435670(_DWORD** this, int a2, int a3, int a4, int a5, int a6);
void* __thiscall sub_43575D(void* this);
// int __usercall sub_43579F@<eax>(int a1@<ebx>, int a2);
int __cdecl sub_43753C(int a1, int a2);
_WORD* __cdecl sub_437672(_WORD* a1, __int16 a2, __int16 a3, int a4);
unsigned int __cdecl sub_4377A3(int a1, int a2, int a3, int a4, int a5, int a6);
// int __usercall sub_4378A2@<eax>(int a1@<ecx>, int a2@<ebx>);
int __thiscall sub_4379E4(_DWORD* this);
int __thiscall sub_437B41(int this);
int __thiscall sub_4381EC(_DWORD* this);
int __thiscall sub_438BC1(_DWORD* this);
int __thiscall sub_438EF8(_DWORD* this, int a2, int a3, int a4, int a5);
// int __usercall sub_439137@<eax>(int a1@<ecx>, int a2@<ebx>);
int __thiscall sub_439965(_DWORD* this);
int __cdecl sub_439AD6(_DWORD* a1);
int __cdecl sub_439DA0(int a1);
int __cdecl sub_439F88(int a1);
int __cdecl sub_43A1EC(int a1);
int __cdecl sub_43A338(int a1);
// int __usercall sub_43A464@<eax>(int a1@<ebx>, _DWORD *a2);
int __cdecl sub_43A659(int a1);
int sub_43A70A();
BOOL __thiscall sub_43A736(_BYTE* this, int a2, int a3);
// int __thiscall unknown_libname_4(_DWORD); weak
_DWORD* __thiscall sub_43A7D0(_DWORD* this);
int __thiscall sub_43A800(LPDIRECTSOUND8* this, HWND a2, DWORD a3, __int16 a4, int a5, unsigned __int16 a6);
int __thiscall sub_43A890(_DWORD* this, __int16 a2, int a3, unsigned __int16 a4);
// int __userpurge sub_43A9C0@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, _DWORD *a3, LPSTR pszFileName, int a5, int a6, int a7, int a8, int a9, unsigned int a10, int a11, int a12);
// int __userpurge sub_43AC90@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4, unsigned int a5, int a6);
void* __thiscall sub_43AD70(void* this, char a2);
void __thiscall sub_43ADA0(void* this);
// int __userpurge sub_43AEA0@<eax>(int a1@<ecx>, int a2@<ebx>, int a3, int a4);
int __stdcall sub_43B090(int a1, _DWORD* a2);
int __thiscall sub_43B140(_DWORD* this);
int __thiscall sub_43B200(_DWORD* this, unsigned int a2);
// int __userpurge sub_43B240@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, int a3, int a4);
int __thiscall sub_43B300(_DWORD* this);
int __thiscall sub_43B3B0(_DWORD* this);
// _DWORD *__userpurge sub_43B420@<eax>(_DWORD *a1@<ecx>, int a2@<ebx>, char a3, int a4, int a5, int a6);
_DWORD* __thiscall sub_43B480(_DWORD* this, char a2);
void __thiscall sub_43B4B0(_DWORD* this);
int __thiscall sub_43B4D0(int this);
// int __userpurge sub_43B560@<eax>(int a1@<ecx>, int a2@<ebx>, int a3);
// int __usercall sub_43B8E0@<eax>(int a1@<ecx>, int a2@<ebx>);
_DWORD* __thiscall sub_43B9B0(_DWORD* this);
void __thiscall sub_43BA10(int this);
int __thiscall sub_43BA60(int this, LPSTR pszFileName, int a3, int a4);
int __thiscall sub_43BC00(int this);
// int __thiscall unknown_libname_5(_DWORD); weak
int __thiscall sub_43BE70(int this, char a2);
int __thiscall sub_43C080(int this, void* a2, unsigned int a3, unsigned int* a4);
int __thiscall sub_43C2C0(int this);
int __thiscall sub_43C2F0(int this);
int __thiscall sub_43C310(int(__thiscall*** this)(_DWORD));
int __thiscall sub_43C380(void* this);
int __thiscall sub_43C3C0(void* this, int a2, unsigned int a3);
_DWORD* __thiscall sub_43C440(_DWORD* this);
int __thiscall sub_43C4A0(int this, LPCSTR lpFileName);
int __thiscall sub_43C4F0(void* this);
BOOL __thiscall sub_43C510(int this);
int __thiscall sub_43C570(int this, char a2);
int __thiscall sub_43C5F0(_DWORD* this);
int __thiscall sub_43C610(_DWORD* this, unsigned int lDistanceToMove);
int __thiscall sub_43C650(_DWORD* this);
BOOL __thiscall sub_43C680(void* this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead);
BOOL __thiscall sub_43C6B0(_DWORD* this, LPFILETIME lpLastWriteTime);
int __thiscall sub_43C6D0(_DWORD* this);
void* __thiscall sub_43C6E0(_DWORD* this);
_DWORD* __thiscall sub_43C750(_DWORD* Block, char a2);
_DWORD* __thiscall sub_43C770(_DWORD* this);
int __thiscall sub_43C790(_DWORD* this);
int __thiscall sub_43C8D0(int* this);
int __thiscall sub_43C920(_DWORD* this, const char* a2);
int __thiscall sub_43C990(_DWORD* this, unsigned int a2);
void* __thiscall sub_43C9C0(_DWORD* this, size_t* a2, _DWORD* a3, unsigned int a4);
int __thiscall sub_43CA80(int* this);
int __thiscall sub_43CA80(int* this) {
    return 0;
}
int __thiscall sub_43CA90(int* this, LPCSTR lpFileName);
void* __thiscall sub_43CB40(_DWORD* this, unsigned int a2, int a3);
_DWORD* __thiscall sub_43CE40(_DWORD* this);
int __thiscall sub_43CE60(_DWORD* this, LPCSTR lpFileName, _BYTE* a3);
int __thiscall sub_43CF20(int this);
BOOL __thiscall sub_43CF50(int this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead);
BOOL __thiscall sub_43CF80(int this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten);
int __thiscall sub_43CFB0(void* this);
int __thiscall sub_43CFF0(void* this, int a2);
int __thiscall sub_43D030(_DWORD* this, LONG lDistanceToMove, DWORD dwMoveMethod);
DWORD __thiscall sub_43D060(_DWORD* this);
DWORD __thiscall sub_43D080(_DWORD* this);
HLOCAL __thiscall sub_43D0A0(_DWORD* this, SIZE_T a2);
void* __thiscall sub_43D130(_DWORD* this);
// HRESULT __stdcall DirectInput8Create(HINSTANCE hinst, DWORD dwVersion, const IID *const riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
// HRESULT __stdcall DirectSoundCreate8(LPCGUID pcGuidDevice, LPDIRECTSOUND8 *ppDS8, LPUNKNOWN pUnkOuter);
// int __stdcall Direct3DCreate8(_DWORD); weak
float* __stdcall sub_43EBB2(float* a1, float* a2, float* a3);
char* __stdcall sub_43EC4B(char* a1, char* a2, char* a3);
int __stdcall sub_43ED2E(int a1, int a2);
float* __stdcall sub_43ED9B(float* a1, float a2);
float* __stdcall sub_43EE15(float* a1, float a2);
float* __stdcall sub_43EE90(float* a1, float a2);
float* __stdcall sub_43EF0C(float* a1, float* a2);
float* __stdcall sub_43EFEE(float* a1, float a2, float a3, float a4, float a5);
float* __cdecl sub_43F082(float* a1, float* a2, float* a3);
float* __stdcall sub_43F0CE(float* a1, float* a2);
float* __stdcall sub_43F175(float* a1, float* a2, float* a3);
float* __stdcall sub_43F245(float* a1, float* a2, float* a3, char* a4, char* a5, char* a6);
int __stdcall sub_43F362(int a1, float* a2, float* a3, int* a4, float* a5, float* a6, float* a7);
float* __stdcall sub_43F561(float* a1, float* a2, float* a3, float* a4);
int __stdcall sub_43F667(int a1, LOGFONTA* lplf, _DWORD* a3);
// int __userpurge sub_43F6DB@<eax>(int a1@<ebp>, int a2, _DWORD *a3);
int __stdcall sub_43F745(int a1, HANDLE h, _DWORD* a3);
_DWORD* __cdecl sub_43F778(int a1);
// int __usercall sub_43F79C@<eax>(int a1@<eax>, _DWORD *a2@<ecx>);
// int __usercall sub_43F81C@<eax>(int a1@<eax>, unsigned int *a2, unsigned int *a3, int *a4, int *a5, int a6, int *a7, unsigned int a8, int a9);
int __stdcall sub_43FBFE(int a1, int a2, int* a3, int a4, int a5, int a6, int a7, int* a8, float* a9, int a10);
int __stdcall sub_43FE34(int a1, unsigned int* a2, unsigned int* a3, int* a4, int a5, int* a6, unsigned int a7);
int __stdcall sub_43FE5C(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8);
int __stdcall sub_43FEC2(int a1, int a2, int* a3, unsigned __int8* a4, unsigned int a5, int* a6, float* a7, int a8, _DWORD* a9);
int __stdcall sub_43FF78(int a1, int a2, int* a3, int a4, int a5, int* a6, float* a7, int a8);
int __stdcall sub_440095(int a1, int a2, unsigned int a3, float* a4);
int __stdcall sub_4401C6(int a1, unsigned __int8* a2, unsigned int a3, int a4, int a5, unsigned int a6, int a7, unsigned int a8, unsigned int a9, float* a10, float* a11, int a12, int a13, int* a14, int* a15);
void __thiscall sub_4405D7(_DWORD* this);
int __stdcall sub_440609(int a1);
int __thiscall sub_440616(_DWORD* this, int a2, LOGFONTA* lplf);
int __stdcall sub_440668(int a1, _DWORD* a2);
int __stdcall sub_44068E(int a1, void* a2);
int __stdcall sub_4406B2(int a1);
int __stdcall sub_4406C1(int a1);
HGDIOBJ __stdcall sub_4406D0(int a1, LPCWCH lpWideCharStr, int cchWideChar, int* a4, UINT format, int a6);
HGDIOBJ __stdcall sub_4406F6(int a1, LPCWCH lpWideCharStr, int cchWideChar, int* a4, UINT format, int a6);
int __stdcall sub_44071C(int a1, const void* a2, _DWORD* a3);
int __stdcall sub_440760(_DWORD* Block);
_DWORD* __thiscall sub_440781(_DWORD* this);
int __thiscall sub_44079C(_DWORD* this);
// int __userpurge sub_4407DC@<eax>(int a1@<ecx>, int a2@<ebx>, int a3@<ebp>, int a4);
int __stdcall sub_440A63(int a1, _DWORD* a2);
int __stdcall sub_440A89(int a1);
int __stdcall sub_440AC6(int a1);
int __stdcall sub_440AF1(int a1, const void* a2, _DWORD* a3);
int __stdcall sub_440B35(_DWORD* Block);
int __stdcall sub_440B56(int a1, int a2, int a3, int* a4, int* a5, float a6, int* a7, int a8);
int __stdcall sub_440C2D(int a1, int a2, int* a3, float* a4, int a5);
_DWORD* __thiscall sub_440EEC(_DWORD* this);
_DWORD* __thiscall sub_440F0A(_DWORD* this);
int __thiscall sub_440F14(_DWORD* this);
void __thiscall sub_440F32(int this);
_DWORD* __cdecl sub_440F54(unsigned int a1, signed int a2, int a3);
int __thiscall sub_4411F5(_DWORD* this);
int __thiscall sub_4415AB(_DWORD* this);
int __thiscall sub_441A82(_DWORD* this);
int sub_441C03();
int __fastcall sub_441C09(_DWORD* a1);
int __fastcall sub_441D67(_DWORD* a1);
int __fastcall sub_441E83(_DWORD* a1);
int __fastcall sub_441FD3(_DWORD* a1);
int __fastcall sub_4420F7(_DWORD* a1);
int __fastcall sub_442246(_DWORD* a1);
int __fastcall sub_442399(_DWORD* a1);
int __thiscall sub_4424D8(_DWORD* this);
int __fastcall sub_442573(_DWORD* a1);
int __fastcall sub_4426BF(_DWORD* a1);
int __fastcall sub_4427E0(_DWORD* a1);
int __fastcall sub_44292C(_DWORD* a1);
int sub_442A6B();
int sub_442A8E();
int __thiscall sub_442A9E(_DWORD* this);
int __thiscall sub_442BD0(_DWORD* this);
int __thiscall sub_442C72(_DWORD* this);
int __thiscall sub_442DE7(_DWORD* this);
int __thiscall sub_442F7D(_DWORD* this);
int __thiscall sub_443312(int this);
// int *__usercall sub_4436BB@<eax>(unsigned int a1@<ebx>, unsigned int a2@<edi>, int a3);
int __thiscall sub_44378C(_DWORD* this);
int __thiscall sub_443ACD(_DWORD* this);
int __thiscall sub_44411A(float** this, float* Block, float* a3, float* a4);
_DWORD* __thiscall sub_44422C(_DWORD* this);
void __thiscall sub_444245(int this);
int __thiscall sub_44429E(int* this, int a2, unsigned int a3);
void __cdecl __noreturn sub_4448D9(int a1);
int __cdecl sub_4448F5(int a1);
char __cdecl sub_444912(int a1);
_DWORD* __cdecl sub_444927(int a1, int a2);
int __cdecl nullsub_1(_DWORD); // weak
int __thiscall sub_444939(_DWORD* this, int a2, int a3);
int __thiscall sub_444B8E(int* this, unsigned __int8* a2, unsigned int a3);
unsigned int __thiscall sub_445006(_DWORD* this, _BYTE* a2, unsigned int a3);
unsigned int __cdecl sub_445288(jmp_buf Buf, void* a2, unsigned int a3);
int __thiscall sub_4452CB(_DWORD* this, int a2, unsigned int a3);
int __thiscall sub_4457E1(_DWORD* this, _DWORD* a2, unsigned int a3);
int __thiscall sub_445AF4(int* this, int a2, unsigned int a3);
int __thiscall sub_445B24(int this, unsigned __int8* a2, unsigned int a3, _DWORD* a4);
_DWORD* __thiscall sub_445C7E(_DWORD* this);
int* __thiscall sub_445CBD(int this);
void __thiscall sub_445D88(_DWORD* this);
int __thiscall sub_445D8B(int this, int a2);
int __thiscall sub_445F45(int this);
int __thiscall sub_445F87(int this);
void __thiscall sub_445FB7(_DWORD* Block);
int __cdecl sub_445FCC(int a1, _DWORD* a2);
HGDIOBJ __thiscall sub_446048(int this, HGDIOBJ h, LPCWCH lpWideCharStr, int cchWideChar, int* a5, UINT format, int a7, LPSTR lpMultiByteStr);
void __thiscall sub_4465E2(_DWORD* this);
float* __thiscall sub_4465EC(float* this, unsigned int a2);
char* __thiscall sub_446642(_DWORD* this, int a2, int a3, float* a4);
_BYTE* __thiscall sub_4466AB(_DWORD* this, int a2, int a3, float* a4);
char* __thiscall sub_446741(_DWORD* this, int a2, int a3, float* a4);
char* __thiscall sub_4467B9(_DWORD* this, int a2, int a3, float* a4);
__int16* __thiscall sub_446837(_DWORD* this, int a2, int a3, float* a4);
unsigned int* __thiscall sub_4468A1(_DWORD* this, int a2, int a3, float* a4);
float* __thiscall sub_446940(float* this, float* a2, float* a3);
int sub_44696C();
int sub_44698F();
float* __thiscall sub_44699F(float* this, float* a2, unsigned int a3, int a4);
_DWORD* __thiscall sub_446B88(_DWORD* Block, char a2);
void __thiscall sub_446BA4(int this, unsigned int a2);
int __thiscall sub_446C14(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_446CD5(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_446DCE(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_446EA5(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_446F7C(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447053(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447146(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_44723F(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447310(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447392(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_44748B(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447562(float* this, int a2, int a3, float* a4);
int __thiscall sub_44765F(float* this, int a2, int a3, float* a4);
int __thiscall sub_447719(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_4477B7(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447887(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_44794F(_DWORD* this, char a2, char a3, float* a4);
int __thiscall sub_4479FF(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447ADE(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447BC5(_DWORD* this, char a2, char a3, int a4);
int __thiscall sub_447CD6(_DWORD* this, char a2, char a3, float* a4);
int __thiscall sub_447D87(_DWORD* this, char a2, char a3, int a4);
void __thiscall sub_447E73(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_447EFF(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_447FA1(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448039(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_4480DE(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448180(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448230(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_4482DF(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448381(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_4483F3(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_4484A5(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448544(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_4485CB(_DWORD* this, int a2, int a3, _DWORD* a4);
void __thiscall sub_44862F(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_44869D(_DWORD* this, int a2, int a3, float* a4);
void __thiscall sub_448726(_DWORD* this, int a2, int a3, float* a4);
int __thiscall sub_4487AF(int this, int a2);
int __thiscall sub_448880(_DWORD* this);
int __thiscall sub_448A73(int this, unsigned int a2, unsigned int a3, int a4);
int __thiscall sub_448D44(_DWORD* this, int a2, int a3, const void* a4);
void __thiscall sub_448DBC(_DWORD* this, int a2, int a3, void* a4);
int __thiscall sub_448E2B(int this, int a2);
int __thiscall sub_448F42(_DWORD* this);
int __thiscall sub_44926F(_DWORD* this, unsigned int a2, unsigned int a3, int a4);
int __thiscall sub_449516(_DWORD* this, int a2, int a3, const void* a4);
void __thiscall sub_44959C(_DWORD* this, int a2, int a3, void* a4);
_DWORD* __thiscall sub_449610(_DWORD* Block, char a2);
void __thiscall sub_44962C(_DWORD* this);
void __thiscall sub_449631(int this);
void __thiscall sub_449676(void** this);
float* __cdecl sub_4496CA(float* Block);
void* __thiscall sub_449CDA(void* Block, char a2);
void** __thiscall sub_449CF6(void** Block, char a2);
void* __thiscall sub_449D12(void* Block, char a2);
int sub_449D2E(void); // weak
void* __thiscall sub_449D33(void* Block, char a2);
int sub_449D4F(void); // weak
unsigned int __cdecl sub_449D54(_DWORD* a1, int a2, int a3);
int __cdecl sub_449E14(int);
// int __usercall sub_449E19@<eax>(int a1@<esi>);
int __cdecl sub_449F98(_DWORD* a1);
char __cdecl sub_44A032(int a1);
int __cdecl sub_44A0D3(_DWORD* a1, char a2);
// char __usercall sub_44A136@<al>(int a1@<esi>);
_DWORD* __cdecl sub_44A1DA(_DWORD* a1, int a2, int a3);
char __cdecl sub_44A25E(int a1);
// char __usercall sub_44A31F@<al>(int a1@<esi>);
// char __usercall sub_44A3AD@<al>(char a1@<cl>, int a2@<esi>, char a3);
// char __usercall sub_44A6A8@<al>(_DWORD *a1@<esi>);
char __cdecl sub_44A991(_DWORD* a1);
char __cdecl sub_44ABCD(_DWORD* a1);
// char __usercall sub_44AD47@<al>(_DWORD *a1@<esi>);
// char __usercall sub_44AE9E@<al>(_DWORD *a1@<ebx>);
// char __usercall sub_44B132@<al>(_DWORD *a1@<edi>);
char __cdecl sub_44B37C(int a1);
char __cdecl sub_44B45B(_DWORD* a1);
char __cdecl sub_44B4F7(_DWORD* a1);
// char __usercall sub_44B5CE@<al>(_DWORD *a1@<ebx>);
int __cdecl sub_44B666(_DWORD* a1);
char __cdecl sub_44B85A(_DWORD* a1);
char __cdecl sub_44B8D8(_DWORD* a1, int a2);
int __cdecl sub_44B9C7(_DWORD* a1);
int __cdecl sub_44B9F1(int a1);
void __cdecl  sub_44BA6E(int a1);
int sub_44BA89(); // weak
int __cdecl sub_44BABA(int, char* Buffer); // idb
int __cdecl sub_44BB51(int* a1);
void(__cdecl __noreturn** __cdecl sub_44BB62(void(__cdecl __noreturn** a1)(int a1)))(int a1);
_BYTE* __cdecl sub_44BBAE(int a1, const void* a2);
void __cdecl __noreturn sub_44BC35(jmp_buf Buf); // idb
_DWORD* __cdecl sub_44BC40(_DWORD* a1, int a2, int a3, int a4);
void __cdecl __noreturn sub_44BC5A(jmp_buf Buf, int); // idb
int(__cdecl* __cdecl sub_44BC7D(int a1, int a2))(int, int);
void __cdecl __noreturn sub_44BC92(jmp_buf Buf, const void* a2);
int(__cdecl* __cdecl sub_44BCB7(int a1, const void* a2))(int, int);
jmp_buf __cdecl sub_44BCDC(_BYTE* a1, int a2, int a3, int a4);
int __cdecl sub_44BDDF(jmp_buf Buf, int); // idb
unsigned int __cdecl sub_44BF53(jmp_buf Buf, int a2);
// int (__cdecl *__usercall sub_44BF73@<eax>(int a1@<ebx>, jmp_buf Buf, char *a3, char *a4))(jmp_buf, int, _DWORD);
int(__cdecl* __cdecl sub_44C31B(jmp_buf Buf, char** a2))(jmp_buf, int, _DWORD);
int __cdecl sub_44C368(int a1, void* a2, void* a3);
void __cdecl sub_44C48B(void** a1, void** a2, void** a3);
int __cdecl sub_44C50C(int a1, int a2, int a3);
int __cdecl sub_44C526(int a1, int a2);
char __cdecl sub_44C53C(int a1, int a2);
int __cdecl sub_44C552(int a1, int a2, double* a3);
int __cdecl sub_44C57B(int a1, int a2, _DWORD* a3);
int __cdecl sub_44C5A6(int a1, int a2, unsigned int* a3, _DWORD* a4, _DWORD* a5, _DWORD* a6, _DWORD* a7, _DWORD* a8, _DWORD* a9);
int __cdecl sub_44C677(int a1, int a2, _DWORD* a3, _DWORD* a4);
int __cdecl sub_44C6AA(int a1, int a2, _DWORD* a3, _DWORD* a4, _DWORD* a5);
int __cdecl sub_44C711(int a1);
int __cdecl sub_44C71A(int a1);
int __cdecl sub_44C733(int a1);
int __cdecl sub_44C74C(int a1, unsigned __int8 a2, int a3);
char __cdecl sub_44C799(int* a1, char* a2);
int __cdecl sub_44C858(int a1);
int __cdecl sub_44C861(int, double, double); // idb
int __cdecl sub_44C897(int a1);
unsigned int __cdecl sub_44C8A0(int a1, int a2);
void __cdecl sub_44C98B(int* a1, int a2);
char __cdecl sub_44CA9A(int* a1, _BYTE* a2, unsigned __int8* a3);
int __cdecl sub_44CC15(int a1, _BYTE* a2);
unsigned int __cdecl sub_44CC59(int a1, int a2, unsigned int a3, char a4);
unsigned __int8* __cdecl sub_44CE90(int* a1, _BYTE* a2, unsigned __int8* a3, int a4, char a5);
int __cdecl sub_44D202(int* a1, int a2, int a3, int a4, int a5);
int __cdecl sub_44D409(int* a1, int a2, _WORD* a3);
int __cdecl sub_44D75C(int* a1, char* a2, int a3, int a4);
void __cdecl sub_44D869(jmp_buf Buf);
void __cdecl sub_44DB68(jmp_buf Buf);
void __cdecl sub_44DC7D(jmp_buf Buf);
void __cdecl sub_44DE19(int a1, int a2, double a3);
void __cdecl sub_44DE34(int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7, char a8, char a9);
void __cdecl sub_44DED6(int a1, int a2, int a3, __int16 a4);
void __cdecl sub_44DEFA(int a1, int a2, char a3);
void __cdecl sub_44DF15(int a1, __int64 a2);
void __cdecl sub_44DF4E(int a1, int a2, int a3, int a4, int a5);
int __cdecl sub_44DF95(jmp_buf Buf, int, int); // idb
int(__cdecl* __cdecl sub_44DFBD(_DWORD* a1, int a2, int(__cdecl* a3)(int, int)))(int, int);
int __cdecl sub_44DFFC(int a1, unsigned int a2, unsigned int a3);
char* __cdecl sub_44E044(jmp_buf Buf, int a2, int a3);
int __cdecl sub_44E097(int, void* Block); // idb
int __cdecl sub_44E09C(int a1);
int __cdecl sub_44E0B4(int a1, _BYTE* a2, unsigned int a3);
int __cdecl sub_44E0F3(void* a1);
int __cdecl sub_44E101(int a1, void* a2);
void* __cdecl sub_44E10C(int a1);
__int16 __cdecl sub_44E12E(_BYTE* a1, int a2);
int __cdecl sub_44E197(unsigned __int16* a1, char* a2);
// float *__usercall sub_44E1BD@<eax>(float *result@<eax>, int a2);
// __int64 __usercall sub_44E1EF@<edx:eax>(int a1@<eax>, int a2);
// _WORD *__usercall sub_44E224@<eax>(_BYTE *a1@<eax>, _WORD *a2);
// unsigned int __usercall sub_44E254@<eax>(unsigned __int16 *a1@<eax>, unsigned int *a2);
// float *__usercall sub_44E2A1@<eax>(float *result@<eax>, float *a2@<ecx>);
// float *__usercall sub_44E340@<eax>(unsigned __int16 *a1@<esi>, float *a2, float *a3, int a4);
// float *__usercall sub_44E3CB@<eax>(float *a1@<edx>, float *a2@<edi>);
// __int16 __usercall sub_44E4FD@<ax>(_BYTE *a1@<edi>, int a2@<esi>, unsigned __int16 a3);
__int16 __cdecl sub_44E55E(_BYTE* a1, int a2, int a3, int a4);
char __cdecl sub_44E9F5(unsigned __int16* a1, char* a2);
int __cdecl sub_44EADE(int a1, char* a2);
int __cdecl sub_44EB2C(unsigned __int16* a1, char* a2);
__int16 __cdecl sub_44EC2C(_BYTE* a1, int a2);
__int16 __cdecl sub_44EC5E(_BYTE* a1, _WORD* a2);
__int16 __cdecl sub_44ECB7(_BYTE* a1, int a2);
int __cdecl sub_44EE0D(int a1, int a2);
int __cdecl sub_44EE1D(int a1, int a2);
const void** __cdecl sub_44EE35(int a1, int a2, int a3, int a4, int a5, unsigned int a6);
int __cdecl sub_44EE7C(const void* a1, void* a2, int a3);
int __cdecl sub_44EE9E(void* a1, unsigned int a2);
unsigned int sub_44EEB9();
// int __usercall sub_44EEEA@<eax>(int a1@<esi>);
// int __usercall sub_44F0A5@<eax>(int *a1@<esi>);
// void __usercall sub_44F21B(int a1@<ebx>);
int __cdecl sub_44F2AD(int a1);
int __cdecl sub_44F2E7(_DWORD* a1);
int __cdecl sub_44F37A(int a1);
_DWORD* __cdecl sub_44F3B1(int a1);
int __cdecl sub_44F3C2(int a1);
// int __usercall sub_44F403@<eax>(int a1@<eax>, int a2@<edx>);
int __cdecl sub_44F418(_DWORD* a1, unsigned int a2, unsigned int a3);
_DWORD* __cdecl sub_44F514(_DWORD* a1, unsigned int a2, unsigned int a3);
int __cdecl sub_44F5A2(_DWORD* a1, unsigned int a2, unsigned int a3, unsigned int a4);
int __cdecl sub_44F634(_DWORD* a1, unsigned int a2, int a3, signed int a4);
int __cdecl sub_44F6D2(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_44F733(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6);
int __cdecl sub_44F794(_DWORD* a1);
// int __usercall sub_44F913@<eax>(int a1@<esi>, int a2, char a3);
// int __usercall sub_44F99B@<eax>(int a1@<esi>, int a2, char a3);
int __cdecl sub_44FA26(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
int __cdecl sub_44FB44(int a1, int a2, unsigned int a3, unsigned int a4, char a5);
_DWORD* __cdecl sub_44FC67(_DWORD* a1, unsigned int a2);
int __cdecl sub_44FD48(int a1);
_DWORD* __cdecl sub_44FD78(_DWORD* a1);
int __cdecl sub_44FE2C(int a1);
int __cdecl sub_44FE4E(int a1);
int __cdecl sub_44FE69(int a1);
int __cdecl sub_44FE85(int a1);
char __fastcall sub_44FEA1(int a1, int a2);
char __cdecl sub_44FF12(int a1);
// int __usercall sub_450101@<eax>(int a1@<eax>);
// int __usercall sub_450170@<eax>(int a1@<esi>);
int __cdecl sub_45031D(int a1);
int __cdecl sub_45044A(int a1);
int __cdecl sub_45046B(int a1);
int __cdecl sub_45049B(_DWORD* a1);
int __cdecl sub_4504DA(_DWORD* a1);
int __cdecl sub_450518(_DWORD* a1, int a2, _BYTE* a3, int a4);
int __cdecl sub_4505FD(_DWORD* a1, _BYTE* a2, int a3);
int __cdecl sub_450614(unsigned __int8** a1, int a2);
void* __cdecl sub_450975(int a1);
void __cdecl sub_4509B7(void* Block);
void* __cdecl sub_4509C4(jmp_buf Buf, size_t Size);
void __cdecl sub_4509FA(int a1, void* Block);
void* __cdecl sub_450A13(int a1, void* a2, const void* a3, unsigned int a4);
// char *__usercall sub_450A36@<eax>(int a1@<ebx>, int a2, char *a3, char a4, unsigned int a5);
int __cdecl sub_450A69(unsigned __int8* a1);
// int __usercall sub_450A8C@<eax>(int a1@<eax>, unsigned __int8 *a2);
int __cdecl sub_450A9F(jmp_buf Buf, _BYTE* a2, int a3);
BOOL __cdecl sub_450AC3(jmp_buf Buf);
unsigned __int8 __cdecl sub_450B21(jmp_buf Buf, unsigned __int8* a2);
char __cdecl sub_450B83(int a1, char* a2, int a3);
void __cdecl sub_450D97(int* a1, int a2, int a3);
char __cdecl sub_451060(int a1, int a2, _BYTE* a3, unsigned __int8* a4, int a5);
char* __cdecl sub_4511D9(jmp_buf Buf);
int __cdecl sub_451375(jmp_buf Buf, unsigned int a2);
void __cdecl sub_451401(jmp_buf Buf, int a2, int a3);
void __cdecl sub_4515F8(jmp_buf Buf, int a2, int a3);
int __cdecl sub_451721(jmp_buf Buf, int, int); // idb
void __cdecl sub_45176B(jmp_buf Buf, int a2, int a3);
void __cdecl sub_45186B(jmp_buf Buf, int a2, int a3);
void __cdecl sub_45195A(jmp_buf Buf, int a2, size_t Size);
int __cdecl sub_451AF3(jmp_buf Buf, int, int); // idb
// int __usercall sub_451B3D@<eax>(int a1@<ebx>, jmp_buf Buf);
int __cdecl sub_451D62(int a1, _BYTE* a2, unsigned int a3);
void* __cdecl sub_451E6B(int a1, size_t Size);
void __cdecl sub_451E76(int a1, void* Block);
int __cdecl sub_451E81(int a1, int a2, int a3);
int __cdecl sub_451E86(int a1);
// int __usercall sub_451E9A@<eax>(int a1@<esi>);
// int __usercall sub_451F42@<eax>(_DWORD *a1@<edi>);
// int __usercall sub_452073@<eax>(_DWORD *a1@<edi>);
// int __usercall sub_452147@<eax>(_DWORD *a1@<esi>);
int __cdecl sub_4521DD(_DWORD* a1, int a2, int a3, int a4);
unsigned int __cdecl sub_452245(_DWORD* a1, int a2, unsigned int* a3, unsigned int a4);
int __cdecl sub_45234D(int a1, int a2, int a3, int a4);
int sub_452370(); // weak
int __cdecl sub_4523D8(int a1, char a2);
_DWORD* __thiscall sub_4524AB(_DWORD* this);
_DWORD* __cdecl sub_4524EA(_DWORD* a1);
int __cdecl sub_4524FA(_DWORD* a1, int a2);
int __cdecl sub_4526D4(_DWORD* a1);
int __cdecl sub_452873(int a1, int a2);
// char __usercall sub_4529D9@<al>(int a1@<esi>);
int __cdecl sub_452ABC(_DWORD* a1, int a2);
int sub_452FD4(); // weak
int __cdecl sub_45300F(int a1, char a2);
int __cdecl sub_453107(int a1, int a2, int a3);
char __cdecl sub_4532AA(unsigned __int8** a1, int a2, int a3, int a4);
int __cdecl sub_453394(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_45347A(_DWORD* a1);
char __cdecl sub_4534D8(_DWORD* a1, int a2);
int __cdecl sub_4538A5(_DWORD* a1);
_DWORD* __cdecl sub_4539D4(int a1);
// char __usercall sub_453A0E@<al>(_DWORD *a1@<edi>);
char __cdecl sub_453A69(_DWORD* a1, int a2);
char __cdecl sub_453C66(_DWORD* a1, int* a2);
char __cdecl sub_453E93(_DWORD* a1, int a2);
char __cdecl sub_453F75(_DWORD* a1, int* a2);
int __cdecl sub_4542E3(int* a1);
int __cdecl sub_454586(int a1);
int __cdecl sub_4545E7(_DWORD* a1);
_DWORD* __cdecl sub_45479E(int a1);
int __cdecl sub_454812(int a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7);
unsigned int __cdecl sub_454877(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6);
unsigned int __cdecl sub_454907(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7);
int __cdecl sub_454993(int a1, int a2);
int(__cdecl** __cdecl sub_454A39(int a1, char a2))(int a1, int a2);
int __cdecl sub_454ABC(_DWORD* a1);
_DWORD* __cdecl sub_454AD6(_DWORD* a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6, int a7);
_DWORD* __cdecl sub_454B9C(int a1, int a2, int a3, _DWORD* a4);
_DWORD* __cdecl sub_454BA7(int a1, int a2, int a3, _DWORD* a4);
const void** __cdecl sub_454BAF(unsigned int* a1, int a2, char** a3, int* a4);
_BYTE*** __cdecl sub_454C8E(int a1, int a2, int a3, _BYTE*** a4);
const void** __cdecl sub_454CE5(int a1, int a2, char** a3, int* a4);
int __cdecl sub_454D4F(int a1, int a2, int a3, _BYTE*** a4);
unsigned __int8** __cdecl sub_454DF2(unsigned __int8** a1, int a2, unsigned __int8** a3, int* a4);
int __cdecl sub_454EF9(int a1);
// int __usercall sub_4550BA@<eax>(int a1@<eax>);
_BYTE* __cdecl sub_45516A(int a1, int a2, int a3, _DWORD* a4, _BYTE* a5);
const void** __cdecl sub_4551D4(int a1, int* a2, int a3, int a4, int a5);
_BYTE* __cdecl sub_4551F7(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4, int a5);
unsigned int* __cdecl sub_455329(unsigned int a1, unsigned int* a2, unsigned int* a3, unsigned int* a4, int a5);
unsigned int* __cdecl sub_455466(_DWORD* a1, _DWORD* a2, int a3, int* a4, int a5);
int __cdecl sub_455684(int a1);
// int __usercall sub_4557A5@<eax>(int a1@<eax>);
int __cdecl sub_455855(int a1);
const void** __cdecl sub_45586A(int a1, int a2, const void** a3, int a4, int a5, _DWORD* a6, int a7);
int __cdecl sub_455910(int a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6);
_BYTE* __cdecl sub_455941(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4);
char __cdecl sub_455A97(_DWORD* a1, _DWORD* a2, int a3, int a4);
int __cdecl sub_455C7D(int a1);
_WORD* __cdecl sub_455CF2(int a1, _WORD* a2, int a3, int a4);
// int *__usercall sub_455D5E@<eax>(int a1@<eax>, int a2@<ecx>);
// int *__usercall sub_455D87@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_455DAA@<eax>(int a1@<eax>, int *a2@<esi>);
int __cdecl sub_4560E2(int a1, int a2, int a3, int a4);
// int __usercall sub_4561FC@<eax>(int *a1@<eax>, int a2@<esi>, int a3);
// int __usercall sub_456334@<eax>(int a1@<edi>, int a2);
// int __usercall sub_4563C1@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5);
int __cdecl sub_456541(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE* a7);
// _WORD *__usercall sub_45665B@<eax>(int a1@<eax>, int a2, int a3, int a4);
int __cdecl sub_45672B(int a1, int a2, _DWORD* a3, int a4);
__int16 __cdecl sub_4567D4(_DWORD* a1, int a2, _DWORD* a3, int a4);
// int __usercall sub_456A42@<eax>(int a1@<eax>);
int __cdecl sub_456AD2(int a1);
int __cdecl sub_456AF4(_DWORD* a1, char a2);
int __cdecl sub_456BF6(int a1);
int __cdecl sub_456C05(int a1);
int __cdecl sub_456D18(_DWORD* a1, char* a2);
int __cdecl sub_456DE3(int a1, int a2, int a3);
// int __usercall sub_456DFC@<eax>(int a1@<eax>, int a2@<ecx>);
// int __usercall sub_456E0F@<eax>(_DWORD *a1@<esi>);
// int __usercall sub_456F2C@<eax>(_DWORD *a1@<edi>);
// int *__usercall sub_45704D@<eax>(int a1@<eax>, int a2@<ecx>);
// void __usercall sub_4570AF(int a1@<edi>);
int __cdecl sub_457108(_DWORD* a1, int a2, _DWORD* a3, int a4);
int __cdecl sub_457190(int a1, int a2, _DWORD* a3, int a4);
int __cdecl sub_45721D(_DWORD* a1, int a2, void** a3, int a4);
_DWORD* __cdecl sub_457308(int a1, int a2, _BYTE** a3, int a4);
char __cdecl sub_457407(_DWORD* a1, int a2, void** a3, int a4);
// int __usercall sub_45758B@<eax>(_DWORD *a1@<esi>);
void __cdecl sub_4575C1(_DWORD* a1);
int __cdecl sub_457689(int a1);
int __cdecl sub_45769D(_DWORD* a1);
int(__cdecl* __cdecl sub_457726(_DWORD* a1, int a2, _DWORD* a3))(_DWORD, _DWORD, _DWORD);
_DWORD* __cdecl sub_457791(int a1, int a2, int a3);
int __cdecl sub_45781C(int* a1, int a2, int a3);
int __cdecl sub_458135(_DWORD* a1, int a2);
int __cdecl sub_458169(unsigned int a1, unsigned __int8* a2, unsigned int a3);
int __cdecl sub_458282(int a1, int a2, int a3);
_BYTE* __cdecl sub_458292(int a1, int a2, int a3, int a4, int a5);
char* __cdecl sub_4585A7(int a1, int a2, int a3, int a4, int a5);
char __cdecl sub_458765(int a1, int a2, __int16* a3, _DWORD* a4, int a5);
int __cdecl sub_4587A2(int a1, int a2, __m64* a3, int a4, int a5);
char __cdecl sub_4587EE(int a1, int a2, __m64* a3, _DWORD* a4, int a5);
char __cdecl sub_45883A(int a1, int a2, __int16* a3, int a4, int a5);
int __cdecl sub_458C1B(char a1, char a2, int a3, int a4, int a5);
int __cdecl sub_458C4F(_DWORD* a1, int a2, int a3);
int __cdecl sub_4591A5(int a1, int a2);
// int __usercall sub_4591B6@<eax>(unsigned int *a1@<eax>, _DWORD *a2, unsigned int a3, unsigned int a4, int a5, int a6, _DWORD *a7, int a8, unsigned int *a9, unsigned int *a10);
int __cdecl sub_45953B(_DWORD* a1, unsigned int* a2, _DWORD* a3, int a4, int a5);
int __cdecl sub_4595BA(unsigned int a1, unsigned int a2, _DWORD* a3, unsigned int* a4, unsigned int* a5, _DWORD* a6, _DWORD* a7, int a8, int a9);
int __cdecl sub_4596BD(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4);
int __cdecl sub_4596EC(_DWORD* a1, _DWORD* a2, int a3);
int __cdecl sub_459801(__int16* a1, __int16* a2, int* a3, int a4, int a5, int a6);
int __cdecl sub_459CEE(__m64* a1, __m64* a2, __m64* a3, int a4, int a5, int a6);
__int16 __cdecl sub_45A479(_WORD* a1, _WORD* a2, _WORD* a3, int a4, int a5, int a6);
char __cdecl sub_45A822(__m64* a1, __m64* a2, __m64* a3, _DWORD* a4, int a5, int a6);
int __cdecl sub_45B5F5(int a1, int a2, int a3, int a4, _DWORD* a5, unsigned __int8** a6);
// int __cdecl atexit(void (__cdecl *)());
// _DWORD _fpmath(); weak
// int __cdecl vsprintf(char *const Buffer, const char *const Format, va_list ArgList);
// void __noreturn report_failure(void); weak
void __thiscall sub_45BA68(void* this);
// void __cdecl free(void *Block);
// void *__cdecl malloc(size_t Size);
// double __cdecl sqrt(double X);
// double __cdecl sin(double X);
// double __cdecl cos(double X);
int __cdecl sub_45BE40(double, double);
// double __cdecl fmod(double X, double Y);
// int __cdecl atol(const char *String);
int __cdecl j__atol(const char* String);
void __cdecl j__free(void* Block);
// void *__cdecl operator new(size_t Size); idb
// const struct _s_TryBlockMapEntry *__cdecl _GetRangeOfTrysToCheck(const struct _s_FuncInfo *, int, int, unsigned int *, unsigned int *); idb
_DWORD* __cdecl sub_45C100(_DWORD* a1, int a2);
// int __cdecl IsExceptionObjectToBeDestroyed(void *); idb
int __cdecl sub_45C149(int a1);
// void *__cdecl _CallCatchBlock2(struct EHRegistrationNode *, const struct _s_FuncInfo *, void *, int, unsigned int); idb
// int __cdecl _CallSETranslator(struct EHExceptionRecord *, struct EHRegistrationNode *, void *, void *, const struct _s_FuncInfo *, int, struct EHRegistrationNode *); idb
// int __cdecl _abnormal_termination();
// int sprintf(char *const Buffer, const char *const Format, ...);
// double __cdecl fabs(double X);
// double __cdecl tan(double X);
// int __cdecl fclose(FILE *Stream);
// size_t __cdecl fread(void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl sub_45C6E8(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream);
// int __cdecl ftell(FILE *Stream);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// char *__cdecl strrchr(const char *Str, int Ch);
// size_t __cdecl fwrite(const void *Buffer, size_t ElementSize, size_t ElementCount, FILE *Stream);
size_t __cdecl sub_45CB54(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream);
// size_t __cdecl strlen(const char *Str);
// void *__cdecl memset(void *, int Val, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
int __cdecl sub_45D30D(FILE* Stream, char* a2, int a3);
// char *__cdecl _strdate(char *Buffer);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// int __cdecl _mkdir(const char *Path);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
int __cdecl sub_45D5F9(LPCSTR lpPathName); // idb
// int __cdecl rand();
// int __cdecl isdigit(int C);
// int __cdecl isspace(int C);
// double __cdecl floor(double X);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// _DWORD __cdecl _setjmp3(_DWORD, _DWORD, _DWORD);
// void __cdecl __noreturn __crtExitProcess(UINT uExitCode); idb
int sub_45E01C();
int __cdecl sub_45E081(UINT uExitCode, int, int); // idb
// void __cdecl __noreturn exit(int Code);
// void __cdecl __noreturn _exit(int Code);
int __cdecl sub_45E194(int a1, int a2);
// _DWORD __cdecl _cftoe2(_DWORD, _DWORD, char); weak
int __cdecl sub_45E66A(_DWORD* a1, int a2, int a3, int a4);
// int __cdecl _cftof2(int, size_t Size, char); idb
int __cdecl sub_45E77A(_DWORD* a1, int a2, size_t Size);
int __cdecl sub_45E7E2(_DWORD* a1, int a2, int Size, int a4);
// int __thiscall write_char(FILE *File); idb
// int __cdecl write_multi_char(char, int, FILE *File); idb
// int __cdecl write_string(_DWORD); weak
int __cdecl sub_45EAF5(FILE* File, char* a2, int a3);
void __cdecl __noreturn sub_45F2E0(int a1, int a2);
// int _mtinitlocks(void); weak
// _DWORD __cdecl _unlock(_DWORD); weak
int __cdecl sub_45F548(int a1);
// _DWORD __cdecl _lock(_DWORD); weak
// _DWORD __cdecl __sbh_alloc_block(_DWORD); weak
// int __cdecl _callnewh(size_t Size);
// int __cdecl _ctrandisp2(double, double); idb
// int _mtterm(void); weak
// int __thiscall _getptd(_DWORD); weak
int sub_461888();
// int __cdecl TypeMatch(const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_ThrowInfo *); idb
_DWORD* __cdecl sub_461964(int a1, int a2, int a3, int a4);
// _DWORD __cdecl __DestructExceptionObject(_DWORD, char); weak
void* __cdecl sub_461A94(_DWORD* a1, struct EHRegistrationNode* a2, int a3, struct _s_FuncInfo* a4, int a5, unsigned int a6);
// void __cdecl CatchIt(struct EHExceptionRecord *, struct EHRegistrationNode *, struct _CONTEXT *, void *, const struct _s_FuncInfo *, const struct _s_HandlerType *, const struct _s_CatchableType *, const struct _s_TryBlockMapEntry *, int, struct EHRegistrationNode *, unsigned __int8); idb
// void __usercall sub_461E1E(unsigned __int8 a1@<cl>, const struct _s_TryBlockMapEntry *a2@<ebx>, int a3@<edi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, int a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11);
// void __usercall sub_461EDE(struct EHRegistrationNode *a1@<ebx>, int a2@<edi>, const struct _s_ThrowInfo *a3@<esi>, struct EHExceptionRecord *a4, struct EHRegistrationNode *a5, struct EHRegistrationNode *a6, struct _CONTEXT *a7, struct _s_FuncInfo *a8, char a9, struct _s_FuncInfo *a10, struct EHRegistrationNode *a11);
// void __cdecl __noreturn terminate(); idb
void __noreturn sub_462197();
// _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD); weak
// int __cdecl _raise_exc(ULONG_PTR Arguments, int, DWORD dwExceptionCode, int, int, int); idb
// _DWORD __cdecl _handle_exc(_DWORD, _DWORD, _DWORD); weak
// errno_t __cdecl _set_errno(int Value);
// _DWORD __cdecl _errcode(char); weak
// int __cdecl _umatherr(int Value, int, int, int, int, int, double, int); idb
int __cdecl sub_462829(DWORD dwExceptionCode, int a2, int a3, int a4, double a5, int a6);
// _DWORD __cdecl _ctrlfp(_DWORD, _DWORD); weak
// _DWORD __cdecl _fflush_lk(_DWORD); weak
int __cdecl sub_462C92(int a1);
int sub_462D67();
// void __cdecl _lock_file(FILE *Stream);
// _DWORD __cdecl _lock_file2(_DWORD, _DWORD); weak
// void __cdecl _unlock_file(FILE *Stream);
// _DWORD __cdecl _unlock_file2(_DWORD, _DWORD); weak
// int *__cdecl _errno();
// unsigned int *__cdecl __doserrno();
// _DWORD __cdecl _dosmaperr(_DWORD); weak
// int __cdecl _lseek_lk(int FileHandle, LONG lDistanceToMove, DWORD dwMoveMethod); idb
int __cdecl sub_463856(int FileHandle, _BYTE* lpBuffer, DWORD nNumberOfBytesToWrite);
int __cdecl sub_4639FB(int a1, _BYTE* lpBuffer, DWORD nNumberOfBytesToWrite);
// _DWORD __cdecl _stbuf(_DWORD); weak
// _DWORD __cdecl _ftbuf(_DWORD, _DWORD); weak
// unsigned int __cdecl _mbctoupper(unsigned int Ch);
unsigned int __cdecl sub_463C43(DWORD NumberOfBytesWritten);
const char* sub_463F57();
// _DWORD __cdecl parse_cmdline(_DWORD, _DWORD); weak
int sub_4641F3();
void sub_4643B7();
void __cdecl sub_4643FB(); // idb
int* __cdecl sub_46443F(double* a1, double* a2, double* a3, int a4);
// _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_465C66(int a1, int a2);
int __cdecl sub_465C7C(int a1, int a2);
int __cdecl sub_465C92(int a1, char* a2);
int __cdecl sub_465CD5(int a1, char* a2);
// int __cdecl _fptostr(void *, int, int); idb
// _DWORD __cdecl __dtold(_DWORD, _DWORD); weak
_DWORD* __cdecl sub_465E49(char a1, int a2, _DWORD* a3, char* Destination);
// int __cdecl wctomb(char *MbCh, wchar_t WCh);
// _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, __int16); weak
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD); weak
int __cdecl sub_46647F(int a1, int a2, unsigned __int16* a3);
// int __cdecl __crtGetStringTypeA(DWORD dwInfoType, LPCCH lpMultiByteStr, int cbMultiByte, LPWORD lpCharType, UINT CodePage, LCID Locale, int); idb
// int CPtoLCID(void); weak
// int setSBCS(void); weak
unsigned int sub_466C38();
_DWORD* sub_466DCA();
int __cdecl sub_466E39(UINT CodePage); // idb
int __cdecl sub_466FCF(UINT CodePage); // idb
// int __initmbctable(void); weak
// int __cdecl _ValidateRead(const void *lp, UINT_PTR ucb); idb
int sub_4671A5();
// intptr_t __cdecl _get_osfhandle(int FileHandle);
int __cdecl sub_4672E4(int a1);
// _DWORD __cdecl _unlock_fhandle(_DWORD); weak
int sub_467379();
// int __cdecl _lseeki64_lk(int FileHandle, int, int, DWORD dwMoveMethod); idb
// int __cdecl __crtLCMapStringA(LCID Locale, DWORD dwMapFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpDestStr, int cchDest, UINT CodePage, int); idb
// int __cdecl _ismbblead(unsigned int Ch);
BOOL sub_467DDA();
// _DWORD __cdecl __addl(_DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __add_12(_DWORD, _DWORD); weak
// _DWORD __cdecl __shl_12(_DWORD); weak
// _DWORD __cdecl __shr_12(_DWORD); weak
__int16 __cdecl sub_467F98(char* a1, int a2, int a3);
int __cdecl sub_46807C(int a1, char** a2, char* a3, int a4, int a5, int a6, int a7);
int __cdecl sub_4684B6(__int64 a1, __int16 a2, int a3, char a4, int a5);
int __cdecl sub_4688F1(LCID Locale); // idb
void* __cdecl sub_46893A(UINT CodePage, UINT a2, LPCCH lpMultiByteStr, int* a4, LPSTR a5, int a6);
int __cdecl sub_468B5E(int FileHandle, LONG lDistanceToMove); // idb
int __cdecl sub_468C99(int a1, int a2);
unsigned int __cdecl sub_468ED1(_WORD* a1, int a2, int a3);
// _DWORD __cdecl _setmode_lk(_DWORD, _DWORD); weak
int sub_469900();
int sub_469910();
int sub_469920();
int sub_469930();
int sub_469940();
int sub_469950();
int sub_469960();
int sub_469970();
int sub_469980();
int sub_469990();
int sub_4699A0();
int sub_4699B0();
int sub_4699C0();
int sub_4699CF();
int sub_4699DE();
int sub_4699ED();
int sub_4699FC();
int sub_469A10();
void sub_469A20();
void sub_469A30();
int sub_469A40();
int sub_469A50();

//-------------------------------------------------------------------------
// Data declarations

// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern HFONT (__stdcall *CreateFontIndirectA)(const LOGFONTA *lplf);
// extern int (__stdcall *GetObjectA)(HANDLE h, int c, LPVOID pv);
// extern HGDIOBJ (__stdcall *GetStockObject)(int i);
// extern BOOL (__stdcall *TextOutA)(HDC hdc, int x, int y, LPCSTR lpString, int c);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern HBITMAP (__stdcall *CreateDIBSection)(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern HFONT (__stdcall *CreateFontA)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern UINT (__stdcall *GetOEMCP)();
// extern UINT (__stdcall *GetACP)();
// extern int (__stdcall *GetLocaleInfoA)(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);
// extern BOOL (__stdcall *GetCPInfo)(UINT CodePage, LPCPINFO lpCPInfo);
// extern DWORD (__stdcall *GetLastError)();
// extern HANDLE (__stdcall *CreateMutexA)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern HANDLE (__stdcall *CreateEventA)(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern BOOL (__stdcall *FindNextFileA)(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);
// extern HANDLE (__stdcall *FindFirstFileA)(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetFileSize)(HANDLE hFile, LPDWORD lpFileSizeHigh);
// extern BOOL (__stdcall *GetFileTime)(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern BOOL (__stdcall *DeleteFileA)(LPCSTR lpFileName);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern HLOCAL (__stdcall *LocalAlloc)(UINT uFlags, SIZE_T uBytes);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern BOOL (__stdcall *GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation);
// extern HANDLE (__stdcall *GetStdHandle)(DWORD nStdHandle);
// extern DWORD (__stdcall *TlsAlloc)();
// extern BOOL (__stdcall *TlsSetValue)(DWORD dwTlsIndex, LPVOID lpTlsValue);
// extern LPVOID (__stdcall *VirtualAlloc)(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern DWORD (__stdcall *GetModuleFileNameA)(HMODULE hModule, LPSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *VirtualProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern SIZE_T (__stdcall *VirtualQuery)(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);
// extern BOOL (__stdcall *SetEndOfFile)(HANDLE hFile);
// extern HANDLE (__stdcall *CreateFileA)(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern BOOL (__stdcall *SetEnvironmentVariableA)(LPCSTR lpName, LPCSTR lpValue);
// extern DWORD (__stdcall *GetCurrentDirectoryA)(DWORD nBufferLength, LPSTR lpBuffer);
// extern BOOL (__stdcall *SetCurrentDirectoryA)(LPCSTR lpPathName);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetCurrentThreadId)();
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern DWORD (__stdcall *MsgWaitForMultipleObjects)(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
// extern BOOL (__stdcall *PostThreadMessageA)(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern BOOL (__stdcall *KillTimer)(HWND hWnd, UINT_PTR uIDEvent);
// extern UINT_PTR (__stdcall *SetTimer)(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);
// extern HCURSOR (__stdcall *SetCursor)(HCURSOR hCursor);
// extern LRESULT (__stdcall *DefWindowProcA)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
// extern HCURSOR (__stdcall *LoadCursorA)(HINSTANCE hInstance, LPCSTR lpCursorName);
// extern ATOM (__stdcall *RegisterClassA)(const WNDCLASSA *lpWndClass);
// extern HWND (__stdcall *CreateWindowExA)(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
// extern int (__stdcall *GetSystemMetrics)(int nIndex);
// extern BOOL (__stdcall *SystemParametersInfoA)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern int (__stdcall *ShowCursor)(BOOL bShow);
// extern BOOL (__stdcall *PeekMessageA)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
// extern BOOL (__stdcall *TranslateMessage)(const MSG *lpMsg);
// extern LRESULT (__stdcall *DispatchMessageA)(const MSG *lpMsg);
// extern BOOL (__stdcall *ShowWindow)(HWND hWnd, int nCmdShow);
// extern BOOL (__stdcall *MoveWindow)(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
// extern BOOL (__stdcall *DestroyWindow)(HWND hWnd);
// extern int (__stdcall *DrawTextA)(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern int (__stdcall *MessageBoxA)(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
// extern BOOL (__stdcall *SetKeyboardState)(LPBYTE lpKeyState);
// extern BOOL (__stdcall *GetKeyboardState)(PBYTE lpKeyState);
// extern LONG (__stdcall *GetWindowLongA)(HWND hWnd, int nIndex);
// extern LONG (__stdcall *mmioSeek)(HMMIO hmmio, LONG lOffset, int iOrigin);
// extern MMRESULT (__stdcall *mmioGetInfo)(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);
// extern MMRESULT (__stdcall *mmioSetInfo)(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);
// extern MMRESULT (__stdcall *mmioDescend)(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO *pmmckiParent, UINT fuDescend);
// extern LONG (__stdcall *mmioRead)(HMMIO hmmio, HPSTR pch, LONG cch);
// extern MMRESULT (__stdcall *mmioAscend)(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);
// extern HMMIO (__stdcall *mmioOpenA)(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);
// extern MMRESULT (__stdcall *mmioClose)(HMMIO hmmio, UINT fuClose);
// extern MMRESULT (__stdcall *midiOutUnprepareHeader)(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
// extern MMRESULT (__stdcall *timeKillEvent)(UINT uTimerID);
// extern MMRESULT (__stdcall *timeSetEvent)(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent);
// extern MMRESULT (__stdcall *timeGetDevCaps)(LPTIMECAPS ptc, UINT cbtc);
// extern MMRESULT (__stdcall *midiOutShortMsg)(HMIDIOUT hmo, DWORD dwMsg);
// extern MMRESULT (__stdcall *midiOutPrepareHeader)(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
// extern MMRESULT (__stdcall *midiOutLongMsg)(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);
// extern MMRESULT (__stdcall *midiOutReset)(HMIDIOUT hmo);
// extern MMRESULT (__stdcall *midiOutClose)(HMIDIOUT hmo);
// extern MMRESULT (__stdcall *midiOutOpen)(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
// extern MMRESULT (__stdcall *timeBeginPeriod)(UINT uPeriod);
// extern DWORD (__stdcall *timeGetTime)();
// extern MMRESULT (__stdcall *timeEndPeriod)(UINT uPeriod);
// extern MMRESULT (__stdcall *joyGetPosEx)(UINT uJoyID, LPJOYINFOEX pji);
// extern MMRESULT (__stdcall *joyGetDevCapsA)(UINT_PTR uJoyID, LPJOYCAPSA pjc, UINT cbjc);
// extern UINT (__stdcall *midiOutGetNumDevs)();
// extern MMRESULT (__stdcall *mmioAdvance)(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);
const char byte_46A3AC = '\x83'; // idb
const char byte_46A480 = '\x93'; // idb
const char aError_0 [8] = "error : "; // idb
int dword_46A6E8 [] = {512}; // weak
int dword_46A6EC [] = {526}; // weak
int dword_46A6F0 [] = {527}; // weak
int dword_46A6F4 [] = {528}; // weak
int dword_46A6F8 [46] =
{
  523,
  513,
  529,
  530,
  531,
  524,
  514,
  529,
  530,
  531,
  524,
  515,
  529,
  530,
  531,
  524,
  516,
  529,
  530,
  531,
  524,
  517,
  529,
  530,
  531,
  524,
  518,
  532,
  532,
  532,
  525,
  519,
  532,
  532,
  532,
  525,
  520,
  532,
  532,
  532,
  525,
  666,
  668,
  668,
  668,
  667
}; // weak
const char Format [] = {'+', '%', 'd', '\0'}; // idb
const char aError_1 [8] = "error : "; // idb
const char aError2d [10] = "error : 2D"; // idb
const char aError_7 [8] = "error : "; // idb
const char aError_6 [8] = "error : "; // idb
const char aError_5 [8] = "error : "; // idb
const char aError_4 [8] = "error : "; // idb
const char aError_3 [8] = "error : "; // idb
const char aError_2 [8] = "error : "; // idb
const char byte_46B028 = '\x8E'; // idb
const char byte_46B150 = '\x8D'; // idb
const char aDirect3d [9] = "Direct3D "; // idb
const char aD3dfmtA8r8g8b8 [16] = "D3DFMT_A8R8G8B8 "; // idb
const char byte_46B270 = '\x83'; // idb
const char aD3dtexopcapsAd [17] = "D3DTEXOPCAPS_ADD "; // idb
const char aTLHal_0 [8] = "T&L HAL "; // idb
const char aHal_0 [4] = "HAL "; // idb
const char aRef [4] = "REF "; // idb
const char aDirect3d_0 [9] = "Direct3D "; // idb
const char byte_46B3B8 = '\x83'; // idb
const char byte_46B3E4 = '\x83'; // idb
const char aHal [4] = "HAL "; // idb
const char aTLHal [8] = "T&L HAL "; // idb
const char byte_46B460 = '\x83'; // idb
const char byte_46B488 = '\x8F'; // idb
const char byte_46B4B4 = '\x8F'; // idb
const char byte_46B4E0 = '\x93'; // idb
const CHAR off_46B520 [] = {'l', 'o', 'g', '\0'}; // idb
int (*off_46B564 [2])() = {&unknown_libname_2, &sub_422680}; // weak
int (*off_46B568)() = &sub_422680; // weak
const char aErrorMidiFile [18] = "error : MIDI File "; // idb
const char aError_8 [8] = "error : "; // idb
const char byte_46B64C = '\x97'; // idb
const char aDirectinput_0 [12] = "DirectInput "; // idb
const char aDirectinputSet_0 [32] = "DirectInput SetCooperativeLevel "; // idb
const char aDirectinputSet [26] = "DirectInput SetDataFormat "; // idb
const char aDirectinput [12] = "DirectInput "; // idb
const char aError_9 [8] = "error : "; // idb
const char byte_46B780 = '\x83'; // idb
const char byte_46B7D8 = '\x83'; // idb
const char byte_46B7F8 = '\x83'; // idb
const char byte_46B830 = '\x83'; // idb
const char byte_46B858 = '\x83'; // idb
const char byte_46B878 = '\x83'; // idb
const char byte_46B898 = '\x82'; // idb
const char byte_46B8B8 = '\x83'; // idb
const char byte_46B8D4 = '\x83'; // idb
const char byte_46B8F8 = '\x83'; // idb
const char byte_46B920 = '\x83'; // idb
const char a16bit [6] = "16Bit "; // idb
const char byte_46B96C = '\x83'; // idb
const char byte_46B988 = '\x92'; // idb
const char byte_46B9A8 = '\x83'; // idb
const char byte_46B9E0 = '\x83'; // idb
const char byte_46BC09 [3] = {'\0', '\0', '\0'}; // idb
const char off_46BCC0 [] = {'%', '9', 'd', '\0'}; // idb
const char off_46BDD0 [] = {'%', '2', 'd', '\0'}; // idb
const char aDirectsound_0 [12] = "DirectSound "; // idb
const char aDirectsound [12] = "DirectSound "; // idb
const char aWav_0 [4] = "Wav "; // idb
const char aWav [4] = "Wav "; // idb
const char aErrorSound [14] = "error : Sound "; // idb
int dword_46C220 [6] = {0, 21, 25, 23, 20, 26}; // weak
const char aError_10 [8] = "error : "; // idb
const char byte_46C260 = '\x83'; // idb
const char byte_46C2A8 = '\x83'; // idb
const char aS_0 [2] = "%s"; // idb
const char byte_46C368 = '\x83'; // idb
int(__stdcall* off_46C680)(int) = &sub_43AD70; // weak
int(__stdcall* off_46C69C)(int) = &sub_43B480; // weak
void (__noreturn* off_46CB7C [7])() =
{
  &_purecall,
  &_purecall,
  &_purecall,
  &_purecall,
  &_purecall,
  &_purecall,
  &_purecall
}; // weak
int (*off_46CB9C)() = &sub_43C510; // weak
int(__stdcall* off_46CBBC)(LPCSTR lpFileName, int) = &sub_43CE60; // weak
_BYTE byte_46CBE4 [4] = {114, 0, 0, 0}; // weak
int(__stdcall* off_46CBE8)(LPCSTR lpFileName, int) = &sub_43CE60; // weak
_UNKNOWN unk_46CDFC; // weak
_UNKNOWN unk_46D004; // weak
int(__stdcall* off_46D034)(int, int, int) = &sub_44071C; // weak
int(__stdcall* off_46D058)(int, int, int) = &sub_440AF1; // weak
_UNKNOWN unk_46D07C; // weak
_UNKNOWN unk_46D0C8; // weak
_UNKNOWN unk_46D0D8; // weak
int(__thiscall* off_46D0E8)(void* Block, char) = &sub_446B88; // weak
int(__thiscall* off_46D134)(void* Block, char) = &sub_449CDA; // weak
int(__thiscall* off_46D174)(void* Block, char) = &sub_449CF6; // weak
int(__thiscall* off_46D180)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D18C)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D198)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1A4)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1B0)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1BC)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1C8)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1D4)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1E0)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1EC)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D1F8)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D204)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D210)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D21C)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D228)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D234)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D240)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D24C)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D258)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D264)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D270)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D27C)(void* Block, char) = &sub_449610; // weak
int(__thiscall* off_46D288)(void* Block, char) = &sub_449D12; // weak
int(__thiscall* off_46D294)(void* Block, char) = &sub_449D33; // weak
char* off_46D2A0 [120] =
{
  "Bogus message code %d",
  "Sorry, there are legal restrictions on arithmetic coding",
  "ALIGN_TYPE is wrong, please fix",
  "MAX_ALLOC_CHUNK is wrong, please fix",
  "Bogus buffer control mode",
  "Invalid component ID %d in SOS",
  "IDCT output block size %d not supported",
  "Bogus input colorspace",
  "Bogus JPEG colorspace",
  "Bogus marker length",
  "Wrong JPEG library version: library is %d, caller expects %d",
  "Sampling factors too large for interleaved scan",
  "Invalid memory pool code %d",
  "Unsupported JPEG data precision %d",
  "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d",
  "Invalid progressive parameters at scan script entry %d",
  "Bogus sampling factors",
  "Invalid scan script at entry %d",
  "Improper call to JPEG library in state %d",
  "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u",
  "Bogus virtual array access",
  "Buffer passed to JPEG library is too small",
  "Suspension not allowed here",
  "CCIR601 sampling not implemented yet",
  "Too many color components: %d, max %d",
  "Unsupported color conversion request",
  "Bogus DAC index %d",
  "Bogus DAC value 0x%x",
  "Bogus DHT counts",
  "Bogus DHT index %d",
  "Bogus DQT index %d",
  "Empty JPEG image (DNL not supported)",
  "Read from EMS failed",
  "Write to EMS failed",
  "Didn't expect more than one scan",
  "Input file read error",
  "Output file write error --- out of disk space?",
  "Fractional sampling not implemented yet",
  "Huffman code size table overflow",
  "Missing Huffman code table entry",
  "Maximum supported image dimension is %u pixels",
  "Empty input file",
  "Premature end of input file",
  "Cannot transcode due to multiple use of quantization table %d",
  "Scan script does not transmit all data",
  "Invalid color quantization mode change",
  "Not implemented yet",
  "Requested feature was omitted at compile time",
  "Backing store not supported",
  "Huffman table 0x%02x was not defined",
  "JPEG datastream contains no image",
  "Quantization table 0x%02x was not defined",
  "Not a JPEG file: starts with 0x%02x 0x%02x",
  "Insufficient memory (case %d)",
  "Cannot quantize more than %d color components",
  "Cannot quantize to fewer than %d colors",
  "Cannot quantize to more than %d colors",
  "Invalid JPEG file structure: two SOF markers",
  "Invalid JPEG file structure: missing SOS marker",
  "Unsupported JPEG process: SOF type 0x%02x",
  "Invalid JPEG file structure: two SOI markers",
  "Invalid JPEG file structure: SOS before SOF",
  "Failed to create temporary file %s",
  "Read failed on temporary file",
  "Seek failed on temporary file",
  "Write failed on temporary file --- out of disk space?",
  "Application transferred too few scanlines",
  "Unsupported marker type 0x%02x",
  "Virtual array controller messed up",
  "Image too wide for this implementation",
  "Read from XMS failed",
  "Write to XMS failed",
  "Copyright (C) 1996, Thomas G. Lane",
  "6a  7-Feb-96",
  "Caution: quantization tables are too coarse for baseline JPEG",
  "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d",
  "Unknown APP0 marker (not JFIF), length %u",
  "Unknown APP14 marker (not Adobe), length %u",
  "Define Arithmetic Table 0x%02x: 0x%02x",
  "Define Huffman Table 0x%02x",
  "Define Quantization Table %d  precision %d",
  "Define Restart Interval %u",
  "Freed EMS handle %u",
  "Obtained EMS handle %u",
  "End Of Image",
  "        %3d %3d %3d %3d %3d %3d %3d %3d",
  "JFIF APP0 marker, density %dx%d  %d",
  "Warning: thumbnail image size does not match data length %u",
  "Unknown JFIF minor revision number %d.%02d",
  "    with %d x %d thumbnail image",
  "Skipping marker 0x%02x, length %u",
  "Unexpected marker 0x%02x",
  "        %4u %4u %4u %4u %4u %4u %4u %4u",
  "Quantizing to %d = %d*%d*%d colors",
  "Quantizing to %d colors",
  "Selected %d colors for quantization",
  "At marker 0x%02x, recovery action %d",
  "RST%d",
  "Smoothing not supported with nonstandard sampling ratios",
  "Start Of Frame 0x%02x: width=%u, height=%u, components=%d",
  "    Component %d: %dhx%dv q=%d",
  "Start of Image",
  "Start Of Scan: %d components",
  "    Component %d: dc=%d ac=%d",
  "  Ss=%d, Se=%d, Ah=%d, Al=%d",
  "Closed temporary file %s",
  "Opened temporary file %s",
  "Unrecognized component IDs %d %d %d, assuming YCbCr",
  "Freed XMS handle %u",
  "Obtained XMS handle %u",
  "Unknown Adobe color transform code %d",
  "Inconsistent progression sequence for component %d coefficient %d",
  "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x",
  "Corrupt JPEG data: premature end of data segment",
  "Corrupt JPEG data: bad Huffman code",
  "Warning: unknown JFIF revision number %d.%02d",
  "Premature end of JPEG file",
  "Corrupt JPEG data: found marker 0x%02x instead of RST%d",
  "Invalid SOS parameters for sequential JPEG",
  "Application transferred too many scanlines"
}; // weak
char byte_46E618 [] = {'0'}; // weak
int dword_46E634 [7] = {128, 8, 136, 34, 170, 85, 255}; // weak
int dword_46E650 [7] = {255, 15, 255, 51, 255, 85, 255}; // weak
char byte_46E964 [268] =
{
  '\x89',
  'P',
  'N',
  'G',
  '\r',
  '\n',
  '\x1A',
  '\n',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\x05',
  '\0',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\0',
  '\0',
  '\x0E',
  '\0',
  '\0',
  '\0',
  '\x0F',
  '\0',
  '\0',
  '\0',
  '\x1B',
  '\0',
  '\0',
  '\0',
  '\x1C',
  '\0',
  '\0',
  '\0',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\x04',
  '\0',
  '\0',
  '\0',
  '\a',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\0',
  '\0',
  '\x1A',
  '\0',
  '\0',
  '\0',
  '\x1D',
  '\0',
  '\0',
  '\0',
  '*',
  '\0',
  '\0',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\b',
  '\0',
  '\0',
  '\0',
  '\f',
  '\0',
  '\0',
  '\0',
  '\x11',
  '\0',
  '\0',
  '\0',
  '\x19',
  '\0',
  '\0',
  '\0',
  '\x1E',
  '\0',
  '\0',
  '\0',
  ')',
  '\0',
  '\0',
  '\0',
  '+',
  '\0',
  '\0',
  '\0',
  '\t',
  '\0',
  '\0',
  '\0',
  '\v',
  '\0',
  '\0',
  '\0',
  '\x12',
  '\0',
  '\0',
  '\0',
  '\x18',
  '\0',
  '\0',
  '\0',
  '\x1F',
  '\0',
  '\0',
  '\0',
  '(',
  '\0',
  '\0',
  '\0',
  ',',
  '\0',
  '\0',
  '\0',
  '5',
  '\0',
  '\0',
  '\0',
  '\n',
  '\0',
  '\0',
  '\0',
  '\x13',
  '\0',
  '\0',
  '\0',
  '\x17',
  '\0',
  '\0',
  '\0',
  ' ',
  '\0',
  '\0',
  '\0',
  '\'',
  '\0',
  '\0',
  '\0',
  '-',
  '\0',
  '\0',
  '\0',
  '4',
  '\0',
  '\0',
  '\0',
  '6',
  '\0',
  '\0',
  '\0',
  '\x14',
  '\0',
  '\0',
  '\0',
  '\x16',
  '\0',
  '\0',
  '\0',
  '!',
  '\0',
  '\0',
  '\0',
  '&',
  '\0',
  '\0',
  '\0',
  '.',
  '\0',
  '\0',
  '\0',
  '3',
  '\0',
  '\0',
  '\0',
  '7',
  '\0',
  '\0',
  '\0',
  '<',
  '\0',
  '\0',
  '\0',
  '\x15',
  '\0',
  '\0',
  '\0',
  '\"',
  '\0',
  '\0',
  '\0',
  '%',
  '\0',
  '\0',
  '\0',
  '/',
  '\0',
  '\0',
  '\0',
  '2',
  '\0',
  '\0',
  '\0',
  '8',
  '\0',
  '\0',
  '\0',
  ';',
  '\0',
  '\0',
  '\0',
  '=',
  '\0',
  '\0',
  '\0',
  '#',
  '\0',
  '\0',
  '\0',
  '$',
  '\0',
  '\0',
  '\0',
  '0',
  '\0',
  '\0',
  '\0',
  '1',
  '\0',
  '\0',
  '\0',
  '9',
  '\0',
  '\0',
  '\0',
  ':',
  '\0',
  '\0',
  '\0',
  '>',
  '\0',
  '\0',
  '\0',
  '?',
  '\0',
  '\0',
  '\0'
}; // weak
int dword_46EA70 [64] =
{
  0,
  1,
  8,
  16,
  9,
  2,
  3,
  10,
  17,
  24,
  32,
  25,
  18,
  11,
  4,
  5,
  12,
  19,
  26,
  33,
  40,
  48,
  41,
  34,
  27,
  20,
  13,
  6,
  7,
  14,
  21,
  28,
  35,
  42,
  49,
  56,
  57,
  50,
  43,
  36,
  29,
  22,
  15,
  23,
  30,
  37,
  44,
  51,
  58,
  59,
  52,
  45,
  38,
  31,
  39,
  46,
  53,
  60,
  61,
  54,
  47,
  55,
  62,
  63
}; // weak
_UNKNOWN unk_46EB70; // weak
int dword_46EBB0 [] = {1600}; // weak
int dword_46EBB8 [] = {0}; // weak
int dword_46EC40 [7] = {0, 4, 0, 2, 0, 1, 0}; // weak
int dword_46EC5C [7] = {8, 8, 4, 4, 2, 2, 1}; // weak
int dword_46EC78 [] = {0}; // weak
int dword_46EC94 [7] = {8, 8, 8, 4, 4, 2, 2}; // weak
int dword_46F140 [256] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117
}; // weak
int dword_46F540 [16] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384}; // weak
int dword_46F580 [42] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767,
  0,
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024,
  2048,
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  0
}; // weak
int dword_46F628 [16] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384}; // weak
int dword_46F668 [16] =
{
  0,
  -1,
  -3,
  -7,
  -15,
  -31,
  -63,
  -127,
  -255,
  -511,
  -1023,
  -2047,
  -4095,
  -8191,
  -16383,
  -32767
}; // weak
_UNKNOWN unk_46F6A8; // weak
_UNKNOWN unk_46F728; // weak
_UNKNOWN unk_46F768; // weak
int dword_46F868 [] = {1}; // weak
int dword_46F878 [19] = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}; // weak
_UNKNOWN unk_46F9F0; // weak
_UNKNOWN unk_46FA70; // weak
_UNKNOWN unk_46FAF0; // weak
_UNKNOWN unk_46FB68; // weak
_UNKNOWN unk_46FE10; // weak
_UNKNOWN unk_46FE20; // weak
const IID riidltf = {3212410928u, 18490u, 19874u, { 170u, 153u, 93u, 100u, 237u, 54u, 151u, 0u }}; // idb
_UNKNOWN unk_46FEE0; // weak
const CHAR aIsprocessorfea [] = "IsProcessorFeaturePresent"; // idb
char byte_470090 [92] =
{
  '\x06',
  '\0',
  '\0',
  '\x06',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\x10',
  '\0',
  '\x03',
  '\x06',
  '\0',
  '\x06',
  '\x02',
  '\x10',
  '\x04',
  'E',
  'E',
  'E',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '\x05',
  '5',
  '0',
  '\0',
  'P',
  '\0',
  '\0',
  '\0',
  '\0',
  ' ',
  '(',
  '8',
  'P',
  'X',
  '\a',
  '\b',
  '\0',
  '7',
  '0',
  '0',
  'W',
  'P',
  '\a',
  '\0',
  '\0',
  ' ',
  ' ',
  '\b',
  '\0',
  '\0',
  '\0',
  '\0',
  '\b',
  '`',
  'h',
  '`',
  '`',
  '`',
  '`',
  '\0',
  '\0',
  'p',
  'p',
  'x',
  'x',
  'x',
  'x',
  '\b',
  '\a',
  '\b',
  '\0',
  '\0',
  '\a',
  '\0',
  '\b',
  '\b',
  '\b',
  '\0',
  '\0',
  '\b',
  '\0',
  '\b',
  '\0',
  '\a',
  '\b',
  '\0',
  '\0',
  '\0'
}; // weak
void (*dword_474AB8 [2])(void) = {NULL, NULL}; // weak
void (*dword_474AC0)(void) = NULL; // weak
_UNKNOWN unk_476000; // weak
void (*dword_4760A4)(void) = NULL; // weak
_UNKNOWN unk_4760A8; // weak
int (*dword_4760C0)(void) = NULL; // weak
_UNKNOWN unk_4760C4; // weak
void (*dword_4760CC)(void) = NULL; // weak
_UNKNOWN unk_4760D0; // weak
void (*dword_4760D8)(void) = NULL; // weak
int dword_4760DC = 0; // weak
int off_4760E0 = 4629412; // idb
char* off_4760E4 = "dummy"; // idb
int dword_476120 [64] =
{
  200000,
  200000,
  200000,
  200000,
  200000,
  200000,
  200000,
  250000,
  250000,
  250000,
  250000,
  250000,
  250000,
  250000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  300000,
  400000,
  400000,
  400000,
  400000,
  400000,
  400000,
  400000,
  400000,
  500000,
  500000,
  500000,
  500000,
  500000,
  500000,
  600000,
  600000,
  600000,
  600000,
  600000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000,
  700000
}; // weak
int(__cdecl* funcs_409BF3 [17])(int, int) =
{
  &sub_40B8E0,
  &sub_40BA80,
  &sub_40BB80,
  &sub_40C100,
  &sub_40C180,
  &sub_40C5B0,
  &sub_40CAF0,
  &sub_40D040,
  &sub_40D400,
  &sub_40D530,
  &sub_40D930,
  &sub_40D770,
  &sub_40DAA0,
  &sub_40DBC0,
  &sub_40DCC0,
  &sub_40DE00,
  &sub_40E1B0
}; // weak
int dword_476264 [] = {0}; // weak
int dword_476268 [] = {3}; // weak
int dword_47626C [11] = {1, 2, 3, 4, 1, 4, 0, 4, 2, 3, 0}; // weak
int dword_476298 [] = {669}; // weak
int dword_47629C [39] =
{
  0,
  670,
  0,
  671,
  0,
  672,
  4253104,
  675,
  4252512,
  676,
  4252512,
  677,
  4252512,
  678,
  4252512,
  679,
  4252512,
  680,
  4252512,
  681,
  4252512,
  682,
  4252512,
  683,
  0,
  684,
  4253984,
  684,
  4253984,
  684,
  4253984,
  691,
  0,
  673,
  4254736,
  674,
  4255152,
  685,
  4253712
}; // weak
char byte_476338 [] = {'\0'}; // weak
_UNKNOWN unk_476358; // weak
_UNKNOWN unk_4763C8; // weak
void* off_476438 = &unk_476358; // weak
int dword_476440 [16] = {0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 0}; // weak
int dword_476480 [8] = {0, 1, 1, 2, 2, 3, 4, 0}; // weak
int dword_4764A0 = 10539263; // weak
int dword_4764A4 = 10518783; // weak
int dword_4764A8 = 14713024; // weak
int dword_4764AC = 16728128; // weak
int dword_4764B0 [5] = {10000000, 20000000, 40000000, 60000000, 1900000000}; // weak
char* off_4764C4 = "dummy"; // idb
char* off_4764E8 [7] =
{
  "dummy",
  "dummy",
  "data/stg1enm.anm",
  "data/stg1enm2.anm",
  "data/stg2enm.anm",
  "data/stg2enm2.anm",
  "data/stg3enm.anm"
}; // weak
char* off_4764EC [6] =
{
  "dummy",
  "data/stg1enm.anm",
  "data/stg1enm2.anm",
  "data/stg2enm.anm",
  "data/stg2enm2.anm",
  "data/stg3enm.anm"
}; // weak
int dword_47652C [] = {12}; // weak
int dword_476530 [13] = {20, 16, 10, 32, 16, 10, 32, 16, 10, 32, 16, 14, 18}; // weak
int dword_476564 [] = {16}; // weak
int dword_476568 [] = {12}; // weak
int dword_47656C [13] = {20, 16, 10, 32, 16, 10, 32, 16, 10, 32, 16, 14, 18}; // weak
__int16 word_4765A0 = 0; // weak
__int16 word_4765A4 = 2; // weak
__int16 word_4765A8 = -1; // weak
__int16 word_4765AA = -1; // weak
int dword_4765B8 [42] =
{
  22,
  32,
  0,
  16711680,
  65280,
  255,
  21,
  32,
  -16777216,
  16711680,
  65280,
  255,
  24,
  16,
  0,
  31744,
  992,
  31,
  23,
  16,
  0,
  63488,
  2016,
  31,
  25,
  16,
  32768,
  31744,
  992,
  31,
  26,
  16,
  61440,
  3840,
  240,
  15,
  -1,
  0,
  0,
  0,
  0,
  0
}; // weak
int dword_476660 [31] =
{
  10,
  20,
  30,
  40,
  50,
  60,
  70,
  80,
  90,
  100,
  200,
  300,
  400,
  500,
  600,
  700,
  800,
  900,
  1000,
  2000,
  3000,
  4000,
  5000,
  6000,
  7000,
  8000,
  9000,
  10000,
  11000,
  12000,
  51200
}; // weak
int dword_4766DC [11] = {8, 16, 32, 48, 64, 80, 96, 128, 999, 1, 0}; // weak
int(__cdecl* off_476708 [8])(int) =
{
  &sub_405260,
  &sub_405C10,
  &sub_406160,
  &sub_4065E0,
  &sub_4066F0,
  &sub_406B10,
  &sub_406E70,
  &sub_4071B0
}; // weak
int(__cdecl* off_47670C [7])(int) =
{
  &sub_405C10,
  &sub_406160,
  &sub_4065E0,
  &sub_4066F0,
  &sub_406B10,
  &sub_406E70,
  &sub_4071B0
}; // weak
_UNKNOWN unk_476728; // weak
void* off_4784D4 = &unk_46BBA8; // weak
char* off_4784D8 = "Reimu Hakurei (A)"; // idb
char* off_4784DC = "Reimu Hakurei (B)"; // idb
char* off_478504 [9] =
{
  "     Easy",
  "   Normal",
  "     Hard",
  "  Lunatic",
  "    Extra",
  "ReimuA ",
  "ReimuB ",
  "MarisaA",
  "MarisaB"
}; // weak
char* off_478518 [4] = {"ReimuA ", "ReimuB ", "MarisaA", "MarisaB"}; // weak
int dword_478528 [] = {0}; // weak
__int16 word_47852C [] = {-1500}; // weak
__int16 word_47852E [125] =
{
  0,
  0,
  0,
  -2000,
  0,
  1,
  0,
  -1200,
  5,
  1,
  0,
  -1400,
  5,
  2,
  0,
  -1000,
  100,
  3,
  0,
  -500,
  100,
  4,
  0,
  -500,
  100,
  5,
  0,
  -1700,
  50,
  6,
  0,
  -1700,
  50,
  7,
  0,
  -1700,
  50,
  8,
  0,
  -1000,
  100,
  9,
  0,
  -1000,
  100,
  10,
  0,
  -1900,
  10,
  11,
  0,
  -1200,
  10,
  12,
  0,
  -900,
  100,
  5,
  0,
  -1500,
  50,
  13,
  0,
  -900,
  50,
  14,
  0,
  -900,
  50,
  15,
  0,
  -600,
  100,
  16,
  0,
  -400,
  100,
  17,
  0,
  -1100,
  0,
  18,
  0,
  -900,
  0,
  5,
  0,
  -1800,
  20,
  6,
  0,
  -1800,
  20,
  7,
  0,
  -1800,
  20,
  19,
  0,
  -300,
  50,
  20,
  0,
  -600,
  50,
  21,
  0,
  -800,
  50,
  22,
  0,
  -100,
  140,
  23,
  0,
  -500,
  100,
  24,
  0,
  -1000,
  20,
  25,
  0,
  -1000,
  90
}; // weak
char off_478628 [] = {'x', '\xC0', 'F', '\0'}; // idb
__int16 word_478690 = 32; // weak
char off_478694 [] = {'\x18', '\xC4', 'F', '\0'}; // idb
char* off_4786B0 [9] =
{
  "ReimuA ",
  "ReimuB ",
  "MarisaA",
  "MarisaB",
  "Easy   ",
  "Normal ",
  "Hard   ",
  "Lunatic",
  "Extra  "
}; // weak
char* off_4786C0 [5] = {"Easy   ", "Normal ", "Hard   ", "Lunatic", "Extra  "}; // weak
_UNKNOWN unk_4786D8; // weak
_UNKNOWN unk_478B60; // weak
void* off_478B88 = &unk_478B60; // weak
_UNKNOWN unk_479328; // weak
_UNKNOWN unk_4793A8; // weak
_DWORD dword_479428 [8] = {16, 33, 66, 132, 272, 584, 1360, 4080}; // weak
float flt_479448 [3] = {0.082000002, 0.60939997, 0.30860001}; // weak
int dword_479454 [4] = {0, 2, 3, 1}; // weak
int dword_479464 [4] = {0, 2, 1, 3}; // weak
char byte_479474 = '\x02'; // weak
__int64 qword_479478 = 36029346783166592i64; // weak
__int64 qword_479480 = -51228819435421784i64; // weak
__int64 qword_479488 = 72059135947964775i64; // weak
__int64 qword_479490 = 72059543969857990i64; // weak
__int64 qword_479498 = -4294967296i64; // weak
int dword_4794D0 = 9; // weak
int dword_4794D4 = 5; // weak
_UNKNOWN unk_4794D8; // weak
_UNKNOWN unk_47A4D8; // weak
int dword_47A5D8 [19] =
{
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  39029,
  39027
}; // weak
int (*off_47A624)(void) = &_fpmath; // weak
int dword_47A630 = -1153374642; // weak
int dword_47A6F4 = 2; // weak
int(__cdecl* off_47A71C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD) = &_fptrap; // weak
char* off_47A734 = "(null)"; // idb
void** off_47A738 = &off_4700EC; // weak
LPCRITICAL_SECTION lpCriticalSection = NULL; // idb
DWORD dwTlsIndex = 4294967295u; // idb
int (*off_47ABDC)(void) = &terminate; // weak
int dword_47B118 [] = {2}; // weak
char* off_47B11C = "R6002\r\n- floating point not loaded\r\n"; // weak
_UNKNOWN unk_47B1A8; // weak
int(__cdecl* off_47B230)(_DWORD) = &sub_4671A5; // weak
char byte_47B2A0 = '.'; // weak
_UNKNOWN unk_47B2A8; // weak
_UNKNOWN unk_47B2C0; // weak
__int16* off_47B2D8 = &word_4743C2; // weak
char byte_47B3F0 [8] = {'\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0'}; // weak
int dword_47B3F8 [] = {932}; // weak
_UNKNOWN unk_47B3FC; // weak
_UNKNOWN unk_47B408; // weak
int dword_47B4E8 = 9876; // weak
_UNKNOWN unk_47B610; // weak
_UNKNOWN unk_47B770; // weak
_UNKNOWN unk_47B8E0; // weak
int dword_47B8E4 = 0; // weak
int dword_47B8E8 = 0; // weak
int dword_47B8EC = 0; // weak
int dword_47B8FC = 0; // weak
_DWORD dword_47B900 [6281] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
}; // weak
int dword_481B24; // weak
float flt_481B28; // weak
float flt_481B2C; // weak
int dword_481B30; // weak
int dword_481B34; // weak
_UNKNOWN unk_487AAC; // weak
int dword_487AB0; // weak
int dword_487AB4; // weak
int dword_487AB8; // weak
int dword_487AC8; // weak
_UNKNOWN unk_487ACC; // weak
int dword_487AD0; // weak
int dword_487AD4; // weak
int dword_487AD8; // weak
int dword_487AE8; // weak
_UNKNOWN unk_487AF0; // weak
int dword_487AF4; // weak
int dword_487AF8; // weak
int dword_487AFC; // weak
int dword_487B0C; // weak
_UNKNOWN unk_487B10; // weak
int dword_487B14; // weak
int dword_487B60; // weak
char byte_487B8C; // weak
int dword_487B90; // weak
int dword_487B94; // weak
char byte_487DB8; // weak
_UNKNOWN unk_487E04; // weak
int dword_487E08; // weak
int dword_487E0C; // weak
int dword_487E10; // weak
int dword_487E20; // weak
_UNKNOWN unk_487E24; // weak
int dword_487E28; // weak
int dword_487E2C; // weak
int dword_487E30; // weak
int dword_487E40; // weak
int dword_487E44; // weak
float flt_487E48; // weak
float flt_487E4C; // weak
_DWORD dword_487E50 [2]; // weak
int dword_487E58; // weak
float flt_487EDC; // idb
float flt_487EE0; // idb
float flt_487EE4; // idb
float flt_487EE8; // idb
float flt_487EEC; // idb
float flt_487EF0; // weak
int dword_487F5C; // weak
int dword_487F60; // weak
int dword_487F64; // weak
int dword_487F68; // weak
int dword_487F6C; // weak
int dword_487F70; // weak
_UNKNOWN unk_487FBC; // weak
_DWORD dword_487FE0 [48737]; // weak
_UNKNOWN unk_4B7964; // weak
int dword_4B7968; // weak
int dword_4B796C; // weak
int dword_4B7970; // weak
int dword_4B7980; // weak
_UNKNOWN unk_4B7984; // weak
int dword_4B7988; // weak
int dword_4B798C; // weak
int dword_4B7990; // weak
int dword_4B79A0; // weak
_UNKNOWN unk_4B79A8; // weak
int dword_4B79AC; // weak
int dword_4B79B0; // weak
int dword_4B79B4; // weak
int dword_4B79C4; // weak
_DWORD dword_4B79C8 [948]; // weak
_UNKNOWN unk_4B8898; // weak
int dword_5A5F60 [11]; // weak
int dword_5A5F8C; // weak
int dword_5A5F90; // weak
int dword_5A5F94; // weak
int dword_5A5F98; // weak
int dword_5A5F9C; // weak
_UNKNOWN unk_5A5FB4; // weak
int dword_5A5FB8; // weak
int dword_5A5FBC; // weak
int dword_5A5FC0; // weak
int dword_5A5FD0; // weak
_UNKNOWN unk_5A5FD8; // weak
int dword_5A5FDC; // weak
int dword_5A5FE0; // weak
int dword_5A5FE4; // weak
int dword_5A5FF4; // weak
_DWORD dword_5A5FF8 [5504]; // weak
_UNKNOWN unk_5AB5F8; // weak
_UNKNOWN unk_5B6900; // weak
_UNKNOWN unk_602000; // weak
_UNKNOWN unk_606060; // weak
_UNKNOWN unk_69BC10; // weak
int dword_69BC14; // weak
int dword_69BC18; // weak
int dword_69BC1C; // weak
int dword_69BC2C; // weak
int dword_69BC30 [5]; // weak
int dword_69BC44; // weak
int dword_69BC48; // weak
char byte_69BC50; // weak
int dword_69BC54; // weak
_UNKNOWN unk_69BC5C; // weak
int dword_69BC60; // weak
int dword_69BC64; // weak
int dword_69BC68; // weak
int dword_69BC78; // weak
_UNKNOWN unk_69BC7C; // weak
int dword_69BC80; // weak
int dword_69BC84; // weak
int dword_69BC88; // weak
int dword_69BC98; // weak
char dword_69BCA0 []; // idb
int dword_69BCA4; // weak
int dword_69BCA8; // weak
char dword_69BCAC []; // idb
int dword_69BCB0; // weak
char dword_69BCB4 []; // idb
int dword_69BCB8; // weak
int dword_69BCBC; // weak
char dword_69BCC0 []; // idb
char dword_69BCC4 []; // idb
char dword_69BCC8 []; // idb
char byte_69BCCC; // weak
_UNKNOWN unk_69BCD0; // weak
__int16 word_69BD0C []; // weak
__int16 word_69BD0E [2017]; // weak
_UNKNOWN unk_69CCD0; // weak
char byte_69CCDC []; // weak
char byte_69CCE1 [79]; // weak
_DWORD dword_69CD30 [480]; // weak
__int16 word_69D4B0; // weak
__int16 word_69D4B4; // weak
__int16 word_69D4B6; // weak
char byte_69D4B8; // weak
char byte_69D4B9; // weak
char byte_69D4BA; // weak
char byte_69D4BB; // weak
char byte_69D4BC; // weak
char byte_69D4BD; // weak
char byte_69D4BE; // weak
char byte_69D4BF; // weak
char byte_69D4C0; // weak
char byte_69D4C1; // weak
char byte_69D4C2; // weak
char byte_69D4C3; // weak
char byte_69D4C4; // weak
int dword_69D4C8; // weak
char Destination [512]; // idb
__int16 word_69D6CC; // weak
char dword_69D6D4 []; // idb
int dword_69D6D8; // weak
float flt_69D6DC; // weak
float flt_69D6E0; // weak
float flt_69D6E4; // weak
float flt_69D6E8; // weak
float flt_69D6EC; // weak
float flt_69D6F0; // weak
int dword_69D6F4; // weak
int dword_69D6F8; // weak
float flt_69D6FC; // weak
float flt_69D700; // weak
float flt_69D704; // weak
float flt_69D708; // weak
int dword_69D70C; // weak
int dword_69D710; // weak
_UNKNOWN unk_69D720; // weak
int dword_69D724; // weak
int dword_69D728; // weak
int dword_69D72C; // weak
int dword_69D73C; // weak
_UNKNOWN unk_69D740; // weak
int dword_69D744; // weak
int dword_69D748; // weak
int dword_69D74C; // weak
int dword_69D75C; // weak
struct tagJOYCAPSA pjc; // idb
__int16 word_69D8F4; // weak
__int16 word_69D8F8; // weak
int dword_69D8FC; // weak
int dword_69D900; // weak
__int16 word_69D904; // weak
__int16 word_69D908; // weak
__int16 word_69D90C; // weak
__int16 word_69D910; // weak
int dword_69D914; // weak
char byte_69D918 [128]; // weak
_BYTE byte_69D998 [2048]; // weak
int dword_69E198; // weak
char byte_69E1B0 [128]; // weak
int dword_69E230; // weak
int dword_69E234; // weak
int dword_69E238; // weak
int dword_69E23C; // weak
int dword_69E240; // weak
_UNKNOWN unk_69E248; // weak
char byte_69E268 [138765]; // weak
_UNKNOWN unk_6C6BB4; // weak
HWND hWnd; // idb
int dword_6C6BD8; // weak
int dword_6C6BDC; // weak
int dword_6C6BE0; // weak
char byte_6C6BE4; // weak
UINT uiParam; // idb
UINT dword_6C6BEC; // idb
UINT dword_6C6BF0; // idb
int dword_6C6BF4; // weak
double dbl_6C6BF8; // weak
int dword_6C6C00; // weak
char Buffer [256]; // idb
int dword_6C6D08; // weak
int dword_6C6D0C; // weak
int dword_6C6D10; // weak
int dword_6C6D18; // weak
int dword_6C6D1C; // weak
int dword_6C6D20; // weak
int dword_6C6D24; // weak
int dword_6C6D28; // weak
int dword_6C6D2C; // weak
int dword_6C6D30; // weak
DWORD_PTR lpParameter; // idb
float flt_6C6D60 [16]; // weak
float flt_6C6DA0 [16]; // weak
int dword_6C6DE0; // weak
int dword_6C6DE4; // weak
int dword_6C6DE8; // weak
int dword_6C6DEC; // weak
int dword_6C6DF0; // weak
int dword_6C6DF4; // weak
_UNKNOWN unk_6C6DF8; // weak
int dword_6C6E00; // weak
__int16 word_6C6E2C; // weak
__int16 word_6C6E2E; // weak
__int16 word_6C6E30; // weak
__int16 word_6C6E32; // weak
__int16 word_6C6E34; // weak
__int16 word_6C6E36; // weak
__int16 word_6C6E38; // weak
__int16 word_6C6E3A; // weak
__int16 word_6C6E3C; // weak
int dword_6C6E40; // weak
char byte_6C6E44; // weak
char byte_6C6E45; // weak
char byte_6C6E46; // weak
char byte_6C6E47; // weak
char byte_6C6E48; // weak
char byte_6C6E49; // weak
char byte_6C6E4A; // weak
char byte_6C6E4B; // weak
__int16 word_6C6E4C; // weak
__int16 word_6C6E4E; // weak
int dword_6C6E60; // weak
char byte_6C6E7C; // weak
char byte_6C6E7D; // weak
int dword_6C6EA4; // weak
int dword_6C6EA8; // weak
int dword_6C6EB0; // weak
int dword_6C6EB4; // weak
int dword_6C6EB8; // weak
int dword_6C6EBC; // weak
float flt_6C6EC0; // weak
int dword_6C6EC4; // weak
int dword_6C6EC8; // weak
float flt_6C6ECC; // weak
float flt_6C6ED0; // weak
char byte_6C7114; // weak
char byte_6C7115; // weak
char byte_6C7116; // weak
int dword_6C7118; // weak
_UNKNOWN unk_6C711C; // weak
int dword_6C7130; // weak
int dword_6C71AC; // weak
int dword_6C71F0 [214]; // weak
int dword_6CA624; // weak
float flt_6CA628 [272]; // weak
float flt_6CAA68; // weak
float flt_6CAA6C; // weak
float flt_6CAA70; // weak
int dword_6CB044; // weak
float flt_6CB048; // weak
int dword_6CB04C; // weak
int dword_6D1BF0; // weak
int dword_6D3F0C; // weak
int dword_6D3F10; // weak
int dword_6D3F14; // weak
int dword_6D3F18; // weak
int dword_6D3F50 [395]; // weak
int dword_6D457C; // weak
HANDLE pHandles; // idb
int dword_6D4588; // idb
int dword_6D4590; // weak
int dword_6D4594; // weak
int dword_6D4598; // weak
int dword_6D459C; // weak
int dword_6D45A0; // weak
int dword_6D45A4; // weak
int dword_6D45A8; // weak
int dword_6D45AC; // weak
int dword_6D45B0; // weak
int dword_6D45B4; // weak
int dword_6D45B8; // weak
int dword_6D45BC; // weak
int dword_6D45C0; // weak
int dword_6D45C4; // weak
int dword_6D45C8; // weak
int dword_6D45CC; // weak
int dword_6D45D0; // weak
int dword_6D45D4; // weak
int dword_6D45D8; // weak
int dword_6D45DC; // weak
int dword_6D45E0; // weak
int dword_6D45E4; // weak
int dword_6D45E8; // weak
int dword_6D45EC; // weak
int dword_6D45F0; // weak
int dword_6D45F4; // weak
int dword_6D45F8; // weak
int dword_6D45FC; // weak
float flt_6D4600; // weak
float flt_6D4604; // weak
int dword_6D4608; // weak
int dword_6D460C; // weak
int dword_6D4610; // weak
int dword_6D4614; // weak
float flt_6D4618; // weak
float flt_6D461C; // weak
int dword_6D4620; // weak
int dword_6D4624; // weak
int dword_6D4628; // weak
int dword_6D462C; // weak
float flt_6D4630; // weak
float flt_6D4634; // weak
int dword_6D4638; // weak
int dword_6D463C; // weak
int dword_6D4640; // weak
int dword_6D4644; // weak
float flt_6D4648; // weak
float flt_6D464C; // weak
int dword_6D4650; // weak
int dword_6D4654; // weak
int dword_6D4658; // weak
int dword_6D465C; // weak
int dword_6D4660; // weak
int dword_6D4664; // weak
int dword_6D4668; // weak
int dword_6D466C; // weak
int dword_6D4670; // weak
int dword_6D4674; // weak
int dword_6D4678; // weak
int dword_6D467C; // weak
int dword_6D4680; // weak
int dword_6D4684; // weak
int dword_6D4688; // weak
int dword_6D468C; // weak
int dword_6D4690; // weak
int dword_6D4694; // weak
int dword_6D4698; // weak
int dword_6D469C; // weak
int dword_6D46A0; // weak
int dword_6D46A4; // weak
int dword_6D46A8; // weak
int dword_6D46AC; // weak
int dword_6D46B0; // weak
int dword_6D46B4; // weak
int dword_6D46B8; // weak
int dword_6D46BC; // weak
_UNKNOWN unk_6D46C0; // weak
int dword_6E61D4; // weak
int dword_6E61D8; // weak
int dword_6E61DC; // weak
__int64 qword_6E61E0; // weak
int dword_6E61F8; // weak
int dword_6E6200; // weak
int dword_6E6214; // weak
int dword_6E6218; // weak
int dword_6E6230; // weak
char byte_6E6238; // weak
int dword_6E623C; // weak
int dword_6E6240; // weak
int(__cdecl* dword_6E6244)(_DWORD, _DWORD); // weak
int dword_6E639C; // idb
CHAR Filename [260]; // idb
char byte_6E64C4; // weak
int dword_6E6530; // weak
int dword_6E655C; // weak
LCID Locale; // idb
void* dword_6E6654; // idb
int dword_6E6658; // weak
char byte_6E6660 []; // weak
char byte_6E6661 [259]; // weak
UINT CodePage; // idb
__int16 word_6E6770 []; // weak
char byte_6E6780 [256]; // weak
UINT uNumber; // idb
int dword_6E68A0 []; // weak
int dword_6E69A0; // weak
int dword_6E79C0; // weak
int dword_6E79D0; // weak
HANDLE hHeap; // idb
int dword_6E79E4; // weak
int dword_6E79EC; // weak
void* Block; // idb
int dword_6E79F4; // weak
int dword_6E79F8; // weak

//----- (00401000) --------------------------------------------------------
int __thiscall sub_401000(int this) {
    int j; // [esp+4h] [ebp-84h]
    int v4; // [esp+Ch] [ebp-7Ch]
    int i; // [esp+5Ch] [ebp-2Ch]
    int v6; // [esp+64h] [ebp-24h]

    sub_403720(this);
    sub_403720(this + 272);
    v6 = 256;
    for(i = this + 544; --v6 >= 0; i += 96)
        ;
    sub_4010E0((void*) (this + 25156));
    sub_4010E0((void*) (this + 27068));
    v4 = 515;
    for(j = this + 28980; --v4 >= 0; j += 40)
        sub_424127((_DWORD*) (j + 24));
    return this;
}

//----- (004010E0) --------------------------------------------------------
void* __thiscall sub_4010E0(void* this) {
    int i; // [esp+14h] [ebp-1Ch]
    int v4; // [esp+1Ch] [ebp-14h]

    v4 = 6;
    for(i = (int) this + 8; --v4 >= 0; i += 272)
        sub_403720(i);
    sub_403720((int) this + 1640);
    return this;
}

//----- (00401140) --------------------------------------------------------
int __cdecl sub_401140(int a1) {
    int v2; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    if(byte_69D4BF || byte_69D4C0) {
        if(byte_69D4BF)
            sub_401B80((_WORD*) (a1 + 25156));
    }
    else {
        v2 = a1 + 28980;
        for(i = 0; i < 515; ++i) {
            if(*(_BYTE*) (v2 + 36)) {
                *(float*) (v2 + 12) = *(float*) (v2 + 12) - 0.5 * flt_6C6EC0;
                *(_DWORD*) (v2 + 24) = *(_DWORD*) (v2 + 32);
                sub_424285((float*) &dword_6C6D18, (_DWORD*) (v2 + 32), (float*) (v2 + 28));
                if(*(int*) (v2 + 32) > 60)
                    *(_BYTE*) (v2 + 36) = 0;
            }
            v2 += 40;
        }
    }
    if(byte_69D4C0)
        sub_402870((_WORD*) (a1 + 27068));
    return 1;
}
// 69D4BF: using guessed type char byte_69D4BF;
// 69D4C0: using guessed type char byte_69D4C0;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;

//----- (00401250) --------------------------------------------------------
int __cdecl sub_401250(_DWORD* a1) {
    sub_4016B0(a1);
    a1 [6280] = 0;
    sub_402740(a1 + 6289);
    sub_403060(a1 + 6767);
    return 1;
}

//----- (00401290) --------------------------------------------------------
int __cdecl sub_401290(int a1) {
    if(byte_6C7114)
        sub_4031E0(a1);
    else
        sub_4033B0(a1);
    return 1;
}
// 6C7114: using guessed type char byte_6C7114;

//----- (004012C0) --------------------------------------------------------
int sub_4012C0() {
    dword_487AB0 = (int) sub_401140;
    dword_487AB4 = (int) sub_4013A0;
    dword_487AB8 = (int) sub_4014D0;
    dword_487AC8 = (int) dword_47B900;
    if(sub_41C860(byte_69D918, (int) &unk_487AAC, 1))
        return -1;
    dword_47B8E4 = (int) sub_401250;
    dword_47B8E8 = 0;
    dword_47B8EC = 0;
    dword_47B8FC = (int) dword_47B900;
    sub_41C940((__int16*) byte_69D918, (int) &unk_47B8E0, 15);
    dword_487AD0 = (int) sub_401290;
    dword_487AD4 = 0;
    dword_487AD8 = 0;
    dword_487AE8 = (int) dword_47B900;
    sub_41C940((__int16*) byte_69D918, (int) &unk_487ACC, 10);
    return 0;
}
// 47B8E4: using guessed type int dword_47B8E4;
// 47B8E8: using guessed type int dword_47B8E8;
// 47B8EC: using guessed type int dword_47B8EC;
// 47B8FC: using guessed type int dword_47B8FC;
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 487AB0: using guessed type int dword_487AB0;
// 487AB4: using guessed type int dword_487AB4;
// 487AB8: using guessed type int dword_487AB8;
// 487AC8: using guessed type int dword_487AC8;
// 487AD0: using guessed type int dword_487AD0;
// 487AD4: using guessed type int dword_487AD4;
// 487AD8: using guessed type int dword_487AD8;
// 487AE8: using guessed type int dword_487AE8;

//----- (004013A0) --------------------------------------------------------
int __cdecl sub_4013A0(_DWORD* a1) {
    if(sub_431DC0((_DWORD*) dword_6D4588, 1, "data/ascii.anm", 0))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 2, "data/asciis.anm", 119))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 3, "data/capture.anm", 1816))
        return -1;
    sub_401410(a1);
    return 0;
}

//----- (00401410) --------------------------------------------------------
_DWORD* __thiscall sub_401410(_DWORD* this) {
    int v1; // ecx
    _DWORD* result; // eax
    int* v4; // [esp+8h] [ebp-Ch]
    int* v5; // [esp+Ch] [ebp-8h]

    memset(this, 0, 0xC1ACu);
    this [6281] = -1;
    this [6282] = 1065353216;
    this [6283] = 1065353216;
    v1 = this [100];
    BYTE1(v1) |= 3u;
    this [100] = v1;
    v5 = (int*) dword_6D4588;
    sub_403580(this + 68);
    sub_4323A0(v5, (int) (this + 68), 0);
    v4 = (int*) dword_6D4588;
    sub_403580(this);
    sub_4323A0(v4, (int) this, 32);
    this [106] = 1036831949;
    result = this;
    this [6285] = 0;
    return result;
}

//----- (004014D0) --------------------------------------------------------
int sub_4014D0() {
    sub_432030(dword_6D4588, 1);
    sub_432030(dword_6D4588, 2);
    sub_432030(dword_6D4588, 3);
    return 0;
}

//----- (00401500) --------------------------------------------------------
void sub_401500() {
    sub_41CDE0(byte_69D918, (int) &unk_487AAC);
    sub_41CDE0(byte_69D918, (int) &unk_47B8E0);
}

//----- (00401530) --------------------------------------------------------
int __fastcall sub_401530(_DWORD* a1, int a2, _DWORD* a3, char* a4) {
    int result; // eax
    char v5; // dl
    _BYTE* v6; // [esp+8h] [ebp-10h]
    _DWORD* v8; // [esp+14h] [ebp-4h]

    result = (int) a1;
    if((int) a1 [6280] < 256) {
        v8 = &a1 [24 * a1 [6280]++ + 136];
        v6 = v8;
        do {
            v5 = *a4;
            *v6++ = *a4++;
        }
        while(v5);
        v8 [16] = *a3;
        v8 [17] = a3 [1];
        v8 [18] = a3 [2];
        v8 [19] = a1 [6281];
        v8 [20] = a1 [6282];
        v8 [21] = a1 [6283];
        v8 [23] = a1 [6284];
        result = dword_6C6E60 & 1;
        if(result | ((unsigned int) dword_6C6E60 >> 8) & 1) {
            result = (int) a1;
            v8 [22] = a1 [6285];
        }
        else {
            v8 [22] = 0;
        }
    }
    return result;
}
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00401650) --------------------------------------------------------
int sub_401650(_DWORD* a1, _DWORD* a2, char* Format, ...) {
    char Buffer [512]; // [esp+0h] [ebp-208h] BYREF
    unsigned int v5; // [esp+200h] [ebp-8h]
    va_list ArgList; // [esp+204h] [ebp-4h]
    unsigned int retaddr; // [esp+20Ch] [ebp+4h]
    va_list va; // [esp+21Ch] [ebp+14h] BYREF

    va_start(va, Format);
    v5 = retaddr ^ dword_47A630;
    va_copy(ArgList, va);
    vsprintf(Buffer, Format, va);
    return sub_401530(a1, (int) a2, a2, Buffer);
}
// 47A630: using guessed type int dword_47A630;

//----- (004016B0) --------------------------------------------------------
_DWORD* __thiscall sub_4016B0(_DWORD* this) {
    int v1; // edx
    _DWORD* result; // eax
    int v4; // [esp+10h] [ebp-14h]
    _BYTE* v5; // [esp+14h] [ebp-10h]
    _DWORD* v6; // [esp+18h] [ebp-Ch]
    int i; // [esp+1Ch] [ebp-8h]
    float v8; // [esp+20h] [ebp-4h]

    v4 = 1;
    v6 = this + 136;
    this [32] |= 1u;
    v1 = this [32];
    BYTE1(v1) |= 3u;
    this [32] = v1;
    for(i = 0; ; ++i) {
        result = this;
        if(i >= this [6280])
            break;
        this [36] = v6 [16];
        this [37] = v6 [17];
        this [38] = v6 [18];
        v5 = v6;
        this [7] = v6 [20];
        this [6] = v6 [21];
        v8 = 14.0 * *((float*) v6 + 20);
        if(v4 != v6 [23]) {
            v4 = v6 [23];
            if(v4) {
                dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
                dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
                dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
                dword_6C6DEC = (unsigned __int64) flt_69D6E8;
            }
            else {
                dword_6C6DE0 = 0;
                dword_6C6DE4 = 0;
                dword_6C6DE8 = 640;
                dword_6C6DEC = 480;
            }
            (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
        }
        while(*v5) {
            if(*v5 == 10) {
                *((float*) this + 37) = 16.0 * *((float*) v6 + 21) + *((float*) this + 37);
                this [36] = v6 [16];
            }
            else if(*v5 == 32) {
                *((float*) this + 36) = v8 + *((float*) this + 36);
            }
            else {
                if(v6 [22]) {
                    this [48] = 56 * ((unsigned __int8) *v5 + 97) + dword_6D4588;
                    this [31] = -1;
                }
                else {
                    this [48] = 56 * ((unsigned __int8) *v5 - 21) + dword_6D4588;
                    this [31] = v6 [19];
                }
                sub_432AD0((void*) dword_6D4588, (unsigned int) this);
                *((float*) this + 36) = v8 + *((float*) this + 36);
            }
            ++v5;
        }
        v6 += 24;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (00401940) --------------------------------------------------------
_DWORD* __thiscall sub_401940(_DWORD* this, _DWORD* a2, int a3, int a4) {
    _DWORD* result; // eax
    int v5; // [esp+8h] [ebp-8h]
    int v6; // [esp+Ch] [ebp-4h]

    if((int) this [6286] >= 512)
        this [6286] = 0;
    v6 = (int) &this [10 * this [6286] + 7245];
    LOBYTE(this [10 * this [6286] + 7254]) = 1;
    v5 = 0;
    if(a3 < 0) {
        *(_BYTE*) v6 = 10;
        v5 = 1;
    }
    else {
        while(a3) {
            *(_BYTE*) (v5 + v6) = a3 % 10;
            ++v5;
            a3 /= 10;
        }
    }
    if(!v5) {
        *(_BYTE*) v6 = 0;
        LOBYTE(v5) = 1;
    }
    *(_BYTE*) (v6 + 37) = v5;
    *(_DWORD*) (v6 + 20) = a4;
    *(_DWORD*) (v6 + 32) = 0;
    *(_DWORD*) (v6 + 28) = 0;
    *(_DWORD*) (v6 + 24) = -999;
    *(_DWORD*) (v6 + 8) = *a2;
    *(_DWORD*) (v6 + 12) = a2 [1];
    *(_DWORD*) (v6 + 16) = a2 [2];
    result = this;
    ++this [6286];
    return result;
}

//----- (00401A60) --------------------------------------------------------
_DWORD* __thiscall sub_401A60(_DWORD* this, _DWORD* a2, int a3, int a4) {
    _DWORD* result; // eax
    int v5; // [esp+8h] [ebp-8h]
    int v6; // [esp+Ch] [ebp-4h]

    if((int) this [6287] >= 3)
        this [6287] = 0;
    v6 = (int) &this [10 * this [6287] + 12365];
    LOBYTE(this [10 * this [6287] + 12374]) = 1;
    v5 = 0;
    if(a3 < 0) {
        *(_BYTE*) v6 = 10;
        v5 = 1;
    }
    else {
        while(a3) {
            *(_BYTE*) (v5 + v6) = a3 % 10;
            ++v5;
            a3 /= 10;
        }
    }
    if(!v5) {
        *(_BYTE*) v6 = 0;
        LOBYTE(v5) = 1;
    }
    *(_BYTE*) (v6 + 37) = v5;
    *(_DWORD*) (v6 + 20) = a4;
    *(_DWORD*) (v6 + 32) = 0;
    *(_DWORD*) (v6 + 28) = 0;
    *(_DWORD*) (v6 + 24) = -999;
    *(_DWORD*) (v6 + 8) = *a2;
    *(_DWORD*) (v6 + 12) = a2 [1];
    *(_DWORD*) (v6 + 16) = a2 [2];
    result = this;
    ++this [6287];
    return result;
}

//----- (00401B80) --------------------------------------------------------
int __thiscall sub_401B80(_WORD* this) {
    int v1; // eax
    int* v4; // [esp+10h] [ebp-7Ch]
    _DWORD* v5; // [esp+18h] [ebp-74h]
    int* v6; // [esp+1Ch] [ebp-70h]
    int i; // [esp+88h] [ebp-4h]
    int j; // [esp+88h] [ebp-4h]
    int k; // [esp+88h] [ebp-4h]
    int m; // [esp+88h] [ebp-4h]
    int n; // [esp+88h] [ebp-4h]
    int ii; // [esp+88h] [ebp-4h]
    int jj; // [esp+88h] [ebp-4h]
    int kk; // [esp+88h] [ebp-4h]
    int mm; // [esp+88h] [ebp-4h]
    int nn; // [esp+88h] [ebp-4h]
    int i1; // [esp+88h] [ebp-4h]
    int i2; // [esp+88h] [ebp-4h]
    int i3; // [esp+88h] [ebp-4h]

    if((word_69D904 & 8) != 0 && (word_69D904 & 8) != (word_69D908 & 8)) {
        *(_DWORD*) this = 3;
        for(i = 0; i < 6; ++i) {
            if((*(_DWORD*) &this [136 * i + 68] & 1) != 0)
                this [136 * i + 73] = 2;
        }
        *((_DWORD*) this + 1) = 0;
        this [889] = 1;
    }
    if((word_69D904 & 0x200) != 0 && (word_69D904 & 0x200) != (word_69D908 & 0x200)) {
        *(_DWORD*) this = 6;
        for(j = 0; j < 6; ++j) {
            if((*(_DWORD*) &this [136 * j + 68] & 1) != 0)
                this [136 * j + 73] = 2;
        }
        *((_DWORD*) this + 1) = 0;
    }
    switch(*(_DWORD*) this) {
        case 0:
            for(k = 0; k < 6; ++k) {
                v6 = (int*) dword_6D4588;
                this [136 * k + 94] = k + 2;
                sub_432430(v6, &this [136 * k + 4], v6 [k + 29263]);
            }
            for(m = 0; m < 3; ++m)
                this [136 * m + 73] = 1;
            ++* (_DWORD*) this;
            *((_DWORD*) this + 1) = 0;
            if(byte_6C7115) {
                v5 = (_DWORD*) dword_6D4588;
                *(_DWORD*) (dword_6D4588 + 135448) = 3;
                v5 [33863] = 32;
                v5 [33864] = 16;
                v5 [33865] = 384;
                v5 [33866] = 448;
                v4 = (int*) dword_6D4588;
                this [910] = 1816;
                sub_432430(v4, (_DWORD*) this + 410, v4 [31077]);
                *((_DWORD*) this + 446) = 1107296256;
                *((_DWORD*) this + 447) = 1098907648;
                *((_DWORD*) this + 448) = 0;
            }
            goto LABEL_26;
        case 1:
            LABEL_26:
            *((_DWORD*) this + 101) = -32640;
            *((_DWORD*) this + 169) = -2139062144;
            *((_DWORD*) this + 76) = 1071225242;
            *((_DWORD*) this + 77) = 1071225242;
            *((_DWORD*) this + 144) = 1069547520;
            *((_DWORD*) this + 145) = 1069547520;
            *((_DWORD*) this + 127) = -1065353216;
            *((_DWORD*) this + 128) = -1065353216;
            *((_DWORD*) this + 129) = 0;
            *((_DWORD*) this + 195) = 0;
            *((_DWORD*) this + 196) = 0;
            *((_DWORD*) this + 197) = 0;
            if(*((int*) this + 1) >= 4) {
                if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                   || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                    *(_DWORD*) this = 2;
                }
                if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                    for(n = 0; n < 3; ++n)
                        this [136 * n + 73] = 2;
                    *(_DWORD*) this = 3;
                    *((_DWORD*) this + 1) = 0;
                    this [889] = 1;
                }
            }
            break;
        case 2:
            *((_DWORD*) this + 101) = -2139062144;
            *((_DWORD*) this + 169) = -32640;
            *((_DWORD*) this + 76) = 1069547520;
            *((_DWORD*) this + 77) = 1069547520;
            *((_DWORD*) this + 144) = 1071225242;
            *((_DWORD*) this + 145) = 1071225242;
            *((_DWORD*) this + 127) = 0;
            *((_DWORD*) this + 128) = 0;
            *((_DWORD*) this + 129) = 0;
            *((_DWORD*) this + 195) = -1065353216;
            *((_DWORD*) this + 196) = -1065353216;
            *((_DWORD*) this + 197) = 0;
            if(*((int*) this + 1) >= 4) {
                if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                   || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                    *(_DWORD*) this = 1;
                }
                if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                    for(ii = 0; ii < 3; ++ii)
                        this [136 * ii + 73] = 2;
                    for(jj = 3; jj < 6; ++jj)
                        this [136 * jj + 73] = 1;
                    *(_DWORD*) this = 5;
                    *((_DWORD*) this + 1) = 0;
                }
            }
            break;
        case 3:
            if(*((int*) this + 1) >= 20) {
                *(_DWORD*) this = 0;
                byte_69D4BF = 0;
                for(kk = 0; kk < 6; ++kk)
                    *(_DWORD*) &this [136 * kk + 68] &= ~1u;
            }
            break;
        case 4:
            *((_DWORD*) this + 305) = -32640;
            *((_DWORD*) this + 373) = -2139062144;
            *((_DWORD*) this + 280) = 1071225242;
            *((_DWORD*) this + 281) = 1071225242;
            *((_DWORD*) this + 348) = 1069547520;
            *((_DWORD*) this + 349) = 1069547520;
            *((_DWORD*) this + 331) = -1065353216;
            *((_DWORD*) this + 332) = -1065353216;
            *((_DWORD*) this + 333) = 0;
            *((_DWORD*) this + 399) = 0;
            *((_DWORD*) this + 400) = 0;
            *((_DWORD*) this + 401) = 0;
            if(*((int*) this + 1) >= 4) {
                if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                   || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                    *(_DWORD*) this = 5;
                }
                if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                    for(mm = 3; mm < 6; ++mm)
                        this [136 * mm + 73] = 2;
                    *(_DWORD*) this = 6;
                    *((_DWORD*) this + 1) = 0;
                }
            }
            break;
        case 5:
            *((_DWORD*) this + 305) = -2139062144;
            *((_DWORD*) this + 373) = -32640;
            *((_DWORD*) this + 280) = 1069547520;
            *((_DWORD*) this + 281) = 1069547520;
            *((_DWORD*) this + 348) = 1071225242;
            *((_DWORD*) this + 349) = 1071225242;
            *((_DWORD*) this + 331) = 0;
            *((_DWORD*) this + 332) = 0;
            *((_DWORD*) this + 333) = 0;
            *((_DWORD*) this + 399) = -1065353216;
            *((_DWORD*) this + 400) = -1065353216;
            *((_DWORD*) this + 401) = 0;
            if(*((int*) this + 1) >= 4) {
                if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                   || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                    *(_DWORD*) this = 4;
                }
                if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                    for(nn = 0; nn < 3; ++nn)
                        this [136 * nn + 73] = 1;
                    for(i1 = 3; i1 < 6; ++i1)
                        this [136 * i1 + 73] = 2;
                    *(_DWORD*) this = 2;
                    *((_DWORD*) this + 1) = 0;
                }
            }
            break;
        case 6:
            if(*((int*) this + 1) >= 20) {
                *(_DWORD*) this = 0;
                byte_69D4BF = 0;
                dword_6C6EA4 = 1;
                for(i2 = 0; i2 < 6; ++i2) {
                    v1 = *(_DWORD*) &this [136 * i2 + 68];
                    LOBYTE(v1) = v1 & 0xFE;
                    *(_DWORD*) &this [136 * i2 + 68] = v1;
                }
            }
            break;
        default:
            break;
    }
    for(i3 = 0; i3 < 6; ++i3)
        sub_433960((int*) dword_6D4588, (int) &this [136 * i3 + 4]);
    if(byte_6C7115)
        sub_433960((int*) dword_6D4588, (int) (this + 820));
    ++* ((_DWORD*) this + 1);
    return 0;
}
// 69D4BF: using guessed type char byte_69D4BF;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C7115: using guessed type char byte_6C7115;

//----- (00402740) --------------------------------------------------------
int __thiscall sub_402740(_DWORD* this) {
    int result; // eax
    int v2; // eax
    int v4 [69]; // [esp+Ch] [ebp-118h] BYREF
    int i; // [esp+120h] [ebp-4h]

    result = (unsigned __int8) byte_69D4BF;
    if(byte_69D4BF) {
        dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
        dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
        dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
        dword_6C6DEC = (unsigned __int64) flt_69D6E8;
        result = (*(int(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
        if(byte_6C7115 && *this) {
            qmemcpy(v4, this + 410, 0x110u);
            v2 = v4 [32];
            BYTE1(v2) = BYTE1(v4 [32]) | 0x10;
            v4 [32] = v2;
            result = sub_432AD0((void*) dword_6D4588, (unsigned int) v4);
        }
        for(i = 0; i < 6; ++i) {
            result = 272 * i;
            if((this [68 * i + 34] & 1) != 0)
                result = sub_432AD0((void*) dword_6D4588, (unsigned int) &this [68 * i + 2]);
        }
    }
    return result;
}
// 69D4BF: using guessed type char byte_69D4BF;
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C7115: using guessed type char byte_6C7115;

//----- (00402870) --------------------------------------------------------
int __thiscall sub_402870(_WORD* this) {
    int result; // eax
    int v2; // eax
    int v3; // eax
    unsigned int v4; // edx
    unsigned int v5; // eax
    int* v7; // [esp+10h] [ebp-58h]
    _DWORD* v8; // [esp+18h] [ebp-50h]
    int* v9; // [esp+1Ch] [ebp-4Ch]
    int* v10; // [esp+28h] [ebp-40h]
    int i; // [esp+64h] [ebp-4h]
    int j; // [esp+64h] [ebp-4h]
    int k; // [esp+64h] [ebp-4h]
    int n; // [esp+64h] [ebp-4h]
    int m; // [esp+64h] [ebp-4h]
    int ii; // [esp+64h] [ebp-4h]

    if(byte_69D4C3) {
        byte_69D4C0 = 0;
        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
        dword_6C6EA4 = 7;
        return 1;
    }
    else if(dword_69BCBC) {
        byte_69D4C0 = 0;
        dword_6C6EA4 = 8;
        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
        return 1;
    }
    else if((unsigned __int8) byte_69D4B8 < 3u && dword_69BCB0 < 4) {
        switch(*(_DWORD*) this) {
            case 0:
                if(!*((_DWORD*) this + 1)) {
                    for(i = 0; i < 4; ++i) {
                        if(i >= 2) {
                            v9 = (int*) dword_6D4588;
                            this [136 * i + 94] = i + 4;
                            sub_432430(v9, &this [136 * i + 4], v9 [i + 29265]);
                        }
                        else {
                            v10 = (int*) dword_6D4588;
                            this [136 * i + 94] = i + 8;
                            sub_432430(v10, &this [136 * i + 4], v10 [i + 29269]);
                        }
                        this [136 * i + 73] = 1;
                    }
                    if(byte_6C7115) {
                        v8 = (_DWORD*) dword_6D4588;
                        *(_DWORD*) (dword_6D4588 + 135448) = 3;
                        v8 [33863] = 32;
                        v8 [33864] = 16;
                        v8 [33865] = 384;
                        v8 [33866] = 448;
                        v7 = (int*) dword_6D4588;
                        this [910] = 1816;
                        sub_432430(v7, (_DWORD*) this + 410, v7 [31077]);
                        *((_DWORD*) this + 446) = 1107296256;
                        *((_DWORD*) this + 447) = 1098907648;
                        *((_DWORD*) this + 448) = 0;
                    }
                }
                if(*((int*) this + 1) > 8)
                    goto LABEL_57;
                *(_DWORD*) this += 2;
                *((_DWORD*) this + 1) = 0;
                goto LABEL_20;
            case 1:
                LABEL_20:
                *((_DWORD*) this + 169) = -32640;
                *((_DWORD*) this + 237) = -2139062144;
                *((_DWORD*) this + 144) = 1071225242;
                *((_DWORD*) this + 145) = 1071225242;
                *((_DWORD*) this + 212) = 1069547520;
                *((_DWORD*) this + 213) = 1069547520;
                *((_DWORD*) this + 195) = -1065353216;
                *((_DWORD*) this + 196) = -1065353216;
                *((_DWORD*) this + 197) = 0;
                *((_DWORD*) this + 263) = 0;
                *((_DWORD*) this + 264) = 0;
                *((_DWORD*) this + 265) = 0;
                if(*((int*) this + 1) >= 4) {
                    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                       || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                        *(_DWORD*) this = 2;
                    }
                    if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                        for(j = 0; j < 4; ++j)
                            this [136 * j + 73] = 2;
                        *(_DWORD*) this = 3;
                        this [889] = 1;
                        *((_DWORD*) this + 1) = 0;
                    }
                }
                goto LABEL_57;
            case 2:
                *((_DWORD*) this + 237) = -32640;
                *((_DWORD*) this + 169) = -2139062144;
                *((_DWORD*) this + 144) = 1069547520;
                *((_DWORD*) this + 145) = 1069547520;
                *((_DWORD*) this + 212) = 1071225242;
                *((_DWORD*) this + 213) = 1071225242;
                *((_DWORD*) this + 263) = -1065353216;
                *((_DWORD*) this + 264) = -1065353216;
                *((_DWORD*) this + 265) = 0;
                *((_DWORD*) this + 195) = 0;
                *((_DWORD*) this + 196) = 0;
                *((_DWORD*) this + 197) = 0;
                if(*((int*) this + 1) >= 30) {
                    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
                       || (word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
                        *(_DWORD*) this = 1;
                    }
                    if((word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1)) {
                        for(k = 0; k < 4; ++k)
                            this [136 * k + 73] = 2;
                        *(_DWORD*) this = 4;
                        *((_DWORD*) this + 1) = 0;
                    }
                }
                goto LABEL_57;
            case 3:
                if(*((int*) this + 1) < 30)
                    goto LABEL_57;
                *(_DWORD*) this = 0;
                *((_DWORD*) this + 1) = 0;
                byte_69D4C0 = 0;
                for(m = 0; m < 4; ++m)
                    *(_DWORD*) &this [136 * m + 68] &= ~1u;
                *(_DWORD*) dword_69BCA0 = (unsigned __int8)++byte_69D4B8;
                dword_69BCA8 = 0;
                dword_69BCA4 = (unsigned __int8) byte_69D4B8;
                byte_69D4BA = byte_6C6E7C;
                byte_69D4BB = byte_6C6E7D;
                *(_DWORD*) dword_69BCB4 = 0;
                word_69D4B4 = 0;
                word_69D4B0 = 0;
                byte_69D4BC = 0;
                v3 = dword_69BC30 [0];
                LOBYTE(v3) = dword_69BC30 [0] & 0xFC | 2;
                v4 = v3 & 0xFFFFFFF3 | 8;
                LOBYTE(v4) = dword_69BC30 [0] & 0x30 | 0x8A;
                v5 = v4;
                BYTE1(v5) = BYTE1(v4) & 0xFC | 2;
                dword_69BC30 [0] = v5 & 0xFFFFFFCF | 0x20;
                result = 0;
                break;
            case 4:
                if(*((int*) this + 1) < 20)
                    goto LABEL_57;
                *(_DWORD*) this = 0;
                *((_DWORD*) this + 1) = 0;
                byte_69D4C0 = 0;
                dword_6C6EA4 = 7;
                for(n = 0; n < 4; ++n) {
                    v2 = *(_DWORD*) &this [136 * n + 68];
                    LOBYTE(v2) = v2 & 0xFE;
                    *(_DWORD*) &this [136 * n + 68] = v2;
                }
                *(_DWORD*) dword_69BCA0 = dword_69BCA4;
                result = 0;
                break;
            default:
                LABEL_57:
                for(ii = 0; ii < 4; ++ii)
                    sub_433960((int*) dword_6D4588, (int) &this [136 * ii + 4]);
                if(byte_6C7115)
                    sub_433960((int*) dword_6D4588, (int) (this + 820));
                ++* ((_DWORD*) this + 1);
                result = 0;
                break;
        }
    }
    else {
        byte_69D4C0 = 0;
        dword_6C6EA4 = 7;
        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
        return 1;
    }
    return result;
}
// 69BC30: using guessed type int dword_69BC30[5];
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCA8: using guessed type int dword_69BCA8;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B4: using guessed type __int16 word_69D4B4;
// 69D4B8: using guessed type char byte_69D4B8;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BC: using guessed type char byte_69D4BC;
// 69D4C0: using guessed type char byte_69D4C0;
// 69D4C3: using guessed type char byte_69D4C3;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6E7C: using guessed type char byte_6C6E7C;
// 6C6E7D: using guessed type char byte_6C6E7D;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C7115: using guessed type char byte_6C7115;

//----- (00403060) --------------------------------------------------------
int __thiscall sub_403060(int* this) {
    int result; // eax
    int i; // [esp+Ch] [ebp-4h]

    result = (unsigned __int8) byte_69D4C0;
    if(byte_69D4C0) {
        dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
        dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
        dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
        dword_6C6DEC = (unsigned __int64) flt_69D6E8;
        (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
        if(byte_6C7115 && (*this || this [1] > 2))
            sub_432AD0((void*) dword_6D4588, (unsigned int) (this + 410));
        if(*this == 1 || (result = (int) this, *this == 2)) {
            qmemcpy(this + 274, this + 70, 0x110u);
            *((float*) this + 310) = 8.0 * *((float*) this + 281) + *((float*) this + 310);
            this [322] = 56 * (30 - (unsigned __int8) byte_69D4B8) + dword_6D4588;
            result = sub_432AD0((void*) dword_6D4588, (unsigned int) (this + 274));
        }
        for(i = 0; i < 4; ++i) {
            if((this [68 * i + 34] & 1) != 0)
                sub_432AD0((void*) dword_6D4588, (unsigned int) &this [68 * i + 2]);
            result = i + 1;
        }
    }
    return result;
}
// 69D4B8: using guessed type char byte_69D4B8;
// 69D4C0: using guessed type char byte_69D4C0;
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C7115: using guessed type char byte_6C7115;

//----- (004031E0) --------------------------------------------------------
int __thiscall sub_4031E0(int this) {
    int result; // eax
    float v2; // [esp+0h] [ebp-28h]
    unsigned __int8* v4; // [esp+18h] [ebp-10h]
    int i; // [esp+1Ch] [ebp-Ch]
    int j; // [esp+20h] [ebp-8h]
    int v7; // [esp+24h] [ebp-4h]

    v7 = this + 28980;
    dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
    dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
    dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
    dword_6C6DEC = (unsigned __int64) flt_69D6E8;
    result = (*(int(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    for(i = 0; i < 515; ++i) {
        result = v7;
        if(*(_BYTE*) (v7 + 36)) {
            v2 = (float) (4 * *(unsigned __int8*) (v7 + 37));
            *(float*) (this + 416) = *(float*) (v7 + 8) - v2;
            *(_DWORD*) (this + 420) = *(_DWORD*) (v7 + 12);
            *(_DWORD*) (this + 396) = *(_DWORD*) (v7 + 20);
            result = v7 + *(unsigned __int8*) (v7 + 37) - 1;
            v4 = (unsigned __int8*) result;
            for(j = *(unsigned __int8*) (v7 + 37); j > 0; --j) {
                *(_DWORD*) (this + 464) = 56 * *v4 + dword_6D4588;
                if(*v4 < 0xAu) {
                    sub_433590(dword_6D4588, this + 272);
                }
                else {
                    *(_DWORD*) (this + 332) = 1044381696;
                    *(_DWORD*) (this + 352) = 1023410176;
                    sub_433590(dword_6D4588, this + 272);
                    *(_DWORD*) (this + 332) = 1023410176;
                    *(_DWORD*) (this + 352) = 1023410176;
                }
                *(float*) (this + 416) = *(float*) (this + 416) + 8.0;
                --v4;
                result = j - 1;
            }
        }
        v7 += 40;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (004033B0) --------------------------------------------------------
int __thiscall sub_4033B0(int this) {
    int result; // eax
    float v2; // [esp+0h] [ebp-28h]
    unsigned __int8* v4; // [esp+18h] [ebp-10h]
    int i; // [esp+1Ch] [ebp-Ch]
    int j; // [esp+20h] [ebp-8h]
    int v7; // [esp+24h] [ebp-4h]

    v7 = this + 28980;
    dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
    dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
    dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
    dword_6C6DEC = (unsigned __int64) flt_69D6E8;
    result = (*(int(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    for(i = 0; i < 515; ++i) {
        result = v7;
        if(*(_BYTE*) (v7 + 36)) {
            v2 = (float) (4 * *(unsigned __int8*) (v7 + 37));
            *(float*) (this + 416) = *(float*) (v7 + 8) - v2;
            *(_DWORD*) (this + 420) = *(_DWORD*) (v7 + 12);
            *(_DWORD*) (this + 396) = *(_DWORD*) (v7 + 20);
            result = v7 + *(unsigned __int8*) (v7 + 37) - 1;
            v4 = (unsigned __int8*) result;
            for(j = *(unsigned __int8*) (v7 + 37); j > 0; --j) {
                *(_DWORD*) (this + 464) = 56 * *v4 + dword_6D4588;
                if(*v4 < 0xAu) {
                    sub_433590(dword_6D4588, this + 272);
                }
                else {
                    *(_DWORD*) (this + 332) = 1044381696;
                    *(_DWORD*) (this + 352) = 1023410176;
                    sub_432AD0((void*) dword_6D4588, this + 272);
                    *(_DWORD*) (this + 332) = 1023410176;
                    *(_DWORD*) (this + 352) = 1023410176;
                }
                *(float*) (this + 416) = *(float*) (this + 416) + 8.0;
                --v4;
                result = j - 1;
            }
        }
        v7 += 40;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (00403580) --------------------------------------------------------
_DWORD* __thiscall sub_403580(_DWORD* this) {
    this [11] = 0;
    this [10] = 0;
    this [9] = 0;
    this [8] = 0;
    this [5] = 0;
    this [4] = 0;
    this [3] = 0;
    this [2] = 0;
    this [1] = 0;
    *this = 0;
    this [7] = 1065353216;
    this [6] = 1065353216;
    *((_WORD*) this + 67) = 0;
    *((_WORD*) this + 66) = 0;
    this [31] = -1;
    sub_403670(this + 15);
    *((_WORD*) this + 64) = 3;
    *((_WORD*) this + 68) = 0;
    *((_WORD*) this + 69) = 0;
    *((_WORD*) this + 70) = 0;
    return sub_424127(this + 12);
}

//----- (00403670) --------------------------------------------------------
_DWORD* __cdecl sub_403670(_DWORD* a1) {
    a1 [14] = 0;
    a1 [13] = 0;
    a1 [12] = 0;
    a1 [11] = 0;
    a1 [9] = 0;
    a1 [8] = 0;
    a1 [7] = 0;
    a1 [6] = 0;
    a1 [4] = 0;
    a1 [3] = 0;
    a1 [2] = 0;
    a1 [1] = 0;
    a1 [15] = 1065353216;
    a1 [10] = 1065353216;
    a1 [5] = 1065353216;
    *a1 = 1065353216;
    return a1;
}

//----- (00403720) --------------------------------------------------------
int __thiscall sub_403720(int this) {
    sub_424127((_DWORD*) (this + 48));
    sub_424127((_DWORD*) (this + 164));
    sub_424127((_DWORD*) (this + 240));
    sub_424127((_DWORD*) (this + 256));
    *(_WORD*) (this + 176) = -1;
    return this;
}

//----- (00403790) --------------------------------------------------------
_DWORD* __thiscall sub_403790(_DWORD* this) {
    sub_424127(this + 7);
    sub_424127(this + 11);
    sub_424127(this + 28);
    sub_403720((int) (this + 34));
    sub_403720((int) (this + 102));
    sub_424127(this + 178);
    return this;
}

//----- (00403810) --------------------------------------------------------
int __cdecl sub_403810(int a1) {
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    float v6; // [esp+8h] [ebp-9Ch]
    float v7; // [esp+10h] [ebp-94h]
    float v8; // [esp+18h] [ebp-8Ch]
    float v9; // [esp+1Ch] [ebp-88h]
    float v10; // [esp+20h] [ebp-84h]
    float v11; // [esp+24h] [ebp-80h]
    float v12; // [esp+28h] [ebp-7Ch]
    float v13; // [esp+30h] [ebp-74h]
    float v14; // [esp+34h] [ebp-70h]
    float v15; // [esp+54h] [ebp-50h]
    float v16; // [esp+58h] [ebp-4Ch]
    float v17; // [esp+5Ch] [ebp-48h]
    int i; // [esp+84h] [ebp-20h]
    float v19; // [esp+88h] [ebp-1Ch]
    float v20; // [esp+8Ch] [ebp-18h]
    int v21; // [esp+90h] [ebp-14h]
    int v22; // [esp+94h] [ebp-10h]
    float v23; // [esp+94h] [ebp-10h]
    int v24; // [esp+98h] [ebp-Ch]
    float v25; // [esp+98h] [ebp-Ch]
    int v26; // [esp+9Ch] [ebp-8h]
    float v27; // [esp+A0h] [ebp-4h]

    if(!*(_DWORD*) (a1 + 4))
        return 1;
    if(byte_69BCCC) {
        *(_BYTE*) (a1 + 263) = 96;
        *(_BYTE*) (a1 + 262) = 0x80;
        *(_BYTE*) (a1 + 261) = 48;
        *(_BYTE*) (a1 + 260) = 48;
        return 1;
    }
    else {
        while(2) {
            v26 = *(_DWORD*) (a1 + 24) + 20 * *(_DWORD*) (a1 + 40);
            switch(*(_WORD*) (v26 + 4)) {
                case 0:
                    if(*(_DWORD*) v26 == -1) {
                        *(_DWORD*) (a1 + 740) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 744) = *(_DWORD*) (v26 + 12);
                        *(_DWORD*) (a1 + 748) = *(_DWORD*) (v26 + 16);
                        *(_DWORD*) (a1 + 60) = *(_DWORD*) (a1 + 740);
                        *(_DWORD*) (a1 + 64) = *(_DWORD*) (a1 + 744);
                        *(_DWORD*) (a1 + 68) = *(_DWORD*) (a1 + 748);
                    }
                    else if(*(_DWORD*) (a1 + 36) >= *(_DWORD*) v26) {
                        v21 = *(_DWORD*) (v26 + 8);
                        v22 = *(_DWORD*) (v26 + 12);
                        v24 = *(_DWORD*) (v26 + 16);
                        *(_DWORD*) (a1 + 60) = v21;
                        *(_DWORD*) (a1 + 64) = v22;
                        *(_DWORD*) (a1 + 68) = v24;
                        *(_DWORD*) (a1 + 740) = v21;
                        *(_DWORD*) (a1 + 744) = v22;
                        *(_DWORD*) (a1 + 748) = v24;
                        *(_DWORD*) (a1 + 752) = *(_DWORD*) v26;
                        ++* (_DWORD*) (a1 + 40);
                        for(v26 += 20; *(_WORD*) (v26 + 4); v26 += 20)
                            ;
                        *(_DWORD*) (a1 + 736) = *(_DWORD*) v26;
                        *(_DWORD*) (a1 + 724) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 728) = *(_DWORD*) (v26 + 12);
                        *(_DWORD*) (a1 + 732) = *(_DWORD*) (v26 + 16);
                    }
                    break;
                case 1:
                    if(*(_DWORD*) (a1 + 36) >= *(_DWORD*) v26) {
                        *(_DWORD*) (a1 + 80) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 72) = *(_DWORD*) (v26 + 12);
                        *(_DWORD*) (a1 + 76) = *(_DWORD*) (v26 + 16);
                        if(!*(_DWORD*) (a1 + 108)) {
                            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(
                                dword_6C6D20,
                                34,
                                *(_DWORD*) (a1 + 80));
                            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(
                                dword_6C6D20,
                                36,
                                *(_DWORD*) (a1 + 72));
                            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(
                                dword_6C6D20,
                                37,
                                *(_DWORD*) (a1 + 76));
                        }
                        ++* (_DWORD*) (a1 + 40);
                        *(_DWORD*) (a1 + 96) = *(_DWORD*) (a1 + 72);
                        *(_DWORD*) (a1 + 100) = *(_DWORD*) (a1 + 76);
                        *(_DWORD*) (a1 + 104) = *(_DWORD*) (a1 + 80);
                        continue;
                    }
                    break;
                case 2:
                    if(*(_DWORD*) (a1 + 36) >= *(_DWORD*) v26) {
                        *(_DWORD*) (a1 + 684) = *(_DWORD*) (a1 + 696);
                        *(_DWORD*) (a1 + 688) = *(_DWORD*) (a1 + 700);
                        *(_DWORD*) (a1 + 692) = *(_DWORD*) (a1 + 704);
                        *(_DWORD*) (a1 + 696) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 700) = *(_DWORD*) (v26 + 12);
                        *(_DWORD*) (a1 + 704) = *(_DWORD*) (v26 + 16);
                        ++* (_DWORD*) (a1 + 40);
                        continue;
                    }
                    break;
                case 3:
                    if(*(_DWORD*) (a1 + 36) >= *(_DWORD*) v26) {
                        *(_DWORD*) (a1 + 708) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 720) = 0;
                        *(_DWORD*) (a1 + 716) = 0;
                        *(_DWORD*) (a1 + 712) = -999;
                        ++* (_DWORD*) (a1 + 40);
                        continue;
                    }
                    break;
                case 4:
                    if(*(_DWORD*) (a1 + 36) >= *(_DWORD*) v26) {
                        *(_DWORD*) (a1 + 84) = *(_DWORD*) (a1 + 72);
                        *(_DWORD*) (a1 + 88) = *(_DWORD*) (a1 + 76);
                        *(_DWORD*) (a1 + 92) = *(_DWORD*) (a1 + 80);
                        *(_DWORD*) (a1 + 108) = *(_DWORD*) (v26 + 8);
                        *(_DWORD*) (a1 + 120) = 0;
                        *(_DWORD*) (a1 + 116) = 0;
                        *(_DWORD*) (a1 + 112) = -999;
                        ++* (_DWORD*) (a1 + 40);
                        continue;
                    }
                    break;
                case 5:
                    if(*(_BYTE*) (a1 + 680)) {
                        ++* (_DWORD*) (a1 + 40);
                        *(_BYTE*) (a1 + 680) = 0;
                        continue;
                    }
                    break;
                default:
                    goto LABEL_30;
            }
            break;
        }
        LABEL_30:
        if(*(_DWORD*) v26 != -1) {
            v14 = (float) *(int*) (a1 + 752);
            v13 = (float) *(int*) (a1 + 36);
            v12 = (float) (*(_DWORD*) (a1 + 736) - *(_DWORD*) (a1 + 752));
            v27 = (v13 + *(float*) (a1 + 32) - v14) / v12;
            v23 = *(float*) (a1 + 728);
            v25 = *(float*) (a1 + 732);
            *(float*) (a1 + 60) = (*(float*) (a1 + 724) - *(float*) (a1 + 740)) * v27 + *(float*) (a1 + 740);
            *(float*) (a1 + 64) = (v23 - *(float*) (a1 + 744)) * v27 + *(float*) (a1 + 744);
            *(float*) (a1 + 68) = (v25 - *(float*) (a1 + 748)) * v27 + *(float*) (a1 + 748);
        }
        if(*(_DWORD*) (a1 + 708)) {
            if(*(_DWORD*) (a1 + 720) >= *(_DWORD*) (a1 + 708)) {
                *(_DWORD*) (a1 + 720) = *(_DWORD*) (a1 + 708);
                *(_DWORD*) (a1 + 716) = 0;
                *(_DWORD*) (a1 + 712) = -999;
            }
            else {
                *(_DWORD*) (a1 + 712) = *(_DWORD*) (a1 + 720);
                sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 720), (float*) (a1 + 716));
            }
            v17 = *(float*) (a1 + 704) - *(float*) (a1 + 692);
            v16 = *(float*) (a1 + 700) - *(float*) (a1 + 688);
            v15 = *(float*) (a1 + 696) - *(float*) (a1 + 684);
            v11 = (float) *(int*) (a1 + 708);
            v10 = (float) *(int*) (a1 + 720);
            v20 = (v10 + *(float*) (a1 + 716)) / v11;
            flt_69D700 = v15 * v20 + *(float*) (a1 + 684);
            flt_69D704 = v16 * v20 + *(float*) (a1 + 688);
            flt_69D708 = v17 * v20 + *(float*) (a1 + 692);
        }
        if(*(_DWORD*) (a1 + 108)) {
            *(_DWORD*) (a1 + 112) = *(_DWORD*) (a1 + 120);
            sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 120), (float*) (a1 + 116));
            v9 = (float) *(int*) (a1 + 108);
            v8 = (float) *(int*) (a1 + 120);
            v19 = (v8 + *(float*) (a1 + 116)) / v9;
            v3 = v19 < 1.0;
            v4 = 0;
            v5 = v19 == 1.0;
            if((v2 & 0x100) == 0)
                v19 = 1.0;
            for(i = 0; i < 4; ++i) {
                v7 = (float) *(unsigned __int8*) (i + a1 + 104);
                v6 = (float) *(unsigned __int8*) (i + a1 + 92);
                *(_BYTE*) (i + a1 + 80) = (unsigned __int64) ((v7 - v6) * v19 + v6);
            }
            *(float*) (a1 + 72) = (*(float*) (a1 + 96) - *(float*) (a1 + 84)) * v19 + *(float*) (a1 + 84);
            *(float*) (a1 + 76) = (*(float*) (a1 + 100) - *(float*) (a1 + 88)) * v19 + *(float*) (a1 + 88);
            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 34, *(_DWORD*) (a1 + 80));
            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 36, *(_DWORD*) (a1 + 72));
            (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 37, *(_DWORD*) (a1 + 76));
            if(*(_DWORD*) (a1 + 120) >= *(_DWORD*) (a1 + 108))
                *(_DWORD*) (a1 + 108) = 0;
        }
        if(*(_WORD*) (v26 + 4) != 5) {
            *(_DWORD*) (a1 + 28) = *(_DWORD*) (a1 + 36);
            sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 36), (float*) (a1 + 32));
        }
        sub_404860((_DWORD*) a1);
        if(*(int*) (a1 + 128) >= 1) {
            if(*(_DWORD*) (a1 + 132) == 60)
                ++* (_DWORD*) (a1 + 128);
            ++* (_DWORD*) (a1 + 132);
            sub_433960((int*) dword_6D4588, a1 + 136);
        }
        return 1;
    }
}
// 69BCCC: using guessed type char byte_69BCCC;
// 69D700: using guessed type float flt_69D700;
// 69D704: using guessed type float flt_69D704;
// 69D708: using guessed type float flt_69D708;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6D20: using guessed type int dword_6C6D20;

//----- (004040D0) --------------------------------------------------------
int __cdecl sub_4040D0(int a1) {
    if(*(_BYTE*) (a1 + 124)) {
        *(_BYTE*) (a1 + 124) = 0;
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 34, *(_DWORD*) (a1 + 80));
    }
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 36, *(_DWORD*) (a1 + 72));
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 37, *(_DWORD*) (a1 + 76));
    if(*(int*) (a1 + 128) <= 1 && !sub_4172D3(dword_69BC30)) {
        sub_404970((void*) a1, 0);
        sub_404970((void*) a1, 1);
    }
    return 1;
}
// 69BC30: using guessed type int dword_69BC30[5];
// 6C6D20: using guessed type int dword_6C6D20;

//----- (00404180) --------------------------------------------------------
int __cdecl sub_404180(int a1) {
    int* v2; // [esp+0h] [ebp-20h]
    int v3 [4]; // [esp+8h] [ebp-18h] BYREF
    int v4; // [esp+18h] [ebp-8h]
    int v5; // [esp+1Ch] [ebp-4h]

    if(*(int*) (a1 + 128) <= 1 && !sub_4172D3(dword_69BC30)) {
        sub_404970((void*) a1, 2);
        sub_404970((void*) a1, 3);
        if(*(_DWORD*) (a1 + 128) == 1) {
            v3 [0] = 1107296256;
            v3 [1] = 1098907648;
            v3 [2] = 1137704960;
            v3 [3] = 1139277824;
            v4 = 255 * *(_DWORD*) (a1 + 132) / 60;
            sub_42F8B0(v3, v4 << 24);
        }
    }
    if(*(int*) (a1 + 128) >= 1) {
        if(*(_DWORD*) (a1 + 132) <= (int) (unsigned __int8) byte_6C6E4B) {
            v2 = (int*) dword_6D4588;
            *(_WORD*) (a1 + 316) = 691;
            sub_432430(v2, (_DWORD*) (a1 + 136), v2 [29952]);
        }
        sub_432CC0((void*) dword_6D4588, a1 + 136);
    }
    dword_6C6DF0 = 0;
    dword_6C6DF4 = 1056964608;
    sub_41C28C(0.0);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    v5 = 1148846080;
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 36, 1148846080);
    v5 = 1157234688;
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 37, 1157234688);
    return 1;
}
// 69BC30: using guessed type int dword_69BC30[5];
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DF0: using guessed type int dword_6C6DF0;
// 6C6DF4: using guessed type int dword_6C6DF4;
// 6C6E4B: using guessed type char byte_6C6E4B;

//----- (00404300) --------------------------------------------------------
int __cdecl sub_404300(int a1) {
    *(_DWORD*) (a1 + 36) = 0;
    *(_DWORD*) (a1 + 32) = 0;
    *(_DWORD*) (a1 + 28) = -999;
    *(_DWORD*) (a1 + 40) = 0;
    *(_DWORD*) (a1 + 60) = 0;
    *(_DWORD*) (a1 + 64) = 0;
    *(_DWORD*) (a1 + 68) = 0;
    *(_DWORD*) (a1 + 128) = 0;
    *(_DWORD*) (a1 + 108) = 0;
    if(sub_404690(
        (void**) a1,
        (char*) *(&off_4760E0 + 2 * *(_DWORD*) dword_69D6D4),
        (&off_4760E4) [2 * *(_DWORD*) dword_69D6D4])) {
        return -1;
    }
    *(_DWORD*) (a1 + 80) = -16777216;
    *(_DWORD*) (a1 + 72) = 1128792064;
    *(_DWORD*) (a1 + 76) = 1140457472;
    *(_DWORD*) (a1 + 696) = 0;
    *(_DWORD*) (a1 + 700) = 0;
    *(_DWORD*) (a1 + 704) = 1065353216;
    *(_DWORD*) (a1 + 684) = 0;
    *(_DWORD*) (a1 + 688) = 0;
    *(_DWORD*) (a1 + 692) = 1065353216;
    *(_DWORD*) (a1 + 708) = 1;
    *(_DWORD*) (a1 + 720) = 0;
    *(_DWORD*) (a1 + 716) = 0;
    *(_DWORD*) (a1 + 712) = -999;
    *(_BYTE*) (a1 + 680) = 0;
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 34, *(_DWORD*) (a1 + 80));
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 36, *(_DWORD*) (a1 + 72));
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 37, *(_DWORD*) (a1 + 76));
    return 0;
}
// 6C6D20: using guessed type int dword_6C6D20;

//----- (004044C0) --------------------------------------------------------
int __cdecl sub_4044C0(int a1) {
    memset(&unk_487B10, 0, 0x2F4u);
    *((_DWORD*) &unk_487B10 + 1) = 0;
    *((_DWORD*) &unk_487B10 + 13) = 0;
    *((_DWORD*) &unk_487B10 + 12) = 0;
    *((_DWORD*) &unk_487B10 + 11) = -999;
    *((_DWORD*) &unk_487B10 + 14) = a1;
    dword_487E28 = (int) sub_403810;
    dword_487E2C = (int) sub_404300;
    dword_487E30 = (int) sub_4045E0;
    dword_487E40 = (int) &unk_487B10;
    if(sub_41C860(byte_69D918, (int) &unk_487E24, 6))
        return -1;
    dword_487AF4 = (int) sub_4040D0;
    dword_487AF8 = 0;
    dword_487AFC = 0;
    dword_487B0C = (int) &unk_487B10;
    sub_41C940((__int16*) byte_69D918, (int) &unk_487AF0, 3);
    dword_487E08 = (int) sub_404180;
    dword_487E0C = 0;
    dword_487E10 = 0;
    dword_487E20 = (int) &unk_487B10;
    sub_41C940((__int16*) byte_69D918, (int) &unk_487E04, 4);
    return 0;
}
// 487AF4: using guessed type int dword_487AF4;
// 487AF8: using guessed type int dword_487AF8;
// 487AFC: using guessed type int dword_487AFC;
// 487B0C: using guessed type int dword_487B0C;
// 487E08: using guessed type int dword_487E08;
// 487E0C: using guessed type int dword_487E0C;
// 487E10: using guessed type int dword_487E10;
// 487E20: using guessed type int dword_487E20;
// 487E28: using guessed type int dword_487E28;
// 487E2C: using guessed type int dword_487E2C;
// 487E30: using guessed type int dword_487E30;
// 487E40: using guessed type int dword_487E40;

//----- (004045E0) --------------------------------------------------------
int __cdecl sub_4045E0(void** a1) {
    sub_432030(dword_6D4588, 4);
    if(*a1) {
        free(*a1);
        *a1 = 0;
    }
    if(a1 [1]) {
        free(a1 [1]);
        a1 [1] = 0;
    }
    return 0;
}

//----- (00404650) --------------------------------------------------------
void sub_404650() {
    sub_41CDE0(byte_69D918, (int) &unk_487E24);
    sub_41CDE0(byte_69D918, (int) &unk_487AF0);
    sub_41CDE0(byte_69D918, (int) &unk_487E04);
}

//----- (00404690) --------------------------------------------------------
int __thiscall sub_404690(void** this, char* a2, char* Str) {
    __int16* j; // [esp+20h] [ebp-10h]
    int v6; // [esp+24h] [ebp-Ch]
    int i; // [esp+28h] [ebp-8h]
    int v8; // [esp+28h] [ebp-8h]
    int v9; // [esp+2Ch] [ebp-4h]

    if(sub_431DC0((_DWORD*) dword_6D4588, 4, a2, 768))
        return -1;
    this [1] = sub_41E290(Str, 0);
    if(this [1]) {
        this [3] = (void*) *(__int16*) this [1];
        this [2] = (void*) *((__int16*) this [1] + 1);
        this [5] = (char*) this [1] + *((_DWORD*) this [1] + 1);
        this [6] = (char*) this [1] + *((_DWORD*) this [1] + 2);
        this [4] = (char*) this [1] + 1168;
        for(i = 0; i < (int) this [3]; ++i)
            *((_DWORD*) this [4] + i) += this [1];
        *this = malloc(272 * (_DWORD) this [2]);
        v8 = 0;
        v9 = 0;
        while(v8 < (int) this [3]) {
            v6 = *((_DWORD*) this [4] + v8);
            *(_BYTE*) (v6 + 3) = 1;
            for(j = (__int16*) (v6 + 28); *j >= 0; j = (__int16*) ((char*) j + j [1])) {
                sub_4051B0((int*) dword_6D4588, (int) *this + 272 * v9, j [2] + 768);
                j [3] = v9++;
            }
            ++v8;
        }
        return 0;
    }
    else {
        sub_41E4D0((int) byte_69D998, (char*) &byte_46A3AC);
        return -1;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (00404860) --------------------------------------------------------
int __thiscall sub_404860(_DWORD* this) {
    __int16* j; // [esp+8h] [ebp-18h]
    int v4; // [esp+Ch] [ebp-14h]
    int v5; // [esp+10h] [ebp-10h]
    int i; // [esp+14h] [ebp-Ch]
    int v7; // [esp+18h] [ebp-8h]

    for(i = 0; i < this [3]; ++i) {
        v4 = *(_DWORD*) (this [4] + 4 * i);
        if((*(_BYTE*) (v4 + 3) & 1) != 0) {
            v7 = 0;
            for(j = (__int16*) (v4 + 28); *j >= 0; j = (__int16*) ((char*) j + j [1])) {
                v5 = *this + 272 * j [3];
                if(!*j || *j == 1)
                    sub_433960((int*) dword_6D4588, v5);
                if(*(_DWORD*) (v5 + 188))
                    ++v7;
            }
            if(!v7)
                *(_BYTE*) (v4 + 3) &= ~1u;
        }
    }
    return 0;
}

//----- (00404970) --------------------------------------------------------
int __thiscall sub_404970(void* this, int a2) {
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    __int16 v6; // fps
    bool v7; // c0
    char v8; // c2
    bool v9; // c3
    __int16 v10; // fps
    bool v11; // c0
    char v12; // c2
    bool v13; // c3
    __int16 v14; // fps
    bool v15; // c0
    char v16; // c2
    bool v17; // c3
    __int16 v18; // fps
    bool v19; // c0
    char v20; // c2
    bool v21; // c3
    __int16 v22; // fps
    bool v23; // c0
    char v24; // c2
    bool v25; // c3
    __int16 v26; // fps
    bool v27; // c0
    char v28; // c2
    bool v29; // c3
    __int16 v30; // fps
    bool v31; // c0
    char v32; // c2
    bool v33; // c3
    int v34; // ecx
    float v36; // [esp+4h] [ebp-148h]
    float v37; // [esp+10h] [ebp-13Ch]
    float v38; // [esp+1Ch] [ebp-130h]
    float v39; // [esp+28h] [ebp-124h]
    float v40; // [esp+34h] [ebp-118h]
    float v41; // [esp+40h] [ebp-10Ch]
    float v42; // [esp+4Ch] [ebp-100h]
    float v43; // [esp+58h] [ebp-F4h]
    float v44; // [esp+64h] [ebp-E8h]
    float v45; // [esp+70h] [ebp-DCh]
    float v46; // [esp+7Ch] [ebp-D0h]
    float v47; // [esp+88h] [ebp-C4h]
    float v48; // [esp+94h] [ebp-B8h]
    float v49; // [esp+A0h] [ebp-ACh]
    float v50; // [esp+ACh] [ebp-A0h]
    float v51; // [esp+B8h] [ebp-94h]
    float v53; // [esp+C8h] [ebp-84h]
    float v54 [3]; // [esp+CCh] [ebp-80h] BYREF
    int v55; // [esp+D8h] [ebp-74h]
    float* v56; // [esp+DCh] [ebp-70h]
    float v57; // [esp+E0h] [ebp-6Ch] BYREF
    float v58; // [esp+E4h] [ebp-68h]
    int v59; // [esp+E8h] [ebp-64h]
    float v60 [3]; // [esp+ECh] [ebp-60h] BYREF
    int v61; // [esp+F8h] [ebp-54h]
    _DWORD v62 [12]; // [esp+FCh] [ebp-50h] BYREF
    float v63; // [esp+12Ch] [ebp-20h]
    float v64; // [esp+130h] [ebp-1Ch]
    float v65; // [esp+134h] [ebp-18h]
    float* v66; // [esp+13Ch] [ebp-10h]
    int v67; // [esp+140h] [ebp-Ch]
    unsigned int v68; // [esp+144h] [ebp-8h]
    int v69; // [esp+148h] [ebp-4h]

    v66 = (float*) *((_DWORD*) this + 5);
    v67 = 0;
    v55 = 0;
    memset(v54, 0, sizeof(v54));
    sub_403670(v62);
    while(*(__int16*) v66 >= 0) {
        v61 = *(_DWORD*) (*((_DWORD*) this + 4) + 4 * *(__int16*) v66);
        if(*(char*) (v61 + 2) == a2) {
            v56 = (float*) (v61 + 28);
            v69 = 0;
            v63 = *(float*) (v61 + 4) + v66 [1] - *((float*) this + 15);
            v64 = -(*(float*) (v61 + 8) + v66 [2] - *((float*) this + 16));
            v65 = *(float*) (v61 + 12) + v66 [3] - *((float*) this + 17) + *(float*) (v61 + 24);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v51 = (float) (unsigned int) dword_6C6DE4;
            v3 = v58 < (double) v51;
            v4 = 0;
            v5 = v58 == v51;
            if((v2 & 0x100) == 0) {
                v50 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v50)
                    goto LABEL_21;
            }
            v64 = v64 - *(float*) (v61 + 20);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v49 = (float) (unsigned int) dword_6C6DE4;
            v7 = v58 < (double) v49;
            v8 = 0;
            v9 = v58 == v49;
            if((v6 & 0x100) == 0) {
                v48 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v48)
                    goto LABEL_21;
            }
            v65 = v65 - *(float*) (v61 + 24);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v47 = (float) (unsigned int) dword_6C6DE4;
            v11 = v58 < (double) v47;
            v12 = 0;
            v13 = v58 == v47;
            if((v10 & 0x100) == 0) {
                v46 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v46)
                    goto LABEL_21;
            }
            v64 = v64 + *(float*) (v61 + 20);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v45 = (float) (unsigned int) dword_6C6DE4;
            v15 = v58 < (double) v45;
            v16 = 0;
            v17 = v58 == v45;
            if((v14 & 0x100) == 0) {
                v44 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v44)
                    goto LABEL_21;
            }
            v63 = *(float*) (v61 + 4) + v66 [1] - *((float*) this + 15) + *(float*) (v61 + 16);
            v64 = -(*(float*) (v61 + 8) + v66 [2] - *((float*) this + 16));
            v65 = *(float*) (v61 + 12) + v66 [3] - *((float*) this + 17) + *(float*) (v61 + 24);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v43 = (float) (unsigned int) dword_6C6DE4;
            v19 = v58 < (double) v43;
            v20 = 0;
            v21 = v58 == v43;
            if((v18 & 0x100) == 0) {
                v42 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v42)
                    goto LABEL_21;
            }
            v64 = v64 - *(float*) (v61 + 20);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v41 = (float) (unsigned int) dword_6C6DE4;
            v23 = v58 < (double) v41;
            v24 = 0;
            v25 = v58 == v41;
            if((v22 & 0x100) == 0) {
                v40 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v40)
                    goto LABEL_21;
            }
            v65 = v65 - *(float*) (v61 + 24);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v39 = (float) (unsigned int) dword_6C6DE4;
            v27 = v58 < (double) v39;
            v28 = 0;
            v29 = v58 == v39;
            if((v26 & 0x100) == 0) {
                v38 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v38)
                    goto LABEL_21;
            }
            v64 = v64 + *(float*) (v61 + 20);
            sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
            v37 = (float) (unsigned int) dword_6C6DE4;
            v31 = v58 < (double) v37;
            v32 = 0;
            v33 = v58 == v37;
            if((v30 & 0x100) == 0) {
                v36 = (float) (unsigned int) (dword_6C6DEC + dword_6C6DE4);
                if(v58 <= (double) v36) {
                    LABEL_21:
                    v55 = 1;
                    while(*(__int16*) v56 >= 0) {
                        v68 = *(_DWORD*) this + 272 * *((__int16*) v56 + 3);
                        if(!*(_WORD*) v56) {
                            *(float*) (v68 + 144) = v56 [2] + v66 [1] - *((float*) this + 15);
                            *(float*) (v68 + 148) = v56 [3] + v66 [2] - *((float*) this + 16);
                            *(float*) (v68 + 152) = v56 [4] + v66 [3] - *((float*) this + 17);
                            if(v56 [5] != 0.0)
                                *(float*) (v68 + 28) = v56 [5] / *(float*) (*(_DWORD*) (v68 + 192) + 48);
                            if(v56 [6] != 0.0)
                                *(float*) (v68 + 24) = v56 [6] / *(float*) (*(_DWORD*) (v68 + 192) + 44);
                            if(*(_WORD*) (v68 + 136) == 2) {
                                if(v56 [5] == 0.0)
                                    v53 = *(float*) (*(_DWORD*) (v68 + 192) + 48);
                                else
                                    v53 = v56 [5];
                                v63 = *(float*) (v68 + 144);
                                v64 = -*(float*) (v68 + 148);
                                v65 = *(float*) (v68 + 152);
                                sub_43F245(&v57, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
                                v63 = v53 * *(float*) (v68 + 28) + v63;
                                sub_43F245(v60, v54, (float*) &dword_6C6DE0, (char*) flt_6C6DA0, (char*) flt_6C6D60, (char*) v62);
                                *(float*) (v68 + 28) = (v60 [0] - v57) / v53;
                                *(_DWORD*) (v68 + 24) = *(_DWORD*) (v68 + 28);
                                v34 = v68 + 144;
                                *(float*) (v68 + 144) = v57;
                                *(float*) (v34 + 4) = v58;
                                *(_DWORD*) (v34 + 8) = v59;
                                sub_432FA0((void*) dword_6D4588, v68);
                            }
                            else {
                                sub_433150(dword_6D4588, v68);
                            }
                        }
                        v56 = (float*) ((char*) v56 + *((__int16*) v56 + 1));
                    }
                    ++v67;
                }
            }
        }
        v66 += 4;
    }
    return 0;
}
// 6C6D60: using guessed type float flt_6C6D60[16];
// 6C6DA0: using guessed type float flt_6C6DA0[16];
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 404970: using guessed type float var_60[3];

//----- (004051B0) --------------------------------------------------------
int __thiscall sub_4051B0(int* this, int a2, int a3) {
    *(_WORD*) (a2 + 180) = a3;
    *(_DWORD*) (a2 + 144) = 0;
    *(_DWORD*) (a2 + 148) = 0;
    *(_DWORD*) (a2 + 152) = 0;
    *(_DWORD*) (a2 + 228) = 0;
    *(_DWORD*) (a2 + 232) = 0;
    *(_DWORD*) (a2 + 236) = 0;
    *(_BYTE*) (a2 + 269) = 15;
    *(_BYTE*) (a2 + 268) = 15;
    return sub_432430(this, (_DWORD*) a2, this [a3 + 29261]);
}

//----- (00405260) --------------------------------------------------------
void __cdecl sub_405260(int a1) {
    _DWORD* v1; // ecx
    __int16 v2; // fps
    double v3; // st7
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    __int16 v7; // fps
    bool v8; // c0
    char v9; // c2
    bool v10; // c3
    _DWORD* v11; // edx
    int v12; // [esp+Ch] [ebp-8Ch]
    float v13; // [esp+10h] [ebp-88h]
    float v14; // [esp+14h] [ebp-84h]
    float v15; // [esp+18h] [ebp-80h]
    float v16; // [esp+1Ch] [ebp-7Ch]
    int j; // [esp+74h] [ebp-24h]
    float v18; // [esp+78h] [ebp-20h]
    float v19; // [esp+7Ch] [ebp-1Ch]
    float v20; // [esp+84h] [ebp-14h]
    int v21; // [esp+88h] [ebp-10h]
    int i; // [esp+8Ch] [ebp-Ch]
    int v23; // [esp+8Ch] [ebp-Ch]
    int k; // [esp+8Ch] [ebp-Ch]
    float v25; // [esp+90h] [ebp-8h]
    float v26; // [esp+90h] [ebp-8h]
    float v27; // [esp+90h] [ebp-8h]
    float v28; // [esp+94h] [ebp-4h]
    float v29; // [esp+94h] [ebp-4h]

    if(*(_DWORD*) (a1 + 30168) < *(_DWORD*) (a1 + 30156)) {
        if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160) && !*(_DWORD*) (a1 + 30168)) {
            sub_417ACD((int) dword_69BC30, 1185, "Spirit Sign \"Fantasy Seal\"");
            *(_DWORD*) (a1 + 30156) = 300;
            *(_DWORD*) (a1 + 30140) = 360;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            for(i = 0; i < 8; ++i)
                *(_DWORD*) (a1 + 4 * i + 30180) = 0;
            sub_420130(byte_69E268);
            sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 1088), 1, -12566273);
            *(_DWORD*) (a1 + 2360) = *(_DWORD*) (a1 + 1088);
            *(_DWORD*) (a1 + 2364) = *(_DWORD*) (a1 + 1092);
            *(_DWORD*) (a1 + 2368) = 1132462080;
            *(_DWORD*) (a1 + 2372) = 1132462080;
        }
        if(*(int*) (a1 + 30168) >= 60 && *(int*) (a1 + 30168) < 180 && !(*(_DWORD*) (a1 + 30168) % 16)) {
            v23 = (*(_DWORD*) (a1 + 30168) - 60) / 16;
            if(v23) {
                *(_DWORD*) (a1 + 4 * v23 + 30180) = 1;
                *(_DWORD*) (a1 + 4 * v23 + 30212) = 1082130432;
                v1 = (_DWORD*) (a1 + 12 * v23 + 30244);
                *v1 = *(_DWORD*) (a1 + 1088);
                v1 [1] = *(_DWORD*) (a1 + 1092);
                v1 [2] = *(_DWORD*) (a1 + 1096);
                v25 = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
                v16 = cos(v25);
                *(float*) (a1 + 12 * v23 + 30340) = v16 * *(float*) (a1 + 4 * v23 + 30212);
                v15 = sin(v25);
                *(float*) (a1 + 12 * v23 + 30344) = v15 * *(float*) (a1 + 4 * v23 + 30212);
                *(_DWORD*) (a1 + 4 * v23 + 2104) = 0;
                v21 = a1 + 1088 * v23 + 30436;
                for(j = 0; j < 4; ++j) {
                    sub_4051B0((int*) dword_6D4588, v21, j + 1157);
                    v21 += 272;
                }
                sub_4311E0(dword_6D3F50, (int*) 0xD, 0);
            }
        }
        *(_BYTE*) (a1 + 2528) = 3;
        for(k = 0; k < 8; ++k) {
            if(*(_DWORD*) (a1 + 4 * k + 30180)) {
                if(*(_DWORD*) (a1 + 4 * k + 30180) == 1) {
                    if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160)) {
                        v3 = *(float*) (a1 + 2588);
                        v4 = v3 < -100.0;
                        v5 = 0;
                        v6 = v3 == -100.0;
                        if((v2 & 0x4100) != 0) {
                            v18 = *(float*) (a1 + 1088);
                            v19 = *(float*) (a1 + 1092);
                        }
                        else {
                            v18 = *(float*) (a1 + 2588);
                            v19 = *(float*) (a1 + 2592);
                        }
                        v26 = v18 - *(float*) (a1 + 12 * k + 30244);
                        v28 = v19 - *(float*) (a1 + 12 * k + 30248);
                        v14 = sqrt(v28 * v28 + v26 * v26);
                        v20 = v14 / (*(float*) (a1 + 4 * k + 30212) / 8.0);
                        if(v20 < 1.0)
                            v20 = 1.0;
                        v27 = v26 / v20 + *(float*) (a1 + 12 * k + 30340);
                        v29 = v28 / v20 + *(float*) (a1 + 12 * k + 30344);
                        v13 = sqrt(v29 * v29 + v27 * v27);
                        v8 = v13 < 10.0;
                        v9 = 0;
                        v10 = v13 == 10.0;
                        if((v7 & 0x4100) != 0)
                            v12 = LODWORD(v13);
                        else
                            v12 = 1092616192;
                        *(_DWORD*) (a1 + 4 * k + 30212) = v12;
                        if(*(float*) (a1 + 4 * k + 30212) < 1.0)
                            *(_DWORD*) (a1 + 4 * k + 30212) = 1065353216;
                        *(float*) (a1 + 12 * k + 30340) = v27 * *(float*) (a1 + 4 * k + 30212) / v13;
                        *(float*) (a1 + 12 * k + 30344) = v29 * *(float*) (a1 + 4 * k + 30212) / v13;
                        *(_DWORD*) (a1 + 12 * k + 1592) = 1111490560;
                        *(_DWORD*) (a1 + 12 * k + 1596) = 1111490560;
                        v11 = (_DWORD*) (a1 + 12 * k + 1208);
                        *v11 = *(_DWORD*) (a1 + 12 * k + 30244);
                        v11 [1] = *(_DWORD*) (a1 + 12 * k + 30248);
                        v11 [2] = *(_DWORD*) (a1 + 12 * k + 30252);
                        *(_DWORD*) (a1 + 4 * k + 1976) = 8;
                        *(_DWORD*) (a1 + 16 * k + 2232) = *(_DWORD*) (a1 + 12 * k + 30244);
                        *(_DWORD*) (a1 + 16 * k + 2236) = *(_DWORD*) (a1 + 12 * k + 30248);
                        *(_DWORD*) (a1 + 16 * k + 2240) = 1111490560;
                        *(_DWORD*) (a1 + 16 * k + 2244) = 1111490560;
                        if(*(int*) (a1 + 4 * k + 2104) >= 100 || *(_DWORD*) (a1 + 30168) >= *(_DWORD*) (a1 + 30156) - 30) {
                            sub_40EF50(dword_487FE0, 6, (_DWORD*) (a1 + 12 * k + 30244), 8, -1);
                            sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 12 * k + 30244), 1, -12566273);
                            *(_DWORD*) (a1 + 4 * k + 30180) = 2;
                            *(_WORD*) (a1 + 1088 * k + 30574) = 1;
                            *(_WORD*) (a1 + 272 * (4 * k + 1) + 30574) = 1;
                            *(_WORD*) (a1 + 272 * (4 * k + 2) + 30574) = 1;
                            *(_WORD*) (a1 + 272 * (4 * k + 3) + 30574) = 1;
                            *(_DWORD*) (a1 + 12 * k + 1592) = 1132462080;
                            *(_DWORD*) (a1 + 12 * k + 1596) = 1132462080;
                            *(_DWORD*) (a1 + 4 * k + 1976) = 200;
                            *(_DWORD*) (a1 + 16 * k + 2240) = 1132462080;
                            *(_DWORD*) (a1 + 16 * k + 2244) = 1132462080;
                            sub_4311E0(dword_6D3F50, (int*) 0xF, 0);
                            sub_42FD30(1, 16, 8, 0, 0);
                        }
                    }
                }
                else if(*(_DWORD*) (a1 + 4 * k + 30180)) {
                    if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160) && (int)++ * (_DWORD*) (a1 + 4 * k + 30180) >= 30)
                        *(_DWORD*) (a1 + 4 * k + 30180) = 0;
                }
                *(float*) (a1 + 12 * k + 30244) = flt_6C6EC0 * *(float*) (a1 + 12 * k + 30340) + *(float*) (a1 + 12 * k + 30244);
                *(float*) (a1 + 12 * k + 30248) = flt_6C6EC0 * *(float*) (a1 + 12 * k + 30344) + *(float*) (a1 + 12 * k + 30248);
                sub_433960((int*) dword_6D4588, a1 + 1088 * k + 30436);
                sub_433960((int*) dword_6D4588, a1 + 272 * (4 * k + 1) + 30436);
                sub_433960((int*) dword_6D4588, a1 + 272 * (4 * k + 2) + 30436);
                sub_433960((int*) dword_6D4588, a1 + 272 * (4 * k + 3) + 30436);
            }
        }
        *(_DWORD*) (a1 + 30160) = *(_DWORD*) (a1 + 30168);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30168), (float*) (a1 + 30164));
    }
    else {
        sub_417314(dword_69BC30);
        *(_DWORD*) (a1 + 30152) = 0;
    }
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69BC30: using guessed type int dword_69BC30[5];
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00405C10) --------------------------------------------------------
int __cdecl sub_405C10(int a1) {
    int result; // eax
    float v2; // [esp+28h] [ebp-80h]
    float v3; // [esp+2Ch] [ebp-7Ch]
    float v4; // [esp+30h] [ebp-78h]
    float v5; // [esp+3Ch] [ebp-6Ch]
    float v6; // [esp+40h] [ebp-68h]
    float v7; // [esp+44h] [ebp-64h]
    float v8; // [esp+50h] [ebp-58h]
    float v9; // [esp+54h] [ebp-54h]
    float v10; // [esp+58h] [ebp-50h]
    float v11; // [esp+64h] [ebp-44h]
    float v12; // [esp+68h] [ebp-40h]
    float v13; // [esp+6Ch] [ebp-3Ch]
    int i; // [esp+A0h] [ebp-8h]
    float* v15; // [esp+A4h] [ebp-4h]
    float* v16; // [esp+A4h] [ebp-4h]

    result = sub_406020(a1);
    v15 = (float*) (a1 + 30436);
    for(i = 0; i < 8; ++i) {
        result = i;
        if(*(_DWORD*) (a1 + 4 * i + 30180)) {
            v13 = *(float*) (a1 + 12 * i + 30252) + v15 [59];
            v12 = *(float*) (a1 + 12 * i + 30248) + v15 [58];
            v11 = *(float*) (a1 + 12 * i + 30244) + v15 [57];
            v15 [36] = v11;
            v15 [37] = v12;
            v15 [38] = v13;
            v15 [36] = flt_69D6DC + v15 [36];
            v15 [37] = flt_69D6E0 + v15 [37];
            v15 [38] = 0.0;
            sub_432AD0((void*) dword_6D4588, (unsigned int) v15);
            v16 = v15 + 68;
            v10 = *(float*) (a1 + 12 * i + 30252) + v16 [59];
            v9 = *(float*) (a1 + 12 * i + 30248) + v16 [58];
            v8 = *(float*) (a1 + 12 * i + 30244) + v16 [57];
            v16 [36] = v8;
            v16 [37] = v9;
            v16 [38] = v10;
            v16 [36] = flt_69D6DC + v16 [36];
            v16 [37] = flt_69D6E0 + v16 [37];
            v16 [38] = 0.0;
            sub_432AD0((void*) dword_6D4588, (unsigned int) v16);
            v16 += 68;
            v7 = *(float*) (a1 + 12 * i + 30252) + v16 [59];
            v6 = *(float*) (a1 + 12 * i + 30248) + v16 [58];
            v5 = *(float*) (a1 + 12 * i + 30244) + v16 [57];
            v16 [36] = v5;
            v16 [37] = v6;
            v16 [38] = v7;
            v16 [36] = flt_69D6DC + v16 [36];
            v16 [37] = flt_69D6E0 + v16 [37];
            v16 [38] = 0.0;
            sub_432AD0((void*) dword_6D4588, (unsigned int) v16);
            v16 += 68;
            v4 = *(float*) (a1 + 12 * i + 30252) + v16 [59];
            v3 = *(float*) (a1 + 12 * i + 30248) + v16 [58];
            v2 = *(float*) (a1 + 12 * i + 30244) + v16 [57];
            v16 [36] = v2;
            v16 [37] = v3;
            v16 [38] = v4;
            v16 [36] = flt_69D6DC + v16 [36];
            v16 [37] = flt_69D6E0 + v16 [37];
            v16 [38] = 0.0;
            result = sub_432AD0((void*) dword_6D4588, (unsigned int) v16);
            v15 = v16 + 68;
        }
        else {
            v15 += 272;
        }
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00406020) --------------------------------------------------------
int __cdecl sub_406020(int a1) {
    __int16 v1; // fps
    bool v2; // c0
    char v3; // c2
    bool v4; // c3
    int v6; // [esp+0h] [ebp-34h]
    float v7; // [esp+4h] [ebp-30h]
    float v8; // [esp+8h] [ebp-2Ch]
    int v9; // [esp+Ch] [ebp-28h]
    float v10; // [esp+10h] [ebp-24h]
    float v11; // [esp+1Ch] [ebp-18h]
    float v12; // [esp+1Ch] [ebp-18h]
    int v13 [4]; // [esp+20h] [ebp-14h] BYREF
    int v14; // [esp+30h] [ebp-4h]

    v13 [0] = 1107296256;
    v13 [1] = 1098907648;
    v13 [2] = 1137704960;
    v13 [3] = 1139277824;
    if(*(int*) (a1 + 30168) >= 60) {
        if(*(_DWORD*) (a1 + 30168) < *(_DWORD*) (a1 + 30156) - 60) {
            v14 = 176;
        }
        else {
            v8 = (float) *(int*) (a1 + 30156);
            v7 = (float) *(int*) (a1 + 30168);
            v12 = (v8 - (v7 + *(float*) (a1 + 30164))) * 176.0 / 60.0;
            if(v12 >= 0.0)
                v6 = (unsigned __int64) v12;
            else
                v6 = 0;
            v14 = v6;
        }
    }
    else {
        v10 = (float) *(int*) (a1 + 30168);
        v11 = (v10 + *(float*) (a1 + 30164)) * 176.0 / 60.0;
        v2 = v11 < 176.0;
        v3 = 0;
        v4 = v11 == 176.0;
        if((v1 & 0x100) != 0)
            v9 = (unsigned __int64) v11;
        else
            v9 = 176;
        v14 = v9;
    }
    return sub_42F8B0(v13, v14 << 24);
}

//----- (00406160) --------------------------------------------------------
void __cdecl sub_406160(int a1) {
    float* v1; // eax
    float v2; // [esp+10h] [ebp-54h]
    float v3; // [esp+14h] [ebp-50h]
    float v4; // [esp+18h] [ebp-4Ch]
    int v5; // [esp+5Ch] [ebp-8h]
    int j; // [esp+60h] [ebp-4h]
    int i; // [esp+60h] [ebp-4h]

    if(*(_DWORD*) (a1 + 30168) < *(_DWORD*) (a1 + 30156)) {
        if(*(_DWORD*) (a1 + 30168) == *(_DWORD*) (a1 + 30160) || *(_DWORD*) (a1 + 30168)) {
            if(*(_DWORD*) (a1 + 30168) == 60)
                sub_42FD30(1, 80, 20, 0, 0);
            *(_DWORD*) (a1 + 2240) = 1115160576;
            *(_DWORD*) (a1 + 2244) = 1138753536;
            *(_DWORD*) (a1 + 2256) = 1136656384;
            *(_DWORD*) (a1 + 2260) = 1115160576;
            *(_DWORD*) (a1 + 2272) = 1115160576;
            *(_DWORD*) (a1 + 2276) = 1138753536;
            *(_DWORD*) (a1 + 2288) = 1136656384;
            *(_DWORD*) (a1 + 2292) = 1115160576;
            for(i = 0; i < 4; ++i) {
                sub_433960((int*) dword_6D4588, a1 + 272 * i + 30436);
                if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160) && *(_DWORD*) (a1 + 30168) % 2) {
                    *(float*) (a1 + 16 * i + 2232) = *(float*) (a1 + 12 * i + 30244) + *(float*) (a1 + 272 * i + 30664);
                    *(float*) (a1 + 16 * i + 2236) = *(float*) (a1 + 12 * i + 30248) + *(float*) (a1 + 272 * i + 30668);
                    *(_DWORD*) (a1 + 12 * i + 1592) = *(_DWORD*) (a1 + 16 * i + 2240);
                    *(_DWORD*) (a1 + 12 * i + 1596) = *(_DWORD*) (a1 + 16 * i + 2244);
                    v4 = *(float*) (a1 + 12 * i + 30252) + *(float*) (a1 + 272 * i + 30672);
                    v3 = *(float*) (a1 + 12 * i + 30248) + *(float*) (a1 + 272 * i + 30668);
                    v2 = *(float*) (a1 + 12 * i + 30244) + *(float*) (a1 + 272 * i + 30664);
                    v1 = (float*) (a1 + 12 * i + 1208);
                    *v1 = v2;
                    v1 [1] = v3;
                    v1 [2] = v4;
                    *(_DWORD*) (a1 + 4 * i + 1976) = 8;
                }
            }
        }
        else {
            sub_420130(byte_69E268);
            sub_417ACD((int) dword_69BC30, 1187, "Dream Sign \"Evil-Sealing Circle\" ");
            *(_DWORD*) (a1 + 30156) = 140;
            *(_DWORD*) (a1 + 30140) = 200;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            v5 = a1 + 30436;
            for(j = 0; j < 4; ++j) {
                sub_4051B0((int*) dword_6D4588, v5, j + 1161);
                v5 += 272;
            }
            sub_4311E0(dword_6D3F50, (int*) 6, 0);
            *(_DWORD*) (a1 + 30244) = *(_DWORD*) (a1 + 1088);
            *(_DWORD*) (a1 + 30248) = 1130364928;
            *(_DWORD*) (a1 + 30252) = 1054280253;
            *(_DWORD*) (a1 + 30256) = 1128267776;
            *(_DWORD*) (a1 + 30260) = *(_DWORD*) (a1 + 1092);
            *(_DWORD*) (a1 + 30264) = 1054112481;
            *(_DWORD*) (a1 + 30268) = *(_DWORD*) (a1 + 1088);
            *(_DWORD*) (a1 + 30272) = 1130364928;
            *(_DWORD*) (a1 + 30276) = 1053944709;
            *(_DWORD*) (a1 + 30280) = 1128267776;
            *(_DWORD*) (a1 + 30284) = *(_DWORD*) (a1 + 1092);
            *(_DWORD*) (a1 + 30288) = 1053776937;
            sub_42FD30(1, 60, 2, 6, 0);
        }
        *(_BYTE*) (a1 + 2528) = 3;
        *(_DWORD*) (a1 + 30160) = *(_DWORD*) (a1 + 30168);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30168), (float*) (a1 + 30164));
    }
    else {
        sub_417314(dword_69BC30);
        *(_DWORD*) (a1 + 30152) = 0;
    }
}
// 69BC30: using guessed type int dword_69BC30[5];
// 6C6D18: using guessed type int dword_6C6D18;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (004065E0) --------------------------------------------------------
int __cdecl sub_4065E0(int a1) {
    int result; // eax
    float v2; // [esp+8h] [ebp-20h]
    float v3; // [esp+Ch] [ebp-1Ch]
    float v4; // [esp+10h] [ebp-18h]
    int i; // [esp+20h] [ebp-8h]
    float* v6; // [esp+24h] [ebp-4h]

    result = sub_406020(a1);
    v6 = (float*) (a1 + 30436);
    for(i = 0; i < 4; ++i) {
        v4 = *(float*) (a1 + 12 * i + 30252) + v6 [59];
        v3 = *(float*) (a1 + 12 * i + 30248) + v6 [58];
        v2 = *(float*) (a1 + 12 * i + 30244) + v6 [57];
        v6 [36] = v2;
        v6 [37] = v3;
        v6 [38] = v4;
        v6 [36] = flt_69D6DC + v6 [36];
        v6 [37] = flt_69D6E0 + v6 [37];
        v6 [38] = 0.0;
        sub_432CC0((void*) dword_6D4588, (unsigned int) v6);
        result = (int) (v6 + 68);
        v6 += 68;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (004066F0) --------------------------------------------------------
void __cdecl sub_4066F0(int a1) {
    _DWORD* v1; // ecx
    _DWORD* v2; // eax
    float v3; // [esp+Ch] [ebp-74h]
    float v4; // [esp+10h] [ebp-70h]
    float v5; // [esp+14h] [ebp-6Ch]
    float* v6; // [esp+24h] [ebp-5Ch]
    float v7; // [esp+30h] [ebp-50h]
    float v8; // [esp+34h] [ebp-4Ch]
    float v9; // [esp+38h] [ebp-48h]
    float v10; // [esp+68h] [ebp-18h]
    int v11; // [esp+78h] [ebp-8h]
    int j; // [esp+7Ch] [ebp-4h]
    int i; // [esp+7Ch] [ebp-4h]

    if(*(_DWORD*) (a1 + 30168) < *(_DWORD*) (a1 + 30156)) {
        if(*(_DWORD*) (a1 + 30168) == *(_DWORD*) (a1 + 30160) || *(_DWORD*) (a1 + 30168)) {
            for(i = 0; i < 8; ++i) {
                v9 = flt_6C6EC0 * *(float*) (a1 + 12 * i + 30348);
                v8 = flt_6C6EC0 * *(float*) (a1 + 12 * i + 30344);
                v7 = flt_6C6EC0 * *(float*) (a1 + 12 * i + 30340);
                v6 = (float*) (a1 + 12 * i + 30244);
                *v6 = v7 + *v6;
                v6 [1] = v8 + v6 [1];
                v6 [2] = v9 + *(float*) (a1 + 12 * i + 30252);
                if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160) && *(_DWORD*) (a1 + 30168) % 3) {
                    *(_DWORD*) (a1 + 16 * i + 2232) = *(_DWORD*) (a1 + 12 * i + 30244);
                    *(_DWORD*) (a1 + 16 * i + 2236) = *(_DWORD*) (a1 + 12 * i + 30248);
                    *(_DWORD*) (a1 + 16 * i + 2240) = 1124073472;
                    *(_DWORD*) (a1 + 16 * i + 2244) = 1124073472;
                    *(_DWORD*) (a1 + 12 * i + 1592) = 1124073472;
                    *(_DWORD*) (a1 + 12 * i + 1596) = 1124073472;
                    v2 = (_DWORD*) (a1 + 12 * i + 1208);
                    *v2 = *(_DWORD*) (a1 + 12 * i + 30244);
                    v2 [1] = *(_DWORD*) (a1 + 12 * i + 30248);
                    v2 [2] = *(_DWORD*) (a1 + 12 * i + 30252);
                    *(_DWORD*) (a1 + 4 * i + 1976) = 8;
                }
                sub_433960((int*) dword_6D4588, a1 + 272 * i + 30436);
            }
        }
        else {
            sub_420130(byte_69E268);
            sub_417ACD((int) dword_69BC30, 1187, "Magic Sign \"Stardust Reverie\"  ");
            *(_DWORD*) (a1 + 30156) = 250;
            *(_DWORD*) (a1 + 30140) = 300;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            v11 = a1 + 30436;
            for(j = 0; j < 8; ++j) {
                sub_4051B0((int*) dword_6D4588, v11, j % 3 + 1029);
                v1 = (_DWORD*) (a1 + 12 * j + 30244);
                *v1 = *(_DWORD*) (a1 + 1088);
                v1 [1] = *(_DWORD*) (a1 + 1092);
                v1 [2] = *(_DWORD*) (a1 + 1096);
                v5 = (float) j;
                v10 = v5 * 6.2831855 / 8.0;
                v4 = cos(v10);
                *(float*) (a1 + 12 * j + 30340) = v4 + v4;
                v3 = sin(v10);
                *(float*) (a1 + 12 * j + 30344) = v3 + v3;
                *(_DWORD*) (a1 + 12 * j + 30348) = 0;
                v11 += 272;
            }
            sub_4311E0(dword_6D3F50, (int*) 6, 0);
            sub_42FD30(1, 120, 4, 1, 0);
        }
        *(_BYTE*) (a1 + 2528) = 3;
        *(_DWORD*) (a1 + 30160) = *(_DWORD*) (a1 + 30168);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30168), (float*) (a1 + 30164));
    }
    else {
        sub_417314(dword_69BC30);
        *(_DWORD*) (a1 + 30152) = 0;
    }
}
// 69BC30: using guessed type int dword_69BC30[5];
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00406B10) --------------------------------------------------------
int __cdecl sub_406B10(int a1) {
    int result; // eax
    double v2; // st7
    double v3; // st7
    double v4; // st7
    double v5; // st7
    double v6; // st7
    double v7; // st7
    float v8; // [esp+8h] [ebp-60h]
    float v9; // [esp+Ch] [ebp-5Ch]
    float v10; // [esp+10h] [ebp-58h]
    float v11; // [esp+1Ch] [ebp-4Ch]
    float v12; // [esp+20h] [ebp-48h]
    float v13; // [esp+24h] [ebp-44h]
    float v14; // [esp+30h] [ebp-38h]
    float v15; // [esp+34h] [ebp-34h]
    float v16; // [esp+38h] [ebp-30h]
    int i; // [esp+60h] [ebp-8h]
    float* v18; // [esp+64h] [ebp-4h]

    result = sub_406020(a1);
    v18 = (float*) (a1 + 30436);
    for(i = 0; i < 8; ++i) {
        v18 [36] = *(float*) (a1 + 12 * i + 30244);
        v18 [37] = *(float*) (a1 + 12 * i + 30248);
        v18 [38] = *(float*) (a1 + 12 * i + 30252);
        v18 [36] = flt_69D6DC + v18 [36];
        v18 [37] = flt_69D6E0 + v18 [37];
        v18 [38] = 0.0;
        v18 [7] = 3.2;
        v18 [6] = 3.2;
        sub_432CC0((void*) dword_6D4588, (unsigned int) v18);
        v16 = *(float*) (a1 + 12 * i + 30348) * 6.0;
        v15 = *(float*) (a1 + 12 * i + 30344) * 6.0;
        v14 = *(float*) (a1 + 12 * i + 30340) * 6.0;
        v18 [36] = v18 [36] - v14;
        v18 [37] = v18 [37] - v15;
        v18 [38] = v18 [38] - v16;
        v18 [36] = v18 [36] + -32.0;
        v18 [37] = v18 [37] + -32.0;
        v18 [38] = 0.0;
        v18 [7] = 2.2;
        v18 [6] = 2.2;
        sub_432CC0((void*) dword_6D4588, (unsigned int) v18);
        v2 = *(float*) (a1 + 12 * i + 30348);
        v13 = v2 + v2;
        v3 = *(float*) (a1 + 12 * i + 30344);
        v12 = v3 + v3;
        v4 = *(float*) (a1 + 12 * i + 30340);
        v11 = v4 + v4;
        v18 [36] = v18 [36] - v11;
        v18 [37] = v18 [37] - v12;
        v18 [38] = v18 [38] - v13;
        v18 [36] = v18 [36] + 64.0;
        v18 [37] = v18 [37] + 64.0;
        v18 [38] = 0.0;
        v5 = *(float*) (a1 + 12 * i + 30348);
        v10 = v5 + v5;
        v6 = *(float*) (a1 + 12 * i + 30344);
        v9 = v6 + v6;
        v7 = *(float*) (a1 + 12 * i + 30340);
        v8 = v7 + v7;
        v18 [36] = v18 [36] - v8;
        v18 [37] = v18 [37] - v9;
        v18 [38] = v18 [38] - v10;
        v18 [36] = v18 [36] + -32.0;
        v18 [37] = v18 [37] + -32.0;
        v18 [38] = 0.0;
        v18 [7] = 1.0;
        v18 [6] = 1.0;
        result = sub_432CC0((void*) dword_6D4588, (unsigned int) v18);
        v18 += 68;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00406E70) --------------------------------------------------------
void __cdecl sub_406E70(int a1) {
    _DWORD* v1; // ecx
    int v2; // [esp+38h] [ebp-8h]
    int i; // [esp+3Ch] [ebp-4h]

    if(*(_DWORD*) (a1 + 30168) < *(_DWORD*) (a1 + 30156)) {
        if(*(_DWORD*) (a1 + 30168) == *(_DWORD*) (a1 + 30160) || *(_DWORD*) (a1 + 30168)) {
            if(*(_DWORD*) (a1 + 30168) == 60) {
                sub_42FD30(1, 60, 1, 7, 0);
            }
            else if(*(_DWORD*) (a1 + 30168) == 120) {
                sub_42FD30(1, 200, 24, 0, 0);
            }
            if(*(_DWORD*) (a1 + 30168) != *(_DWORD*) (a1 + 30160) && *(_DWORD*) (a1 + 30168) % 4) {
                *(_DWORD*) (a1 + 2232) = 1128267776;
                *(float*) (a1 + 2236) = *(float*) (a1 + 1092) / 2.0;
                *(_DWORD*) (a1 + 2240) = 1136656384;
                *(_DWORD*) (a1 + 2244) = *(_DWORD*) (a1 + 1092);
                *(_DWORD*) (a1 + 1592) = 1136656384;
                *(_DWORD*) (a1 + 1596) = *(_DWORD*) (a1 + 1092);
                *(_DWORD*) (a1 + 1208) = *(_DWORD*) (a1 + 2232);
                *(_DWORD*) (a1 + 1212) = *(_DWORD*) (a1 + 2236);
                *(_DWORD*) (a1 + 1976) = 12;
            }
            sub_433960((int*) dword_6D4588, a1 + 30436);
            sub_433960((int*) dword_6D4588, a1 + 30708);
            sub_433960((int*) dword_6D4588, a1 + 30980);
            sub_433960((int*) dword_6D4588, a1 + 31252);
        }
        else {
            sub_420130(byte_69E268);
            sub_417ACD((int) dword_69BC30, 1185, "Love Sign \"Master Spark\"  ");
            *(_DWORD*) (a1 + 30156) = 300;
            *(_DWORD*) (a1 + 30140) = 360;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            v2 = a1 + 30436;
            for(i = 0; i < 4; ++i) {
                sub_4051B0((int*) dword_6D4588, v2, i + 1032);
                v1 = (_DWORD*) (a1 + 12 * i + 30244);
                *v1 = *(_DWORD*) (a1 + 1088);
                v1 [1] = *(_DWORD*) (a1 + 1092);
                v1 [2] = *(_DWORD*) (a1 + 1096);
                v2 += 272;
            }
            sub_4311E0(dword_6D3F50, (int*) 0x13, 0);
            *(_DWORD*) (a1 + 2516) = 1050253722;
            *(_DWORD*) (a1 + 2512) = 1050253722;
        }
        *(_BYTE*) (a1 + 2528) = 3;
        *(_DWORD*) (a1 + 30160) = *(_DWORD*) (a1 + 30168);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30168), (float*) (a1 + 30164));
    }
    else {
        sub_417314(dword_69BC30);
        *(_DWORD*) (a1 + 30152) = 0;
        *(_DWORD*) (a1 + 2516) = 1065353216;
        *(_DWORD*) (a1 + 2512) = 1065353216;
    }
}
// 69BC30: using guessed type int dword_69BC30[5];
// 6C6D18: using guessed type int dword_6C6D18;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (004071B0) --------------------------------------------------------
int __cdecl sub_4071B0(_DWORD* a1) {
    int result; // eax
    float v2; // [esp+8h] [ebp-18h]
    float v3; // [esp+Ch] [ebp-14h]
    float v4; // [esp+10h] [ebp-10h]
    float v5; // [esp+14h] [ebp-Ch]
    float v6; // [esp+14h] [ebp-Ch]
    int i; // [esp+18h] [ebp-8h]
    unsigned int v8; // [esp+1Ch] [ebp-4h]

    result = sub_406020((int) a1);
    v8 = (unsigned int) (a1 + 7609);
    for(i = 0; i < 4; ++i) {
        v4 = (float) i;
        v5 = 0.62831855 * v4 / 3.0 - 3.1415927 + 1.2566371;
        *(_DWORD*) (v8 + 144) = a1 [272];
        *(_DWORD*) (v8 + 148) = a1 [273];
        *(_DWORD*) (v8 + 152) = a1 [274];
        v3 = cos(v5);
        *(float*) (v8 + 144) = v3 * *(float*) (*(_DWORD*) (v8 + 192) + 44) * *(float*) (v8 + 24) / 2.0
            + *(float*) (v8 + 144);
        v2 = sin(v5);
        *(float*) (v8 + 148) = v2 * *(float*) (*(_DWORD*) (v8 + 192) + 44) * *(float*) (v8 + 24) / 2.0
            + *(float*) (v8 + 148);
        v6 = 1.5707964 - v5;
        *(float*) (v8 + 8) = sub_41E850(v6, 3.1415927);
        *(float*) (v8 + 144) = flt_69D6DC + *(float*) (v8 + 144);
        *(float*) (v8 + 148) = flt_69D6E0 + *(float*) (v8 + 148);
        *(_DWORD*) (v8 + 152) = 0;
        result = sub_432CC0((void*) dword_6D4588, v8);
        v8 += 272;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00407340) --------------------------------------------------------
int __thiscall sub_407340(__int16** this, char* Str) {
    int i; // [esp+4h] [ebp-4h]

    *this = (__int16*) sub_41E290(Str, 0);
    if(*this) {
        *((_DWORD*) *this + 1) += *this;
        this [1] = *this + 8;
        for(i = 0; i < **this; ++i)
            *(_DWORD*) &this [1] [2 * i] += *this;
        this [2] = (__int16*) *((_DWORD*) *this + 1);
        return 0;
    }
    else {
        sub_41E4D0((int) byte_69D998, (char*) &byte_46A480);
        return -1;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (00407400) --------------------------------------------------------
void __thiscall sub_407400(void** this) {
    if(*this)
        free(*this);
    *this = 0;
}

//----- (00407440) --------------------------------------------------------
int __thiscall sub_407440(_DWORD* this, int a2, __int16 a3) {
    *(_DWORD*) a2 = *(_DWORD*) (this [1] + 4 * a3);
    *(_DWORD*) (a2 + 12) = 0;
    *(_DWORD*) (a2 + 8) = 0;
    *(_DWORD*) (a2 + 4) = -999;
    *(_WORD*) (a2 + 72) = a3;
    return 0;
}

//----- (004074A0) --------------------------------------------------------
int __stdcall sub_4074A0(_DWORD* a1) {
    unsigned int v2; // eax
    unsigned int v3; // eax
    double v4; // st7
    double v5; // st7
    int v6; // edx
    int v7; // eax
    int v8; // eax
    double v9; // st7
    float* v10; // eax
    float* v11; // eax
    float* v12; // ecx
    int* v13; // eax
    double v14; // st7
    int* v15; // eax
    int* v16; // eax
    int* v17; // eax
    float* v18; // eax
    int* v19; // eax
    int* v20; // eax
    int* v21; // eax
    int* v22; // eax
    int* v23; // eax
    int v24; // esi
    int* v25; // eax
    int* v26; // eax
    float* v27; // eax
    _DWORD* v28; // eax
    int v29; // edx
    _DWORD* v30; // ecx
    double v31; // st7
    double v32; // st7
    __int16 v33; // fps
    double v34; // st7
    bool v35; // c0
    char v36; // c2
    bool v37; // c3
    __int16 v38; // fps
    double v39; // st7
    bool v40; // c0
    char v41; // c2
    bool v42; // c3
    __int16 v43; // fps
    double v44; // st7
    bool v45; // c0
    char v46; // c2
    bool v47; // c3
    __int16 v48; // fps
    double v49; // st7
    bool v50; // c0
    char v51; // c2
    bool v52; // c3
    __int16 v53; // fps
    double v54; // st7
    bool v55; // c0
    char v56; // c2
    bool v57; // c3
    __int16 v58; // fps
    double v59; // st7
    bool v60; // c0
    char v61; // c2
    bool v62; // c3
    int v63; // eax
    int v64; // eax
    __int16 v65; // fps
    bool v66; // c0
    char v67; // c2
    bool v68; // c3
    double v69; // st7
    __int16 v70; // fps
    double v71; // st7
    bool v72; // c0
    char v73; // c2
    bool v74; // c3
    int v75; // edx
    int v76; // ecx
    int v77; // ecx
    int v78; // ecx
    int v79; // ecx
    float v80; // [esp+Ch] [ebp-304h]
    float v81; // [esp+1Ch] [ebp-2F4h]
    float v82; // [esp+24h] [ebp-2ECh]
    float v83; // [esp+28h] [ebp-2E8h]
    char v84; // [esp+2Ch] [ebp-2E4h]
    int v85; // [esp+38h] [ebp-2D8h]
    char v86; // [esp+4Fh] [ebp-2C1h]
    _BYTE* v87; // [esp+54h] [ebp-2BCh]
    char* v88; // [esp+58h] [ebp-2B8h]
    float v89; // [esp+5Ch] [ebp-2B4h]
    float v90; // [esp+60h] [ebp-2B0h]
    float v91; // [esp+64h] [ebp-2ACh]
    int v92; // [esp+68h] [ebp-2A8h]
    int v93; // [esp+6Ch] [ebp-2A4h]
    int v94; // [esp+70h] [ebp-2A0h]
    unsigned int v95; // [esp+74h] [ebp-29Ch]
    unsigned int v96; // [esp+78h] [ebp-298h]
    int* v97; // [esp+88h] [ebp-288h]
    int* v98; // [esp+90h] [ebp-280h]
    int* v99; // [esp+98h] [ebp-278h]
    int* v100; // [esp+A0h] [ebp-270h]
    int* v101; // [esp+A8h] [ebp-268h]
    float v102; // [esp+BCh] [ebp-254h]
    float v103; // [esp+C0h] [ebp-250h]
    float v104; // [esp+C4h] [ebp-24Ch]
    float v105; // [esp+D4h] [ebp-23Ch]
    float v106; // [esp+D8h] [ebp-238h]
    float v107; // [esp+DCh] [ebp-234h]
    float v108; // [esp+ECh] [ebp-224h]
    float v109; // [esp+F0h] [ebp-220h]
    float v110; // [esp+F4h] [ebp-21Ch]
    float v111; // [esp+FCh] [ebp-214h]
    float v112; // [esp+100h] [ebp-210h]
    float v113; // [esp+104h] [ebp-20Ch]
    float v114; // [esp+10Ch] [ebp-204h]
    float v115; // [esp+110h] [ebp-200h]
    float v116; // [esp+114h] [ebp-1FCh]
    float v117; // [esp+120h] [ebp-1F0h]
    float v118; // [esp+124h] [ebp-1ECh]
    int v119; // [esp+130h] [ebp-1E0h]
    float v120; // [esp+144h] [ebp-1CCh]
    float v121; // [esp+148h] [ebp-1C8h]
    float v122; // [esp+158h] [ebp-1B8h]
    float v123; // [esp+15Ch] [ebp-1B4h]
    float v124; // [esp+160h] [ebp-1B0h]
    float v125; // [esp+16Ch] [ebp-1A4h]
    float v126; // [esp+170h] [ebp-1A0h]
    float v127; // [esp+174h] [ebp-19Ch]
    float v128; // [esp+180h] [ebp-190h]
    float v129; // [esp+184h] [ebp-18Ch]
    float v130; // [esp+188h] [ebp-188h]
    unsigned int v131; // [esp+190h] [ebp-180h]
    unsigned int v132; // [esp+194h] [ebp-17Ch]
    float v133; // [esp+1B4h] [ebp-15Ch]
    float v134; // [esp+1B8h] [ebp-158h]
    float v135; // [esp+1BCh] [ebp-154h]
    int* v136; // [esp+1C8h] [ebp-148h]
    _DWORD* v137; // [esp+1CCh] [ebp-144h]
    int v138; // [esp+1D0h] [ebp-140h]
    int* v139; // [esp+1D4h] [ebp-13Ch]
    int v140; // [esp+254h] [ebp-BCh]
    float v141; // [esp+258h] [ebp-B8h]
    float v142; // [esp+258h] [ebp-B8h]
    float v143; // [esp+258h] [ebp-B8h]
    int k; // [esp+25Ch] [ebp-B4h]
    char* v145; // [esp+260h] [ebp-B0h]
    int v146 [6]; // [esp+264h] [ebp-ACh] BYREF
    float v147; // [esp+27Ch] [ebp-94h] BYREF
    float v148; // [esp+280h] [ebp-90h]
    int v149; // [esp+284h] [ebp-8Ch]
    int m; // [esp+288h] [ebp-88h]
    int v151; // [esp+28Ch] [ebp-84h]
    int j; // [esp+290h] [ebp-80h]
    int v153; // [esp+294h] [ebp-7Ch]
    int v154; // [esp+298h] [ebp-78h]
    int v155; // [esp+29Ch] [ebp-74h]
    int i; // [esp+2A0h] [ebp-70h]
    int v157; // [esp+2A4h] [ebp-6Ch]
    int v158; // [esp+2A8h] [ebp-68h]
    int n; // [esp+2ACh] [ebp-64h]
    int v160; // [esp+2B0h] [ebp-60h]
    __int16* v161; // [esp+2B4h] [ebp-5Ch]
    int v162; // [esp+2B8h] [ebp-58h]
    _DWORD* v163; // [esp+2BCh] [ebp-54h]
    int v164; // [esp+2C0h] [ebp-50h]
    int v165; // [esp+2C4h] [ebp-4Ch]
    int v166; // [esp+2C8h] [ebp-48h]
    int v167; // [esp+2CCh] [ebp-44h]
    int v168; // [esp+2D0h] [ebp-40h]
    float* v169; // [esp+2D4h] [ebp-3Ch]
    float* v170; // [esp+2D8h] [ebp-38h]
    int v171; // [esp+2DCh] [ebp-34h]
    int v172; // [esp+2E0h] [ebp-30h]
    int v173; // [esp+2E4h] [ebp-2Ch]
    int v174; // [esp+2E8h] [ebp-28h]
    unsigned int v175; // [esp+2ECh] [ebp-24h]
    unsigned int v176; // [esp+2F0h] [ebp-20h]
    int v177; // [esp+2F4h] [ebp-1Ch]
    float* v178; // [esp+2F8h] [ebp-18h]
    float v179; // [esp+2FCh] [ebp-14h] BYREF
    int v180; // [esp+300h] [ebp-10h] BYREF
    float v181; // [esp+304h] [ebp-Ch] BYREF
    float v182; // [esp+308h] [ebp-8h] BYREF
    int v183; // [esp+30Ch] [ebp-4h]

    LABEL_1:
    while(1) {
        v177 = a1 [612];
        if((int) a1 [794] < 0)
            break;
        LABEL_186:
        a1 [612] = *(__int16*) (v177 + 6) + v177;
        if((*((_BYTE*) a1 + 3666) & 4) == 0)
            qmemcpy(&a1 [19 * a1 [783] + 631], a1 + 612, 0x4Cu);
        sub_407440(dword_487E50, (int) (a1 + 612), a1 [a1 [794] + 786]);
        if((int) a1 [783] < 7)
            ++a1 [783];
        a1 [794] = -1;
    }
    LABEL_2:
    while(a1 [615] == *(_DWORD*) v177) {
        if(((1 << dword_69BCB0) & *(unsigned __int8*) (v177 + 9)) != 0) {
            v178 = (float*) (v177 + 12);
            switch(*(_WORD*) (v177 + 4)) {
                case 1:
                    return -1;
                case 2:
                    goto LABEL_7;
                case 3:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 2, 0);
                    --v180;
                    sub_40B3C0((float*) a1, v178 [2], (float*) &v180);
                    if(v180 <= 0)
                        goto LABEL_263;
                    goto LABEL_7;
                case 4:
                case 5:
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), v178 + 1);
                    goto LABEL_263;
                case 6:
                    v176 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 1, 0);
                    if(v176) {
                        v2 = sub_41E7F0(&word_69D8F8);
                        v96 = v2 % v176;
                    }
                    else {
                        v96 = 0;
                    }
                    v180 = v96;
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), (float*) &v180);
                    goto LABEL_263;
                case 7:
                    v175 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 1, 0);
                    v174 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 2, 0);
                    if(v175) {
                        v3 = sub_41E7F0(&word_69D8F8);
                        v95 = v3 % v175;
                    }
                    else {
                        v95 = 0;
                    }
                    v180 = v174 + v95;
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), (float*) &v180);
                    goto LABEL_263;
                case 8:
                    v173 = *sub_40B380((float*) a1, v178 + 1, 0);
                    v4 = sub_41E820(&word_69D8F8);
                    v179 = v4 * *(float*) &v173;
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), &v179);
                    goto LABEL_263;
                case 9:
                    v172 = *sub_40B380((float*) a1, v178 + 1, 0);
                    v171 = *sub_40B380((float*) a1, v178 + 2, 0);
                    v5 = sub_41E820(&word_69D8F8);
                    v179 = v5 * *(float*) &v172;
                    v179 = v179 + *(float*) &v171;
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), &v179);
                    goto LABEL_263;
                case 0xA:
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), (float*) a1 + 795);
                    goto LABEL_263;
                case 0xB:
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), (float*) a1 + 796);
                    goto LABEL_263;
                case 0xC:
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), (float*) a1 + 797);
                    goto LABEL_263;
                case 0xD:
                case 0x14:
                    sub_40B420((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2);
                    goto LABEL_263;
                case 0xE:
                case 0x15:
                    sub_40B4D0((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2);
                    goto LABEL_263;
                case 0xF:
                case 0x16:
                    sub_40B580((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2);
                    goto LABEL_263;
                case 0x10:
                case 0x17:
                    sub_40B650((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2);
                    goto LABEL_263;
                case 0x11:
                case 0x18:
                    sub_40B700((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2);
                    goto LABEL_263;
                case 0x12:
                    v170 = sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    ++* (_DWORD*) v170;
                    goto LABEL_263;
                case 0x13:
                    v169 = sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    --* (_DWORD*) v169;
                    goto LABEL_263;
                case 0x19:
                    sub_40B7D0((float*) a1, *(float*) (v177 + 12), v178 + 1, v178 + 2, v178 + 3, v178 + 4);
                    goto LABEL_263;
                case 0x1A:
                    v179 = *sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    v179 = sub_41E850(v179, 0.0);
                    sub_40B3C0((float*) a1, *(float*) (v177 + 12), &v179);
                    goto LABEL_263;
                case 0x1B:
                    v167 = *(_DWORD*) sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    v168 = *(_DWORD*) sub_40AFB0((float*) a1, (float*) (v177 + 16), 0);
                    if(v167 == v168)
                        v94 = 0;
                    else
                        v94 = 2 * (v167 >= v168) - 1;
                    a1 [629] = v94;
                    goto LABEL_263;
                case 0x1C:
                    v166 = *sub_40B380((float*) a1, (float*) (v177 + 12), 0);
                    v165 = *sub_40B380((float*) a1, (float*) (v177 + 16), 0);
                    if(*(float*) &v166 == *(float*) &v165) {
                        v93 = 0;
                    }
                    else {
                        if(*(float*) &v166 >= (double) *(float*) &v165)
                            v92 = 1;
                        else
                            v92 = -1;
                        v93 = v92;
                    }
                    a1 [629] = v93;
                    goto LABEL_263;
                case 0x1D:
                    if((int) a1 [629] >= 0)
                        goto LABEL_263;
                    goto LABEL_7;
                case 0x1E:
                    if((int) a1 [629] > 0)
                        goto LABEL_263;
                    goto LABEL_7;
                case 0x1F:
                    if(a1 [629])
                        goto LABEL_263;
                    goto LABEL_7;
                case 0x20:
                    if((int) a1 [629] <= 0)
                        goto LABEL_263;
                    goto LABEL_7;
                case 0x21:
                    if((int) a1 [629] < 0)
                        goto LABEL_263;
                    goto LABEL_7;
                case 0x22:
                    if(!a1 [629])
                        goto LABEL_263;
                    LABEL_7:
                    a1 [615] = *(_DWORD*) (v177 + 12);
                    v177 += *((_DWORD*) v178 + 1);
                    goto LABEL_2;
                case 0x23:
                    goto LABEL_54;
                case 0x24:
                    if((*((_BYTE*) a1 + 3666) & 4) != 0)
                        sub_41E940();
                    --a1 [783];
                    qmemcpy(a1 + 612, &a1 [19 * a1 [783] + 631], 0x4Cu);
                    goto LABEL_1;
                case 0x25:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 >= *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    goto LABEL_54;
                case 0x26:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 > *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    goto LABEL_54;
                case 0x27:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 != *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    goto LABEL_54;
                case 0x28:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 <= *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    goto LABEL_54;
                case 0x29:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 < *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    goto LABEL_54;
                case 0x2A:
                    v180 = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    if(v180 == *((_DWORD*) v178 + 4))
                        goto LABEL_263;
                    LABEL_54:
                    v180 = *(_DWORD*) (v177 + 12);
                    a1 [612] = *(__int16*) (v177 + 6) + v177;
                    if((*((_BYTE*) a1 + 3666) & 4) == 0)
                        qmemcpy(&a1 [19 * a1 [783] + 631], a1 + 612, 0x4Cu);
                    sub_407440(dword_487E50, (int) (a1 + 612), v180);
                    if((*((_BYTE*) a1 + 3666) & 4) == 0 && (int) a1 [783] < 7)
                        ++a1 [783];
                    a1 [617] = *(_DWORD*) (v177 + 16);
                    a1 [621] = *(_DWORD*) (v177 + 20);
                    break;
                case 0x2B:
                    v7 = v177 + 12;
                    a1 [795] = *(_DWORD*) (v177 + 12);
                    a1 [796] = *(_DWORD*) (v7 + 4);
                    a1 [797] = *(_DWORD*) (v7 + 8);
                    a1 [795] = *sub_40B380((float*) a1, (float*) a1 + 795, 0);
                    a1 [796] = *sub_40B380((float*) a1, (float*) a1 + 796, 0);
                    a1 [797] = *sub_40B380((float*) a1, (float*) a1 + 797, 0);
                    sub_412240((int) a1);
                    goto LABEL_263;
                case 0x2C:
                    v8 = v177 + 12;
                    a1 [801] = *(_DWORD*) (v177 + 12);
                    a1 [802] = *(_DWORD*) (v8 + 4);
                    a1 [803] = *(_DWORD*) (v8 + 8);
                    a1 [801] = *sub_40B380((float*) a1, (float*) a1 + 801, 0);
                    a1 [802] = *sub_40B380((float*) a1, (float*) a1 + 802, 0);
                    a1 [803] = *sub_40B380((float*) a1, (float*) a1 + 803, 0);
                    *((_BYTE*) a1 + 3664) &= 0xFCu;
                    goto LABEL_263;
                case 0x2D:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    a1 [804] = *sub_40B380((float*) a1, &v181, 0);
                    a1 [806] = *sub_40B380((float*) a1, &v182, 0);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xFC | 1;
                    goto LABEL_263;
                case 0x2E:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    a1 [805] = *sub_40B380((float*) a1, &v181, 0);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xFC | 1;
                    goto LABEL_263;
                case 0x2F:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    a1 [806] = *sub_40B380((float*) a1, &v181, 0);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xFC | 1;
                    goto LABEL_263;
                case 0x30:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    a1 [807] = *sub_40B380((float*) a1, &v181, 0);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xFC | 1;
                    goto LABEL_263;
                case 0x31:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    v121 = v182 - v181;
                    v31 = sub_41E820(&word_69D8F8);
                    *((float*) a1 + 804) = v31 * v121 + v181;
                    goto LABEL_263;
                case 0x32:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    v120 = v182 - v181;
                    v32 = sub_41E820(&word_69D8F8);
                    *((float*) a1 + 804) = v32 * v120 + v181;
                    v34 = *((float*) a1 + 920) + 96.0;
                    v35 = v34 < *((float*) a1 + 795);
                    v36 = 0;
                    v37 = v34 == *((float*) a1 + 795);
                    if((v33 & 0x4100) == 0) {
                        v39 = *((float*) a1 + 804);
                        v40 = v39 < 1.5707964;
                        v41 = 0;
                        v42 = v39 == 1.5707964;
                        if((v38 & 0x4100) != 0) {
                            if(*((float*) a1 + 804) < -1.5707964)
                                *((float*) a1 + 804) = -3.1415927 - *((float*) a1 + 804);
                        }
                        else {
                            *((float*) a1 + 804) = 3.1415927 - *((float*) a1 + 804);
                        }
                    }
                    if(*((float*) a1 + 922) - 96.0 < *((float*) a1 + 795)) {
                        if(*((float*) a1 + 804) >= 1.5707964
                           || (v44 = *((float*) a1 + 804), v45 = v44 < 0.0, v46 = 0, v47 = v44 == 0.0, (v43 & 0x100) != 0)) {
                            v49 = *((float*) a1 + 804);
                            v50 = v49 < -1.5707964;
                            v51 = 0;
                            v52 = v49 == -1.5707964;
                            if((v48 & 0x4100) == 0 && *((float*) a1 + 804) <= 0.0)
                                *((float*) a1 + 804) = -3.1415927 - *((float*) a1 + 804);
                        }
                        else {
                            *((float*) a1 + 804) = 3.1415927 - *((float*) a1 + 804);
                        }
                    }
                    v54 = *((float*) a1 + 921) + 48.0;
                    v55 = v54 < *((float*) a1 + 796);
                    v56 = 0;
                    v57 = v54 == *((float*) a1 + 796);
                    if((v53 & 0x4100) == 0 && *((float*) a1 + 804) < 0.0)
                        *((float*) a1 + 804) = -*((float*) a1 + 804);
                    if(*((float*) a1 + 923) - 48.0 < *((float*) a1 + 796)) {
                        v59 = *((float*) a1 + 804);
                        v60 = v59 < 0.0;
                        v61 = 0;
                        v62 = v59 == 0.0;
                        if((v58 & 0x4100) == 0)
                            *((float*) a1 + 804) = -*((float*) a1 + 804);
                    }
                    goto LABEL_263;
                case 0x33:
                    v181 = *(float*) (v177 + 12);
                    v182 = *(float*) (v177 + 16);
                    v183 = *(_DWORD*) (v177 + 20);
                    v9 = sub_428700(flt_6CA628, (float*) a1 + 795);
                    *((float*) a1 + 804) = v9 + v181;
                    a1 [806] = *sub_40B380((float*) a1, &v182, 0);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xFC | 1;
                    goto LABEL_263;
                case 0x34:
                    sub_40ABE0((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 4;
                    goto LABEL_263;
                case 0x35:
                    sub_40ABE0((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 8;
                    goto LABEL_263;
                case 0x36:
                    sub_40ABE0((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0xC;
                    goto LABEL_263;
                case 0x37:
                    sub_40ABE0((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0x10;
                    goto LABEL_263;
                case 0x38:
                    sub_40AD10((int) a1, v177);
                    *((_BYTE*) a1 + 3664) &= 0xE3u;
                    goto LABEL_263;
                case 0x39:
                    sub_40AD10((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 4;
                    goto LABEL_263;
                case 0x3A:
                    sub_40AD10((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 8;
                    goto LABEL_263;
                case 0x3B:
                    sub_40AD10((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0xC;
                    goto LABEL_263;
                case 0x3C:
                    sub_40AD10((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0x10;
                    goto LABEL_263;
                case 0x3D:
                    sub_40AE80((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 4;
                    goto LABEL_263;
                case 0x3E:
                    sub_40AE80((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 8;
                    goto LABEL_263;
                case 0x3F:
                    sub_40AE80((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0xC;
                    goto LABEL_263;
                case 0x40:
                    sub_40AE80((int) a1, v177);
                    *((_BYTE*) a1 + 3664) = a1 [916] & 0xE3 | 0x10;
                    goto LABEL_263;
                case 0x41:
                    a1 [920] = *(_DWORD*) (v177 + 12);
                    a1 [921] = *(_DWORD*) (v177 + 16);
                    a1 [922] = *(_DWORD*) (v177 + 20);
                    a1 [923] = *(_DWORD*) (v177 + 24);
                    *((_BYTE*) a1 + 3666) |= 1u;
                    goto LABEL_263;
                case 0x42:
                    *((_BYTE*) a1 + 3666) &= ~1u;
                    goto LABEL_263;
                case 0x43:
                case 0x44:
                case 0x45:
                case 0x46:
                case 0x47:
                case 0x48:
                case 0x49:
                case 0x4A:
                case 0x4B:
                    v164 = v177 + 12;
                    v163 = a1 + 832;
                    *((_WORD*) a1 + 1664) = *(_WORD*) (v177 + 12);
                    *((_WORD*) v163 + 36) = *(_WORD*) (v177 + 4) - 67;
                    v10 = sub_40AFB0((float*) a1, (float*) (v164 + 4), 0);
                    *((_WORD*) v163 + 34) = *(_WORD*) v10;
                    *((_WORD*) v163 + 34) += *((_WORD*) a1 + 1646)
                        + dword_69D710 * (*((__int16*) a1 + 1647) - *((__int16*) a1 + 1646)) / 32;
                    if(*((__int16*) v163 + 34) <= 0)
                        *((_WORD*) v163 + 34) = 1;
                    v11 = sub_40AFB0((float*) a1, (float*) (v164 + 8), 0);
                    *((_WORD*) v163 + 35) = *(_WORD*) v11;
                    *((_WORD*) v163 + 35) += *((_WORD*) a1 + 1648)
                        + dword_69D710 * (*((__int16*) a1 + 1649) - *((__int16*) a1 + 1648)) / 32;
                    if(*((__int16*) v163 + 35) <= 0)
                        *((_WORD*) v163 + 35) = 1;
                    v135 = *((float*) a1 + 797) + *((float*) a1 + 810);
                    v134 = *((float*) a1 + 796) + *((float*) a1 + 809);
                    v133 = *((float*) a1 + 795) + *((float*) a1 + 808);
                    v12 = (float*) (v163 + 1);
                    *((float*) v163 + 1) = v133;
                    v12 [1] = v134;
                    v12 [2] = v135;
                    v13 = sub_40B380((float*) a1, (float*) (v164 + 20), 0);
                    v163 [4] = *v13;
                    v14 = sub_41E850(*((float*) v163 + 4), 0.0);
                    *((float*) v163 + 4) = v14;
                    v15 = sub_40B380((float*) a1, (float*) (v164 + 12), 0);
                    v163 [6] = *v15;
                    if(*((float*) v163 + 6) != 0.0) {
                        v91 = (float) dword_69D710;
                        *((float*) v163 + 6) = (*((float*) a1 + 822) - *((float*) a1 + 821)) * v91 / 32.0
                            + *((float*) a1 + 821)
                            + *((float*) v163 + 6);
                        if(*((float*) v163 + 6) < 0.30000001)
                            v163 [6] = 1050253722;
                    }
                    v16 = sub_40B380((float*) a1, (float*) (v164 + 24), 0);
                    v163 [5] = *v16;
                    v17 = sub_40B380((float*) a1, (float*) (v164 + 16), 0);
                    v163 [7] = *v17;
                    v90 = (float) dword_69D710;
                    *((float*) v163 + 7) = ((*((float*) a1 + 822) - *((float*) a1 + 821)) * v90 / 32.0 + *((float*) a1 + 821))
                        / 2.0
                        + *((float*) v163 + 7);
                    if(*((float*) v163 + 7) < 0.30000001)
                        v163 [7] = 1050253722;
                    *((_WORD*) v163 + 37) = 0;
                    v163 [19] = *(_DWORD*) (v164 + 28);
                    v180 = *(__int16*) (v164 + 2);
                    v18 = sub_40AFB0((float*) a1, (float*) &v180, 0);
                    *((_WORD*) v163 + 1) = *(_WORD*) v18;
                    if((a1 [916] & 0x20) == 0)
                        sub_4145C0(dword_5A5FF8, (int) v163);
                    goto LABEL_263;
                case 0x4C:
                    a1 [853] = *(_DWORD*) (v177 + 12);
                    a1 [853] += a1 [853] / 5 + dword_69D710 * (-a1 [853] / 5 - a1 [853] / 5) / 32;
                    a1 [856] = 0;
                    a1 [855] = 0;
                    a1 [854] = -999;
                    goto LABEL_263;
                case 0x4D:
                    a1 [853] = *(_DWORD*) (v177 + 12);
                    a1 [853] += a1 [853] / 5 + dword_69D710 * (-a1 [853] / 5 - a1 [853] / 5) / 32;
                    if(a1 [853]) {
                        v132 = a1 [853];
                        if(v132)
                            v131 = sub_41E7F0(&word_69D8F8) % v132;
                        else
                            v131 = 0;
                        a1 [856] = v131;
                        a1 [855] = 0;
                        a1 [854] = -999;
                    }
                    goto LABEL_263;
                case 0x4E:
                    *((_BYTE*) a1 + 3664) |= 0x20u;
                    goto LABEL_263;
                case 0x4F:
                    *((_BYTE*) a1 + 3664) &= ~0x20u;
                    goto LABEL_263;
                case 0x50:
                    v130 = *((float*) a1 + 797) + *((float*) a1 + 810);
                    v129 = *((float*) a1 + 796) + *((float*) a1 + 809);
                    v128 = *((float*) a1 + 795) + *((float*) a1 + 808);
                    *((float*) a1 + 833) = v128;
                    *((float*) a1 + 834) = v129;
                    *((float*) a1 + 835) = v130;
                    sub_4145C0(dword_5A5FF8, (int) (a1 + 832));
                    goto LABEL_263;
                case 0x51:
                    a1 [808] = *sub_40B380((float*) a1, v178, 0);
                    a1 [809] = *sub_40B380((float*) a1, v178 + 1, 0);
                    a1 [810] = *sub_40B380((float*) a1, v178 + 2, 0);
                    goto LABEL_263;
                case 0x52:
                    a1 [844] = *(_DWORD*) sub_40AFB0((float*) a1, v178, 0);
                    a1 [845] = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 1, 0);
                    a1 [846] = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 2, 0);
                    a1 [847] = *(_DWORD*) sub_40AFB0((float*) a1, v178 + 3, 0);
                    a1 [840] = *sub_40B380((float*) a1, v178 + 4, 0);
                    a1 [841] = *sub_40B380((float*) a1, v178 + 5, 0);
                    a1 [842] = *sub_40B380((float*) a1, v178 + 6, 0);
                    a1 [843] = *sub_40B380((float*) a1, v178 + 7, 0);
                    goto LABEL_263;
                case 0x53:
                    sub_414340((char*) dword_5A5FF8);
                    goto LABEL_263;
                case 0x54:
                    if(*(int*) (v177 + 12) < 0) {
                        v64 = a1 [851];
                        BYTE1(v64) &= ~2u;
                    }
                    else {
                        a1 [852] = *(_DWORD*) (v177 + 12);
                        v64 = a1 [851];
                        BYTE1(v64) |= 2u;
                    }
                    a1 [851] = v64;
                    goto LABEL_263;
                case 0x55:
                case 0x56:
                    v160 = v177 + 12;
                    v161 = (__int16*) (a1 + 857);
                    v127 = *((float*) a1 + 797) + *((float*) a1 + 810);
                    v126 = *((float*) a1 + 796) + *((float*) a1 + 809);
                    v125 = *((float*) a1 + 795) + *((float*) a1 + 808);
                    *((float*) a1 + 858) = v125;
                    *((float*) a1 + 859) = v126;
                    *((float*) a1 + 860) = v127;
                    *v161 = *(_WORD*) v160;
                    v161 [1] = *(_WORD*) (v160 + 2);
                    v19 = sub_40B380((float*) a1, (float*) (v160 + 4), 0);
                    *((_DWORD*) v161 + 4) = *v19;
                    v20 = sub_40B380((float*) a1, (float*) (v160 + 8), 0);
                    *((_DWORD*) v161 + 6) = *v20;
                    v21 = sub_40B380((float*) a1, (float*) (v160 + 12), 0);
                    *((_DWORD*) v161 + 8) = *v21;
                    v22 = sub_40B380((float*) a1, (float*) (v160 + 16), 0);
                    *((_DWORD*) v161 + 9) = *v22;
                    v23 = sub_40B380((float*) a1, (float*) (v160 + 20), 0);
                    *((_DWORD*) v161 + 10) = *v23;
                    *((_DWORD*) v161 + 11) = *(_DWORD*) (v160 + 24);
                    *((_DWORD*) v161 + 12) = *(_DWORD*) (v160 + 28);
                    *((_DWORD*) v161 + 13) = *(_DWORD*) (v160 + 32);
                    *((_DWORD*) v161 + 14) = *(_DWORD*) (v160 + 36);
                    *((_DWORD*) v161 + 15) = *(_DWORD*) (v160 + 40);
                    *((_DWORD*) v161 + 16) = *(_DWORD*) (v160 + 44);
                    *((_DWORD*) v161 + 19) = *(_DWORD*) (v160 + 48);
                    v161 [36] = *(_WORD*) (v177 + 4) != 86;
                    a1 [a1 [910] + 878] = sub_414670(dword_5A5FF8, v161);
                    goto LABEL_263;
                case 0x57:
                    a1 [910] = *(_DWORD*) sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    goto LABEL_263;
                case 0x58:
                    if(a1 [*(_DWORD*) (v177 + 12) + 878]) {
                        v24 = a1 [*(_DWORD*) (v177 + 12) + 878];
                        v25 = sub_40B380((float*) a1, (float*) (v177 + 16), 0);
                        *(float*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 556) = *(float*) (v24 + 556) + *(float*) v25;
                    }
                    goto LABEL_263;
                case 0x59:
                    if(a1 [*(_DWORD*) (v177 + 12) + 878]) {
                        v89 = sub_428700(flt_6CA628, (float*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 544));
                        v26 = sub_40B380((float*) a1, (float*) (v177 + 16), 0);
                        *(float*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 556) = v89 + *(float*) v26;
                    }
                    goto LABEL_263;
                case 0x5A:
                    if(a1 [*(_DWORD*) (v177 + 12) + 878]) {
                        v124 = *((float*) a1 + 797) + *(float*) (v177 + 24);
                        v123 = *((float*) a1 + 796) + *(float*) (v177 + 20);
                        v122 = *((float*) a1 + 795) + *(float*) (v177 + 16);
                        v27 = (float*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 544);
                        *v27 = v122;
                        v27 [1] = v123;
                        v27 [2] = v124;
                    }
                    goto LABEL_263;
                case 0x5B:
                    a1 [629] = !a1 [*(_DWORD*) (v177 + 12) + 878] || !*(_DWORD*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 600);
                    goto LABEL_263;
                case 0x5C:
                    if(a1 [*(_DWORD*) (v177 + 12) + 878]
                       && *(_DWORD*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 600)
                       && *(unsigned __int8*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 620) < 2u) {
                        *(_BYTE*) (a1 [*(_DWORD*) (v177 + 12) + 878] + 620) = 2;
                        v28 = (_DWORD*) a1 [*(_DWORD*) (v177 + 12) + 878];
                        v28 [153] = 0;
                        v28 [152] = 0;
                        v28 [151] = -999;
                    }
                    goto LABEL_263;
                case 0x5D:
                    sub_417BFD(
                        (int) dword_69BC30,
                        *(__int16*) (v177 + 12),
                        (char*) (dword_4760DC + 80 * *(__int16*) (v177 + 14) + 5120));
                    dword_5A5F8C = 1;
                    dword_5A5F90 = 1;
                    dword_5A5F98 = *(__int16*) (v177 + 14);
                    dword_5A5F94 = dword_476120 [dword_5A5F98];
                    sub_414340((char*) dword_5A5FF8);
                    dword_487B90 = 1;
                    dword_487B94 = 0;
                    a1 [821] = -1090519040;
                    a1 [822] = 1056964608;
                    *((_WORD*) a1 + 1646) = 0;
                    *((_WORD*) a1 + 1647) = 0;
                    *((_WORD*) a1 + 1648) = 0;
                    *((_WORD*) a1 + 1649) = 0;
                    v157 = (int) &unk_69BCD0 + 64 * dword_5A5F98;
                    v155 = 0;
                    if(!dword_69BCBC) {
                        v88 = (char*) (v177 + 16);
                        v87 = (_BYTE*) (v157 + 24);
                        do {
                            v86 = *v88;
                            *v87++ = *v88++;
                        }
                        while(v86);
                        for(i = strlen((const char*) (v157 + 24)); i > 0; v155 += *(char*) (i + v157 + 24))
                            --i;
                        if(*(unsigned __int8*) (v157 + 18) != (unsigned __int8) v155) {
                            *(_WORD*) (v157 + 62) = 0;
                            *(_WORD*) (v157 + 60) = 0;
                            *(_BYTE*) (v157 + 18) = v155;
                        }
                        *(_DWORD*) (v157 + 12) = dword_5A5F94;
                        if(*(unsigned __int16*) (v157 + 60) < 0x270Fu)
                            ++* (_WORD*) (v157 + 60);
                    }
                    goto LABEL_263;
                case 0x5E:
                    if(dword_5A5F90) {
                        sub_41732C(dword_69BC30);
                        if(dword_5A5F90 == 1) {
                            v154 = sub_414360((char*) dword_5A5FF8, 12800, 1);
                            if(dword_5A5F8C) {
                                v153 = (int) &unk_69BCD0 + 64 * dword_5A5F98;
                                if(dword_5A5F94 < 500000)
                                    v85 = dword_5A5F94 / 10;
                                else
                                    v85 = 50000;
                                v151 = v85;
                                v154 = dword_69BC48 * dword_5A5F94 / 10 + dword_5A5F94;
                                sub_417458(dword_69BC30, v154);
                                dword_69BCA4 += v154;
                                if(!dword_69BCBC) {
                                    ++* (_WORD*) (v153 + 62);
                                    for(j = 4; j > 0; --j)
                                        *(_BYTE*) (j + v153 + 19) = *(_BYTE*) (j + v153 + 18);
                                    *(_BYTE*) (v153 + 19) = byte_69D4BE + 2 * byte_69D4BD;
                                }
                                ++* (_DWORD*) dword_69BCC8;
                            }
                        }
                        dword_5A5F90 = 0;
                    }
                    dword_487B90 = 0;
                    goto LABEL_263;
                case 0x5F:
                    qmemcpy(v146, (const void*) (v177 + 12), sizeof(v146));
                    v146 [1] = *sub_40B380((float*) a1, (float*) &v146 [1], 0);
                    v146 [2] = *sub_40B380((float*) a1, (float*) &v146 [2], 0);
                    v146 [3] = *sub_40B380((float*) a1, (float*) &v146 [3], 0);
                    sub_411390((int) dword_4B79C8, v146 [0], &v146 [1], v146 [4], SBYTE2(v146 [4]), v146 [5]);
                    goto LABEL_263;
                case 0x60:
                    v145 = (char*) &unk_4B8898;
                    for(k = 0; k < 256; ++k) {
                        if(v145 [3664] < 0 && (v145 [3665] & 8) == 0) {
                            *((_DWORD*) v145 + 825) = 0;
                            if((v145 [3665] & 1) == 0 && *((int*) v145 + 785) >= 0) {
                                sub_407440(dword_487E50, (int) (v145 + 2448), *((_WORD*) v145 + 1570));
                                *((_DWORD*) v145 + 785) = -1;
                            }
                        }
                        v145 += 3784;
                    }
                    goto LABEL_263;
                case 0x61:
                    v6 = *(_DWORD*) (v177 + 12);
                    v139 = (int*) dword_6D4588;
                    *((_WORD*) a1 + 90) = v6 + 256;
                    sub_432430(v139, a1, v139 [v6 + 29517]);
                    goto LABEL_263;
                case 0x62:
                    *((_WORD*) a1 + 1834) = *(_WORD*) (v177 + 12);
                    *((_WORD*) a1 + 1835) = *(_WORD*) (v177 + 14);
                    *((_WORD*) a1 + 1836) = *(_WORD*) (v177 + 16);
                    *((_WORD*) a1 + 1837) = *(_WORD*) (v177 + 18);
                    *((_WORD*) a1 + 1838) = *(_WORD*) (v177 + 20);
                    *((_BYTE*) a1 + 3667) = -1;
                    goto LABEL_263;
                case 0x63:
                    if(*(int*) (v177 + 12) >= 8)
                        sub_41E940();
                    v138 = *((_DWORD*) v178 + 1) + 256;
                    v137 = &a1 [68 * *(_DWORD*) (v177 + 12) + 68];
                    v136 = (int*) dword_6D4588;
                    *((_WORD*) v137 + 90) = v138;
                    sub_432430(v136, v137, v136 [v138 + 29261]);
                    goto LABEL_263;
                case 0x64:
                    v162 = v177 + 12;
                    *((_BYTE*) a1 + 3644) = *(_BYTE*) (v177 + 12);
                    *((_BYTE*) a1 + 3645) = *(_BYTE*) (v162 + 1);
                    *((_BYTE*) a1 + 3646) = *(_BYTE*) (v162 + 2);
                    goto LABEL_263;
                case 0x65:
                    if(*(int*) (v177 + 12) < 0) {
                        byte_69BC50 = 0;
                        dword_5A5F60 [*((unsigned __int8*) a1 + 3648)] = 0;
                        *((_BYTE*) a1 + 3665) &= ~8u;
                    }
                    else {
                        dword_5A5F60 [*(_DWORD*) (v177 + 12)] = (int) a1;
                        byte_69BC50 = 1;
                        dword_69BC54 = 1065353216;
                        *((_BYTE*) a1 + 3665) |= 8u;
                        *((_BYTE*) a1 + 3648) = *(_BYTE*) (v177 + 12);
                    }
                    goto LABEL_263;
                case 0x66:
                    v158 = v177 + 12;
                    a1 [a1 [936] + 924] = sub_40EF50(
                        dword_487FE0,
                        13,
                        a1 + 795,
                        1,
                        *((_DWORD*) off_476438 + *(_DWORD*) (v177 + 12)));
                    v29 = v158 + 4;
                    v30 = (_DWORD*) (a1 [a1 [936] + 924] + 320);
                    *v30 = *(_DWORD*) (v158 + 4);
                    v30 [1] = *(_DWORD*) (v29 + 4);
                    v30 [2] = *(_DWORD*) (v29 + 8);
                    a1 [937] = *(_DWORD*) (v158 + 16);
                    ++a1 [936];
                    goto LABEL_263;
                case 0x67:
                    a1 [798] = *(_DWORD*) (v177 + 12);
                    a1 [799] = *(_DWORD*) (v177 + 16);
                    a1 [800] = *(_DWORD*) (v177 + 20);
                    goto LABEL_263;
                case 0x68:
                    *((_BYTE*) a1 + 3665) = (2 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3665) & 0xFD;
                    goto LABEL_263;
                case 0x69:
                    *((_BYTE*) a1 + 3665) = (16 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3665) & 0xEF;
                    goto LABEL_263;
                case 0x6A:
                    sub_4311E0(dword_6D3F50, *(int**) (v177 + 12), 0);
                    goto LABEL_263;
                case 0x6B:
                    *((_BYTE*) a1 + 3665) = (32 * (*(_BYTE*) (v177 + 12) & 7)) | *((_BYTE*) a1 + 3665) & 0x1F;
                    goto LABEL_263;
                case 0x6C:
                    a1 [785] = *(_DWORD*) (v177 + 12);
                    goto LABEL_263;
                case 0x6D:
                    a1 [*((_DWORD*) v178 + 1) + 786] = *(_DWORD*) v178;
                    goto LABEL_263;
                case 0x6E:
                    a1 [794] = *(_DWORD*) (v177 + 12);
                    goto LABEL_186;
                case 0x6F:
                    a1 [826] = *(_DWORD*) (v177 + 12);
                    a1 [825] = a1 [826];
                    goto LABEL_263;
                case 0x70:
                    a1 [830] = *(_DWORD*) (v177 + 12);
                    a1 [829] = 0;
                    a1 [828] = -999;
                    goto LABEL_263;
                case 0x71:
                    a1 [938] = *(_DWORD*) (v177 + 12);
                    goto LABEL_263;
                case 0x72:
                    a1 [939] = *(_DWORD*) (v177 + 12);
                    goto LABEL_263;
                case 0x73:
                    a1 [940] = *(_DWORD*) (v177 + 12);
                    a1 [830] = 0;
                    a1 [829] = 0;
                    a1 [828] = -999;
                    goto LABEL_263;
                case 0x74:
                    a1 [941] = *(_DWORD*) (v177 + 12);
                    goto LABEL_263;
                case 0x75:
                    *((_BYTE*) a1 + 3665) = *(_BYTE*) (v177 + 12) & 1 | *((_BYTE*) a1 + 3665) & 0xFE;
                    goto LABEL_263;
                case 0x76:
                    sub_40EF50(dword_487FE0, *(_DWORD*) (v177 + 12), a1 + 795, *(_DWORD*) (v177 + 16), *(_DWORD*) (v177 + 20));
                    goto LABEL_263;
                case 0x77:
                    for(m = 0; m < *(_DWORD*) (v177 + 12); ++m) {
                        v147 = *((float*) a1 + 795);
                        v148 = *((float*) a1 + 796);
                        v149 = a1 [797];
                        v147 = sub_41E820(&word_69D8F8) * 144.0 - 72.0 + v147;
                        v148 = sub_41E820(&word_69D8F8) * 144.0 - 72.0 + v148;
                        if((unsigned __int16) word_69D4B0 >= 0x80u) {
                            sub_41F290(byte_69E268, &v147, 1, 0);
                        }
                        else {
                            v63 = -(m != 0);
                            LOBYTE(v63) = v63 & 0xFE;
                            sub_41F290(byte_69E268, &v147, v63 + 2, 0);
                        }
                    }
                    goto LABEL_263;
                case 0x78:
                    *((_BYTE*) a1 + 3666) = (2 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3666) & 0xFD;
                    goto LABEL_263;
                case 0x79:
                    funcs_409BF3 [*(_DWORD*) (v177 + 12)]((int) a1, v177);
                    goto LABEL_263;
                case 0x7A:
                    if(*(int*) (v177 + 12) < 0)
                        a1 [616] = 0;
                    else
                        a1 [616] = funcs_409BF3 [*(_DWORD*) (v177 + 12)];
                    goto LABEL_263;
                case 0x7B:
                    v119 = *(_DWORD*) sub_40AFB0((float*) a1, (float*) (v177 + 12), 0);
                    sub_424145((float*) a1 + 613, v119);
                    goto LABEL_263;
                case 0x7C:
                    sub_41F290(byte_69E268, a1 + 795, *(_DWORD*) (v177 + 12), 0);
                    goto LABEL_263;
                case 0x7D:
                    byte_487DB8 = 1;
                    goto LABEL_263;
                case 0x7E:
                    dword_69BC44 = *(_DWORD*) (v177 + 12);
                    dword_69D70C += 1800;
                    goto LABEL_263;
                case 0x80:
                    *((_WORD*) a1 + 69) = *(_WORD*) (v177 + 12);
                    goto LABEL_263;
                case 0x81:
                    HIWORD(a1 [68 * *(_DWORD*) v178 + 102]) = *((_WORD*) v178 + 2);
                    goto LABEL_263;
                case 0x82:
                    *((_BYTE*) a1 + 3666) = (4 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3666) & 0xFB;
                    goto LABEL_263;
                case 0x83:
                    a1 [821] = *(_DWORD*) v178;
                    a1 [822] = *((_DWORD*) v178 + 1);
                    *((_WORD*) a1 + 1646) = *((_WORD*) v178 + 4);
                    *((_WORD*) a1 + 1647) = *((_WORD*) v178 + 6);
                    *((_WORD*) a1 + 1648) = *((_WORD*) v178 + 8);
                    *((_WORD*) a1 + 1649) = *((_WORD*) v178 + 10);
                    goto LABEL_263;
                case 0x84:
                    *((_BYTE*) a1 + 3666) = (8 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3666) & 0xF7;
                    goto LABEL_263;
                case 0x85:
                    a1 [941] = a1 [785];
                    a1 [830] = 0;
                    a1 [829] = 0;
                    a1 [828] = -999;
                    goto LABEL_263;
                case 0x86:
                    for(n = 0; n < 32; ++n)
                        a1 [n + 878] = 0;
                    goto LABEL_263;
                case 0x87:
                    *((_BYTE*) a1 + 3666) = (16 * (*(_BYTE*) (v177 + 12) & 1)) | *((_BYTE*) a1 + 3666) & 0xEF;
                    goto LABEL_263;
                default:
                    goto LABEL_263;
            }
            goto LABEL_1;
        }
        LABEL_263:
        v177 += *(__int16*) (v177 + 6);
    }
    v84 = a1 [916] & 3;
    if(v84 == 1) {
        v80 = flt_6C6EC0 * *((float*) a1 + 805);
        *((float*) a1 + 804) = sub_41E850(*((float*) a1 + 804), v80);
        *((float*) a1 + 806) = flt_6C6EC0 * *((float*) a1 + 807) + *((float*) a1 + 806);
        v118 = *((float*) a1 + 806);
        v117 = *((float*) a1 + 804);
        *((float*) a1 + 801) = cos(v117) * v118;
        *((float*) a1 + 802) = sin(v117) * v118;
        a1 [803] = 0;
    }
    else if(v84 == 2) {
        sub_4241E5((int) (a1 + 817), 1);
        v83 = (float) (int) a1 [820];
        v82 = (float) (int) a1 [819];
        v141 = (v82 + *((float*) a1 + 818)) / v83;
        v66 = v141 < 1.0;
        v67 = 0;
        v68 = v141 == 1.0;
        if((v65 & 0x100) == 0)
            v141 = 1.0;
        switch((*((_BYTE*) a1 + 3664) >> 2) & 7) {
            case 0:
                v141 = 1.0 - v141;
                break;
            case 1:
                v141 = 1.0 - v141 * v141;
                break;
            case 2:
                v141 = 1.0 - v141 * v141 * v141 * v141;
                break;
            case 3:
                v142 = 1.0 - v141;
                v141 = v142 * v142;
                break;
            case 4:
                v143 = 1.0 - v141;
                v141 = v143 * v143 * v143 * v143;
                break;
            default:
                break;
        }
        v116 = v141 * *((float*) a1 + 813);
        v115 = v141 * *((float*) a1 + 812);
        v114 = v141 * *((float*) a1 + 811);
        v113 = v116 + *((float*) a1 + 816);
        v112 = v115 + *((float*) a1 + 815);
        v111 = v114 + *((float*) a1 + 814);
        v110 = v113 - *((float*) a1 + 797);
        v109 = v112 - *((float*) a1 + 796);
        v108 = v111 - *((float*) a1 + 795);
        *((float*) a1 + 801) = v108;
        *((float*) a1 + 802) = v109;
        *((float*) a1 + 803) = v110;
        v69 = *((float*) a1 + 802);
        sub_45BE40(v69, *((float*) a1 + 801));
        v81 = v69;
        *((float*) a1 + 804) = v81;
        if((int) a1 [819] <= 0) {
            *((_BYTE*) a1 + 3664) &= 0xFCu;
            v107 = *((float*) a1 + 816) + *((float*) a1 + 813);
            v106 = *((float*) a1 + 815) + *((float*) a1 + 812);
            v105 = *((float*) a1 + 814) + *((float*) a1 + 811);
            *((float*) a1 + 795) = v105;
            *((float*) a1 + 796) = v106;
            *((float*) a1 + 797) = v107;
            a1 [801] = 0;
            a1 [802] = 0;
            a1 [803] = 0;
        }
    }
    if((int) a1 [825] > 0) {
        if((int) a1 [853] > 0) {
            a1 [854] = a1 [856];
            sub_424285((float*) &dword_6C6D18, a1 + 856, (float*) a1 + 855);
            if(a1 [856] >= a1 [853]) {
                v104 = *((float*) a1 + 797) + *((float*) a1 + 810);
                v103 = *((float*) a1 + 796) + *((float*) a1 + 809);
                v102 = *((float*) a1 + 795) + *((float*) a1 + 808);
                *((float*) a1 + 833) = v102;
                *((float*) a1 + 834) = v103;
                *((float*) a1 + 835) = v104;
                sub_4145C0(dword_5A5FF8, (int) (a1 + 832));
                a1 [856] = 0;
                a1 [855] = 0;
                a1 [854] = -999;
            }
        }
        if(*((__int16*) a1 + 1837) >= 0) {
            v140 = 0;
            if(*((float*) a1 + 801) >= 0.0) {
                v71 = *((float*) a1 + 801);
                v72 = v71 < 0.0;
                v73 = 0;
                v74 = v71 == 0.0;
                if((v70 & 0x4100) == 0)
                    v140 = 2;
            }
            else {
                v140 = 1;
            }
            if(*((unsigned __int8*) a1 + 3667) != v140) {
                if(v140) {
                    if(v140 == 1) {
                        v78 = *((__int16*) a1 + 1837);
                        v98 = (int*) dword_6D4588;
                        *((_WORD*) a1 + 90) = v78 + 256;
                        sub_432430(v98, a1, v98 [v78 + 29517]);
                    }
                    else {
                        v79 = *((__int16*) a1 + 1838);
                        v97 = (int*) dword_6D4588;
                        *((_WORD*) a1 + 90) = v79 + 256;
                        sub_432430(v97, a1, v97 [v79 + 29517]);
                    }
                }
                else if(*((unsigned __int8*) a1 + 3667) == 255) {
                    v75 = *((__int16*) a1 + 1834);
                    v101 = (int*) dword_6D4588;
                    *((_WORD*) a1 + 90) = v75 + 256;
                    sub_432430(v101, a1, v101 [v75 + 29517]);
                }
                else if(*((_BYTE*) a1 + 3667) == 1) {
                    v76 = *((__int16*) a1 + 1835);
                    v100 = (int*) dword_6D4588;
                    *((_WORD*) a1 + 90) = v76 + 256;
                    sub_432430(v100, a1, v100 [v76 + 29517]);
                }
                else {
                    v77 = *((__int16*) a1 + 1836);
                    v99 = (int*) dword_6D4588;
                    *((_WORD*) a1 + 90) = v77 + 256;
                    sub_432430(v99, a1, v99 [v77 + 29517]);
                }
                *((_BYTE*) a1 + 3667) = v140;
            }
        }
        if(a1 [616])
            ((void(__cdecl*)(_DWORD*, _DWORD))a1 [616])(a1, 0);
    }
    a1 [612] = v177;
    a1 [613] = a1 [615];
    sub_424285((float*) &dword_6C6D18, a1 + 615, (float*) a1 + 614);
    return 0;
}
// 40A73B: conditional instruction was optimized away because %var_BC.4==2
// 4760DC: using guessed type int dword_4760DC;
// 476120: using guessed type int dword_476120[64];
// 476220: using guessed type int (__cdecl *funcs_409BF3[17])(int, int);
// 476438: using guessed type void *off_476438;
// 487B90: using guessed type int dword_487B90;
// 487B94: using guessed type int dword_487B94;
// 487DB8: using guessed type char byte_487DB8;
// 487E50: using guessed type _DWORD dword_487E50[2];
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 4B79C8: using guessed type _DWORD dword_4B79C8[948];
// 5A5F60: using guessed type int dword_5A5F60[11];
// 5A5F8C: using guessed type int dword_5A5F8C;
// 5A5F90: using guessed type int dword_5A5F90;
// 5A5F94: using guessed type int dword_5A5F94;
// 5A5F98: using guessed type int dword_5A5F98;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BC44: using guessed type int dword_69BC44;
// 69BC48: using guessed type int dword_69BC48;
// 69BC50: using guessed type char byte_69BC50;
// 69BC54: using guessed type int dword_69BC54;
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D70C: using guessed type int dword_69D70C;
// 69D710: using guessed type int dword_69D710;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6CA628: using guessed type float flt_6CA628[272];
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0040ABE0) --------------------------------------------------------
int __cdecl sub_40ABE0(int a1, int a2) {
    int result; // eax
    float v3; // [esp+8h] [ebp-20h]
    float v4; // [esp+Ch] [ebp-1Ch]
    float v5; // [esp+10h] [ebp-18h]
    float v6; // [esp+14h] [ebp-14h]
    float v7; // [esp+20h] [ebp-8h]

    v7 = *(float*) sub_40B380((float*) a1, (float*) (a2 + 16), 0);
    v6 = cos(v7);
    v5 = (float) *(int*) (a2 + 12);
    *(float*) (a1 + 3244) = v6 * *(float*) (a2 + 20) * v5 / 2.0;
    v4 = sin(v7);
    v3 = (float) *(int*) (a2 + 12);
    *(float*) (a1 + 3248) = v4 * *(float*) (a2 + 20) * v3 / 2.0;
    *(_DWORD*) (a1 + 3252) = 0;
    *(_DWORD*) (a1 + 3256) = *(_DWORD*) (a1 + 3180);
    *(_DWORD*) (a1 + 3260) = *(_DWORD*) (a1 + 3184);
    *(_DWORD*) (a1 + 3264) = *(_DWORD*) (a1 + 3188);
    *(_DWORD*) (a1 + 3280) = *(_DWORD*) (a2 + 12);
    *(_DWORD*) (a1 + 3276) = *(_DWORD*) (a1 + 3280);
    *(_DWORD*) (a1 + 3272) = 0;
    *(_DWORD*) (a1 + 3268) = -999;
    result = a1;
    *(_BYTE*) (a1 + 3664) = *(_BYTE*) (a1 + 3664) & 0xFC | 2;
    return result;
}

//----- (0040AD10) --------------------------------------------------------
int __cdecl sub_40AD10(int a1, int a2) {
    int result; // eax
    float v3; // [esp+Ch] [ebp-34h]
    float v4; // [esp+10h] [ebp-30h]
    float v5; // [esp+14h] [ebp-2Ch]
    float v6; // [esp+30h] [ebp-10h]
    float v7; // [esp+34h] [ebp-Ch]

    v6 = *(float*) sub_40B380((float*) a1, (float*) (a2 + 16), 0);
    v7 = *(float*) sub_40B380((float*) a1, (float*) (a2 + 20), 0);
    v5 = *(float*) sub_40B380((float*) a1, (float*) (a2 + 24), 0) - *(float*) (a1 + 3188);
    v4 = v7 - *(float*) (a1 + 3184);
    v3 = v6 - *(float*) (a1 + 3180);
    *(float*) (a1 + 3244) = v3;
    *(float*) (a1 + 3248) = v4;
    *(float*) (a1 + 3252) = v5;
    *(_DWORD*) (a1 + 3256) = *(_DWORD*) (a1 + 3180);
    *(_DWORD*) (a1 + 3260) = *(_DWORD*) (a1 + 3184);
    *(_DWORD*) (a1 + 3264) = *(_DWORD*) (a1 + 3188);
    *(_DWORD*) (a1 + 3280) = *(_DWORD*) (a2 + 12);
    *(_DWORD*) (a1 + 3276) = *(_DWORD*) (a1 + 3280);
    *(_DWORD*) (a1 + 3272) = 0;
    *(_DWORD*) (a1 + 3268) = -999;
    *(_BYTE*) (a1 + 3664) = *(_BYTE*) (a1 + 3664) & 0xFC | 2;
    result = a1 + 3204;
    *(_DWORD*) (a1 + 3204) = 0;
    *(_DWORD*) (a1 + 3208) = 0;
    *(_DWORD*) (a1 + 3212) = 0;
    return result;
}

//----- (0040AE80) --------------------------------------------------------
int __cdecl sub_40AE80(int a1, int a2) {
    int result; // eax
    float v3; // [esp+8h] [ebp-20h]
    float v4; // [esp+Ch] [ebp-1Ch]
    float v5; // [esp+10h] [ebp-18h]
    float v6; // [esp+14h] [ebp-14h]
    float v7; // [esp+20h] [ebp-8h]

    v7 = *(float*) sub_40B380((float*) a1, (float*) (a1 + 3216), 0);
    v6 = cos(v7);
    v5 = (float) *(int*) (a2 + 12);
    *(float*) (a1 + 3244) = v6 * *(float*) (a1 + 3224) * v5 / 2.0;
    v4 = sin(v7);
    v3 = (float) *(int*) (a2 + 12);
    *(float*) (a1 + 3248) = v4 * *(float*) (a1 + 3224) * v3 / 2.0;
    *(_DWORD*) (a1 + 3252) = 0;
    *(_DWORD*) (a1 + 3256) = *(_DWORD*) (a1 + 3180);
    *(_DWORD*) (a1 + 3260) = *(_DWORD*) (a1 + 3184);
    *(_DWORD*) (a1 + 3264) = *(_DWORD*) (a1 + 3188);
    *(_DWORD*) (a1 + 3280) = *(_DWORD*) (a2 + 12);
    *(_DWORD*) (a1 + 3276) = *(_DWORD*) (a1 + 3280);
    *(_DWORD*) (a1 + 3272) = 0;
    *(_DWORD*) (a1 + 3268) = -999;
    result = a1;
    *(_BYTE*) (a1 + 3664) = *(_BYTE*) (a1 + 3664) & 0xFC | 2;
    return result;
}

//----- (0040AFB0) --------------------------------------------------------
float* __cdecl sub_40AFB0(float* a1, float* a2, _DWORD* a3) {
    float* result; // eax
    float v4; // [esp+Ch] [ebp-18h]
    int v5; // [esp+10h] [ebp-14h]
    int v6; // [esp+14h] [ebp-10h]
    int v7 [3]; // [esp+18h] [ebp-Ch] BYREF

    if(a3)
        *a3 = 3;
    switch(*(_DWORD*) a2) {
        case 0xFFFFD8D7:
            dword_487E44 = (unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD;
            if(a3)
                *a3 = 0;
            result = (float*) &dword_487E44;
            break;
        case 0xFFFFD8D8:
            if(a3)
                *a3 = 0;
            result = a1 + 825;
            break;
        case 0xFFFFD8D9:
            *(float*) &v6 = flt_6CAA70 - a1 [797];
            *(float*) &v5 = flt_6CAA6C - a1 [796];
            v4 = flt_6CAA68 - a1 [795];
            *(float*) v7 = v4;
            v7 [1] = v5;
            v7 [2] = v6;
            flt_487E48 = sub_40B890((float*) v7);
            if(a3)
                *a3 = 2;
            result = &flt_487E48;
            break;
        case 0xFFFFD8DA:
            if(a3)
                *a3 = 0;
            result = a1 + 830;
            break;
        case 0xFFFFD8DB:
            flt_487E4C = sub_428700(flt_6CA628, a1 + 795);
            if(a3)
                *a3 = 2;
            result = &flt_487E4C;
            break;
        case 0xFFFFD8DC:
            if(a3)
                *a3 = 2;
            result = &flt_6CAA70;
            break;
        case 0xFFFFD8DD:
            if(a3)
                *a3 = 2;
            result = &flt_6CAA6C;
            break;
        case 0xFFFFD8DE:
            if(a3)
                *a3 = 2;
            result = &flt_6CAA68;
            break;
        case 0xFFFFD8DF:
            if(a3)
                *a3 = 1;
            result = a1 + 797;
            break;
        case 0xFFFFD8E0:
            if(a3)
                *a3 = 1;
            result = a1 + 796;
            break;
        case 0xFFFFD8E1:
            if(a3)
                *a3 = 1;
            result = a1 + 795;
            break;
        case 0xFFFFD8E2:
            if(a3)
                *a3 = 2;
            result = (float*) &dword_69D710;
            break;
        case 0xFFFFD8E3:
            if(a3)
                *a3 = 2;
            result = (float*) &dword_69BCB0;
            break;
        case 0xFFFFD8E4:
            if(a3)
                *a3 = 0;
            result = a1 + 628;
            break;
        case 0xFFFFD8E5:
            if(a3)
                *a3 = 0;
            result = a1 + 627;
            break;
        case 0xFFFFD8E6:
            if(a3)
                *a3 = 0;
            result = a1 + 626;
            break;
        case 0xFFFFD8E7:
            if(a3)
                *a3 = 0;
            result = a1 + 625;
            break;
        case 0xFFFFD8E8:
            if(a3)
                *a3 = 1;
            result = a1 + 624;
            break;
        case 0xFFFFD8E9:
            if(a3)
                *a3 = 1;
            result = a1 + 623;
            break;
        case 0xFFFFD8EA:
            if(a3)
                *a3 = 1;
            result = a1 + 622;
            break;
        case 0xFFFFD8EB:
            if(a3)
                *a3 = 1;
            result = a1 + 621;
            break;
        case 0xFFFFD8EC:
            if(a3)
                *a3 = 0;
            result = a1 + 620;
            break;
        case 0xFFFFD8ED:
            if(a3)
                *a3 = 0;
            result = a1 + 619;
            break;
        case 0xFFFFD8EE:
            if(a3)
                *a3 = 0;
            result = a1 + 618;
            break;
        case 0xFFFFD8EF:
            if(a3)
                *a3 = 0;
            result = a1 + 617;
            break;
        default:
            result = a2;
            break;
    }
    return result;
}
// 487E44: using guessed type int dword_487E44;
// 487E48: using guessed type float flt_487E48;
// 487E4C: using guessed type float flt_487E4C;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D710: using guessed type int dword_69D710;
// 6CA628: using guessed type float flt_6CA628[272];
// 6CAA68: using guessed type float flt_6CAA68;
// 6CAA6C: using guessed type float flt_6CAA6C;
// 6CAA70: using guessed type float flt_6CAA70;

//----- (0040B380) --------------------------------------------------------
int* __cdecl sub_40B380(float* a1, float* a2, _DWORD* a3) {
    int v4; // [esp+0h] [ebp-8h] BYREF
    int* v5; // [esp+4h] [ebp-4h]

    v4 = (unsigned __int64) *a2;
    v5 = (int*) sub_40AFB0(a1, (float*) &v4, a3);
    if(v5 == &v4)
        return (int*) a2;
    else
        return v5;
}

//----- (0040B3C0) --------------------------------------------------------
float* __cdecl sub_40B3C0(float* a1, float a2, float* a3) {
    float* result; // eax
    int v4; // [esp+0h] [ebp-Ch] BYREF
    float* v5; // [esp+4h] [ebp-8h]
    float* v6; // [esp+8h] [ebp-4h]

    v5 = sub_40AFB0(a1, a3, 0);
    result = sub_40AFB0(a1, &a2, &v4);
    v6 = result;
    if(v4) {
        if(v4 == 1) {
            result = v5;
            *v6 = *v5;
        }
    }
    else {
        result = v5;
        *v6 = *v5;
    }
    return result;
}

//----- (0040B420) --------------------------------------------------------
float* __cdecl sub_40B420(float* a1, float a2, float* a3, float* a4) {
    float* result; // eax
    int v5; // [esp+0h] [ebp-10h] BYREF
    float* v6; // [esp+4h] [ebp-Ch]
    int* v7; // [esp+8h] [ebp-8h]
    float* v8; // [esp+Ch] [ebp-4h]

    result = sub_40AFB0(a1, &a2, &v5);
    v8 = result;
    if(v5) {
        if(v5 == 1) {
            v6 = (float*) sub_40B380(a1, a3, 0);
            v7 = sub_40B380(a1, a4, 0);
            result = v6;
            *v8 = *v6 + *(float*) v7;
        }
    }
    else {
        v6 = sub_40AFB0(a1, a3, 0);
        result = sub_40AFB0(a1, a4, 0);
        v7 = (int*) result;
        *(_DWORD*) v8 = *(_DWORD*) result + *(_DWORD*) v6;
    }
    return result;
}

//----- (0040B4D0) --------------------------------------------------------
float* __cdecl sub_40B4D0(float* a1, float a2, float* a3, float* a4) {
    float* result; // eax
    int v5; // [esp+0h] [ebp-10h] BYREF
    float* v6; // [esp+4h] [ebp-Ch]
    float* v7; // [esp+8h] [ebp-8h]
    float* v8; // [esp+Ch] [ebp-4h]

    result = sub_40AFB0(a1, &a2, &v5);
    v8 = result;
    if(v5) {
        if(v5 == 1) {
            v6 = (float*) sub_40B380(a1, a3, 0);
            v7 = (float*) sub_40B380(a1, a4, 0);
            result = v6;
            *v8 = *v6 - *v7;
        }
    }
    else {
        v6 = sub_40AFB0(a1, a3, 0);
        v7 = sub_40AFB0(a1, a4, 0);
        result = (float*) (*(_DWORD*) v6 - *(_DWORD*) v7);
        *(_DWORD*) v8 = result;
    }
    return result;
}

//----- (0040B580) --------------------------------------------------------
float* __cdecl sub_40B580(float* a1, float a2, float* a3, float* a4) {
    float* result; // eax
    int v5; // [esp+0h] [ebp-10h] BYREF
    float* v6; // [esp+4h] [ebp-Ch]
    float* v7; // [esp+8h] [ebp-8h]
    float* v8; // [esp+Ch] [ebp-4h]

    v6 = sub_40AFB0(a1, a3, 0);
    v7 = sub_40AFB0(a1, a4, 0);
    result = sub_40AFB0(a1, &a2, &v5);
    v8 = result;
    if(v5) {
        if(v5 == 1) {
            v6 = (float*) sub_40B380(a1, a3, 0);
            v7 = (float*) sub_40B380(a1, a4, 0);
            result = v8;
            *v8 = *v6 * *v7;
        }
    }
    else {
        v6 = sub_40AFB0(a1, a3, 0);
        result = sub_40AFB0(a1, a4, 0);
        v7 = result;
        *(_DWORD*) v8 = *(_DWORD*) result * *(_DWORD*) v6;
    }
    return result;
}

//----- (0040B650) --------------------------------------------------------
float* __cdecl sub_40B650(float* a1, float a2, float* a3, float* a4) {
    float* result; // eax
    int v5; // [esp+4h] [ebp-10h] BYREF
    float* v6; // [esp+8h] [ebp-Ch]
    float* v7; // [esp+Ch] [ebp-8h]
    float* v8; // [esp+10h] [ebp-4h]

    result = sub_40AFB0(a1, &a2, &v5);
    v8 = result;
    if(v5) {
        if(v5 == 1) {
            v6 = (float*) sub_40B380(a1, a3, 0);
            v7 = (float*) sub_40B380(a1, a4, 0);
            result = v8;
            *v8 = *v6 / *v7;
        }
    }
    else {
        v6 = sub_40AFB0(a1, a3, 0);
        v7 = sub_40AFB0(a1, a4, 0);
        result = (float*) (*(_DWORD*) v6 / *(_DWORD*) v7);
        *(_DWORD*) v8 = result;
    }
    return result;
}

//----- (0040B700) --------------------------------------------------------
float* __cdecl sub_40B700(float* a1, float a2, float* a3, float* a4) {
    float* result; // eax
    float v5; // [esp+14h] [ebp-1Ch]
    int v6; // [esp+20h] [ebp-10h] BYREF
    float* v7; // [esp+24h] [ebp-Ch]
    float* v8; // [esp+28h] [ebp-8h]
    float* v9; // [esp+2Ch] [ebp-4h]

    result = sub_40AFB0(a1, &a2, &v6);
    v9 = result;
    if(v6) {
        if(v6 == 1) {
            v7 = (float*) sub_40B380(a1, a3, 0);
            v8 = (float*) sub_40B380(a1, a4, 0);
            v5 = fmod(*v7, *v8);
            result = v9;
            *v9 = v5;
        }
    }
    else {
        v7 = sub_40AFB0(a1, a3, 0);
        v8 = sub_40AFB0(a1, a4, 0);
        result = v9;
        *(_DWORD*) v9 = *(_DWORD*) v7 % *(_DWORD*) v8;
    }
    return result;
}

//----- (0040B7D0) --------------------------------------------------------
float* __cdecl sub_40B7D0(float* a1, float a2, float* a3, float* a4, float* a5, float* a6) {
    float* result; // eax
    float v7; // [esp+14h] [ebp-20h]
    float v8; // [esp+18h] [ebp-1Ch]
    int* v9; // [esp+1Ch] [ebp-18h]
    int v10; // [esp+20h] [ebp-14h] BYREF
    int* v11; // [esp+24h] [ebp-10h]
    int* v12; // [esp+28h] [ebp-Ch]
    float* v13; // [esp+2Ch] [ebp-8h]
    int* v14; // [esp+30h] [ebp-4h]

    result = sub_40AFB0(a1, &a2, &v10);
    v13 = result;
    if(v10 == 1) {
        v11 = sub_40B380(a1, a3, 0);
        v12 = sub_40B380(a1, a4, 0);
        v14 = sub_40B380(a1, a5, 0);
        v9 = sub_40B380(a1, a6, 0);
        v8 = *(float*) v14 - *(float*) v11;
        v7 = *(float*) v9 - *(float*) v12;
        sub_45BE40(v7, v8);
        result = v13;
        *v13 = v7;
    }
    return result;
}

//----- (0040B890) --------------------------------------------------------
double __cdecl sub_40B890(float* a1) {
    float v3; // [esp+Ch] [ebp-4h]

    v3 = a1 [2] * a1 [2] + a1 [1] * a1 [1] + *a1 * *a1;
    return (float) sqrt(v3);
}

//----- (0040B8E0) --------------------------------------------------------
_DWORD* __cdecl sub_40B8E0(int a1, int a2) {
    _DWORD* result; // eax
    float v3; // [esp+8h] [ebp-24h]
    int v4; // [esp+20h] [ebp-Ch]
    __int16* v5; // [esp+24h] [ebp-8h]
    int i; // [esp+28h] [ebp-4h]

    v5 = (__int16*) &unk_5AB5F8;
    v4 = *(_DWORD*) (a2 + 16);
    result = sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 3180), 1, -1);
    for(i = 0; i < 640; ++i) {
        if(v5 [735] && v5 [735] != 5) {
            v5 [733] = 15;
            sub_4323A0((int*) dword_6D4588, (int) v5, v5 [733] + v5 [89]);
            if(v4) {
                if(v4 == 1) {
                    v5 [732] |= 0x10u;
                    *((_DWORD*) v5 + 362) = 220;
                    *((_DWORD*) v5 + 361) = 0;
                    *((_DWORD*) v5 + 360) = 0;
                    *((_DWORD*) v5 + 359) = -999;
                    v3 = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
                    *((float*) v5 + 350) = cos(v3) * 0.0099999998;
                    *((float*) v5 + 351) = sin(v3) * 0.0099999998;
                }
            }
            else {
                *((_DWORD*) v5 + 353) = 0;
                *((_DWORD*) v5 + 347) = 0;
                *((_DWORD*) v5 + 348) = 0;
                *((_DWORD*) v5 + 349) = 0;
            }
        }
        result = (_DWORD*) (i + 1);
        v5 += 738;
    }
    return result;
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040BA80) --------------------------------------------------------
int __cdecl sub_40BA80(float* a1, int a2) {
    float v3; // [esp+8h] [ebp-1Ch]
    float v4; // [esp+Ch] [ebp-18h]
    float v5; // [esp+10h] [ebp-14h]
    float v6; // [esp+20h] [ebp-4h]
    float v7; // [esp+20h] [ebp-4h]

    v6 = (float) *(int*) (a2 + 16);
    v5 = a1 [797] + a1 [810];
    v4 = a1 [796] + a1 [809];
    v3 = a1 [795] + a1 [808];
    a1 [833] = v3;
    a1 [834] = v4;
    a1 [835] = v5;
    a1 [833] = sub_41E820(&word_69D8F8) * v6 + a1 [795] - v6 / 2.0;
    v7 = v6 * 0.75;
    a1 [834] = sub_41E820(&word_69D8F8) * v7 + a1 [796] - v7 / 2.0;
    return sub_4145C0(dword_5A5FF8, (int) (a1 + 832));
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040BB80) --------------------------------------------------------
int __cdecl sub_40BB80(int a1) {
    int result; // eax
    float v2; // [esp+0h] [ebp-108h]
    float v3; // [esp+8h] [ebp-100h]
    float v4; // [esp+Ch] [ebp-FCh]
    float v5; // [esp+10h] [ebp-F8h]
    float v6; // [esp+14h] [ebp-F4h]
    float v7; // [esp+18h] [ebp-F0h]
    float v8; // [esp+1Ch] [ebp-ECh]
    float v9; // [esp+20h] [ebp-E8h]
    float v10; // [esp+24h] [ebp-E4h]
    float v11; // [esp+2Ch] [ebp-DCh]
    float v12; // [esp+30h] [ebp-D8h]
    float v13; // [esp+38h] [ebp-D0h]
    float v14; // [esp+3Ch] [ebp-CCh]
    float v15; // [esp+48h] [ebp-C0h]
    float v16; // [esp+54h] [ebp-B4h]
    float v17; // [esp+58h] [ebp-B0h]
    float v18; // [esp+5Ch] [ebp-ACh]
    float v19; // [esp+60h] [ebp-A8h]
    float v20; // [esp+68h] [ebp-A0h]
    float v21; // [esp+6Ch] [ebp-9Ch]
    float v22; // [esp+74h] [ebp-94h]
    float v23; // [esp+78h] [ebp-90h]
    float v24; // [esp+E0h] [ebp-28h]
    float v25; // [esp+E0h] [ebp-28h]
    float v26; // [esp+E4h] [ebp-24h]
    float v27; // [esp+E8h] [ebp-20h]
    float v28; // [esp+F0h] [ebp-18h]
    float v29; // [esp+F0h] [ebp-18h]
    float v30; // [esp+F4h] [ebp-14h]
    float v31; // [esp+F8h] [ebp-10h]
    float v32; // [esp+100h] [ebp-8h]
    int i; // [esp+104h] [ebp-4h]

    if(*(_DWORD*) (a1 + 2476) < *(_DWORD*) (a1 + 2480)) {
        if(!*(_DWORD*) (a1 + 2476)) {
            dword_487F5C = *(_DWORD*) (a1 + 3180);
            dword_487F60 = *(_DWORD*) (a1 + 3184);
            dword_487F64 = *(_DWORD*) (a1 + 3188);
            dword_487F68 = LODWORD(flt_6CAA68);
            dword_487F6C = LODWORD(flt_6CAA6C);
            dword_487F70 = LODWORD(flt_6CAA70);
            flt_487EDC = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
            flt_487EE0 = sub_41E850(flt_487EDC, 2.5132742);
        }
        if(!(*(_DWORD*) (a1 + 2476) % 30)) {
            flt_487EDC = flt_487EE0;
            flt_487EE0 = sub_41E850(flt_487EE0, 2.5132742);
            flt_487EE4 = sub_41E850(flt_487EE0, 2.5132742);
            flt_487EE8 = sub_41E850(flt_487EE4, 2.5132742);
            flt_487EEC = sub_41E850(flt_487EE8, 2.5132742);
            flt_487EF0 = sub_41E850(flt_487EEC, 2.5132742);
        }
        if(!(*(_DWORD*) (a1 + 2476) % 6)) {
            v4 = (float) *(int*) (a1 + 2476);
            v3 = (float) *(int*) (a1 + 2480);
            v24 = v4 / v3;
            v28 = v24 * 0.1;
            v23 = *(float*) &dword_487F6C - *(float*) &dword_487F60;
            v22 = *(float*) &dword_487F68 - *(float*) &dword_487F5C;
            v21 = v23 * v28;
            v20 = v22 * v28;
            v19 = v21 + *(float*) &dword_487F60;
            v18 = v20 + *(float*) &dword_487F5C;
            v25 = v24 + 0.5;
            *(float*) (a1 + 3344) = 1.0471976 * v25;
            for(i = 0; i < 5; ++i) {
                v2 = (float) (*(_DWORD*) (a1 + 2476) % 30);
                v29 = v2 / 30.0;
                v17 = *(float*) (a1 + 2496);
                v16 = *(&flt_487EDC + i);
                v26 = cos(v16) * v17;
                v27 = sin(v16) * v17;
                v15 = *(&flt_487EE0 + i);
                v30 = cos(v15) * v17;
                v31 = sin(v15) * v17;
                v14 = v31 - v27;
                v13 = v30 - v26;
                v12 = v14 * v29;
                v11 = v13 * v29;
                v10 = v12 + v27;
                v9 = v11 + v26;
                v8 = 0.0 + 0.0;
                v7 = v19 + v10;
                v6 = v18 + v9;
                *(float*) (a1 + 3332) = v6;
                *(float*) (a1 + 3336) = v7;
                *(float*) (a1 + 3340) = v8;
                v32 = *(float*) (a1 + 3352);
                v5 = *(float*) (a1 + 3356);
                *(float*) (a1 + 3352) = sub_41E820(&word_69D8F8) * v5 + v32;
                sub_4145C0(dword_5A5FF8, a1 + 3328);
                *(float*) (a1 + 3352) = v32;
                *(float*) (a1 + 3344) = *(float*) (a1 + 3344) - 0.52359879 * v25;
            }
            sub_4311E0(dword_6D3F50, (int*) 0x16, 0);
        }
        result = a1;
        ++* (_DWORD*) (a1 + 2476);
    }
    else {
        result = a1;
        *(_DWORD*) (a1 + 2464) = 0;
    }
    return result;
}
// 487EF0: using guessed type float flt_487EF0;
// 487F5C: using guessed type int dword_487F5C;
// 487F60: using guessed type int dword_487F60;
// 487F64: using guessed type int dword_487F64;
// 487F68: using guessed type int dword_487F68;
// 487F6C: using guessed type int dword_487F6C;
// 487F70: using guessed type int dword_487F70;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6CAA68: using guessed type float flt_6CAA68;
// 6CAA6C: using guessed type float flt_6CAA6C;
// 6CAA70: using guessed type float flt_6CAA70;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0040C100) --------------------------------------------------------
int __cdecl sub_40C100(_DWORD* a1) {
    int result; // eax

    a1 [618] = dword_476264 [6 * (unsigned __int8) byte_69D4BD + 3 * (unsigned __int8) byte_69D4BE];
    a1 [619] = dword_476268 [6 * (unsigned __int8) byte_69D4BD + 3 * (unsigned __int8) byte_69D4BE];
    result = 3 * (unsigned __int8) byte_69D4BE;
    a1 [620] = dword_47626C [6 * (unsigned __int8) byte_69D4BD + result];
    return result * 4;
}
// 476264: using guessed type int dword_476264[];
// 476268: using guessed type int dword_476268[];
// 47626C: using guessed type int dword_47626C[11];
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;

//----- (0040C180) --------------------------------------------------------
int __cdecl sub_40C180(int a1, int a2) {
    __int16 v2; // fps
    double v3; // st7
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    __int16 v7; // fps
    bool v8; // c0
    char v9; // c2
    bool v10; // c3
    __int16 v11; // fps
    double v12; // st7
    bool v13; // c0
    char v14; // c2
    bool v15; // c3
    __int16 v16; // fps
    bool v17; // c0
    char v18; // c2
    bool v19; // c3
    int result; // eax
    float v21; // [esp+8h] [ebp-3Ch]
    float v22; // [esp+Ch] [ebp-38h]
    float v23; // [esp+14h] [ebp-30h]
    float v24; // [esp+18h] [ebp-2Ch]
    float v25; // [esp+1Ch] [ebp-28h]
    float v26; // [esp+24h] [ebp-20h]
    float v27; // [esp+28h] [ebp-1Ch]
    float v28; // [esp+2Ch] [ebp-18h]
    __int16* v29; // [esp+30h] [ebp-14h]
    int j; // [esp+34h] [ebp-10h]
    int i; // [esp+34h] [ebp-10h]
    int v32; // [esp+38h] [ebp-Ch]
    int v33; // [esp+38h] [ebp-Ch]
    float v34; // [esp+3Ch] [ebp-8h]
    float v35; // [esp+3Ch] [ebp-8h]
    float v36; // [esp+40h] [ebp-4h]
    float v37; // [esp+40h] [ebp-4h]

    if(*(int*) (a2 + 16) >= 2) {
        v32 = 14;
        v29 = (__int16*) &unk_5AB5F8;
        if(dword_69BCB0 > 1) {
            v33 = 52;
            for(i = 0; i < 640; ++i) {
                if(v29 [735]) {
                    if(v29 [735] != 5) {
                        if(*((_DWORD*) v29 + 48)) {
                            v12 = *(float*) (*((_DWORD*) v29 + 48) + 44);
                            v13 = v12 < 30.0;
                            v14 = 0;
                            v15 = v12 == 30.0;
                            if((v11 & 0x100) == 0 && v29 [733] != 5 && (sub_41E780(&word_69D8F8) & 3) == 0) {
                                v29 [733] = 5;
                                sub_4323A0((int*) dword_6D4588, (int) v29, v29 [733] + v29 [89]);
                                v35 = *((float*) v29 + 344) - flt_6CAA68;
                                v37 = *((float*) v29 + 345) - flt_6CAA6C;
                                v21 = sqrt(v37 * v37 + v35 * v35);
                                v17 = v21 < 128.0;
                                v18 = 0;
                                v19 = v21 == 128.0;
                                if((v16 & 0x4100) != 0) {
                                    v25 = sub_41E820(&word_69D8F8) * 6.2831855;
                                    *((float*) v29 + 356) = sub_428680(flt_6CA628, (float*) v29 + 344) + 1.5707964 + v25;
                                }
                                else {
                                    *((float*) v29 + 356) = sub_41E820(&word_69D8F8) * 6.2831855;
                                }
                                v24 = *((float*) v29 + 353);
                                v23 = *((float*) v29 + 356);
                                *((float*) v29 + 347) = cos(v23) * v24;
                                *((float*) v29 + 348) = sin(v23) * v24;
                                if(!--v33)
                                    break;
                            }
                        }
                    }
                }
                v29 += 738;
            }
        }
        else {
            for(j = 0; j < 640; ++j) {
                if(v29 [735]) {
                    if(v29 [735] != 5) {
                        if(*((_DWORD*) v29 + 48)) {
                            v3 = *(float*) (*((_DWORD*) v29 + 48) + 44);
                            v4 = v3 < 30.0;
                            v5 = 0;
                            v6 = v3 == 30.0;
                            if((v2 & 0x100) == 0 && v29 [733] != 5 && (sub_41E780(&word_69D8F8) & 3) == 0) {
                                v29 [733] = 5;
                                sub_4323A0((int*) dword_6D4588, (int) v29, v29 [733] + v29 [89]);
                                v34 = *((float*) v29 + 344) - flt_6CAA68;
                                v36 = *((float*) v29 + 345) - flt_6CAA6C;
                                v22 = sqrt(v36 * v36 + v34 * v34);
                                v8 = v22 < 128.0;
                                v9 = 0;
                                v10 = v22 == 128.0;
                                if((v7 & 0x4100) != 0) {
                                    v28 = sub_41E820(&word_69D8F8) * 6.2831855;
                                    *((float*) v29 + 356) = sub_428680(flt_6CA628, (float*) v29 + 344) + 1.5707964 + v28;
                                }
                                else {
                                    *((float*) v29 + 356) = sub_41E820(&word_69D8F8) * 2.3561945 + 0.78539819;
                                }
                                v27 = *((float*) v29 + 353);
                                v26 = *((float*) v29 + 356);
                                *((float*) v29 + 347) = cos(v26) * v27;
                                *((float*) v29 + 348) = sin(v26) * v27;
                                if(!--v32)
                                    break;
                            }
                        }
                    }
                }
                v29 += 738;
            }
        }
    }
    else {
        sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 3180), 1, -1);
        byte_69BCCC = *(_BYTE*) (a2 + 16);
    }
    result = a1;
    *(_DWORD*) (a1 + 2476) = 0;
    return result;
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCCC: using guessed type char byte_69BCCC;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6CA628: using guessed type float flt_6CA628[272];
// 6CAA68: using guessed type float flt_6CAA68;
// 6CAA6C: using guessed type float flt_6CAA6C;

//----- (0040C5B0) --------------------------------------------------------
int __cdecl sub_40C5B0(int a1) {
    int result; // eax
    float v2; // [esp+Ch] [ebp-12Ch]
    float v3; // [esp+10h] [ebp-128h]
    float v4; // [esp+14h] [ebp-124h]
    float v5; // [esp+18h] [ebp-120h]
    float v6; // [esp+1Ch] [ebp-11Ch]
    int v7; // [esp+20h] [ebp-118h]
    int v8; // [esp+24h] [ebp-114h]
    int v9; // [esp+28h] [ebp-110h]
    float v10; // [esp+30h] [ebp-108h]
    float v11; // [esp+34h] [ebp-104h]
    float v12; // [esp+38h] [ebp-100h]
    float v13; // [esp+3Ch] [ebp-FCh]
    float v14; // [esp+40h] [ebp-F8h]
    float v15; // [esp+44h] [ebp-F4h]
    float v16; // [esp+48h] [ebp-F0h]
    float v17; // [esp+4Ch] [ebp-ECh]
    float v18; // [esp+50h] [ebp-E8h]
    float v19; // [esp+58h] [ebp-E0h]
    float v20; // [esp+5Ch] [ebp-DCh]
    float v21; // [esp+60h] [ebp-D8h]
    float v22; // [esp+A0h] [ebp-98h] BYREF
    float v23; // [esp+A4h] [ebp-94h]
    float v24; // [esp+A8h] [ebp-90h]
    float v25; // [esp+ACh] [ebp-8Ch]
    float v26; // [esp+B0h] [ebp-88h]
    float v27; // [esp+B4h] [ebp-84h]
    float v28; // [esp+B8h] [ebp-80h] BYREF
    float v29; // [esp+BCh] [ebp-7Ch]
    float v30; // [esp+C0h] [ebp-78h]
    float v31; // [esp+C4h] [ebp-74h]
    float v32; // [esp+C8h] [ebp-70h]
    float v33; // [esp+CCh] [ebp-6Ch]
    float v34; // [esp+D0h] [ebp-68h]
    float v35; // [esp+D4h] [ebp-64h]
    int v36 [22]; // [esp+D8h] [ebp-60h] BYREF
    int v37; // [esp+130h] [ebp-8h]
    int v38; // [esp+134h] [ebp-4h]

    if(!(*(_DWORD*) (a1 + 2476) % 9)) {
        memset(v36, 0, 0x54u);
        v38 = *(_DWORD*) (a1 + 2476) / 9;
        LOWORD(v36 [0]) = 8;
        LOWORD(v36 [18]) = 0;
        if(dword_69BCB0 > 1)
            LOWORD(v36 [17]) = 3;
        else
            LOWORD(v36 [17]) = 1;
        HIWORD(v36 [17]) = 1;
        v36 [5] = 1057360530;
        HIWORD(v36 [18]) = 0;
        v36 [19] = 0;
        v6 = (float) v38;
        v31 = 0.5 - v6 * 0.5 / 9.0;
        v21 = flt_6CAA70 - *(float*) (a1 + 3188);
        v20 = flt_6CAA6C - *(float*) (a1 + 3184);
        v19 = flt_6CAA68 - *(float*) (a1 + 3180);
        v22 = v19;
        v23 = v20;
        v24 = v21;
        sub_43F0CE(&v28, &v22);
        if((v38 & 1) != 0)
            v25 = -256.0;
        else
            v25 = 256.0;
        v28 = v28 * v25;
        v29 = v29 * v25;
        v30 = v30 * v25;
        v22 = v22 * v31;
        v23 = v23 * v31;
        v24 = v24 * v31;
        v18 = v24 + v30;
        v17 = v23 + v29;
        v16 = v22 + v28;
        v32 = v16;
        v33 = v17;
        v34 = v18;
        v15 = -v30;
        v14 = -v29;
        v13 = -v28;
        v28 = v13;
        v29 = v14;
        v30 = v15;
        v31 = 0.78539819;
        v5 = cos(0.78539819);
        v26 = v5;
        v4 = sin(v31);
        v35 = v4;
        v22 = v28;
        v23 = v29;
        v24 = v30;
        v28 = v28 * v26 + v29 * v4;
        v29 = -v22 * v4 + v29 * v26;
        v31 = -0.17453294;
        v3 = cos(-0.17453294);
        v26 = v3;
        v2 = sin(v31);
        v35 = v2;
        v36 [4] = 0;
        v27 = -0.78539819;
        v37 = 0;
        while(v37 < 9) {
            v22 = v28;
            v23 = v29;
            v24 = v30;
            v28 = v28 * v26 + v29 * v35;
            v29 = -v22 * v35 + v29 * v26;
            v12 = v30 + *(float*) (a1 + 3188);
            v11 = v29 + *(float*) (a1 + 3184);
            v10 = v28 + *(float*) (a1 + 3180);
            *(float*) &v9 = v12 + v34;
            *(float*) &v8 = v11 + v33;
            *(float*) &v7 = v10 + v32;
            v36 [1] = v7;
            v36 [2] = v8;
            v36 [3] = v9;
            v36 [6] = 0x40000000;
            if((v38 & 1) != 0 && dword_69BCB0 <= 1)
                *(float*) &v36 [4] = v27;
            HIWORD(v36 [0]) = 3;
            sub_4145C0(dword_5A5FF8, (int) v36);
            ++v37;
            v27 = v27 + 0.17453294;
        }
        sub_4311E0(dword_6D3F50, (int*) 7, 0);
    }
    result = *(_DWORD*) (a1 + 2476) + 1;
    *(_DWORD*) (a1 + 2476) = result;
    return result;
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BCB0: using guessed type int dword_69BCB0;
// 6CAA68: using guessed type float flt_6CAA68;
// 6CAA6C: using guessed type float flt_6CAA6C;
// 6CAA70: using guessed type float flt_6CAA70;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0040CAF0) --------------------------------------------------------
void __cdecl sub_40CAF0(int a1) {
    __int16 v1; // fps
    double v2; // st7
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    double v6; // st7
    float* v7; // eax
    double v8; // st7
    float* v9; // edx
    float v10; // [esp+8h] [ebp-BCh]
    float v11; // [esp+Ch] [ebp-B8h]
    float v12; // [esp+10h] [ebp-B4h]
    float v13; // [esp+14h] [ebp-B0h]
    float v14; // [esp+18h] [ebp-ACh]
    float v15; // [esp+1Ch] [ebp-A8h]
    float v16; // [esp+24h] [ebp-A0h]
    int v17; // [esp+28h] [ebp-9Ch]
    float v18; // [esp+30h] [ebp-94h]
    float v19; // [esp+34h] [ebp-90h]
    float v20; // [esp+38h] [ebp-8Ch]
    float v21; // [esp+44h] [ebp-80h]
    float v22; // [esp+48h] [ebp-7Ch]
    float v23; // [esp+4Ch] [ebp-78h]
    float v24; // [esp+50h] [ebp-74h]
    float v25; // [esp+54h] [ebp-70h]
    float v26; // [esp+58h] [ebp-6Ch]
    float v27; // [esp+5Ch] [ebp-68h]
    float v28; // [esp+64h] [ebp-60h]
    float v29; // [esp+68h] [ebp-5Ch]
    float v30; // [esp+6Ch] [ebp-58h]
    unsigned __int16 v31; // [esp+72h] [ebp-52h]
    float v32; // [esp+A8h] [ebp-1Ch] BYREF
    float v33; // [esp+ACh] [ebp-18h]
    int v34; // [esp+B0h] [ebp-14h]
    float v35; // [esp+B4h] [ebp-10h]
    float v36; // [esp+B8h] [ebp-Ch]
    int v37; // [esp+BCh] [ebp-8h]
    float* v38; // [esp+C0h] [ebp-4h]

    if((*(_BYTE*) (a1 + 3666) & 8) != 0) {
        sub_4114C0(a1);
    }
    else {
        *(float*) (a1 + 3768) = *(float*) (a1 + 3768) + 0.017453292;
        v2 = *(float*) (a1 + 3768);
        v3 = v2 < 0.78539819;
        v4 = 0;
        v5 = v2 == 0.78539819;
        if((v1 & 0x100) == 0)
            *(float*) (a1 + 3768) = *(float*) (a1 + 3768) - 1.5707964;
        if(*(_DWORD*) (a1 + 3780) != *(_DWORD*) (a1 + 3772)
           && (*(int*) (a1 + 3780) > 120
           || *(int*) (a1 + 3780) > 60 && !(*(_DWORD*) (a1 + 3780) % 2)
           || *(int*) (a1 + 3780) > 30 && !(*(_DWORD*) (a1 + 3780) % 4)
           || !(*(_DWORD*) (a1 + 3780) % 8))) {
            v37 = *(_DWORD*) (a1 + 3780) % 16;
            v31 = v37 / 2;
            if(v31)
                v17 = (unsigned __int16) sub_41E780(&word_69D8F8) % (int) v31;
            else
                LOWORD(v17) = 0;
            v37 = v37 / 2 + (unsigned __int16) v17;
            v16 = (float) v37;
            v36 = v16 * 160.0 / 16.0 + 32.0;
            v35 = *(float*) (a1 + 3768) - v16 * 3.1415927 / 40.0;
            if(v36 < -0.78539819)
                v36 = v36 + 1.5707964;
            v32 = *(float*) (a1 + 3180);
            v33 = *(float*) (a1 + 3184);
            v34 = *(_DWORD*) (a1 + 3188);
            v15 = cos(v35);
            v32 = v15 * v36 + v32;
            v14 = sin(v35);
            v33 = v14 * v36 + v33;
            v38 = (float*) sub_40EF50(dword_487FE0, 19, &v32, 1, -13618945);
            v6 = sub_41E820(&word_69D8F8);
            v38 [71] = (v6 * 40.0 - 20.0) / 60.0;
            v13 = (float) v37;
            v38 [72] = 8.0 * v13 / 60.0 - 0.26666668;
            v38 [73] = 0.0;
            v30 = -v38 [73];
            v29 = -v38 [72];
            v28 = -v38 [71];
            v27 = 1.0 / 120.0;
            v26 = v30 * v27;
            v25 = v29 * v27;
            v24 = v28 * v27;
            v7 = v38 + 74;
            v38 [74] = v24;
            v7 [1] = v25;
            v7 [2] = v26;
            v32 = *(float*) (a1 + 3180);
            v33 = *(float*) (a1 + 3184);
            v34 = *(_DWORD*) (a1 + 3188);
            v12 = cos(v35);
            v32 = v32 - v12 * v36;
            v11 = sin(v35);
            v33 = v11 * v36 + v33;
            v38 = (float*) sub_40EF50(dword_487FE0, 19, &v32, 1, -13618945);
            v8 = sub_41E820(&word_69D8F8);
            v38 [71] = (v8 * 40.0 - 20.0) / 60.0;
            v10 = (float) v37;
            v38 [72] = 8.0 * v10 / 60.0 - 0.26666668;
            v38 [73] = 0.0;
            v23 = -v38 [73];
            v22 = -v38 [72];
            v21 = -v38 [71];
            v20 = v23 * v27;
            v19 = v22 * v27;
            v18 = v21 * v27;
            v9 = v38 + 74;
            v38 [74] = v18;
            v9 [1] = v19;
            v9 [2] = v20;
        }
        *(_DWORD*) (a1 + 3772) = *(_DWORD*) (a1 + 3780);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 3780), (float*) (a1 + 3776));
    }
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0040D040) --------------------------------------------------------
void __cdecl sub_40D040(float* a1, int a2) {
    float* v2; // eax
    int v3; // esi
    int v4; // esi
    double v5; // st7
    int* v6; // ecx
    int v7; // esi
    int v8; // esi
    float v9; // [esp+10h] [ebp-F4h]
    float v10; // [esp+14h] [ebp-F0h]
    float v11; // [esp+18h] [ebp-ECh]
    float v12; // [esp+1Ch] [ebp-E8h]
    float* i; // [esp+20h] [ebp-E4h]
    int v14; // [esp+28h] [ebp-DCh]
    float v15 [24]; // [esp+2Ch] [ebp-D8h] BYREF
    float v16; // [esp+8Ch] [ebp-78h]
    int v17; // [esp+90h] [ebp-74h]
    int j; // [esp+94h] [ebp-70h]
    float v19; // [esp+98h] [ebp-6Ch]
    int m; // [esp+9Ch] [ebp-68h]
    int v21; // [esp+A0h] [ebp-64h]
    float v22; // [esp+A4h] [ebp-60h]
    int k; // [esp+A8h] [ebp-5Ch]
    int v24 [22]; // [esp+ACh] [ebp-58h] BYREF

    memset(v24, 0, 0x54u);
    v14 = 8;
    for(i = v15; --v14 >= 0; i += 3)
        ;
    v21 = *(_DWORD*) (a2 + 16);
    v16 = sub_41E820(&word_69D8F8) * 6.2831855;
    for(j = 0; j < 2; ++j) {
        if(j) {
            *(float*) &v17 = v16 + -2.7488937;
            v19 = -0.78539819;
        }
        else {
            *(float*) &v17 = v16 + -3.1415927;
            v19 = 0.78539819;
        }
        v22 = 32.0;
        for(k = 0; k < 8; ++k) {
            v2 = &v15 [3 * k];
            *v2 = a1 [795];
            v2 [1] = a1 [796];
            v2 [2] = a1 [797];
            v3 = 3 * k;
            v12 = cos(*(float*) &v17);
            v15 [3 * k] = v12 * v22 + v15 [v3];
            v4 = 3 * k;
            v11 = sin(*(float*) &v17);
            v15 [3 * k + 1] = v11 * v22 + v15 [v4 + 1];
            *(float*) &v17 = *(float*) &v17 + 0.78539819;
        }
        if(j)
            v5 = v16 + -2.7488937;
        else
            v5 = v16 + -3.1415927;
        *(float*) &v17 = v5;
        for(m = 0; m < 3; ++m) {
            if(m >= 2)
                v22 = 480.0;
            else
                v22 = 112.0;
            for(k = 0; k < 8; ++k) {
                v6 = (int*) &v15 [3 * k];
                v24 [1] = *v6;
                v24 [2] = v6 [1];
                v24 [3] = v6 [2];
                LOWORD(v24 [0]) = 1;
                if(v21) {
                    a1 [833] = *(float*) &v24 [1];
                    a1 [834] = *(float*) &v24 [2];
                    a1 [835] = *(float*) &v24 [3];
                    sub_4145C0(dword_5A5FF8, (int) (a1 + 832));
                }
                else {
                    if(dword_69BCB0 > 1)
                        HIWORD(v24 [0]) = 8;
                    else
                        HIWORD(v24 [0]) = 2;
                    v24 [4] = v17;
                    v24 [6] = 0;
                    v24 [8] = 0;
                    if(dword_69BCB0 > 1) {
                        v24 [9] = 1138491392;
                        v24 [10] = 1138491392;
                    }
                    else {
                        *(float*) &v24 [9] = v22;
                        *(float*) &v24 [10] = v22;
                    }
                    if(dword_69BCB0 > 1)
                        v24 [11] = 1101004800;
                    else
                        v24 [11] = 1105199104;
                    v24 [12] = 16 * m + 60;
                    v24 [13] = 90 - 16 * m;
                    v24 [14] = 16;
                    v24 [15] = 50;
                    v24 [16] = 16;
                    v24 [19] = 2;
                    LOWORD(v24 [18]) = 1;
                    sub_414670(dword_5A5FF8, (__int16*) v24);
                }
                v7 = 3 * k;
                v10 = cos(*(float*) &v17);
                v15 [3 * k] = v10 * v22 + v15 [v7];
                v8 = 3 * k;
                v9 = sin(*(float*) &v17);
                v15 [3 * k + 1] = v9 * v22 + v15 [v8 + 1];
                *(float*) &v17 = *(float*) &v17 + 0.78539819;
            }
            *(float*) &v17 = v19 - 6.2831855 + *(float*) &v17;
        }
    }
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BCB0: using guessed type int dword_69BCB0;
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040D400) --------------------------------------------------------
int __cdecl sub_40D400(int a1) {
    __int16 v1; // fps
    double v2; // st7
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    int result; // eax
    _DWORD* v7; // [esp+4h] [ebp-64h]
    int i; // [esp+8h] [ebp-60h]
    int v9; // [esp+Ch] [ebp-5Ch]
    _DWORD v10 [22]; // [esp+10h] [ebp-58h] BYREF

    v9 = 0;
    v7 = &unk_5AB5F8;
    memset(v10, 0, 0x54u);
    for(i = 0; i < 640; ++i) {
        if(*((_WORD*) v7 + 735) && *((_WORD*) v7 + 735) != 5 && v7 [48]) {
            v2 = *(float*) (v7 [48] + 44);
            v3 = v2 < 30.0;
            v4 = 0;
            v5 = v2 == 30.0;
            if((v1 & 0x100) == 0) {
                v10 [1] = v7 [344];
                v10 [2] = v7 [345];
                v10 [3] = v7 [346];
                v10 [0] = 65539;
                *(float*) &v10 [4] = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
                v10 [6] = 0;
                v10 [17] = 65537;
                v10 [19] = 8;
                LOWORD(v10 [18]) = 1;
                sub_4145C0(dword_5A5FF8, (int) v10);
                ++v9;
            }
        }
        v7 += 369;
    }
    result = a1;
    *(_DWORD*) (a1 + 2480) = v9;
    return result;
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040D530) --------------------------------------------------------
void __cdecl sub_40D530(int a1) {
    __int16 v1; // ax
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    float v6; // [esp+Ch] [ebp-7Ch]
    float v7; // [esp+14h] [ebp-74h]
    float v8; // [esp+20h] [ebp-68h]
    __int16* v9; // [esp+24h] [ebp-64h]
    float v10; // [esp+28h] [ebp-60h]
    float v11; // [esp+28h] [ebp-60h]
    int i; // [esp+2Ch] [ebp-5Ch]
    char v13 [84]; // [esp+30h] [ebp-58h] BYREF

    v9 = (__int16*) &unk_5AB5F8;
    memset(v13, 0, sizeof(v13));
    v8 = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
    sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 3180), 1, -1);
    for(i = 0; i < 640; ++i) {
        if(v9 [735]
           && v9 [735] != 5
           && *((_DWORD*) v9 + 48)
           && *(float*) (*((_DWORD*) v9 + 48) + 44) < 30.0
           && *((float*) v9 + 353) == 0.0) {
            v1 = v9 [732];
            LOBYTE(v1) = v1 | 0x10;
            v9 [732] = v1;
            v9 [733] = 2;
            sub_4323A0((int*) dword_6D4588, (int) v9, v9 [733] + v9 [89]);
            *((_DWORD*) v9 + 353) = 1008981770;
            *((_DWORD*) v9 + 361) = 0;
            *((_DWORD*) v9 + 360) = 0;
            *((_DWORD*) v9 + 359) = -999;
            *((_DWORD*) v9 + 362) = 120;
            v10 = (*(float*) (a1 + 3180) - *((float*) v9 + 344)) * (*(float*) (a1 + 3180) - *((float*) v9 + 344))
                + (*(float*) (a1 + 3184) - *((float*) v9 + 345)) * (*(float*) (a1 + 3184) - *((float*) v9 + 345));
            v3 = v10 < 0.1;
            v4 = 0;
            v5 = v10 == 0.1;
            if((v2 & 0x4100) != 0) {
                v11 = 0.0;
            }
            else {
                v6 = sqrt(v10);
                v11 = v6;
            }
            v7 = v11 * 3.1415927 / 256.0 + v8;
            *((float*) v9 + 350) = cos(v7) * 0.0099999998;
            *((float*) v9 + 351) = sin(v7) * 0.0099999998;
        }
        v9 += 738;
    }
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040D770) --------------------------------------------------------
void __cdecl sub_40D770(int a1) {
    __int16 v1; // ax
    float v2; // [esp+8h] [ebp-70h]
    __int16* v3; // [esp+18h] [ebp-60h]
    int i; // [esp+1Ch] [ebp-5Ch]
    char v5 [84]; // [esp+20h] [ebp-58h] BYREF

    v3 = (__int16*) &unk_5AB5F8;
    memset(v5, 0, sizeof(v5));
    sub_41E820(&word_69D8F8);
    sub_40EF50(dword_487FE0, 12, (_DWORD*) (a1 + 3180), 1, -1);
    for(i = 0; i < 640; ++i) {
        if(v3 [735]
           && v3 [735] != 5
           && *((_DWORD*) v3 + 48)
           && *(float*) (*((_DWORD*) v3 + 48) + 44) < 30.0
           && *((float*) v3 + 353) == 0.0) {
            v1 = v3 [732];
            LOBYTE(v1) = v1 | 0x10;
            v3 [732] = v1;
            v3 [733] = 2;
            sub_4323A0((int*) dword_6D4588, (int) v3, v3 [733] + v3 [89]);
            *((_DWORD*) v3 + 353) = 1008981770;
            *((_DWORD*) v3 + 361) = 0;
            *((_DWORD*) v3 + 360) = 0;
            *((_DWORD*) v3 + 359) = -999;
            *((_DWORD*) v3 + 362) = 120;
            v2 = sub_41E820(&word_69D8F8) * 6.2831855 - 3.1415927;
            *((float*) v3 + 350) = cos(v2) * 0.0099999998;
            *((float*) v3 + 351) = sin(v2) * 0.0099999998;
        }
        v3 += 738;
    }
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040D930) --------------------------------------------------------
void __cdecl sub_40D930(int a1) {
    int* v1; // [esp+0h] [ebp-Ch]
    int* v2; // [esp+8h] [ebp-4h]

    if(*(int*) (a1 + 3300) > 0) {
        sub_40CAF0(a1);
        if(dword_6D1BF0) {
            if(*(__int16*) (a1 + 3674) >= 0) {
                v2 = (int*) dword_6D4588;
                *(_WORD*) (a1 + 180) = 421;
                sub_432430(v2, (_DWORD*) a1, v2 [29682]);
                *(_WORD*) (a1 + 3674) = -1;
            }
            *(_BYTE*) (a1 + 3665) &= ~1u;
            *(_DWORD*) (a1 + 3660) = 60;
            *(_DWORD*) (a1 + 3656) = 0;
            *(_DWORD*) (a1 + 3652) = -999;
        }
        else if(*(int*) (a1 + 3660) > 0) {
            sub_4241E5(a1 + 3652, 1);
            if(!*(_DWORD*) (a1 + 3660)) {
                if(*(__int16*) (a1 + 3674) < 0) {
                    v1 = (int*) dword_6D4588;
                    *(_WORD*) (a1 + 180) = 416;
                    sub_432430(v1, (_DWORD*) a1, v1 [29677]);
                    *(_WORD*) (a1 + 3674) = 161;
                }
                *(_BYTE*) (a1 + 3665) |= 1u;
            }
        }
    }
}
// 6D1BF0: using guessed type int dword_6D1BF0;

//----- (0040DAA0) --------------------------------------------------------
int __cdecl sub_40DAA0(int a1) {
    int result; // eax
    int i; // [esp+14h] [ebp-4h]

    for(i = 0; i < 8; ++i) {
        if(*(_DWORD*) (a1 + 4 * i + 3512)) {
            if(*(_DWORD*) (*(_DWORD*) (a1 + 4 * i + 3512) + 600)) {
                *(_DWORD*) (a1 + 3332) = 1115684864;
                *(_DWORD*) (a1 + 3336) = 0;
                *(_DWORD*) (a1 + 3340) = 0;
                sub_41E8D0((float*) (a1 + 3332), (float*) (a1 + 3332), *(float*) (*(_DWORD*) (a1 + 4 * i + 3512) + 556));
                *(float*) (a1 + 3332) = *(float*) (a1 + 3332) + *(float*) (a1 + 3180);
                *(float*) (a1 + 3336) = *(float*) (a1 + 3336) + *(float*) (a1 + 3184);
                *(float*) (a1 + 3340) = *(float*) (a1 + 3340) + *(float*) (a1 + 3188);
                sub_4145C0(dword_5A5FF8, a1 + 3328);
            }
        }
        result = i + 1;
    }
    return result;
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];

//----- (0040DBC0) --------------------------------------------------------
int __cdecl sub_40DBC0(int a1, int a2) {
    int result; // eax
    float v3; // [esp+8h] [ebp-74h]
    float v4; // [esp+10h] [ebp-6Ch]
    int v5; // [esp+14h] [ebp-68h]
    float v6; // [esp+18h] [ebp-64h]
    float v7 [23]; // [esp+1Ch] [ebp-60h] BYREF
    int v8; // [esp+78h] [ebp-4h]

    qmemcpy(v7, (const void*) (a1 + 3328), 0x54u);
    v5 = *(_DWORD*) (a2 + 16);
    v6 = *(float*) (a1 + 2492);
    if(!(*(_DWORD*) (a1 + 2480) % 6)) {
        v8 = 0;
        while(v8 < v5) {
            v4 = *(float*) (a1 + 2496);
            v7 [1] = cos(v6) * v4;
            v7 [2] = sin(v6) * v4;
            v7 [1] = v7 [1] + 192.0;
            v7 [2] = v7 [2] + 224.0;
            v7 [4] = v6 + *(float*) (a1 + 2488);
            sub_4145C0(dword_5A5FF8, (int) v7);
            ++v8;
            v3 = (float) v5;
            v6 = 6.2831855 / v3 + v6;
        }
    }
    result = a1;
    ++* (_DWORD*) (a1 + 2480);
    return result;
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];

//----- (0040DCC0) --------------------------------------------------------
int __cdecl sub_40DCC0(int a1) {
    int result; // eax
    __int16 v2; // fps
    double v3; // st7
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    float v7; // [esp+8h] [ebp-24h]
    float v8; // [esp+Ch] [ebp-20h]
    float v9; // [esp+10h] [ebp-1Ch]
    float* v10; // [esp+14h] [ebp-18h]
    float v11; // [esp+18h] [ebp-14h]
    int i; // [esp+1Ch] [ebp-10h]
    float v13; // [esp+20h] [ebp-Ch]
    float v14; // [esp+24h] [ebp-8h]

    result = a1;
    *(_DWORD*) (a1 + 2480) = 0;
    for(i = 0; i < 8; ++i) {
        result = a1;
        if(*(_DWORD*) (a1 + 4 * i + 3512)) {
            result = *(_DWORD*) (a1 + 4 * i + 3512);
            if(*(_DWORD*) (result + 600)) {
                v10 = *(float**) (a1 + 4 * i + 3512);
                v8 = v10 [140];
                v7 = v10 [139];
                v9 = cos(v7);
                v11 = sin(v7);
                while(1) {
                    v3 = v10 [141];
                    v4 = v3 < v8;
                    v5 = 0;
                    v6 = v3 == v8;
                    if((v2 & 0x4100) != 0)
                        break;
                    v13 = v9 * v8 + v10 [136];
                    v14 = v11 * v8 + v10 [137];
                    *(float*) (a1 + 3332) = v13;
                    *(float*) (a1 + 3336) = v14;
                    *(_DWORD*) (a1 + 3340) = 0;
                    sub_4145C0(dword_5A5FF8, a1 + 3328);
                    v8 = v8 + 48.0;
                }
                result = a1;
                ++* (_DWORD*) (a1 + 2480);
            }
        }
    }
    return result;
}
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];

//----- (0040DE00) --------------------------------------------------------
int __cdecl sub_40DE00(__int64 a1) {
    __int16 v1; // fps
    double v2; // st7
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    __int16 v6; // ax
    int result; // eax
    float v8; // [esp+18h] [ebp-A4h]
    float v9; // [esp+24h] [ebp-98h]
    float v10; // [esp+2Ch] [ebp-90h]
    float v11; // [esp+30h] [ebp-8Ch]
    float v12; // [esp+38h] [ebp-84h]
    float v13; // [esp+3Ch] [ebp-80h]
    float v14; // [esp+40h] [ebp-7Ch]
    int v15; // [esp+44h] [ebp-78h]
    float* v16; // [esp+4Ch] [ebp-70h]
    float* v17; // [esp+58h] [ebp-64h]
    int i; // [esp+5Ch] [ebp-60h]
    int v19; // [esp+60h] [ebp-5Ch]
    char v20 [84]; // [esp+64h] [ebp-58h] BYREF

    v19 = 0;
    v16 = (float*) &unk_5AB5F8;
    memset(v20, 0, sizeof(v20));
    for(i = 0; i < 640; ++i) {
        if(*((_WORD*) v16 + 735)) {
            if(*((_WORD*) v16 + 735) != 5) {
                if(*((_DWORD*) v16 + 48)) {
                    v2 = *(float*) (*((_DWORD*) v16 + 48) + 44);
                    v3 = v2 < 30.0;
                    v4 = 0;
                    v5 = v2 == 30.0;
                    if((v1 & 0x100) == 0) {
                        ++v19;
                        v14 = v16 [344] - *(float*) (a1 + 3180);
                        v13 = v16 [345] - *(float*) (a1 + 3184);
                        sub_45BE40(v13, v14);
                        v15 = 0;
                        v17 = (float*) &unk_5AB5F8;
                        while(v15 < 640) {
                            if(*((_WORD*) v17 + 735)
                               && *((_WORD*) v17 + 735) != 5
                               && *((_DWORD*) v17 + 48)
                               && *(float*) (*((_DWORD*) v17 + 48) + 44) < 30.0
                               && v17 [353] == 0.0) {
                                v12 = (v17 [345] - v16 [345]) * (v17 [345] - v16 [345]) + (v17 [344] - v16 [344]) * (v17 [344] - v16 [344]);
                                v8 = sqrt(v12);
                                if(v8 < 64.0) {
                                    v6 = *((_WORD*) v17 + 732);
                                    LOBYTE(v6) = v6 | 0x10;
                                    *((_WORD*) v17 + 732) = v6;
                                    v17 [353] = 0.0099999998;
                                    v17 [361] = 0.0;
                                    v17 [360] = 0.0;
                                    v17 [359] = NAN;
                                    *((_DWORD*) v17 + 362) = 120;
                                    v11 = v17 [344] - *(float*) (a1 + 3180);
                                    v10 = v17 [345] - *(float*) (a1 + 3184);
                                    sub_45BE40(v10, v11);
                                    v17 [356] = (v10 - v13) * 2.2 + v13;
                                    v9 = v17 [356];
                                    v17 [350] = cos(v9) * 0.0099999998;
                                    v17 [351] = sin(v9) * 0.0099999998;
                                    sub_4323A0((int*) dword_6D4588, (int) v17, (__int16)++ * ((_WORD*) v17 + 733) + *((__int16*) v17 + 89));
                                }
                            }
                            ++v15;
                            v17 += 369;
                        }
                    }
                }
            }
        }
        v16 += 369;
    }
    sub_40D930(a1);
    result = v19;
    *(_DWORD*) (a1 + 2480) = v19;
    return result;
}

//----- (0040E1B0) --------------------------------------------------------
void __cdecl sub_40E1B0(int a1, int a2) {
    float v2; // [esp+0h] [ebp-1Ch]
    float v3; // [esp+8h] [ebp-14h]
    float v4; // [esp+Ch] [ebp-10h]
    float v5; // [esp+10h] [ebp-Ch]
    float v6; // [esp+14h] [ebp-8h]
    float v7; // [esp+14h] [ebp-8h]
    int v8; // [esp+18h] [ebp-4h]

    v8 = *(_DWORD*) (a1 + 3300);
    if(*(int*) (a1 + 3320) >= 7200)
        v8 = 0;
    if(*(_DWORD*) (a2 + 16)) {
        v4 = (float) v8;
        v6 = 320.0 - v4 * 160.0 / 6000.0;
        v3 = 192.0 - v6 / 2.0;
        *(float*) (a1 + 2492) = sub_41E820(&word_69D8F8) * v6 + v3;
        v7 = 128.0 - v4 * 64.0 / 6000.0;
        v2 = 96.0 - v7 / 2.0;
        *(float*) (a1 + 2496) = sub_41E820(&word_69D8F8) * v7 + v2;
    }
    else {
        v5 = (float) v8;
        *(float*) (a1 + 2496) = 2.0 - v5 * 1.0 / 6000.0;
        *(_DWORD*) (a1 + 2504) = 240 * v8 / 6000 + 40;
    }
}
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0040E2D0) --------------------------------------------------------
void* __thiscall sub_40E2D0(void* this) {
    int i; // [esp+4h] [ebp-20h]
    int v4; // [esp+Ch] [ebp-18h]

    v4 = 513;
    for(i = (int) this + 8; --v4 >= 0; i += 380) {
        sub_403720(i);
        sub_424127((_DWORD*) (i + 356));
    }
    sub_40E340(this);
    return this;
}

//----- (0040E340) --------------------------------------------------------
int __thiscall sub_40E340(void* this) {
    int result; // eax

    result = 0;
    memset(this, 0, 0x2F984u);
    return result;
}

//----- (0040EF50) --------------------------------------------------------
_DWORD* __thiscall sub_40EF50(_DWORD* this, int a2, _DWORD* a3, int a4, int a5) {
    int* v8; // [esp+Ch] [ebp-10h]
    int v9; // [esp+10h] [ebp-Ch]
    int i; // [esp+14h] [ebp-8h]
    int v11; // [esp+18h] [ebp-4h]

    v11 = (int) &this [95 * *this + 2];
    for(i = 0; i < 512; ++i) {
        if((int)++ * this >= 512)
            *this = 0;
        if(*(_BYTE*) (v11 + 376)) {
            if(*this)
                v11 += 380;
            else
                v11 = (int) (this + 2);
        }
        else {
            *(_BYTE*) (v11 + 376) = 1;
            *(_BYTE*) (v11 + 377) = a2;
            *(_DWORD*) (v11 + 272) = *a3;
            *(_DWORD*) (v11 + 276) = a3 [1];
            *(_DWORD*) (v11 + 280) = a3 [2];
            v9 = dword_476298 [2 * a2];
            v8 = (int*) dword_6D4588;
            *(_WORD*) (v11 + 180) = v9;
            sub_432430(v8, (_DWORD*) v11, v8 [v9 + 29261]);
            *(_DWORD*) (v11 + 124) = a5;
            *(_DWORD*) (v11 + 372) = dword_47629C [2 * a2];
            *(_DWORD*) (v11 + 364) = 0;
            *(_DWORD*) (v11 + 360) = 0;
            *(_DWORD*) (v11 + 356) = -999;
            *(_BYTE*) (v11 + 378) = 0;
            *(_BYTE*) (v11 + 379) = 0;
            if(!--a4)
                break;
            if(*this)
                v11 += 380;
            else
                v11 = (int) (this + 2);
        }
    }
    if(i < 512)
        return (_DWORD*) v11;
    else
        return this + 48642;
}
// 476298: using guessed type int dword_476298[];
// 47629C: using guessed type int dword_47629C[39];

//----- (0040F100) --------------------------------------------------------
int __cdecl sub_40F100(int a1) {
    int i; // [esp+4h] [ebp-8h]
    int v3; // [esp+8h] [ebp-4h]

    v3 = a1 + 8;
    *(_DWORD*) (a1 + 4) = 0;
    for(i = 0; i < 512; ++i) {
        if(*(_BYTE*) (v3 + 376)) {
            ++* (_DWORD*) (a1 + 4);
            if(*(_DWORD*) (v3 + 372) && (*(int(__cdecl**)(int))(v3 + 372))(v3) != 1)
                *(_BYTE*) (v3 + 376) = 0;
            if(sub_433960((int*) dword_6D4588, v3))
                *(_BYTE*) (v3 + 376) = 0;
            *(_DWORD*) (v3 + 356) = *(_DWORD*) (v3 + 364);
            sub_424285((float*) &dword_6C6D18, (_DWORD*) (v3 + 364), (float*) (v3 + 360));
        }
        v3 += 380;
    }
    return 1;
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0040F1F0) --------------------------------------------------------
int __cdecl sub_40F1F0(int a1) {
    int i; // [esp+0h] [ebp-8h]
    unsigned int v3; // [esp+4h] [ebp-4h]

    v3 = a1 + 8;
    for(i = 0; i < 512; ++i) {
        if(*(_BYTE*) (v3 + 376)) {
            *(_DWORD*) (v3 + 144) = *(_DWORD*) (v3 + 272);
            *(_DWORD*) (v3 + 148) = *(_DWORD*) (v3 + 276);
            *(_DWORD*) (v3 + 152) = *(_DWORD*) (v3 + 280);
            sub_433150(dword_6D4588, v3);
        }
        v3 += 380;
    }
    return 1;
}

//----- (0040F280) --------------------------------------------------------
int __cdecl sub_40F280(void* a1) {
    int result; // eax

    sub_40E340(a1);
    switch(*(_DWORD*) dword_69D6D4) {
        case 0:
        case 1:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff01.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 2:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff02.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 3:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff03.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 4:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff04.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 5:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff05.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 6:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff05.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        case 7:
            if(!sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff04.anm", 691))
                goto LABEL_22;
            result = -1;
            break;
        default:
            LABEL_22:
            result = 0;
            break;
    }
    return result;
}

//----- (0040F3D0) --------------------------------------------------------
int sub_40F3D0() {
    sub_432030(dword_6D4588, 11);
    return 0;
}

//----- (0040F3F0) --------------------------------------------------------
int sub_40F3F0() {
    sub_40E340(dword_487FE0);
    dword_4B7968 = (int) sub_40F100;
    dword_4B796C = (int) sub_40F280;
    dword_4B7970 = (int) sub_40F3D0;
    dword_4B7980 = (int) dword_487FE0;
    if(sub_41C860(byte_69D918, (int) &unk_4B7964, 10))
        return -1;
    dword_4B7988 = (int) sub_40F1F0;
    dword_4B798C = 0;
    dword_4B7990 = 0;
    dword_4B79A0 = (int) dword_487FE0;
    sub_41C940((__int16*) byte_69D918, (int) &unk_4B7984, 8);
    return 0;
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 4B7968: using guessed type int dword_4B7968;
// 4B796C: using guessed type int dword_4B796C;
// 4B7970: using guessed type int dword_4B7970;
// 4B7980: using guessed type int dword_4B7980;
// 4B7988: using guessed type int dword_4B7988;
// 4B798C: using guessed type int dword_4B798C;
// 4B7990: using guessed type int dword_4B7990;
// 4B79A0: using guessed type int dword_4B79A0;

//----- (0040F4A0) --------------------------------------------------------
void sub_40F4A0() {
    sub_41CDE0(byte_69D918, (int) &unk_4B7964);
    sub_41CDE0(byte_69D918, (int) &unk_4B7984);
}

//----- (0040F4D0) --------------------------------------------------------
int __thiscall sub_40F4D0(const char** this) {
    int v3; // [esp+4h] [ebp-4h]

    v3 = j__atol(this [1115]);
    while(*this [1115])
        ++this [1115];
    while(!*this [1115])
        ++this [1115];
    return v3;
}

//----- (0040F550) --------------------------------------------------------
int __thiscall sub_40F550(int* this) {
    int result; // eax
    int v2 [4]; // [esp+Ch] [ebp-10h] BYREF

    v2 [0] = 0;
    v2 [1] = 0;
    v2 [2] = 1142947840;
    v2 [3] = 1139802112;
    switch(this [1114]) {
        case 0:
            this [1111] = 0;
            break;
        case 1:
            if(this [1112] < this [1113]) {
                this [1111] = (255 - 255 * this [1112]++ / this [1113]) << 24;
            }
            else {
                this [1114] = 0;
                this [1111] = 0;
            }
            break;
        case 2:
            if(this [1112] < this [1113])
                this [1111] = (255 * this [1112]++ / this [1113]) << 24;
            else
                this [1111] = -16777216;
            break;
        case 3:
            if(this [1112] < this [1113]) {
                this [1111] = ((255 - 255 * this [1112]++ / this [1113]) << 24) | 0xFFFFFF;
            }
            else {
                this [1114] = 0;
                this [1111] = 0;
            }
            break;
        case 4:
            if(this [1112] < this [1113])
                this [1111] = ((255 * this [1112]++ / this [1113]) << 24) | 0xFFFFFF;
            else
                this [1111] = -1;
            break;
        default:
            break;
    }
    result = this [1111] & 0xFF000000;
    if(result)
        return sub_42F8B0(v2, this [1111]);
    return result;
}

//----- (0040F7C0) --------------------------------------------------------
int __usercall sub_40F7C0(int a1, int a2) {
    _BYTE* v2; // edi
    _BYTE* v4; // eax
    char* v5; // [esp-4h] [ebp-D8h]
    float v6; // [esp+Ch] [ebp-C8h]
    float v7; // [esp+10h] [ebp-C4h]
    int* v9; // [esp+24h] [ebp-B0h]
    int v10; // [esp+28h] [ebp-ACh]
    int v11; // [esp+2Ch] [ebp-A8h]
    float v12; // [esp+7Ch] [ebp-58h]
    int k; // [esp+80h] [ebp-54h]
    int j; // [esp+84h] [ebp-50h]
    int i; // [esp+88h] [ebp-4Ch]
    int v16; // [esp+94h] [ebp-40h]
    int v17; // [esp+98h] [ebp-3Ch]
    int v18; // [esp+9Ch] [ebp-38h]
    char Format [36]; // [esp+A4h] [ebp-30h] BYREF
    __int16 v20; // [esp+C8h] [ebp-Ch]
    _BYTE v21 [6]; // [esp+CAh] [ebp-Ah] BYREF
    int v22; // [esp+D0h] [ebp-4h]
    unsigned int retaddr; // [esp+D8h] [ebp+4h]

    *(_DWORD*) &v21 [2] = retaddr ^ dword_47A630;
    v22 = 0;
    memset(Format, 0, sizeof(Format));
    v20 = 0;
    v2 = v21;
    if(*(int*) (a1 + 4412) > 0) {
        sub_4241E5(a1 + 4404, 1);
        if(*(_DWORD*) (a1 + 4416)) {
            --* (_DWORD*) (a1 + 4416);
        }
        else if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)
                || *(_DWORD*) (a1 + 4376) && (word_69D904 & 0x100) != 0) {
            *(_DWORD*) (a1 + 4412) = 0;
            *(_DWORD*) (a1 + 4408) = 0;
            *(_DWORD*) (a1 + 4404) = -999;
        }
        if(*(int*) (a1 + 4412) > 0)
            goto LABEL_93;
        memset((void*) (a1 + 20), 0, 0x1100u);
        v2 = (_BYTE*) (a1 + 4372);
        *(_DWORD*) (a1 + 4436) = 0;
    }
    if(*(int*) (a1 + 4400) <= 0) {
        while(1) {
            switch(**(_BYTE**) (a1 + 4460)) {
                case 0:
                case 0xA:
                case 0xD:
                    goto LABEL_77;
                case 0x40:
                    switch(*(_BYTE*)++ * (_DWORD*) (a1 + 4460)) {
                        case '0':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4456) = 1;
                            *(_DWORD*) (a1 + 4448) = 0;
                            *(_DWORD*) (a1 + 4452) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case '1':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4456) = 2;
                            *(_DWORD*) (a1 + 4448) = 0;
                            *(_DWORD*) (a1 + 4452) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case '2':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4456) = 3;
                            *(_DWORD*) (a1 + 4448) = 0;
                            *(_DWORD*) (a1 + 4452) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case '3':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4456) = 4;
                            *(_DWORD*) (a1 + 4448) = 0;
                            *(_DWORD*) (a1 + 4452) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case 'F':
                            if(sub_4106D0((_DWORD*) a1, (char*) (*(_DWORD*) (a1 + 4460) + 1)))
                                return -1;
                            v22 = 0;
                            for(i = 0; i < 4; ++i) {
                                for(j = 0; j < 4; ++j) {
                                    if(byte_69CCDC [24 * i + j] == 99 || byte_69CCE1 [24 * i + j] == 99) {
                                        *(_DWORD*) (a1 + 4376) = 1;
                                        break;
                                    }
                                }
                            }
                            LABEL_41:
                            for(k = 0; k < 16; ++k)
                                *(_WORD*) (a1 + 272 * k + 200) = 0;
                            LABEL_70:
                            while(**(_BYTE**) (a1 + 4460) != 10 && **(_BYTE**) (a1 + 4460) != 13)
                                ++* (_DWORD*) (a1 + 4460);
                            while(**(_BYTE**) (a1 + 4460) == 10 || **(_BYTE**) (a1 + 4460) == 13)
                                ++* (_DWORD*) (a1 + 4460);
                            break;
                        case 'M':
                            ++ * (_DWORD*) (a1 + 4460);
                            v12 = (float) sub_40F4D0((const char**) a1);
                            sub_424D82((float*) &dword_6C6D18, v12);
                            goto LABEL_70;
                        case 'R':
                            goto LABEL_41;
                        case 'V':
                            ++ * (_DWORD*) (a1 + 4460);
                            v7 = (float) sub_40F4D0((const char**) a1);
                            v6 = (float) sub_40F4D0((const char**) a1);
                            *(float*) (a1 + 16) = v7 / v6;
                            goto LABEL_70;
                        case 'a':
                            ++ * (_DWORD*) (a1 + 4460);
                            v17 = sub_40F4D0((const char**) a1);
                            v18 = sub_40F4D0((const char**) a1);
                            v16 = sub_40F4D0((const char**) a1);
                            sub_4051B0((int*) dword_6D4588, a1 + 272 * v17 + 20, v18 + 1536);
                            sub_4323A0((int*) dword_6D4588, a1 + 272 * v17 + 20, v16 + 1536);
                            goto LABEL_70;
                        case 'b':
                            if(!sub_435010((_DWORD**) dword_6D4588, 0, (char*) (*(_DWORD*) (a1 + 4460) + 1)))
                                goto LABEL_70;
                            return -1;
                        case 'c':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4440) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case 'm':
                            sub_424B5D(a2, (char*) (*(_DWORD*) (a1 + 4460) + 1));
                            goto LABEL_70;
                        case 'r':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4412) = sub_40F4D0((const char**) a1);
                            *(_DWORD*) (a1 + 4408) = 0;
                            *(_DWORD*) (a1 + 4404) = -999;
                            *(_DWORD*) (a1 + 4416) = sub_40F4D0((const char**) a1);
                            while(**(_BYTE**) (a1 + 4460) != 10 && **(_BYTE**) (a1 + 4460) != 13)
                                ++* (_DWORD*) (a1 + 4460);
                            while(**(_BYTE**) (a1 + 4460) == 10 || **(_BYTE**) (a1 + 4460) == 13)
                                ++* (_DWORD*) (a1 + 4460);
                            goto LABEL_93;
                        case 's':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4424) = sub_40F4D0((const char**) a1);
                            *(_DWORD*) (a1 + 4428) = sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case 'v':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(float*) (a1 + 12) = (float) sub_40F4D0((const char**) a1);
                            goto LABEL_70;
                        case 'w':
                            ++ * (_DWORD*) (a1 + 4460);
                            *(_DWORD*) (a1 + 4400) = sub_40F4D0((const char**) a1);
                            *(_DWORD*) (a1 + 4396) = 0;
                            *(_DWORD*) (a1 + 4392) = -999;
                            *(_DWORD*) (a1 + 4420) = sub_40F4D0((const char**) a1);
                            while(**(_BYTE**) (a1 + 4460) != 10 && **(_BYTE**) (a1 + 4460) != 13)
                                ++* (_DWORD*) (a1 + 4460);
                            while(**(_BYTE**) (a1 + 4460) == 10 || **(_BYTE**) (a1 + 4460) == 13)
                                ++* (_DWORD*) (a1 + 4460);
                            goto LABEL_93;
                        case 'z':
                            return -1;
                        default:
                            goto LABEL_70;
                    }
                    break;
                default:
                    while(1) {
                        v11 = v22 + 2 * *(_DWORD*) (a1 + 4436) + 1800;
                        v10 = a1 + 272 * (v22 + 2 * *(_DWORD*) (a1 + 4436)) + 20;
                        v9 = (int*) dword_6D4588;
                        *(_WORD*) (v10 + 180) = v11;
                        sub_432430(v9, (_DWORD*) v10, v9 [v11 + 29261]);
                        v5 = *(char**) (a1 + 4460);
                        if(v22) {
                            v2 = *(_BYTE**) (v10 + 192);
                            *((_DWORD*) v2 + 1) = -1015611392;
                        }
                        sub_434B60(
                            (_DWORD*) dword_6D4588,
                            a1 + 272 * (v22 + 2 * *(_DWORD*) (a1 + 4436)) + 20,
                            *(_DWORD*) (a1 + 4440),
                            0xC0D0D0u,
                            v5);
                        if(v22)
                            break;
                        v22 = 1;
                    }
                    v22 = 0;
                    *((_DWORD*) v2 + 1) = 0;
                    while(1) {
                        v4 = *(_BYTE**) (a1 + 4460);
                        if(!*v4)
                            break;
                        *(_DWORD*) (a1 + 4460) = v4 + 1;
                    }
                    LABEL_77:
                    while(**(_BYTE**) (a1 + 4460) == 10 || !**(_BYTE**) (a1 + 4460) || **(_BYTE**) (a1 + 4460) == 13)
                        ++* (_DWORD*) (a1 + 4460);
                    if((word_69D904 & 0x1001) != 0) {
                        *(_DWORD*) (a1 + 4400) = *(_DWORD*) (a1 + 4428);
                        *(_DWORD*) (a1 + 4396) = 0;
                        *(_DWORD*) (a1 + 4392) = -999;
                        *(_DWORD*) (a1 + 4420) = *(_DWORD*) (a1 + 4428);
                    }
                    else {
                        *(_DWORD*) (a1 + 4400) = *(_DWORD*) (a1 + 4424);
                        *(_DWORD*) (a1 + 4396) = 0;
                        *(_DWORD*) (a1 + 4392) = -999;
                        *(_DWORD*) (a1 + 4420) = *(_DWORD*) (a1 + 4424);
                    }
                    ++* (_DWORD*) (a1 + 4436);
                    goto LABEL_93;
            }
        }
    }
    sub_4241E5(a1 + 4392, 1);
    if(*(_DWORD*) (a1 + 4420)) {
        --* (_DWORD*) (a1 + 4420);
    }
    else if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)
            || *(_DWORD*) (a1 + 4376) && (word_69D904 & 0x100) != 0) {
        *(_DWORD*) (a1 + 4400) = 0;
        *(_DWORD*) (a1 + 4396) = 0;
        *(_DWORD*) (a1 + 4392) = -999;
    }
    LABEL_93:
    *(_DWORD*) (a1 + 4380) = *(_DWORD*) (a1 + 4388);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 4388), (float*) (a1 + 4384));
    *(float*) (a1 + 12) = *(float*) (a1 + 12) - *(float*) (a1 + 16);
    if(*(float*) (a1 + 12) <= 0.0) {
        *(_DWORD*) (a1 + 12) = 0;
        *(_DWORD*) (a1 + 16) = 0;
    }
    return 0;
}
// 4101C8: conditional instruction was optimized away because %var_34.4==0
// 47A630: using guessed type int dword_47A630;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6D18: using guessed type int dword_6C6D18;

//----- (004106D0) --------------------------------------------------------
int __thiscall sub_4106D0(_DWORD* this, char* Str) {
    void* Block; // [esp+Ch] [ebp-4h]

    Block = (void*) this [1093];
    this [1093] = sub_41E290(Str, 0);
    if(this [1093]) {
        this [1115] = this [1093];
        this [1106] = 8;
        this [1100] = 0;
        this [1099] = 0;
        this [1098] = -999;
        this [1097] = 0;
        this [1096] = 0;
        this [1095] = -999;
        if(Block)
            free(Block);
        return 0;
    }
    else {
        sub_41E4D0((int) byte_69D998, aError_0);
        return -1;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (004107B0) --------------------------------------------------------
int sub_4107B0() {
    int* v1; // [esp+0h] [ebp-3Ch]
    _DWORD* Block; // [esp+24h] [ebp-18h]

    Block = operator new(0x1170u);
    if(Block)
        v1 = sub_4108B0(Block);
    else
        v1 = 0;
    *v1 = (int) sub_41CD40((int) sub_4109C0);
    *(_DWORD*) (*v1 + 28) = v1;
    *(_DWORD*) (*v1 + 8) = sub_410B10;
    *(_DWORD*) (*v1 + 12) = sub_410D80;
    if(sub_41C860(byte_69D918, *v1, 3))
        return -1;
    v1 [1] = (int) sub_41CD40((int) sub_410A70);
    *(_DWORD*) (v1 [1] + 28) = v1;
    sub_41C940((__int16*) byte_69D918, v1 [1], 1);
    return 0;
}

//----- (004108B0) --------------------------------------------------------
_DWORD* __thiscall sub_4108B0(_DWORD* this) {
    int i; // [esp+1Ch] [ebp-1Ch]
    int v4; // [esp+24h] [ebp-14h]

    v4 = 16;
    for(i = (int) (this + 5); --v4 >= 0; i += 272)
        sub_403720(i);
    sub_424127(this + 1095);
    sub_424127(this + 1098);
    sub_424127(this + 1101);
    memset(this, 0, 0x1170u);
    this [1106] = 8;
    this [1100] = 0;
    this [1099] = 0;
    this [1098] = -999;
    this [1097] = 0;
    this [1096] = 0;
    this [1095] = -999;
    this [2] = 0;
    this [3] = 0;
    this [4] = 0;
    return this;
}

//----- (004109C0) --------------------------------------------------------
int __usercall sub_4109C0(int a1, int a2) {
    int j; // [esp+0h] [ebp-8h]
    int i; // [esp+4h] [ebp-4h]

    for(i = 0; ; ++i) {
        if(sub_40F7C0(a2, a1))
            return 0;
        for(j = 0; j < 16; ++j) {
            if(*(_WORD*) (a2 + 272 * j + 200))
                sub_433960((int*) dword_6D4588, a2 + 272 * j + 20);
        }
        if(!*(_DWORD*) (a2 + 4376) || (word_69D904 & 0x100) == 0 || i >= 4)
            break;
    }
    return 1;
}
// 69D904: using guessed type __int16 word_69D904;

//----- (00410A70) --------------------------------------------------------
int __cdecl sub_410A70(int a1) {
    int i; // [esp+0h] [ebp-4h]

    sub_4354C0(
        (_DWORD*) dword_6D4588,
        0,
        0,
        0,
        (unsigned __int64) *(float*) (a1 + 8),
        (unsigned __int64) *(float*) (a1 + 12),
        640,
        480);
    for(i = 0; i < 16; ++i) {
        if(*(_WORD*) (a1 + 272 * i + 200))
            sub_432AD0((void*) dword_6D4588, a1 + 272 * i + 20);
    }
    sub_40F550((int*) a1);
    return 1;
}

//----- (00410B10) --------------------------------------------------------
int __cdecl sub_410B10(_DWORD* a1) {
    int v2; // [esp+18h] [ebp-8h]

    byte_69D4C2 = 1;
    dword_6C6EB4 = 1;
    sub_424375((int**) &dword_6C6D18, 5, "th06e_ED.dat");
    sub_431DC0((_DWORD*) dword_6D4588, 44, "data/staff01.anm", 1536);
    sub_431DC0((_DWORD*) dword_6D4588, 45, "data/staff02.anm", 1543);
    sub_431DC0((_DWORD*) dword_6D4588, 46, "data/staff03.anm", 1550);
    *(_DWORD*) (dword_6D4588 + 135352) = 0;
    *(_DWORD*) (dword_6D4588 + 135360) = 0;
    *(_BYTE*) (dword_6D4588 + 135356) = -1;
    *(_BYTE*) (dword_6D4588 + 135358) = -1;
    v2 = (unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD;
    a1 [1094] = 0;
    if(byte_69D4B8) {
        if(byte_69CCE1 [24 * v2 + dword_69BCB0] == 99)
            a1 [1094] = 1;
    }
    else {
        if(byte_69CCDC [24 * v2 + dword_69BCB0] == 99)
            a1 [1094] = 1;
        byte_69CCDC [24 * v2 + dword_69BCB0] = 99;
    }
    byte_69CCE1 [24 * v2 + dword_69BCB0] = 99;
    if(dword_69BCB0 && !byte_69D4B8) {
        if(byte_69D4BD) {
            if(byte_69D4BD == 1) {
                if(byte_69D4BE) {
                    if(sub_4106D0(a1, "data/end11.end"))
                        return -1;
                }
                else if(sub_4106D0(a1, "data/end10.end")) {
                    return -1;
                }
            }
        }
        else if(byte_69D4BE) {
            if(sub_4106D0(a1, "data/end01.end"))
                return -1;
        }
        else if(sub_4106D0(a1, "data/end00.end")) {
            return -1;
        }
    }
    else if(byte_69D4BD) {
        if(byte_69D4BD == 1 && sub_4106D0(a1, "data/end10b.end"))
            return -1;
    }
    else if(sub_4106D0(a1, "data/end00b.end")) {
        return -1;
    }
    return 0;
}
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B8: using guessed type char byte_69D4B8;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D4C2: using guessed type char byte_69D4C2;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EB4: using guessed type int dword_6C6EB4;

//----- (00410D80) --------------------------------------------------------
int __cdecl sub_410D80(int a1) {
    sub_432030(dword_6D4588, 44);
    sub_432030(dword_6D4588, 45);
    sub_432030(dword_6D4588, 46);
    dword_6C6EA4 = 7;
    sub_435270((_DWORD**) dword_6D4588, 0);
    free(*(void**) (a1 + 4372));
    sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 4));
    *(_DWORD*) (a1 + 4) = 0;
    j__free((void*) a1);
    dword_6C6EB4 = 0;
    sub_4242F3((int**) &dword_6C6D18, 5);
    return 0;
}
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C6EB4: using guessed type int dword_6C6EB4;

//----- (00410E30) --------------------------------------------------------
int __thiscall sub_410E30(int this) {
    int result; // eax
    int i; // [esp+38h] [ebp-4h]

    memset((void*) this, 0, 0xEE5ECu);
    memset((void*) (this + 8), 0, 0xEC8u);
    for(i = 0; i < 8; ++i)
        *(_WORD*) (this + 8 + 272 * i + 452) = -1;
    *(_BYTE*) (this + 3672) |= 0x80u;
    *(_DWORD*) (this + 3328) = 0;
    *(_DWORD*) (this + 3324) = 0;
    *(_DWORD*) (this + 3320) = -999;
    *(_BYTE*) (this + 3673) |= 1u;
    *(_BYTE*) (this + 3673) |= 2u;
    *(_BYTE*) (this + 3673) &= ~4u;
    *(_DWORD*) (this + 3200) = 1094713344;
    *(_DWORD*) (this + 3204) = 1094713344;
    *(_DWORD*) (this + 3208) = 1094713344;
    *(_DWORD*) (this + 3212) = 0;
    *(_DWORD*) (this + 3216) = 0;
    *(_DWORD*) (this + 3220) = 0;
    *(_DWORD*) (this + 3228) = 0;
    *(_DWORD*) (this + 3224) = 0;
    *(_DWORD*) (this + 3236) = 0;
    *(_DWORD*) (this + 3232) = 0;
    *(_BYTE*) (this + 3672) &= 0xFCu;
    *(_BYTE*) (this + 3672) &= ~0x20u;
    *(_BYTE*) (this + 3672) &= ~0x40u;
    *(_BYTE*) (this + 3673) &= ~8u;
    *(_DWORD*) (this + 3140) = 0;
    *(_DWORD*) (this + 3308) = 1;
    *(_DWORD*) (this + 3316) = 100;
    *(_BYTE*) (this + 3652) = 0;
    *(_BYTE*) (this + 3653) = 0;
    *(_BYTE*) (this + 3654) = 0;
    *(_DWORD*) (this + 3420) = 0;
    *(_DWORD*) (this + 3432) = 0;
    *(_DWORD*) (this + 3428) = 0;
    *(_DWORD*) (this + 3424) = -999;
    *(_DWORD*) (this + 3240) = 0;
    *(_DWORD*) (this + 3244) = 0;
    *(_DWORD*) (this + 3248) = 0;
    *(_WORD*) (this + 3682) = -1;
    *(_WORD*) (this + 3684) = -1;
    *(_WORD*) (this + 3676) = -1;
    *(_BYTE*) (this + 3673) |= 0x10u;
    *(_BYTE*) (this + 3673) &= 0x1Fu;
    *(_DWORD*) (this + 3148) = -1;
    *(_BYTE*) (this + 3674) &= ~1u;
    *(_DWORD*) (this + 3752) = 0;
    *(_DWORD*) (this + 3184) = -1;
    *(_DWORD*) (this + 3760) = -1;
    *(_DWORD*) (this + 3768) = -1;
    *(_DWORD*) (this + 3648) = 0;
    *(_BYTE*) (this + 3657) = 0;
    result = this + 8;
    *(_BYTE*) (this + 3674) &= ~2u;
    *(_DWORD*) (this + 3292) = -1090519040;
    *(_DWORD*) (this + 3296) = 1056964608;
    return result;
}

//----- (00411190) --------------------------------------------------------
_DWORD* __thiscall sub_411190(_DWORD* this) {
    _DWORD* i; // [esp+8h] [ebp-90h]
    int v4; // [esp+10h] [ebp-88h]

    sub_411240(this + 2);
    v4 = 257;
    for(i = this + 948; --v4 >= 0; i += 946)
        sub_411240(i);
    sub_424127(this + 244088);
    sub_410E30((int) this);
    return this;
}

//----- (00411240) --------------------------------------------------------
_DWORD* __thiscall sub_411240(_DWORD* this) {
    _DWORD* j; // [esp+24h] [ebp-34h]
    int v4; // [esp+2Ch] [ebp-2Ch]
    int i; // [esp+3Ch] [ebp-1Ch]
    int v6; // [esp+44h] [ebp-14h]

    sub_403720((int) this);
    v6 = 8;
    for(i = (int) (this + 68); --v6 >= 0; i += 272)
        sub_403720(i);
    sub_424127(this + 613);
    v4 = 8;
    for(j = this + 631; --v4 >= 0; j += 19)
        sub_424127(j + 1);
    sub_424127(this + 817);
    sub_424127(this + 828);
    memset(this + 832, 0, 0x54u);
    sub_424127(this + 854);
    memset(this + 857, 0, 0x54u);
    sub_424127(this + 913);
    sub_424127(this + 943);
    return this;
}

//----- (00411390) --------------------------------------------------------
int __thiscall sub_411390(int this, __int16 a2, _DWORD* a3, __int16 a4, char a5, int a6) {
    int v7; // [esp+Ch] [ebp-8h]
    int i; // [esp+10h] [ebp-4h]

    v7 = this + 3792;
    for(i = 0; i < 256; ++i) {
        if(*(char*) (v7 + 3664) >= 0) {
            qmemcpy((void*) v7, (const void*) (this + 8), 0xEC8u);
            if(a4 >= 0)
                *(_DWORD*) (v7 + 3300) = a4;
            *(_DWORD*) (v7 + 3180) = *a3;
            *(_DWORD*) (v7 + 3184) = a3 [1];
            *(_DWORD*) (v7 + 3188) = a3 [2];
            sub_407440(dword_487E50, v7 + 2448, a2);
            sub_4074A0((_DWORD*) v7);
            *(_DWORD*) (v7 + 3324) = *(_DWORD*) (v7 + 124);
            *(_BYTE*) (v7 + 3647) = a5;
            if(a4 >= 0)
                *(_DWORD*) (v7 + 3300) = a4;
            if(a6 >= 0)
                *(_DWORD*) (v7 + 3308) = a6;
            *(_DWORD*) (v7 + 3304) = *(_DWORD*) (v7 + 3300);
            return v7;
        }
        v7 += 3784;
    }
    return v7;
}
// 487E50: using guessed type _DWORD dword_487E50[2];

//----- (004114C0) --------------------------------------------------------
int __cdecl sub_4114C0(int a1) {
    int result; // eax
    int i; // [esp+0h] [ebp-4h]

    for(i = 0; i < *(_DWORD*) (a1 + 3744); ++i) {
        if(*(_DWORD*) (a1 + 4 * i + 3696)) {
            *(_BYTE*) (*(_DWORD*) (a1 + 4 * i + 3696) + 378) = 1;
            *(_DWORD*) (a1 + 4 * i + 3696) = 0;
        }
        result = i + 1;
    }
    *(_DWORD*) (a1 + 3744) = 0;
    return result;
}

//----- (00411530) --------------------------------------------------------
void __thiscall sub_411530(int* this) {
    int v1; // eax
    int v2; // eax
    int* v3; // edx
    int* v4; // edx
    float v6; // [esp+8h] [ebp-84h]
    float v7; // [esp+Ch] [ebp-80h]
    float v8; // [esp+14h] [ebp-78h]
    float v9; // [esp+18h] [ebp-74h]
    float v10; // [esp+20h] [ebp-6Ch]
    float v11; // [esp+24h] [ebp-68h]
    float v12; // [esp+2Ch] [ebp-60h]
    float v13; // [esp+30h] [ebp-5Ch]
    float v14; // [esp+44h] [ebp-48h] BYREF
    float v15; // [esp+48h] [ebp-44h]
    float v16; // [esp+4Ch] [ebp-40h]
    float v17; // [esp+50h] [ebp-3Ch] BYREF
    float v18; // [esp+54h] [ebp-38h]
    float v19; // [esp+58h] [ebp-34h]
    int v20; // [esp+5Ch] [ebp-30h]
    float v21; // [esp+60h] [ebp-2Ch] BYREF
    float v22; // [esp+64h] [ebp-28h]
    float v23; // [esp+68h] [ebp-24h]
    float v24; // [esp+6Ch] [ebp-20h] BYREF
    float v25; // [esp+70h] [ebp-1Ch]
    float v26; // [esp+74h] [ebp-18h]
    int v27; // [esp+78h] [ebp-14h]
    int v28; // [esp+7Ch] [ebp-10h]
    int v29; // [esp+80h] [ebp-Ch]
    int v30; // [esp+84h] [ebp-8h]
    int v31; // [esp+88h] [ebp-4h]

    if(!this [244087])
        this [244087] = dword_487E58;
    if(!sub_4195A2(dword_69BC30)) {
        v30 = 2400 - 240 * byte_69D4BA;
        if(this [244090] != this [244088] && !(this [244090] % v30))
            sub_41C57E(dword_69BCA0, 0, 100);
    }
    while(*(__int16*) this [244087] >= 0) {
        if(this [244090] == *(__int16*) this [244087]) {
            switch(*(_WORD*) (this [244087] + 4)) {
                case 0:
                    if(!byte_69BC50) {
                        v1 = this [244087];
                        v29 = v1 + 8;
                        sub_411390(
                            (int) this,
                            *(_WORD*) (this [244087] + 2),
                            (_DWORD*) (v1 + 8),
                            *(_WORD*) (v1 + 20),
                            *(_WORD*) (v1 + 22),
                            *(_DWORD*) (v1 + 24));
                    }
                    goto LABEL_72;
                case 1:
                    if(!byte_69BC50)
                        sub_411390((int) this, *(_WORD*) (this [244087] + 2), (_DWORD*) (this [244087] + 8), -1, -1, -1);
                    goto LABEL_72;
                case 2:
                    if(!byte_69BC50) {
                        v2 = this [244087];
                        v28 = v2 + 8;
                        v31 = sub_411390(
                            (int) this,
                            *(_WORD*) (this [244087] + 2),
                            (_DWORD*) (v2 + 8),
                            *(_WORD*) (v2 + 20),
                            *(_WORD*) (v2 + 22),
                            *(_DWORD*) (v2 + 24));
                        *(_BYTE*) (v31 + 3664) |= 0x40u;
                    }
                    goto LABEL_72;
                case 3:
                    if(!byte_69BC50) {
                        v31 = sub_411390((int) this, *(_WORD*) (this [244087] + 2), (_DWORD*) (this [244087] + 8), -1, -1, -1);
                        *(_BYTE*) (v31 + 3664) |= 0x40u;
                    }
                    goto LABEL_72;
                case 4:
                    if(!byte_69BC50) {
                        v27 = this [244087] + 8;
                        v24 = *(float*) v27;
                        v25 = *(float*) (v27 + 4);
                        v26 = *(float*) (v27 + 8);
                        if(*(float*) v27 <= -990.0) {
                            v13 = *(float*) &dword_69D6F4;
                            v24 = sub_41E820(&word_69D8F8) * v13;
                        }
                        if(*(float*) (v27 + 4) <= -990.0) {
                            v12 = *(float*) &dword_69D6F8;
                            v25 = sub_41E820(&word_69D8F8) * v12;
                        }
                        if(*(float*) (v27 + 8) <= -990.0)
                            v26 = sub_41E820(&word_69D8F8) * 800.0;
                        sub_411390(
                            (int) this,
                            *(_WORD*) (this [244087] + 2),
                            &v24,
                            *(_WORD*) (v27 + 12),
                            *(_WORD*) (v27 + 14),
                            *(_DWORD*) (v27 + 16));
                    }
                    goto LABEL_72;
                case 5:
                    if(!byte_69BC50) {
                        v3 = (int*) (this [244087] + 8);
                        v21 = *(float*) v3;
                        v22 = *((float*) v3 + 1);
                        v23 = *((float*) v3 + 2);
                        if(v21 <= -990.0) {
                            v11 = *(float*) &dword_69D6F4;
                            v21 = sub_41E820(&word_69D8F8) * v11;
                        }
                        if(v22 <= -990.0) {
                            v10 = *(float*) &dword_69D6F8;
                            v22 = sub_41E820(&word_69D8F8) * v10;
                        }
                        if(v23 <= -990.0)
                            v23 = sub_41E820(&word_69D8F8) * 800.0;
                        sub_411390((int) this, *(_WORD*) (this [244087] + 2), &v21, -1, -1, -1);
                    }
                    goto LABEL_72;
                case 6:
                    if(!byte_69BC50) {
                        v20 = this [244087] + 8;
                        v17 = *(float*) v20;
                        v18 = *(float*) (v20 + 4);
                        v19 = *(float*) (v20 + 8);
                        if(*(float*) v20 <= -990.0) {
                            v9 = *(float*) &dword_69D6F4;
                            v17 = sub_41E820(&word_69D8F8) * v9;
                        }
                        if(*(float*) (v20 + 4) <= -990.0) {
                            v8 = *(float*) &dword_69D6F8;
                            v18 = sub_41E820(&word_69D8F8) * v8;
                        }
                        if(*(float*) (v20 + 8) <= -990.0)
                            v19 = sub_41E820(&word_69D8F8) * 800.0;
                        v31 = sub_411390(
                            (int) this,
                            *(_WORD*) (this [244087] + 2),
                            &v17,
                            *(_WORD*) (v20 + 12),
                            *(_WORD*) (v20 + 14),
                            *(_DWORD*) (v20 + 16));
                        *(_BYTE*) (v31 + 3664) |= 0x40u;
                    }
                    goto LABEL_72;
                case 7:
                    if(!byte_69BC50) {
                        v4 = (int*) (this [244087] + 8);
                        v14 = *(float*) v4;
                        v15 = *((float*) v4 + 1);
                        v16 = *((float*) v4 + 2);
                        if(v14 <= -990.0) {
                            v7 = *(float*) &dword_69D6F4;
                            v14 = sub_41E820(&word_69D8F8) * v7;
                        }
                        if(v15 <= -990.0) {
                            v6 = *(float*) &dword_69D6F8;
                            v15 = sub_41E820(&word_69D8F8) * v6;
                        }
                        if(v16 <= -990.0)
                            v16 = sub_41E820(&word_69D8F8) * 800.0;
                        v31 = sub_411390((int) this, *(_WORD*) (this [244087] + 2), &v14, -1, -1, -1);
                        *(_BYTE*) (v31 + 3664) |= 0x40u;
                    }
                    goto LABEL_72;
                case 8:
                    if(!dword_69BCB0 && *(_DWORD*) dword_69D6D4 == 5 && *(_WORD*) (this [244087] + 2) == 1)
                        sub_418768((int) dword_69BC30, 1, 10 * (unsigned __int8) byte_69D4BD + 3);
                    else
                        sub_418768(
                            (int) dword_69BC30,
                            this [244087],
                            10 * (unsigned __int8) byte_69D4BD + *(__int16*) (this [244087] + 2));
                    goto LABEL_72;
                case 9:
                    if(!sub_419572(dword_69BC30))
                        goto LABEL_72;
                    break;
                case 0xA:
                    *(_DWORD*) (this [*(_DWORD*) (this [244087] + 8) + 244070] + 3176) = *(_DWORD*) (this [244087] + 12);
                    goto LABEL_72;
                case 0xB:
                    word_69D4B0 = *(_WORD*) (this [244087] + 2);
                    goto LABEL_72;
                case 0xC:
                    if(!this [*(__int16*) (this [244087] + 2) + 244070]
                       || *(char*) (this [*(__int16*) (this [244087] + 2) + 244070] + 3664) >= 0) {
                        goto LABEL_72;
                    }
                    break;
                default:
                    goto LABEL_72;
            }
            sub_4241E5((int) (this + 244088), 1);
            return;
        }
        if(this [244090] < *(__int16*) this [244087])
            break;
        LABEL_72:
        this [244087] += *(__int16*) (this [244087] + 6);
    }
    if(!sub_4195A2(dword_69BC30))
        ++dword_69D70C;
}
// 487E58: using guessed type int dword_487E58;
// 69BC30: using guessed type int dword_69BC30[5];
// 69BC50: using guessed type char byte_69BC50;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D6F4: using guessed type int dword_69D6F4;
// 69D6F8: using guessed type int dword_69D6F8;
// 69D70C: using guessed type int dword_69D70C;
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (00411DA0) --------------------------------------------------------
int __thiscall sub_411DA0(int this) {
    int i; // [esp+4h] [ebp-8h]
    char* v4; // [esp+8h] [ebp-4h]

    if(*(_DWORD*) (this + 3300) >= *(_DWORD*) (this + 3752))
        return 0;
    *(_DWORD*) (this + 3300) = *(_DWORD*) (this + 3752);
    sub_407440(dword_487E50, this + 2448, *(_WORD*) (this + 3756));
    *(_DWORD*) (this + 3752) = -1;
    *(_DWORD*) (this + 3764) = *(_DWORD*) (this + 3140);
    *(_DWORD*) (this + 3284) = -1090519040;
    *(_DWORD*) (this + 3288) = 1056964608;
    *(_WORD*) (this + 3292) = 0;
    *(_WORD*) (this + 3294) = 0;
    *(_WORD*) (this + 3296) = 0;
    *(_WORD*) (this + 3298) = 0;
    *(_DWORD*) (this + 3132) = 0;
    v4 = (char*) &unk_4B8898;
    for(i = 0; i < 256; ++i) {
        if(v4 [3664] < 0 && (v4 [3665] & 8) == 0) {
            *((_DWORD*) v4 + 825) = 0;
            if((v4 [3665] & 1) == 0 && *((int*) v4 + 785) >= 0) {
                sub_407440(dword_487E50, (int) (v4 + 2448), *((_WORD*) v4 + 1570));
                *((_DWORD*) v4 + 785) = -1;
            }
        }
        v4 += 3784;
    }
    return 1;
}
// 487E50: using guessed type _DWORD dword_487E50[2];

//----- (00411F40) --------------------------------------------------------
int __thiscall sub_411F40(int this) {
    int i; // [esp+10h] [ebp-8h]
    char* v4; // [esp+14h] [ebp-4h]

    if((*(_BYTE*) (this + 3665) & 8) != 0)
        dword_69BC48 = (*(_DWORD*) (this + 3760) - *(_DWORD*) (this + 3320)) / 60;
    if(*(_DWORD*) (this + 3320) < *(_DWORD*) (this + 3760))
        return 0;
    if(*(int*) (this + 3752) > 0) {
        *(_DWORD*) (this + 3300) = *(_DWORD*) (this + 3752);
        *(_DWORD*) (this + 3752) = -1;
    }
    sub_407440(dword_487E50, this + 2448, *(_WORD*) (this + 3764));
    *(_DWORD*) (this + 3760) = -1;
    *(_DWORD*) (this + 3764) = *(_DWORD*) (this + 3140);
    *(_DWORD*) (this + 3320) = 0;
    *(_DWORD*) (this + 3316) = 0;
    *(_DWORD*) (this + 3312) = -999;
    if((*(_BYTE*) (this + 3666) & 0x10) == 0) {
        dword_5A5F8C = 0;
        if(dword_5A5F90)
            ++dword_5A5F90;
        sub_414160((char*) dword_5A5FF8, 0);
    }
    v4 = (char*) &unk_4B8898;
    for(i = 0; i < 256; ++i) {
        if(v4 [3664] < 0 && (v4 [3665] & 8) == 0) {
            *((_DWORD*) v4 + 825) = 0;
            if((v4 [3665] & 1) == 0 && *((int*) v4 + 785) >= 0) {
                sub_407440(dword_487E50, (int) (v4 + 2448), *((_WORD*) v4 + 1570));
                *((_DWORD*) v4 + 785) = -1;
            }
        }
        v4 += 3784;
    }
    *(_DWORD*) (this + 3284) = -1090519040;
    *(_DWORD*) (this + 3288) = 1056964608;
    *(_WORD*) (this + 3292) = 0;
    *(_WORD*) (this + 3294) = 0;
    *(_WORD*) (this + 3296) = 0;
    *(_WORD*) (this + 3298) = 0;
    *(_DWORD*) (this + 3132) = 0;
    return 1;
}
// 487E50: using guessed type _DWORD dword_487E50[2];
// 5A5F8C: using guessed type int dword_5A5F8C;
// 5A5F90: using guessed type int dword_5A5F90;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC48: using guessed type int dword_69BC48;

//----- (004121B0) --------------------------------------------------------
int __thiscall sub_4121B0(int this) {
    int result; // eax

    if(((*(_BYTE*) (this + 3665) >> 5) & 7) != 0)
        *(_BYTE*) (this + 3665) &= ~1u;
    else
        *(_BYTE*) (this + 3664) &= ~0x80u;
    result = (*(_BYTE*) (this + 3665) & 8) != 0;
    if((*(_BYTE*) (this + 3665) & 8) != 0)
        byte_69BC50 = 0;
    if(*(_DWORD*) (this + 3744))
        return sub_4114C0(this);
    return result;
}
// 69BC50: using guessed type char byte_69BC50;

//----- (00412240) --------------------------------------------------------
int __fastcall sub_412240(int a1) {
    int result; // eax
    __int16 v2; // fps
    double v3; // st7
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    __int16 v7; // fps
    double v8; // st7
    bool v9; // c0
    char v10; // c2
    bool v11; // c3

    result = a1;
    if((*(_BYTE*) (a1 + 3666) & 1) != 0) {
        if(*(float*) (a1 + 3180) >= (double) *(float*) (a1 + 3680)) {
            v3 = *(float*) (a1 + 3180);
            v4 = v3 < *(float*) (a1 + 3688);
            v5 = 0;
            v6 = v3 == *(float*) (a1 + 3688);
            if((v2 & 0x4100) == 0)
                *(_DWORD*) (a1 + 3180) = *(_DWORD*) (a1 + 3688);
        }
        else {
            *(_DWORD*) (a1 + 3180) = *(_DWORD*) (a1 + 3680);
        }
        if(*(float*) (a1 + 3184) >= (double) *(float*) (a1 + 3684)) {
            v8 = *(float*) (a1 + 3184);
            v9 = v8 < *(float*) (a1 + 3692);
            v10 = 0;
            v11 = v8 == *(float*) (a1 + 3692);
            result = v7 & 0x4100;
            if((v7 & 0x4100) == 0) {
                result = *(_DWORD*) (a1 + 3692);
                *(_DWORD*) (a1 + 3184) = result;
            }
        }
        else {
            result = a1;
            *(_DWORD*) (a1 + 3184) = *(_DWORD*) (a1 + 3684);
        }
    }
    return result;
}

//----- (00412320) --------------------------------------------------------
int __cdecl sub_412320(int a1, int a2) {
    sub_410E30((int) dword_4B79C8);
    dword_4B79C8 [0] = a1;
    dword_4B79C8 [1] = a2;
    dword_5A5FB8 = (int) sub_4123E0;
    dword_5A5FBC = (int) sub_413220;
    dword_5A5FC0 = (int) sub_413320;
    dword_5A5FD0 = (int) dword_4B79C8;
    if(sub_41C860(byte_69D918, (int) &unk_5A5FB4, 9))
        return -1;
    dword_4B79AC = (int) sub_412F10;
    dword_4B79B0 = 0;
    dword_4B79B4 = 0;
    dword_4B79C4 = (int) dword_4B79C8;
    if(sub_41C940((__int16*) byte_69D918, (int) &unk_4B79A8, 6))
        return -1;
    else
        return 0;
}
// 4B79AC: using guessed type int dword_4B79AC;
// 4B79B0: using guessed type int dword_4B79B0;
// 4B79B4: using guessed type int dword_4B79B4;
// 4B79C4: using guessed type int dword_4B79C4;
// 4B79C8: using guessed type _DWORD dword_4B79C8[948];
// 5A5FB8: using guessed type int dword_5A5FB8;
// 5A5FBC: using guessed type int dword_5A5FBC;
// 5A5FC0: using guessed type int dword_5A5FC0;
// 5A5FD0: using guessed type int dword_5A5FD0;

//----- (004123E0) --------------------------------------------------------
int __cdecl sub_4123E0(int a1) {
    int v1; // eax
    float v3; // [esp+0h] [ebp-64h]
    float v4; // [esp+4h] [ebp-60h]
    int v5; // [esp+14h] [ebp-50h]
    float v6; // [esp+24h] [ebp-40h]
    int v7; // [esp+28h] [ebp-3Ch]
    int v8; // [esp+2Ch] [ebp-38h]
    float v9; // [esp+30h] [ebp-34h]
    int v10; // [esp+40h] [ebp-24h]
    int v11; // [esp+44h] [ebp-20h]
    int i; // [esp+48h] [ebp-1Ch]
    int v13 [3]; // [esp+4Ch] [ebp-18h] BYREF
    int v14; // [esp+58h] [ebp-Ch]
    int v15; // [esp+5Ch] [ebp-8h]
    int v16; // [esp+60h] [ebp-4h] BYREF

    v16 = 0;
    sub_411530((int*) a1);
    v10 = a1 + 3792;
    *(_DWORD*) (a1 + 976316) = 0;
    v14 = 0;
    while(v14 < 256) {
        if(*(char*) (v10 + 3664) < 0) {
            ++* (_DWORD*) (a1 + 976316);
            sub_413380(v10);
            sub_412240(v10);
            if((*(_BYTE*) (v10 + 3665) & 4) == 0
               && sub_41B5E1(
               *(float*) (v10 + 3180),
               *(float*) (v10 + 3184),
               *(float*) (*(_DWORD*) (v10 + 192) + 48),
               *(float*) (*(_DWORD*) (v10 + 192) + 44))) {
                *(_BYTE*) (v10 + 3665) |= 4u;
            }
            if((*(_BYTE*) (v10 + 3665) & 4) != 0
               && !sub_41B5E1(
               *(float*) (v10 + 3180),
               *(float*) (v10 + 3184),
               *(float*) (*(_DWORD*) (v10 + 192) + 48),
               *(float*) (*(_DWORD*) (v10 + 192) + 44))) {
                goto LABEL_10;
            }
            if(*(int*) (v10 + 3752) >= 0)
                sub_411DA0(v10);
            if(*(int*) (v10 + 3760) >= 0)
                sub_411F40(v10);
            if(sub_4074A0((_DWORD*) v10) == -1) {
                LABEL_10:
                *(_BYTE*) (v10 + 3664) &= ~0x80u;
                sub_4121B0(v10);
            }
            else {
                sub_412240(v10);
                *(_DWORD*) (v10 + 124) = *(_DWORD*) (v10 + 3324);
                sub_433960((int*) dword_6D4588, v10);
                *(_DWORD*) (v10 + 3324) = *(_DWORD*) (v10 + 124);
                for(i = 0; i < 8; ++i) {
                    if(*(__int16*) (v10 + 272 * i + 452) >= 0) {
                        if(sub_433960((int*) dword_6D4588, v10 + 272 * i + 272))
                            *(_WORD*) (v10 + 272 * i + 452) = -1;
                    }
                }
                v16 = 0;
                if((*(_BYTE*) (v10 + 3665) & 4) != 0 && (*(_BYTE*) (v10 + 3666) & 8) == 0) {
                    v11 = *(_DWORD*) (v10 + 3300);
                    if((*(_BYTE*) (v10 + 3665) & 2) != 0 && (*(_BYTE*) (v10 + 3665) & 1) != 0) {
                        v9 = 1.0 / 1.5;
                        *(float*) &v8 = v9 * *(float*) (v10 + 3200);
                        *(float*) &v7 = v9 * *(float*) (v10 + 3196);
                        v6 = v9 * *(float*) (v10 + 3192);
                        *(float*) v13 = v6;
                        v13 [1] = v7;
                        v13 [2] = v8;
                        if(sub_426C40((int) flt_6CA628, (float*) (v10 + 3180), (float*) v13) == 1
                           && (*(_BYTE*) (v10 + 3665) & 1) != 0
                           && (*(_BYTE*) (v10 + 3665) & 8) == 0) {
                            *(_DWORD*) (v10 + 3300) -= 10;
                        }
                    }
                    if((*(_BYTE*) (v10 + 3665) & 1) != 0) {
                        v15 = sub_4264B0((int) flt_6CA628, (float*) (v10 + 3180), (float*) (v10 + 3192), &v16);
                        if(v15 >= 70)
                            v15 = 70;
                        dword_69BCA4 += 10 * (v15 / 5);
                        if(*(_DWORD*) (a1 + 976328)) {
                            if(v16) {
                                if(*(_DWORD*) (a1 + 976340)) {
                                    if(v15 <= 3)
                                        v15 = v15 != 0;
                                    else
                                        v15 /= 3;
                                }
                                else {
                                    v15 = 0;
                                }
                            }
                            else if(v15 <= 7) {
                                v15 = v15 != 0;
                            }
                            else {
                                v15 /= 7;
                            }
                        }
                        if((*(_BYTE*) (v10 + 3665) & 0x10) != 0)
                            *(_DWORD*) (v10 + 3300) -= v15;
                        if(flt_6CB048 < (double) *(float*) (v10 + 3184)) {
                            dword_6CB044 = *(_DWORD*) (v10 + 3180);
                            flt_6CB048 = *(float*) (v10 + 3184);
                            dword_6CB04C = *(_DWORD*) (v10 + 3188);
                        }
                    }
                    if(*(int*) (v10 + 3300) <= 0 && (*(_BYTE*) (v10 + 3665) & 1) != 0) {
                        *(_DWORD*) (v10 + 3752) = -1;
                        *(_DWORD*) (v10 + 3760) = -1;
                        switch((*(_BYTE*) (v10 + 3665) >> 5) & 7) {
                            case 0:
                                dword_69BCA4 += *(_DWORD*) (v10 + 3308);
                                *(_BYTE*) (v10 + 3664) &= ~0x80u;
                                goto LABEL_53;
                            case 1:
                                dword_69BCA4 += *(_DWORD*) (v10 + 3308);
                                *(_BYTE*) (v10 + 3665) &= ~1u;
                                LABEL_53:
                                if((*(_BYTE*) (v10 + 3665) & 8) != 0) {
                                    byte_69BC50 = 0;
                                    sub_4114C0(v10);
                                }
                                goto LABEL_55;
                            case 2:
                                LABEL_55:
                                if(*(char*) (v10 + 3647) < 0) {
                                    if(*(char*) (v10 + 3647) == -1) {
                                        if(!(*(unsigned __int16*) (a1 + 976312) % 3)) {
                                            sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3645) + 4, (_DWORD*) (v10 + 3180), 6, -1);
                                            sub_41F290(
                                                byte_69E268,
                                                (_DWORD*) (v10 + 3180),
                                                (unsigned __int8) byte_476338 [*(unsigned __int16*) (a1 + 976314)],
                                                v16);
                                            if((unsigned __int16)++ * (_WORD*) (a1 + 976314) >= 0x20u)
                                                *(_WORD*) (a1 + 976314) = 0;
                                        }
                                        ++* (_WORD*) (a1 + 976312);
                                    }
                                }
                                else {
                                    sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3645) + 4, (_DWORD*) (v10 + 3180), 3, -1);
                                    sub_41F290(byte_69E268, (_DWORD*) (v10 + 3180), *(char*) (v10 + 3647), v16);
                                }
                                if((*(_BYTE*) (v10 + 3665) & 8) != 0 && !dword_5A5F90)
                                    sub_414360((char*) dword_5A5FF8, 12800, 0);
                                *(_DWORD*) (v10 + 3300) = 0;
                                break;
                            case 3:
                                *(_DWORD*) (v10 + 3300) = 1;
                                *(_BYTE*) (v10 + 3665) &= ~0x10u;
                                *(_BYTE*) (v10 + 3665) &= 0x1Fu;
                                byte_69BC50 = 0;
                                sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3644), (_DWORD*) (v10 + 3180), 1, -1);
                                sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3644), (_DWORD*) (v10 + 3180), 1, -1);
                                sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3644), (_DWORD*) (v10 + 3180), 1, -1);
                                break;
                            default:
                                break;
                        }
                        sub_4311E0(dword_6D3F50, (int*) (v14 % 2 + 2), 0);
                        sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3644), (_DWORD*) (v10 + 3180), 1, -1);
                        sub_40EF50(dword_487FE0, *(unsigned __int8*) (v10 + 3645) + 4, (_DWORD*) (v10 + 3180), 4, -1);
                        if(*(int*) (v10 + 3140) >= 0) {
                            *(_DWORD*) (v10 + 3284) = -1090519040;
                            *(_DWORD*) (v10 + 3288) = 1056964608;
                            *(_WORD*) (v10 + 3292) = 0;
                            *(_WORD*) (v10 + 3294) = 0;
                            *(_WORD*) (v10 + 3296) = 0;
                            *(_WORD*) (v10 + 3298) = 0;
                            *(_DWORD*) (v10 + 3132) = 0;
                            sub_407440(dword_487E50, v10 + 2448, *(_WORD*) (v10 + 3140));
                            *(_DWORD*) (v10 + 3140) = -1;
                        }
                    }
                    if((*(_BYTE*) (v10 + 3665) & 8) != 0 && !sub_4195A2(dword_69BC30)) {
                        v4 = (float) *(int*) (v10 + 3304);
                        v3 = (float) *(int*) (v10 + 3300);
                        *(float*) &v5 = v3 / v4;
                        dword_69BC54 = v5;
                    }
                    if(*(_BYTE*) (v10 + 3649)) {
                        --* (_BYTE*) (v10 + 3649);
                        *(_DWORD*) (v10 + 128) &= ~8u;
                    }
                    else if(v11 <= *(_DWORD*) (v10 + 3300)) {
                        *(_DWORD*) (v10 + 128) &= ~8u;
                    }
                    else {
                        sub_4311E0(dword_6D3F50, (int*) 0x14, 0);
                        v1 = *(_DWORD*) (v10 + 128);
                        LOBYTE(v1) = v1 | 8;
                        *(_DWORD*) (v10 + 128) = v1;
                        *(_BYTE*) (v10 + 3649) = 4;
                    }
                }
                sub_412E50(v10);
                if(!byte_69BCCC) {
                    *(_DWORD*) (v10 + 3312) = *(_DWORD*) (v10 + 3320);
                    sub_424285((float*) &dword_6C6D18, (_DWORD*) (v10 + 3320), (float*) (v10 + 3316));
                }
            }
        }
        ++v14;
        v10 += 3784;
    }
    *(_DWORD*) (a1 + 976352) = *(_DWORD*) (a1 + 976360);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 976360), (float*) (a1 + 976356));
    return 1;
}
// 487E50: using guessed type _DWORD dword_487E50[2];
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 5A5F90: using guessed type int dword_5A5F90;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BC50: using guessed type char byte_69BC50;
// 69BC54: using guessed type int dword_69BC54;
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCCC: using guessed type char byte_69BCCC;
// 6C6D18: using guessed type int dword_6C6D18;
// 6CA628: using guessed type float flt_6CA628[272];
// 6CB044: using guessed type int dword_6CB044;
// 6CB048: using guessed type float flt_6CB048;
// 6CB04C: using guessed type int dword_6CB04C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00412E50) --------------------------------------------------------
int __cdecl sub_412E50(int a1) {
    int result; // eax
    int i; // [esp+0h] [ebp-8h]
    int v3; // [esp+4h] [ebp-4h]

    for(i = 0; i < *(_DWORD*) (a1 + 3744); ++i) {
        v3 = *(_DWORD*) (a1 + 4 * i + 3696);
        if(v3) {
            *(_DWORD*) (v3 + 308) = *(_DWORD*) (a1 + 3180);
            *(_DWORD*) (v3 + 312) = *(_DWORD*) (a1 + 3184);
            *(_DWORD*) (v3 + 316) = *(_DWORD*) (a1 + 3188);
            if(*(float*) (v3 + 348) < (double) *(float*) (a1 + 3748))
                *(float*) (v3 + 348) = *(float*) (v3 + 348) + 0.30000001;
            *(float*) (v3 + 352) = sub_41E850(*(float*) (v3 + 352), 0.031415928);
        }
        result = i + 1;
    }
    return result;
}

//----- (00412F10) --------------------------------------------------------
int __cdecl sub_412F10(int a1) {
    float v2; // [esp+8h] [ebp-68h]
    float v3; // [esp+Ch] [ebp-64h]
    float v4; // [esp+10h] [ebp-60h]
    float v5; // [esp+1Ch] [ebp-54h]
    float v6; // [esp+20h] [ebp-50h]
    float v7; // [esp+24h] [ebp-4Ch]
    float v8; // [esp+30h] [ebp-40h]
    float v9; // [esp+34h] [ebp-3Ch]
    float v10; // [esp+38h] [ebp-38h]
    unsigned int v11; // [esp+60h] [ebp-10h]
    int j; // [esp+64h] [ebp-Ch]
    int k; // [esp+64h] [ebp-Ch]
    unsigned int v14; // [esp+68h] [ebp-8h]
    int i; // [esp+6Ch] [ebp-4h]

    v11 = a1 + 3792;
    for(i = 0; i < 256; ++i) {
        if(*(char*) (v11 + 3664) < 0 && (*(_BYTE*) (v11 + 3666) & 8) == 0) {
            v14 = v11 + 272;
            for(j = 0; j < 4; ++j) {
                if(*(__int16*) (v14 + 180) >= 0) {
                    if(*(_WORD*) (v14 + 136))
                        *(_DWORD*) (v14 + 8) = *(_DWORD*) (v11 + 3216);
                    v10 = *(float*) (v11 + 3188) + *(float*) (v14 + 236);
                    v9 = *(float*) (v11 + 3184) + *(float*) (v14 + 232);
                    v8 = *(float*) (v11 + 3180) + *(float*) (v14 + 228);
                    *(float*) (v14 + 144) = v8;
                    *(float*) (v14 + 148) = v9;
                    *(float*) (v14 + 152) = v10;
                    *(_DWORD*) (v14 + 152) = 1056796836;
                    sub_433590(dword_6D4588, v14);
                }
                v14 += 272;
            }
            if((*(_BYTE*) (v11 + 3666) & 2) != 0)
                *(_DWORD*) (v11 + 8) = *(_DWORD*) (v11 + 3216);
            v7 = *(float*) (v11 + 3188) + *(float*) (v11 + 236);
            v6 = *(float*) (v11 + 3184) + *(float*) (v11 + 232);
            v5 = *(float*) (v11 + 3180) + *(float*) (v11 + 228);
            *(float*) (v11 + 144) = v5;
            *(float*) (v11 + 148) = v6;
            *(float*) (v11 + 152) = v7;
            *(_DWORD*) (v11 + 152) = 1056763281;
            sub_433590(dword_6D4588, v11);
            for(k = 4; k < 8; ++k) {
                if(*(__int16*) (v14 + 180) >= 0) {
                    if(*(_WORD*) (v14 + 136))
                        *(_DWORD*) (v14 + 8) = *(_DWORD*) (v11 + 3216);
                    v4 = *(float*) (v11 + 3188) + *(float*) (v14 + 236);
                    v3 = *(float*) (v11 + 3184) + *(float*) (v14 + 232);
                    v2 = *(float*) (v11 + 3180) + *(float*) (v14 + 228);
                    *(float*) (v14 + 144) = v2;
                    *(float*) (v14 + 148) = v3;
                    *(float*) (v14 + 152) = v4;
                    *(_DWORD*) (v14 + 152) = 1056796836;
                    sub_433590(dword_6D4588, v14);
                }
                v14 += 272;
            }
        }
        v11 += 3784;
    }
    return 1;
}

//----- (00413220) --------------------------------------------------------
int __cdecl sub_413220(int a1) {
    if(*(_DWORD*) a1 && sub_431DC0((_DWORD*) dword_6D4588, 8, *(char**) a1, 256))
        return -1;
    if(*(_DWORD*) (a1 + 4) && sub_431DC0((_DWORD*) dword_6D4588, 9, *(char**) (a1 + 4), 256))
        return -1;
    *(_WORD*) (a1 + 976312) = (unsigned __int16) sub_41E780(&word_69D8F8) % 3;
    *(_WORD*) (a1 + 976314) = (unsigned __int16) sub_41E780(&word_69D8F8) % 8;
    *(_DWORD*) (a1 + 976328) = 0;
    *(_DWORD*) (a1 + 976348) = 0;
    return 0;
}
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (00413320) --------------------------------------------------------
int sub_413320() {
    sub_432030(dword_6D4588, 9);
    sub_432030(dword_6D4588, 8);
    return 0;
}

//----- (00413350) --------------------------------------------------------
void sub_413350() {
    sub_41CDE0(byte_69D918, (int) &unk_5A5FB4);
    sub_41CDE0(byte_69D918, (int) &unk_4B79A8);
}

//----- (00413380) --------------------------------------------------------
int __thiscall sub_413380(int this) {
    double v1; // st7
    int result; // eax

    if((*(_BYTE*) (this + 3664) & 0x40) != 0)
        v1 = *(float*) (this + 3180) - flt_6C6EC0 * *(float*) (this + 3204);
    else
        v1 = flt_6C6EC0 * *(float*) (this + 3204) + *(float*) (this + 3180);
    *(float*) (this + 3180) = v1;
    *(float*) (this + 3184) = flt_6C6EC0 * *(float*) (this + 3208) + *(float*) (this + 3184);
    result = this;
    *(float*) (this + 3188) = flt_6C6EC0 * *(float*) (this + 3212) + *(float*) (this + 3188);
    return result;
}
// 6C6EC0: using guessed type float flt_6C6EC0;

//----- (00413430) --------------------------------------------------------
int __thiscall sub_413430(void* this) {
    int result; // eax

    result = 0;
    memset(this, 0, 0xF5C18u);
    return result;
}

//----- (00413450) --------------------------------------------------------
_DWORD* __thiscall sub_413450(_DWORD* this) {
    int k; // [esp+8h] [ebp-5Ch]
    int v4; // [esp+10h] [ebp-54h]
    _DWORD* j; // [esp+38h] [ebp-2Ch]
    int v6; // [esp+40h] [ebp-24h]
    char* i; // [esp+48h] [ebp-1Ch]
    int v8; // [esp+50h] [ebp-14h]

    v8 = 16;
    for(i = (char*) this; --v8 >= 0; i += 1376)
        sub_413560(i);
    v6 = 640;
    for(j = this + 5504; --v6 >= 0; j += 369) {
        sub_413560(j);
        sub_424127(j + 359);
    }
    v4 = 64;
    for(k = (int) (this + 241664); --v4 >= 0; k += 624) {
        sub_403720(k);
        sub_403720(k + 272);
        sub_424127((_DWORD*) (k + 604));
    }
    sub_424127(this + 251650);
    sub_413430(this);
    return this;
}

//----- (00413560) --------------------------------------------------------
void* __thiscall sub_413560(void* this) {
    sub_403720((int) this);
    sub_403720((int) this + 272);
    sub_403720((int) this + 544);
    sub_403720((int) this + 816);
    sub_403720((int) this + 1088);
    return this;
}

//----- (004135B0) --------------------------------------------------------
int __thiscall sub_4135B0(_DWORD* this, float* a2, int a3, int a4, float a5) {
    double v6; // st7
    _DWORD* v7; // ecx
    int v8; // eax
    long double v9; // st7
    __int16 v10; // fps
    double v11; // st7
    bool v12; // c0
    char v13; // c2
    bool v14; // c3
    __int16 v15; // fps
    double v16; // st7
    bool v17; // c0
    char v18; // c2
    bool v19; // c3
    float v20; // [esp+8h] [ebp-94h]
    float v21; // [esp+Ch] [ebp-90h]
    float v22; // [esp+14h] [ebp-88h]
    float v23; // [esp+20h] [ebp-7Ch]
    float v24; // [esp+24h] [ebp-78h]
    float v25; // [esp+2Ch] [ebp-70h]
    float v26; // [esp+30h] [ebp-6Ch]
    float v27; // [esp+38h] [ebp-64h]
    float v28; // [esp+3Ch] [ebp-60h]
    float v29; // [esp+44h] [ebp-58h]
    float v30; // [esp+50h] [ebp-4Ch]
    float v31; // [esp+58h] [ebp-44h]
    float v33; // [esp+64h] [ebp-38h]
    float v34; // [esp+68h] [ebp-34h]
    float v35; // [esp+70h] [ebp-2Ch]
    float v36; // [esp+78h] [ebp-24h]
    float v37; // [esp+7Ch] [ebp-20h]
    float v38; // [esp+80h] [ebp-1Ch]
    float v39; // [esp+84h] [ebp-18h]
    float v40; // [esp+88h] [ebp-14h]
    float v41; // [esp+8Ch] [ebp-10h]
    float v42; // [esp+8Ch] [ebp-10h]
    float v43; // [esp+8Ch] [ebp-10h]
    float v44; // [esp+8Ch] [ebp-10h]
    float v45; // [esp+8Ch] [ebp-10h]
    float v46; // [esp+8Ch] [ebp-10h]
    int v47; // [esp+90h] [ebp-Ch]
    int i; // [esp+94h] [ebp-8h]
    float v49; // [esp+98h] [ebp-4h]

    v47 = (int) &this [369 * this [251648] + 5504];
    for(i = 0; i < 640; ++i) {
        if((int)++this [251648] >= 640)
            this [251648] = 0;
        if(!*(_WORD*) (v47 + 1470))
            break;
        v47 += 1476;
        if(!this [251648])
            v47 = (int) (this + 5504);
    }
    if(i >= 640)
        return 1;
    v41 = 0.0;
    v31 = (float) a4;
    v30 = (float) *((__int16*) a2 + 35);
    v49 = a2 [6] - (a2 [6] - a2 [7]) * v31 / v30;
    switch(*((_WORD*) a2 + 36)) {
        case 0:
        case 1:
            if(((_WORD) a2 [17] & 1) != 0) {
                v29 = (float) ((a3 + 1) / 2);
                v6 = v29 * a2 [5] + 0.0;
            }
            else {
                v28 = (float) (a3 / 2);
                v6 = v28 * a2 [5] + a2 [5] * 0.5 + 0.0;
            }
            v42 = v6;
            if((a3 & 1) != 0)
                v42 = v42 * -1.0;
            if(!*((_WORD*) a2 + 36))
                v42 = v42 + a5;
            v41 = v42 + a2 [4];
            break;
        case 2:
            v41 = a5 + 0.0;
            goto LABEL_21;
        case 3:
            LABEL_21:
            v27 = (float) a3;
            v26 = (float) *((__int16*) a2 + 34);
            v43 = v27 * 6.2831855 / v26 + v41;
            v25 = (float) a4;
            v41 = v25 * a2 [5] + a2 [4] + v43;
            break;
        case 4:
            v41 = a5 + 0.0;
            goto LABEL_23;
        case 5:
            LABEL_23:
            v24 = (float) *((__int16*) a2 + 34);
            v44 = 3.1415927 / v24 + v41;
            v23 = (float) a3;
            v45 = v23 * 6.2831855 / v24 + v44;
            v41 = v45 + a2 [4];
            break;
        case 6:
            v40 = a2 [4] - a2 [5];
            v41 = sub_41E820(&word_69D8F8) * v40 + a2 [5];
            break;
        case 7:
            v39 = a2 [6] - a2 [7];
            v49 = sub_41E820(&word_69D8F8) * v39 + a2 [7];
            v22 = (float) a3;
            v21 = (float) *((__int16*) a2 + 34);
            v46 = v22 * 6.2831855 / v21 + 0.0;
            v20 = (float) a4;
            v41 = v20 * a2 [5] + a2 [4] + v46;
            break;
        case 8:
            v38 = a2 [4] - a2 [5];
            v41 = sub_41E820(&word_69D8F8) * v38 + a2 [5];
            v37 = a2 [6] - a2 [7];
            v49 = sub_41E820(&word_69D8F8) * v37 + a2 [7];
            break;
        default:
            break;
    }
    *(_WORD*) (v47 + 1470) = 1;
    *(_BYTE*) (v47 + 1474) = 1;
    *(float*) (v47 + 1412) = v49;
    *(float*) (v47 + 1424) = sub_41E850(v41, 0.0);
    *(float*) (v47 + 1376) = a2 [1];
    *(float*) (v47 + 1380) = a2 [2];
    *(float*) (v47 + 1384) = a2 [3];
    *(_DWORD*) (v47 + 1384) = 1036831949;
    v36 = *(float*) (v47 + 1424);
    *(float*) (v47 + 1388) = cos(v36) * v49;
    *(float*) (v47 + 1392) = sin(v36) * v49;
    *(_WORD*) (v47 + 1464) = *((_WORD*) a2 + 38);
    *(_WORD*) (v47 + 1466) = *((_WORD*) a2 + 1);
    qmemcpy((void*) v47, &this [344 * *(__int16*) a2], 0x110u);
    qmemcpy((void*) (v47 + 1088), &this [344 * *(__int16*) a2 + 272], 0x110u);
    v7 = &this [344 * *(__int16*) a2 + 340];
    *(_DWORD*) (v47 + 1360) = *v7;
    *(_DWORD*) (v47 + 1364) = v7 [1];
    *(_DWORD*) (v47 + 1368) = v7 [2];
    *(_BYTE*) (v47 + 1372) = this [344 * *(__int16*) a2 + 343];
    *(_BYTE*) (v47 + 1373) = BYTE1(this [344 * *(__int16*) a2 + 343]);
    if((*(_WORD*) (v47 + 1464) & 2) != 0) {
        qmemcpy((void*) (v47 + 272), &this [344 * *(__int16*) a2 + 68], 0x110u);
        if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 16.0) {
            if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 32.0) {
                sub_4323A0((int*) dword_6D4588, v47 + 272, *((__int16*) a2 + 1) + *(__int16*) (v47 + 448));
            }
            else if(*(_WORD*) (v47 + 180) == 519) {
                sub_4323A0((int*) dword_6D4588, v47 + 272, *(__int16*) (v47 + 448) + 1);
            }
            else {
                sub_4323A0((int*) dword_6D4588, v47 + 272, dword_476480 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 448));
            }
        }
        else {
            sub_4323A0((int*) dword_6D4588, v47 + 272, dword_476440 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 448));
        }
        *(_WORD*) (v47 + 1470) = 2;
    }
    else if((*(_WORD*) (v47 + 1464) & 4) != 0) {
        qmemcpy((void*) (v47 + 544), &this [344 * *(__int16*) a2 + 136], 0x110u);
        if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 16.0) {
            if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 32.0) {
                sub_4323A0((int*) dword_6D4588, v47 + 544, *((__int16*) a2 + 1) + *(__int16*) (v47 + 720));
            }
            else if(*(_WORD*) (v47 + 180) == 519) {
                sub_4323A0((int*) dword_6D4588, v47 + 544, *(__int16*) (v47 + 720) + 1);
            }
            else {
                sub_4323A0((int*) dword_6D4588, v47 + 544, dword_476480 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 720));
            }
        }
        else {
            sub_4323A0((int*) dword_6D4588, v47 + 544, dword_476440 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 720));
        }
        *(_WORD*) (v47 + 1470) = 3;
    }
    else if((*(_WORD*) (v47 + 1464) & 8) != 0) {
        qmemcpy((void*) (v47 + 816), &this [344 * *(__int16*) a2 + 204], 0x110u);
        if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 16.0) {
            if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 32.0) {
                sub_4323A0((int*) dword_6D4588, v47 + 816, *((__int16*) a2 + 1) + *(__int16*) (v47 + 992));
            }
            else if(*(_WORD*) (v47 + 180) == 519) {
                sub_4323A0((int*) dword_6D4588, v47 + 816, *(__int16*) (v47 + 992) + 1);
            }
            else {
                sub_4323A0((int*) dword_6D4588, v47 + 816, dword_476480 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 992));
            }
        }
        else {
            sub_4323A0((int*) dword_6D4588, v47 + 816, dword_476440 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 992));
        }
        *(_WORD*) (v47 + 1470) = 4;
    }
    sub_4323A0((int*) dword_6D4588, v47, *((__int16*) a2 + 1) + *(__int16*) (v47 + 176));
    if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 16.0) {
        if(*(float*) (*(_DWORD*) (v47 + 192) + 44) > 32.0) {
            sub_4323A0((int*) dword_6D4588, v47 + 1088, *((__int16*) a2 + 1) + *(__int16*) (v47 + 1264));
        }
        else if(*(_WORD*) (v47 + 180) == 519) {
            sub_4323A0((int*) dword_6D4588, v47 + 1088, *(__int16*) (v47 + 1264) + 1);
        }
        else {
            sub_4323A0((int*) dword_6D4588, v47 + 1088, dword_476480 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 1264));
        }
    }
    else {
        sub_4323A0((int*) dword_6D4588, v47 + 1088, dword_476440 [*((__int16*) a2 + 1)] + *(__int16*) (v47 + 1264));
    }
    if((*(_WORD*) (v47 + 1464) & 0x10) != 0) {
        if(a2 [9] > -999.0) {
            v34 = a2 [8];
            v33 = a2 [9];
            v8 = v47 + 1400;
            *(float*) (v47 + 1400) = cos(v33) * v34;
            v9 = sin(v33) * v34;
        }
        else {
            v35 = a2 [8];
            v8 = v47 + 1400;
            *(float*) (v47 + 1400) = cos(v41) * v35;
            v9 = sin(v41) * v35;
        }
        *(float*) (v8 + 4) = v9;
        if(*((int*) a2 + 12) <= 0)
            *(_DWORD*) (v47 + 1448) = 99999;
        else
            *(float*) (v47 + 1448) = a2 [12];
        *(_DWORD*) (v47 + 1408) = 0;
    }
    else if((*(_WORD*) (v47 + 1464) & 0x20) != 0) {
        *(float*) (v47 + 1416) = a2 [8];
        *(float*) (v47 + 1428) = a2 [9];
        *(float*) (v47 + 1448) = a2 [12];
    }
    if((*(_WORD*) (v47 + 1464) & 0x1C0) != 0) {
        *(float*) (v47 + 1432) = a2 [8];
        v11 = a2 [9];
        v12 = v11 < 0.0;
        v13 = 0;
        v14 = v11 == 0.0;
        if((v10 & 0x100) != 0)
            *(float*) (v47 + 1420) = v49;
        else
            *(float*) (v47 + 1420) = a2 [9];
        *(float*) (v47 + 1452) = a2 [12];
        *(float*) (v47 + 1460) = a2 [13];
        *(_DWORD*) (v47 + 1456) = 0;
    }
    if((*(_WORD*) (v47 + 1464) & 0xC00) != 0) {
        v16 = a2 [8];
        v17 = v16 < 0.0;
        v18 = 0;
        v19 = v16 == 0.0;
        if((v15 & 0x100) != 0)
            *(float*) (v47 + 1420) = v49;
        else
            *(float*) (v47 + 1420) = a2 [8];
        *(float*) (v47 + 1460) = a2 [12];
        *(_DWORD*) (v47 + 1456) = 0;
    }
    return 0;
}
// 476440: using guessed type int dword_476440[16];
// 476480: using guessed type int dword_476480[8];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (00414160) --------------------------------------------------------
int __thiscall sub_414160(char* this, int a2) {
    int result; // eax
    __int16 v3; // fps
    double v4; // st7
    bool v5; // c0
    char v6; // c2
    bool v7; // c3
    float v9; // [esp+10h] [ebp-2Ch]
    float v10; // [esp+18h] [ebp-24h]
    float v11; // [esp+1Ch] [ebp-20h]
    char* v12; // [esp+20h] [ebp-1Ch]
    _DWORD* v13; // [esp+24h] [ebp-18h]
    float v14; // [esp+28h] [ebp-14h]
    int i; // [esp+2Ch] [ebp-10h]
    int j; // [esp+2Ch] [ebp-10h]
    float v17 [3]; // [esp+30h] [ebp-Ch] BYREF

    v13 = &unk_5AB5F8;
    for(i = 0; i < 640; ++i) {
        if(*((_WORD*) v13 + 735) && *((_WORD*) v13 + 735) != 5) {
            if(a2) {
                sub_41F290(byte_69E268, v13 + 344, 6, 1);
                memset(v13, 0, 0x5C4u);
            }
            else {
                *((_WORD*) v13 + 735) = 5;
            }
        }
        result = i + 1;
        v13 += 369;
    }
    v12 = this + 966656;
    for(j = 0; j < 64; ++j) {
        if(*((_DWORD*) v12 + 150)) {
            if((unsigned __int8) v12 [620] < 2u) {
                v12 [620] = 2;
                *((_DWORD*) v12 + 153) = 0;
                *((_DWORD*) v12 + 152) = 0;
                *((_DWORD*) v12 + 151) = -999;
                if(a2) {
                    v10 = *((float*) v12 + 140);
                    v9 = *((float*) v12 + 139);
                    v11 = cos(v9);
                    v14 = sin(v9);
                    while(1) {
                        v4 = *((float*) v12 + 141);
                        v5 = v4 < v10;
                        v6 = 0;
                        v7 = v4 == v10;
                        if((v3 & 0x4100) != 0)
                            break;
                        v17 [0] = v11 * v10 + *((float*) v12 + 136);
                        v17 [1] = v14 * v10 + *((float*) v12 + 137);
                        v17 [2] = 0.0;
                        sub_41F290(byte_69E268, v17, 6, 1);
                        v10 = v10 + 32.0;
                    }
                }
            }
            *((_DWORD*) v12 + 149) = 0;
        }
        result = j + 1;
        v12 += 624;
    }
    return result;
}

//----- (00414340) --------------------------------------------------------
int __thiscall sub_414340(char* this) {
    return sub_414160(this, 1);
}

//----- (00414360) --------------------------------------------------------
int __thiscall sub_414360(char* this, int a2, int a3) {
    int v3; // eax
    __int16 v4; // fps
    double v5; // st7
    bool v6; // c0
    char v7; // c2
    bool v8; // c3
    float v11; // [esp+Ch] [ebp-38h]
    float v12; // [esp+14h] [ebp-30h]
    float v13; // [esp+18h] [ebp-2Ch]
    char* v14; // [esp+1Ch] [ebp-28h]
    float v15 [3]; // [esp+20h] [ebp-24h] BYREF
    _DWORD* v16; // [esp+2Ch] [ebp-18h]
    float v17; // [esp+30h] [ebp-14h]
    int v18; // [esp+34h] [ebp-10h]
    int v19; // [esp+38h] [ebp-Ch]
    int v20; // [esp+3Ch] [ebp-8h]
    int v21; // [esp+40h] [ebp-4h]

    v20 = 0;
    v21 = 2000;
    v19 = 0;
    v16 = &unk_5AB5F8;
    v18 = 0;
    while(v18 < 640) {
        if(*((_WORD*) v16 + 735)) {
            if(a3)
                sub_41F290(byte_69E268, v16 + 344, 6, 1);
            v3 = (v21 < a2) - 1;
            LOBYTE(v3) = v3 & 1;
            sub_401940(dword_47B900, v16 + 344, v21, v3 - 1);
            v20 += v21;
            ++v19;
            v21 += 10;
            if(v21 > a2)
                v21 = a2;
            *((_WORD*) v16 + 735) = 5;
        }
        ++v18;
        v16 += 369;
    }
    v14 = this + 966656;
    v18 = 0;
    while(v18 < 64) {
        if(*((_DWORD*) v14 + 150)) {
            if((unsigned __int8) v14 [620] < 2u) {
                v14 [620] = 2;
                *((_DWORD*) v14 + 153) = 0;
                *((_DWORD*) v14 + 152) = 0;
                *((_DWORD*) v14 + 151) = -999;
                if(a3) {
                    sub_41F290(byte_69E268, (_DWORD*) v14 + 136, 6, 1);
                    v12 = *((float*) v14 + 140);
                    v11 = *((float*) v14 + 139);
                    v13 = cos(v11);
                    v17 = sin(v11);
                    while(1) {
                        v5 = *((float*) v14 + 141);
                        v6 = v5 < v12;
                        v7 = 0;
                        v8 = v5 == v12;
                        if((v4 & 0x4100) != 0)
                            break;
                        v15 [0] = v13 * v12 + *((float*) v14 + 136);
                        v15 [1] = v17 * v12 + *((float*) v14 + 137);
                        v15 [2] = 0.0;
                        sub_41F290(byte_69E268, v15, 6, 1);
                        v12 = v12 + 32.0;
                    }
                }
            }
            *((_DWORD*) v14 + 149) = 0;
        }
        ++v18;
        v14 += 624;
    }
    dword_69BCA4 += v20;
    if(v20)
        sub_41735A(dword_69BC30, v20);
    return v20;
}
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BCA4: using guessed type int dword_69BCA4;

//----- (004145C0) --------------------------------------------------------
int __thiscall sub_4145C0(_DWORD* this, int a2) {
    int i; // [esp+4h] [ebp-Ch]
    float v5; // [esp+8h] [ebp-8h]
    int j; // [esp+Ch] [ebp-4h]

    v5 = sub_428700(flt_6CA628, (float*) (a2 + 4));
    for(i = 0; i < *(__int16*) (a2 + 70); ++i) {
        for(j = 0; j < *(__int16*) (a2 + 68); ++j) {
            if(sub_4135B0(this, (float*) a2, j, i, v5))
                goto LABEL_8;
        }
    }
    LABEL_8:
    if((*(_DWORD*) (a2 + 76) & 0x200) != 0)
        sub_4311E0(dword_6D3F50, *(int**) (a2 + 80), 0);
    return 0;
}
// 6CA628: using guessed type float flt_6CA628[272];
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00414670) --------------------------------------------------------
int __thiscall sub_414670(void* this, __int16* a2) {
    int v2; // edx
    int* v4; // [esp+8h] [ebp-1Ch]
    int v5; // [esp+10h] [ebp-14h]
    int* v6; // [esp+14h] [ebp-10h]
    int v7; // [esp+1Ch] [ebp-8h]
    int i; // [esp+20h] [ebp-4h]

    v7 = (int) this + 966656;
    for(i = 0; i < 64; ++i) {
        if(!*(_DWORD*) (v7 + 600)) {
            v2 = *a2;
            v6 = (int*) dword_6D4588;
            *(_WORD*) (v7 + 180) = v2 + 521;
            sub_432430(v6, (_DWORD*) v7, v6 [v2 + 29782]);
            sub_4323A0((int*) dword_6D4588, v7, a2 [1] + *(__int16*) (v7 + 176));
            v5 = dword_476440 [a2 [1]] + 652;
            v4 = (int*) dword_6D4588;
            sub_403580((_DWORD*) (v7 + 272));
            sub_4323A0(v4, v7 + 272, v5);
            *(_DWORD*) (v7 + 400) |= 4u;
            *(_DWORD*) (v7 + 544) = *((_DWORD*) a2 + 1);
            *(_DWORD*) (v7 + 548) = *((_DWORD*) a2 + 2);
            *(_DWORD*) (v7 + 552) = *((_DWORD*) a2 + 3);
            *(_WORD*) (v7 + 618) = a2 [1];
            *(_DWORD*) (v7 + 600) = 1;
            *(_DWORD*) (v7 + 556) = *((_DWORD*) a2 + 4);
            if(!a2 [36])
                *(float*) (v7 + 556) = sub_428700(flt_6CA628, (float*) a2 + 1) + *(float*) (v7 + 556);
            *(_WORD*) (v7 + 616) = a2 [38];
            *(_DWORD*) (v7 + 612) = 0;
            *(_DWORD*) (v7 + 608) = 0;
            *(_DWORD*) (v7 + 604) = -999;
            *(_DWORD*) (v7 + 560) = *((_DWORD*) a2 + 8);
            *(_DWORD*) (v7 + 564) = *((_DWORD*) a2 + 9);
            *(_DWORD*) (v7 + 568) = *((_DWORD*) a2 + 10);
            *(_DWORD*) (v7 + 572) = *((_DWORD*) a2 + 11);
            *(_DWORD*) (v7 + 576) = *((_DWORD*) a2 + 6);
            *(_DWORD*) (v7 + 580) = *((_DWORD*) a2 + 12);
            *(_DWORD*) (v7 + 588) = *((_DWORD*) a2 + 13);
            *(_DWORD*) (v7 + 592) = *((_DWORD*) a2 + 14);
            *(_DWORD*) (v7 + 584) = *((_DWORD*) a2 + 15);
            *(_DWORD*) (v7 + 596) = *((_DWORD*) a2 + 16);
            if(*(_DWORD*) (v7 + 580))
                *(_BYTE*) (v7 + 620) = 0;
            else
                *(_BYTE*) (v7 + 620) = 1;
            return v7;
        }
        v7 += 624;
    }
    return v7;
}
// 476440: using guessed type int dword_476440[16];
// 6CA628: using guessed type float flt_6CA628[272];

//----- (004148F0) --------------------------------------------------------
int __cdecl sub_4148F0(int a1) {
    if((dword_6C6E60 & 1) != 0)
        off_476438 = &unk_4763C8;
    else
        off_476438 = &unk_476358;
    sub_413430(dword_5A5FF8);
    dword_5A5FF8 [251653] = a1;
    dword_69BC14 = (int) sub_4149D0;
    dword_69BC18 = (int) sub_416D60;
    dword_69BC1C = (int) sub_417270;
    dword_69BC2C = (int) dword_5A5FF8;
    if(sub_41C860(byte_69D918, (int) &unk_69BC10, 11))
        return -1;
    dword_5A5FDC = (int) sub_416500;
    dword_5A5FE0 = 0;
    dword_5A5FE4 = 0;
    dword_5A5FF4 = (int) dword_5A5FF8;
    sub_41C940((__int16*) byte_69D918, (int) &unk_5A5FD8, 9);
    return 0;
}
// 476438: using guessed type void *off_476438;
// 5A5FDC: using guessed type int dword_5A5FDC;
// 5A5FE0: using guessed type int dword_5A5FE0;
// 5A5FE4: using guessed type int dword_5A5FE4;
// 5A5FF4: using guessed type int dword_5A5FF4;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC14: using guessed type int dword_69BC14;
// 69BC18: using guessed type int dword_69BC18;
// 69BC1C: using guessed type int dword_69BC1C;
// 69BC2C: using guessed type int dword_69BC2C;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (004149D0) --------------------------------------------------------
int __cdecl sub_4149D0(int a1) {
    float* v2; // eax
    __int16 v3; // ax
    double v4; // st7
    float* v5; // eax
    float* v6; // eax
    __int16 v7; // dx
    float* v8; // eax
    __int16 v9; // ax
    float* v10; // eax
    __int16 v11; // fps
    double v12; // st7
    bool v13; // c0
    char v14; // c2
    bool v15; // c3
    __int16 v16; // fps
    double v17; // st7
    bool v18; // c0
    char v19; // c2
    bool v20; // c3
    float* v21; // eax
    __int16 v22; // ax
    __int16 v23; // fps
    double v24; // st7
    bool v25; // c0
    char v26; // c2
    bool v27; // c3
    float* v28; // eax
    __int16 v29; // ax
    __int16 v30; // fps
    double v31; // st7
    bool v32; // c0
    char v33; // c2
    bool v34; // c3
    __int16 v35; // fps
    double v36; // st7
    bool v37; // c0
    char v38; // c2
    bool v39; // c3
    float v40; // [esp+Ch] [ebp-27Ch]
    float v41; // [esp+14h] [ebp-274h]
    float v42; // [esp+18h] [ebp-270h]
    float v43; // [esp+1Ch] [ebp-26Ch]
    float v44; // [esp+20h] [ebp-268h]
    float v45; // [esp+24h] [ebp-264h]
    float v46; // [esp+28h] [ebp-260h]
    int v47; // [esp+2Ch] [ebp-25Ch]
    float v48; // [esp+30h] [ebp-258h]
    float v49; // [esp+34h] [ebp-254h]
    char v50; // [esp+38h] [ebp-250h]
    float v51; // [esp+3Ch] [ebp-24Ch]
    float v52; // [esp+40h] [ebp-248h]
    float v53; // [esp+44h] [ebp-244h]
    float v54; // [esp+4Ch] [ebp-23Ch]
    float v55; // [esp+50h] [ebp-238h]
    float v56; // [esp+54h] [ebp-234h]
    float v57; // [esp+5Ch] [ebp-22Ch]
    float v58; // [esp+60h] [ebp-228h]
    float v59; // [esp+64h] [ebp-224h]
    float v60; // [esp+6Ch] [ebp-21Ch]
    float v61; // [esp+70h] [ebp-218h]
    int v62; // [esp+7Ch] [ebp-20Ch]
    _DWORD* v63; // [esp+8Ch] [ebp-1FCh]
    _DWORD* v64; // [esp+94h] [ebp-1F4h]
    char* v65; // [esp+A8h] [ebp-1E0h]
    float* v66; // [esp+ACh] [ebp-1DCh]
    float v67; // [esp+B4h] [ebp-1D4h]
    float v68; // [esp+B8h] [ebp-1D0h]
    float v69; // [esp+BCh] [ebp-1CCh]
    float v70; // [esp+C4h] [ebp-1C4h]
    float v71; // [esp+C8h] [ebp-1C0h]
    float v72; // [esp+CCh] [ebp-1BCh]
    float v73; // [esp+D0h] [ebp-1B8h]
    float* v74; // [esp+D4h] [ebp-1B4h]
    float v75; // [esp+E0h] [ebp-1A8h]
    float v76; // [esp+E4h] [ebp-1A4h]
    float v77; // [esp+E8h] [ebp-1A0h]
    float v78; // [esp+F0h] [ebp-198h]
    float v79; // [esp+F8h] [ebp-190h]
    float v80; // [esp+100h] [ebp-188h]
    float v81; // [esp+10Ch] [ebp-17Ch]
    float v82; // [esp+118h] [ebp-170h]
    float v83; // [esp+124h] [ebp-164h]
    float v84; // [esp+128h] [ebp-160h]
    float* v85; // [esp+134h] [ebp-154h]
    float v86; // [esp+140h] [ebp-148h]
    float v87; // [esp+144h] [ebp-144h]
    float v88; // [esp+148h] [ebp-140h]
    float v89; // [esp+150h] [ebp-138h]
    float v90; // [esp+154h] [ebp-134h]
    _DWORD* v91; // [esp+15Ch] [ebp-12Ch]
    float* v92; // [esp+160h] [ebp-128h]
    float v93; // [esp+168h] [ebp-120h]
    float v94; // [esp+16Ch] [ebp-11Ch]
    float v95; // [esp+170h] [ebp-118h]
    float v96; // [esp+178h] [ebp-110h]
    float v97; // [esp+17Ch] [ebp-10Ch]
    float v98; // [esp+180h] [ebp-108h]
    float v99; // [esp+184h] [ebp-104h]
    float* v100; // [esp+188h] [ebp-100h]
    float v101; // [esp+190h] [ebp-F8h]
    float v102; // [esp+194h] [ebp-F4h]
    float v103; // [esp+198h] [ebp-F0h]
    float v104; // [esp+1A0h] [ebp-E8h]
    float v105; // [esp+1A4h] [ebp-E4h]
    float v106; // [esp+1A8h] [ebp-E0h]
    float v107; // [esp+1ACh] [ebp-DCh]
    float* v108; // [esp+1B0h] [ebp-D8h]
    float v109; // [esp+1B8h] [ebp-D0h]
    float v110; // [esp+1BCh] [ebp-CCh]
    float v111; // [esp+1C0h] [ebp-C8h]
    float v112; // [esp+1C8h] [ebp-C0h]
    float v113; // [esp+1CCh] [ebp-BCh]
    float v114; // [esp+1D0h] [ebp-B8h]
    float v115; // [esp+1D4h] [ebp-B4h]
    int v116 [3]; // [esp+254h] [ebp-34h] BYREF
    int v117; // [esp+260h] [ebp-28h]
    int v118; // [esp+264h] [ebp-24h]
    float* v119; // [esp+268h] [ebp-20h]
    int v120 [3]; // [esp+26Ch] [ebp-1Ch] BYREF
    float v121; // [esp+278h] [ebp-10h]
    float v122; // [esp+27Ch] [ebp-Ch]
    int v123; // [esp+280h] [ebp-8h]
    int v124; // [esp+284h] [ebp-4h]

    v119 = (float*) (a1 + 22016);
    if(byte_69BCCC)
        return 1;
    sub_41F4A0((int) byte_69E268);
    *(_DWORD*) (a1 + 1006596) = 0;
    v123 = 0;
    while(v123 < 640) {
        if(*((_WORD*) v119 + 735)) {
            ++* (_DWORD*) (a1 + 1006596);
            switch(*((_WORD*) v119 + 735)) {
                case 1:
                    goto LABEL_14;
                case 2:
                    v115 = 1.0 / 2.0;
                    v114 = v115 * v119 [349];
                    v113 = v115 * v119 [348];
                    v112 = v115 * v119 [347];
                    v111 = v114 * flt_6C6EC0;
                    v110 = v113 * flt_6C6EC0;
                    v109 = v112 * flt_6C6EC0;
                    v108 = v119 + 344;
                    v119 [344] = v109 + v119 [344];
                    v108 [1] = v110 + v108 [1];
                    v108 [2] = v111 + v108 [2];
                    if(sub_433960((int*) dword_6D4588, (int) (v119 + 68)))
                        goto LABEL_13;
                    goto LABEL_92;
                case 3:
                    v107 = 1.0 / 2.5;
                    v106 = v107 * v119 [349];
                    v105 = v107 * v119 [348];
                    v104 = v107 * v119 [347];
                    v103 = v106 * flt_6C6EC0;
                    v102 = v105 * flt_6C6EC0;
                    v101 = v104 * flt_6C6EC0;
                    v100 = v119 + 344;
                    v119 [344] = v101 + v119 [344];
                    v100 [1] = v102 + v100 [1];
                    v100 [2] = v103 + v100 [2];
                    if(sub_433960((int*) dword_6D4588, (int) (v119 + 136)))
                        goto LABEL_13;
                    goto LABEL_92;
                case 4:
                    v99 = 1.0 / 3.0;
                    v98 = v99 * v119 [349];
                    v97 = v99 * v119 [348];
                    v96 = v99 * v119 [347];
                    v95 = v98 * flt_6C6EC0;
                    v94 = v97 * flt_6C6EC0;
                    v93 = v96 * flt_6C6EC0;
                    v92 = v119 + 344;
                    v119 [344] = v93 + v119 [344];
                    v92 [1] = v94 + v92 [1];
                    v92 [2] = v95 + v92 [2];
                    if(!sub_433960((int*) dword_6D4588, (int) (v119 + 204)))
                        goto LABEL_92;
                    LABEL_13:
                    *((_WORD*) v119 + 735) = 1;
                    v91 = v119 + 359;
                    v119 [361] = 0.0;
                    v91 [1] = 0;
                    *v91 = -999;
                    LABEL_14:
                    if(*((_WORD*) v119 + 732)) {
                        if(((_WORD) v119 [366] & 1) != 0) {
                            if(*((int*) v119 + 361) > 16) {
                                *((_WORD*) v119 + 732) ^= 1u;
                            }
                            else {
                                v61 = (float) *((int*) v119 + 361);
                                v122 = 5.0 - (v61 + v119 [360]) * 5.0 / 16.0;
                                v90 = v122 + v119 [353];
                                v89 = v119 [356];
                                v2 = v119 + 347;
                                v119 [347] = cos(v89) * v90;
                                v2 [1] = sin(v89) * v90;
                            }
                        }
                        else if(((_WORD) v119 [366] & 0x10) != 0) {
                            if(*((_DWORD*) v119 + 361) < *((_DWORD*) v119 + 362)) {
                                v88 = flt_6C6EC0 * v119 [352];
                                v87 = flt_6C6EC0 * v119 [351];
                                v86 = flt_6C6EC0 * v119 [350];
                                v85 = v119 + 347;
                                v119 [347] = v86 + v119 [347];
                                v85 [1] = v87 + v85 [1];
                                v85 [2] = v88 + v85 [2];
                                v4 = v119 [348];
                                sub_45BE40(v4, v119 [347]);
                                v60 = v4;
                                v119 [356] = v60;
                            }
                            else {
                                v3 = *((_WORD*) v119 + 732);
                                LOBYTE(v3) = v3 & 0xEF;
                                *((_WORD*) v119 + 732) = v3;
                            }
                        }
                        else if(((_WORD) v119 [366] & 0x20) != 0) {
                            if(*((_DWORD*) v119 + 361) < *((_DWORD*) v119 + 362)) {
                                v40 = flt_6C6EC0 * v119 [357];
                                v119 [356] = sub_41E850(v119 [356], v40);
                                v119 [353] = flt_6C6EC0 * v119 [354] + v119 [353];
                                v84 = v119 [353];
                                v83 = v119 [356];
                                v5 = v119 + 347;
                                v119 [347] = cos(v83) * v84;
                                v5 [1] = sin(v83) * v84;
                            }
                            else {
                                *((_WORD*) v119 + 732) &= ~0x20u;
                            }
                        }
                        if(((_WORD) v119 [366] & 0x40) != 0) {
                            if(*((_DWORD*) v119 + 361) < (*((_DWORD*) v119 + 364) + 1) * *((_DWORD*) v119 + 363)) {
                                v59 = (float) (*((_DWORD*) v119 + 364) * *((_DWORD*) v119 + 363));
                                v58 = (float) *((int*) v119 + 361);
                                v57 = (float) *((int*) v119 + 363);
                                v122 = v119 [353] - (v58 + v119 [360] - v59) * v119 [353] / v57;
                            }
                            else {
                                if(++ * ((_DWORD*) v119 + 364) >= *((_DWORD*) v119 + 365))
                                    *((_WORD*) v119 + 732) &= ~0x40u;
                                v119 [356] = v119 [356] + v119 [358];
                                v119 [353] = v119 [355];
                                v122 = v119 [353];
                            }
                            v82 = v119 [356];
                            v6 = v119 + 347;
                            v119 [347] = cos(v82) * v122;
                            v6 [1] = sin(v82) * v122;
                        }
                        else if(((_WORD) v119 [366] & 0x100) != 0) {
                            if(*((_DWORD*) v119 + 361) < (*((_DWORD*) v119 + 364) + 1) * *((_DWORD*) v119 + 363)) {
                                v56 = (float) (*((_DWORD*) v119 + 364) * *((_DWORD*) v119 + 363));
                                v55 = (float) *((int*) v119 + 361);
                                v54 = (float) *((int*) v119 + 363);
                                v122 = v119 [353] - (v55 + v119 [360] - v56) * v119 [353] / v54;
                            }
                            else {
                                if(++ * ((_DWORD*) v119 + 364) >= *((_DWORD*) v119 + 365)) {
                                    v7 = *((_WORD*) v119 + 732);
                                    HIBYTE(v7) &= ~1u;
                                    *((_WORD*) v119 + 732) = v7;
                                }
                                v119 [356] = v119 [358];
                                v119 [353] = v119 [355];
                                v122 = v119 [353];
                            }
                            v81 = v119 [356];
                            v8 = v119 + 347;
                            v119 [347] = cos(v81) * v122;
                            v8 [1] = sin(v81) * v122;
                        }
                        else if(((_WORD) v119 [366] & 0x80) != 0) {
                            if(*((_DWORD*) v119 + 361) < (*((_DWORD*) v119 + 364) + 1) * *((_DWORD*) v119 + 363)) {
                                v53 = (float) (*((_DWORD*) v119 + 364) * *((_DWORD*) v119 + 363));
                                v52 = (float) *((int*) v119 + 361);
                                v51 = (float) *((int*) v119 + 363);
                                v122 = v119 [353] - (v52 + v119 [360] - v53) * v119 [353] / v51;
                            }
                            else {
                                if(++ * ((_DWORD*) v119 + 364) >= *((_DWORD*) v119 + 365)) {
                                    v9 = *((_WORD*) v119 + 732);
                                    LOBYTE(v9) = v9 & 0x7F;
                                    *((_WORD*) v119 + 732) = v9;
                                }
                                v119 [356] = sub_428700(flt_6CA628, v119 + 344) + v119 [358];
                                v119 [353] = v119 [355];
                                v122 = v119 [353];
                            }
                            v80 = v119 [356];
                            v10 = v119 + 347;
                            v119 [347] = cos(v80) * v122;
                            v10 [1] = sin(v80) * v122;
                        }
                        else if(((_WORD) v119 [366] & 0x400) != 0) {
                            if(!sub_41B5E1(
                                v119 [344],
                                v119 [345],
                                *(float*) (*((_DWORD*) v119 + 48) + 48),
                                *(float*) (*((_DWORD*) v119 + 48) + 44))) {
                                if(v119 [344] < 0.0
                                   || (v12 = v119 [344], v13 = v12 < 384.0, v14 = 0, v15 = v12 == 384.0, (v11 & 0x100) == 0)) {
                                    v119 [356] = -v119 [356] - 3.1415927;
                                    v119 [356] = sub_41E850(v119 [356], 0.0);
                                }
                                if(v119 [345] < 0.0
                                   || (v17 = v119 [345], v18 = v17 < 448.0, v19 = 0, v20 = v17 == 448.0, (v16 & 0x100) == 0)) {
                                    v119 [356] = -v119 [356];
                                }
                                v119 [353] = v119 [355];
                                v122 = v119 [353];
                                v79 = v119 [356];
                                v21 = v119 + 347;
                                v119 [347] = cos(v79) * v122;
                                v21 [1] = sin(v79) * v122;
                                if(++ * ((_DWORD*) v119 + 364) >= *((_DWORD*) v119 + 365)) {
                                    v22 = *((_WORD*) v119 + 732);
                                    HIBYTE(v22) &= ~4u;
                                    *((_WORD*) v119 + 732) = v22;
                                }
                            }
                        }
                        else if(((_WORD) v119 [366] & 0x800) != 0
                                && !sub_41B5E1(
                                v119 [344],
                                v119 [345],
                                *(float*) (*((_DWORD*) v119 + 48) + 48),
                                *(float*) (*((_DWORD*) v119 + 48) + 44))) {
                            if(v119 [344] < 0.0
                               || (v24 = v119 [344], v25 = v24 < 384.0, v26 = 0, v27 = v24 == 384.0, (v23 & 0x100) == 0)) {
                                v119 [356] = -v119 [356] - 3.1415927;
                                v119 [356] = sub_41E850(v119 [356], 0.0);
                            }
                            if(v119 [345] < 0.0)
                                v119 [356] = -v119 [356];
                            v119 [353] = v119 [355];
                            v122 = v119 [353];
                            v78 = v119 [356];
                            v28 = v119 + 347;
                            v119 [347] = cos(v78) * v122;
                            v28 [1] = sin(v78) * v122;
                            if(++ * ((_DWORD*) v119 + 364) >= *((_DWORD*) v119 + 365)) {
                                v29 = *((_WORD*) v119 + 732);
                                HIBYTE(v29) &= ~8u;
                                *((_WORD*) v119 + 732) = v29;
                            }
                        }
                    }
                    v77 = flt_6C6EC0 * v119 [349];
                    v76 = flt_6C6EC0 * v119 [348];
                    v75 = flt_6C6EC0 * v119 [347];
                    v74 = v119 + 344;
                    v119 [344] = v75 + v119 [344];
                    v74 [1] = v76 + v74 [1];
                    v74 [2] = v77 + v74 [2];
                    if(sub_41B5E1(
                        v119 [344],
                        v119 [345],
                        *(float*) (*((_DWORD*) v119 + 48) + 48),
                        *(float*) (*((_DWORD*) v119 + 48) + 44))) {
                        *((_WORD*) v119 + 736) = 0;
                    }
                    else if(((_WORD) v119 [366] & 0x40) == 0
                            && ((_WORD) v119 [366] & 0x100) == 0
                            && ((_WORD) v119 [366] & 0x80) == 0
                            && ((_WORD) v119 [366] & 0x400) == 0
                            && ((_WORD) v119 [366] & 0x800) == 0
                            && !*((_WORD*) v119 + 736)
                            || (++ * ((_WORD*) v119 + 736), *((unsigned __int16*) v119 + 736) >= 0x100u)) {
                        LABEL_91:
                        memset(v119, 0, 0x5C4u);
                        break;
                    }
                    if(*((_BYTE*) v119 + 1475)) {
                        if(*((_BYTE*) v119 + 1475) != 1)
                            goto LABEL_89;
                        goto LABEL_86;
                    }
                    v124 = sub_426DF0((int) flt_6CA628, v119 + 344, v119 + 340);
                    if(v124 == 1) {
                        *((_BYTE*) v119 + 1475) = 1;
                        LABEL_86:
                        v124 = sub_426C40((int) flt_6CA628, v119 + 344, v119 + 340);
                        if(v124) {
                            *((_WORD*) v119 + 735) = 5;
                            if(v124 == 2)
                                sub_41F290(byte_69E268, (_DWORD*) v119 + 344, 6, 1);
                        }
                        goto LABEL_89;
                    }
                    if(v124 == 2) {
                        *((_WORD*) v119 + 735) = 5;
                        sub_41F290(byte_69E268, (_DWORD*) v119 + 344, 6, 1);
                    }
                    LABEL_89:
                    sub_433960((int*) dword_6D4588, (int) v119);
                    LABEL_92:
                    v65 = (char*) (v119 + 359);
                    v119 [359] = v119 [361];
                    sub_424285((float*) &dword_6C6D18, (_DWORD*) v65 + 2, (float*) v65 + 1);
                    break;
                case 5:
                    v73 = 1.0 / 2.0;
                    v72 = v73 * v119 [349];
                    v71 = v73 * v119 [348];
                    v70 = v73 * v119 [347];
                    v69 = v72 * flt_6C6EC0;
                    v68 = v71 * flt_6C6EC0;
                    v67 = v70 * flt_6C6EC0;
                    v66 = v119 + 344;
                    v119 [344] = v67 + v119 [344];
                    v66 [1] = v68 + v66 [1];
                    v66 [2] = v69 + v66 [2];
                    if(sub_433960((int*) dword_6D4588, (int) (v119 + 272)))
                        goto LABEL_91;
                    goto LABEL_92;
                default:
                    goto LABEL_92;
            }
        }
        ++v123;
        v119 += 369;
    }
    v117 = a1 + 966656;
    v123 = 0;
    while(v123 < 64) {
        if(!*(_DWORD*) (v117 + 600))
            goto LABEL_94;
        *(float*) (v117 + 564) = flt_6C6EC0 * *(float*) (v117 + 576) + *(float*) (v117 + 564);
        v31 = *(float*) (v117 + 564) - *(float*) (v117 + 560);
        v32 = v31 < *(float*) (v117 + 568);
        v33 = 0;
        v34 = v31 == *(float*) (v117 + 568);
        if((v30 & 0x4100) == 0)
            *(float*) (v117 + 560) = *(float*) (v117 + 564) - *(float*) (v117 + 568);
        if(*(float*) (v117 + 560) < 0.0)
            *(_DWORD*) (v117 + 560) = 0;
        *(float*) &v120 [1] = *(float*) (v117 + 572) / 2.0;
        *(float*) v120 = *(float*) (v117 + 564) - *(float*) (v117 + 560);
        *(float*) v116 = (*(float*) (v117 + 564) - *(float*) (v117 + 560)) / 2.0
            + *(float*) (v117 + 560)
            + *(float*) (v117 + 544);
        v116 [1] = *(_DWORD*) (v117 + 548);
        *(float*) (v117 + 28) = *(float*) (v117 + 572) / *(float*) (*(_DWORD*) (v117 + 192) + 48);
        v121 = *(float*) (v117 + 564) - *(float*) (v117 + 560);
        *(float*) (v117 + 24) = v121 / *(float*) (*(_DWORD*) (v117 + 192) + 44);
        *(float*) (v117 + 8) = 1.5707964 - *(float*) (v117 + 556);
        v50 = *(_BYTE*) (v117 + 620);
        if(v50) {
            if(v50 != 1) {
                if(v50 != 2)
                    goto LABEL_133;
                goto LABEL_123;
            }
        }
        else {
            if((*(_WORD*) (v117 + 616) & 1) != 0) {
                v49 = (float) *(int*) (v117 + 612);
                v48 = (float) *(int*) (v117 + 580);
                v118 = (unsigned __int64) ((v49 + *(float*) (v117 + 608)) * 255.0 / v48);
                if(v118 > 255)
                    v118 = 255;
                *(_DWORD*) (v117 + 124) = v118 << 24;
            }
            else {
                if(*(int*) (v117 + 580) <= 30)
                    v47 = *(_DWORD*) (v117 + 580);
                else
                    v47 = 30;
                if(*(_DWORD*) (v117 + 580) - v47 >= *(_DWORD*) (v117 + 612)) {
                    v121 = 1.2;
                }
                else {
                    v46 = (float) *(int*) (v117 + 612);
                    v45 = (float) *(int*) (v117 + 580);
                    v121 = (v46 + *(float*) (v117 + 608)) * *(float*) (v117 + 572) / v45;
                }
                *(float*) (v117 + 28) = v121 / 16.0;
                *(float*) v120 = v121 / 2.0;
            }
            if(*(_DWORD*) (v117 + 612) >= *(_DWORD*) (v117 + 584))
                sub_427190(
                    (int) flt_6CA628,
                    (float*) v116,
                    (float*) v120,
                    (float*) (v117 + 544),
                    *(float*) (v117 + 556),
                    *(_DWORD*) (v117 + 612) % 12 == 0);
            if(*(_DWORD*) (v117 + 612) < *(_DWORD*) (v117 + 580))
                goto LABEL_133;
            v64 = (_DWORD*) (v117 + 604);
            *(_DWORD*) (v117 + 612) = 0;
            v64 [1] = 0;
            *v64 = -999;
            ++* (_BYTE*) (v117 + 620);
        }
        sub_427190(
            (int) flt_6CA628,
            (float*) v116,
            (float*) v120,
            (float*) (v117 + 544),
            *(float*) (v117 + 556),
            *(_DWORD*) (v117 + 612) % 12 == 0);
        if(*(_DWORD*) (v117 + 612) < *(_DWORD*) (v117 + 588))
            goto LABEL_133;
        v63 = (_DWORD*) (v117 + 604);
        *(_DWORD*) (v117 + 612) = 0;
        v63 [1] = 0;
        *v63 = -999;
        ++* (_BYTE*) (v117 + 620);
        if(!*(_DWORD*) (v117 + 592)) {
            *(_DWORD*) (v117 + 600) = 0;
            goto LABEL_94;
        }
        LABEL_123:
        if((*(_WORD*) (v117 + 616) & 1) != 0) {
            v44 = (float) *(int*) (v117 + 612);
            v43 = (float) *(int*) (v117 + 580);
            v118 = (unsigned __int64) ((v44 + *(float*) (v117 + 608)) * 255.0 / v43);
            if(v118 > 255)
                v118 = 255;
            *(_DWORD*) (v117 + 124) = v118 << 24;
        }
        else if(*(int*) (v117 + 592) > 0) {
            v42 = (float) *(int*) (v117 + 612);
            v41 = (float) *(int*) (v117 + 592);
            v121 = *(float*) (v117 + 572) - (v42 + *(float*) (v117 + 608)) * *(float*) (v117 + 572) / v41;
            *(float*) (v117 + 28) = v121 / 16.0;
            *(float*) v120 = v121 / 2.0;
        }
        if(*(_DWORD*) (v117 + 612) < *(_DWORD*) (v117 + 596))
            sub_427190(
                (int) flt_6CA628,
                (float*) v116,
                (float*) v120,
                (float*) (v117 + 544),
                *(float*) (v117 + 556),
                *(_DWORD*) (v117 + 612) % 12 == 0);
        if(*(_DWORD*) (v117 + 612) >= *(_DWORD*) (v117 + 592)) {
            *(_DWORD*) (v117 + 600) = 0;
            goto LABEL_94;
        }
        LABEL_133:
        v36 = *(float*) (v117 + 560);
        v37 = v36 < 640.0;
        v38 = 0;
        v39 = v36 == 640.0;
        if((v35 & 0x100) == 0)
            *(_DWORD*) (v117 + 600) = 0;
        v62 = v117 + 604;
        *(_DWORD*) (v117 + 604) = *(_DWORD*) (v117 + 612);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (v62 + 8), (float*) (v62 + 4));
        sub_433960((int*) dword_6D4588, v117);
        LABEL_94:
        ++v123;
        v117 += 624;
    }
    *(_DWORD*) (a1 + 1006600) = *(_DWORD*) (a1 + 1006608);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 1006608), (float*) (a1 + 1006604));
    return 1;
}
// 69BCCC: using guessed type char byte_69BCCC;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6CA628: using guessed type float flt_6CA628[272];

//----- (00416500) --------------------------------------------------------
int __cdecl sub_416500(int a1) {
    int v1; // eax
    float v3; // [esp+8h] [ebp-20h]
    unsigned int v4; // [esp+Ch] [ebp-1Ch]
    unsigned int v5; // [esp+Ch] [ebp-1Ch]
    unsigned int v6; // [esp+Ch] [ebp-1Ch]
    unsigned int v7; // [esp+Ch] [ebp-1Ch]
    unsigned int v8; // [esp+10h] [ebp-18h]
    unsigned int v9; // [esp+10h] [ebp-18h]
    unsigned int v10; // [esp+10h] [ebp-18h]
    unsigned int v11; // [esp+10h] [ebp-18h]
    float v12; // [esp+14h] [ebp-14h]
    float v13; // [esp+18h] [ebp-10h]
    unsigned int v14; // [esp+1Ch] [ebp-Ch]
    float v15; // [esp+20h] [ebp-8h]
    int i; // [esp+24h] [ebp-4h]
    int j; // [esp+24h] [ebp-4h]
    int k; // [esp+24h] [ebp-4h]
    int m; // [esp+24h] [ebp-4h]
    int n; // [esp+24h] [ebp-4h]
    int ii; // [esp+24h] [ebp-4h]
    int jj; // [esp+24h] [ebp-4h]
    int kk; // [esp+24h] [ebp-4h]
    int mm; // [esp+24h] [ebp-4h]

    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 8);
    v14 = a1 + 966656;
    for(i = 0; i < 64; ++i) {
        if(*(_DWORD*) (v14 + 600)) {
            v3 = *(float*) (v14 + 556);
            v12 = cos(v3);
            v15 = sin(v3);
            v13 = (*(float*) (v14 + 564) - *(float*) (v14 + 560)) / 2.0 + *(float*) (v14 + 560);
            *(float*) (v14 + 144) = v12 * v13 + *(float*) (v14 + 544);
            *(float*) (v14 + 148) = v15 * v13 + *(float*) (v14 + 548);
            *(_DWORD*) (v14 + 152) = 0;
            *(_WORD*) (v14 + 618) = -1;
            sub_433150(dword_6D4588, v14);
            if(*(float*) (v14 + 560) < 16.0 || *(float*) (v14 + 576) == 0.0) {
                *(float*) (v14 + 416) = v12 * *(float*) (v14 + 560) + *(float*) (v14 + 544);
                *(float*) (v14 + 420) = v15 * *(float*) (v14 + 560) + *(float*) (v14 + 548);
                *(_DWORD*) (v14 + 424) = 0;
                *(_DWORD*) (v14 + 396) = *(_DWORD*) (v14 + 124);
                v1 = *(_DWORD*) (v14 + 400);
                LOBYTE(v1) = v1 | 8;
                *(_DWORD*) (v14 + 400) = v1;
                *(_DWORD*) (v14 + 396) = *(_DWORD*) (v14 + 396) & 0xFFFFFF | 0xFF000000;
                *(float*) (v14 + 300) = *(float*) (v14 + 572) / 10.0 * ((16.0 - *(float*) (v14 + 560)) / 16.0);
                *(_DWORD*) (v14 + 296) = *(_DWORD*) (v14 + 300);
                if(*(float*) (v14 + 296) < 0.0) {
                    *(float*) (v14 + 300) = *(float*) (v14 + 572) / 10.0;
                    *(_DWORD*) (v14 + 296) = *(_DWORD*) (v14 + 300);
                }
                sub_433150(dword_6D4588, v14 + 272);
            }
        }
        v14 += 624;
    }
    sub_420190(byte_69E268);
    if(byte_6C7114) {
        v8 = a1 + 22016;
        for(j = 0; j < 640; ++j) {
            if(*(_WORD*) (v8 + 1470) && *(unsigned __int8*) (v8 + 1373) > 0x10u)
                sub_416B50(v8);
            v8 += 1476;
        }
        v9 = a1 + 22016;
        for(k = 0; k < 640; ++k) {
            if(*(_WORD*) (v9 + 1470)
               && *(_BYTE*) (v9 + 1373) == 16
               && (*(_WORD*) (v9 + 180) == 513 || *(_WORD*) (v9 + 180) == 515)) {
                sub_416B50(v9);
            }
            v9 += 1476;
        }
        v10 = a1 + 22016;
        for(m = 0; m < 640; ++m) {
            if(*(_WORD*) (v10 + 1470)
               && *(_BYTE*) (v10 + 1373) == 16
               && *(_WORD*) (v10 + 180) != 513
               && *(_WORD*) (v10 + 180) != 515) {
                sub_416B50(v10);
            }
            v10 += 1476;
        }
        v11 = a1 + 22016;
        for(n = 0; n < 640; ++n) {
            if(*(_WORD*) (v11 + 1470) && *(_BYTE*) (v11 + 1373) == 8)
                sub_416B50(v11);
            v11 += 1476;
        }
    }
    else {
        v4 = a1 + 22016;
        for(ii = 0; ii < 640; ++ii) {
            if(*(_WORD*) (v4 + 1470) && *(unsigned __int8*) (v4 + 1373) > 0x10u)
                sub_416C50(v4);
            v4 += 1476;
        }
        v5 = a1 + 22016;
        for(jj = 0; jj < 640; ++jj) {
            if(*(_WORD*) (v5 + 1470)
               && *(_BYTE*) (v5 + 1373) == 16
               && (*(_WORD*) (v5 + 180) == 513 || *(_WORD*) (v5 + 180) == 515)) {
                sub_416C50(v5);
            }
            v5 += 1476;
        }
        v6 = a1 + 22016;
        for(kk = 0; kk < 640; ++kk) {
            if(*(_WORD*) (v6 + 1470)
               && *(_BYTE*) (v6 + 1373) == 16
               && *(_WORD*) (v6 + 180) != 513
               && *(_WORD*) (v6 + 180) != 515) {
                sub_416C50(v6);
            }
            v6 += 1476;
        }
        v7 = a1 + 22016;
        for(mm = 0; mm < 640; ++mm) {
            if(*(_WORD*) (v7 + 1470) && *(_BYTE*) (v7 + 1373) == 8)
                sub_416C50(v7);
            v7 += 1476;
        }
    }
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 4);
    return 1;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C7114: using guessed type char byte_6C7114;

//----- (00416B50) --------------------------------------------------------
int __cdecl sub_416B50(unsigned int a1) {
    unsigned int v2; // [esp+4h] [ebp-4h]

    switch(*(_WORD*) (a1 + 1470)) {
        case 2:
            v2 = a1 + 272;
            break;
        case 3:
            v2 = a1 + 544;
            break;
        case 4:
            v2 = a1 + 816;
            break;
        case 5:
            v2 = a1 + 1088;
            break;
        default:
            v2 = a1;
            break;
    }
    *(_DWORD*) (v2 + 144) = *(_DWORD*) (a1 + 1376);
    *(_DWORD*) (v2 + 148) = *(_DWORD*) (a1 + 1380);
    *(_DWORD*) (v2 + 152) = 0;
    *(_DWORD*) (v2 + 124) = *(_DWORD*) (v2 + 124) & 0xFF000000 | 0xFFFFFF;
    if(*(_WORD*) (v2 + 136))
        *(float*) (v2 + 8) = 1.5707964 - *(float*) (a1 + 1424);
    return sub_433590(dword_6D4588, v2);
}

//----- (00416C50) --------------------------------------------------------
int __cdecl sub_416C50(unsigned int a1) {
    unsigned int v2; // [esp+4h] [ebp-4h]

    switch(*(_WORD*) (a1 + 1470)) {
        case 2:
            v2 = a1 + 272;
            break;
        case 3:
            v2 = a1 + 544;
            break;
        case 4:
            v2 = a1 + 816;
            break;
        case 5:
            v2 = a1 + 1088;
            break;
        default:
            v2 = a1;
            break;
    }
    *(float*) (v2 + 144) = flt_69D6DC + *(float*) (a1 + 1376);
    *(float*) (v2 + 148) = flt_69D6E0 + *(float*) (a1 + 1380);
    *(_DWORD*) (v2 + 152) = 0;
    *(_DWORD*) (v2 + 124) = *(_DWORD*) (v2 + 124) & 0xFF000000 | 0xFFFFFF;
    if(*(_WORD*) (v2 + 136))
        *(float*) (v2 + 8) = 1.5707964 - *(float*) (a1 + 1424);
    return sub_432CC0((void*) dword_6D4588, v2);
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00416D60) --------------------------------------------------------
int __cdecl sub_416D60(int a1) {
    int v2; // [esp+8h] [ebp-48h]
    int v3; // [esp+Ch] [ebp-44h]
    int* v4; // [esp+10h] [ebp-40h]
    int v5; // [esp+18h] [ebp-38h]
    int* v6; // [esp+1Ch] [ebp-34h]
    int v7; // [esp+24h] [ebp-2Ch]
    int* v8; // [esp+28h] [ebp-28h]
    int v9; // [esp+30h] [ebp-20h]
    int* v10; // [esp+34h] [ebp-1Ch]
    int v11; // [esp+3Ch] [ebp-14h]
    int* v12; // [esp+40h] [ebp-10h]
    int v13; // [esp+48h] [ebp-8h]
    unsigned int i; // [esp+4Ch] [ebp-4h]

    if(dword_6C6EA4 == 3)
        goto LABEL_6;
    if(sub_431DC0((_DWORD*) dword_6D4588, 6, "data/etama3.anm", 512))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 7, "data/etama4.anm", 666))
        return -1;
    LABEL_6:
    for(i = 0; i < 0xA; ++i) {
        v13 = dword_46A6E8 [5 * i];
        v12 = (int*) dword_6D4588;
        *(_WORD*) (1376 * i + a1 + 180) = v13;
        sub_432430(v12, (_DWORD*) (1376 * i + a1), v12 [v13 + 29261]);
        v11 = dword_46A6EC [5 * i];
        v10 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 1376 * i + 452) = v11;
        sub_432430(v10, (_DWORD*) (a1 + 1376 * i + 272), v10 [v11 + 29261]);
        v9 = dword_46A6F0 [5 * i];
        v8 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 1376 * i + 724) = v9;
        sub_432430(v8, (_DWORD*) (a1 + 1376 * i + 544), v8 [v9 + 29261]);
        v7 = dword_46A6F4 [5 * i];
        v6 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 1376 * i + 996) = v7;
        sub_432430(v6, (_DWORD*) (a1 + 1376 * i + 816), v6 [v7 + 29261]);
        v5 = dword_46A6F8 [5 * i];
        v4 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 1376 * i + 1268) = v5;
        sub_432430(v4, (_DWORD*) (a1 + 1376 * i + 1088), v4 [v5 + 29261]);
        *(_WORD*) (a1 + 1376 * i + 178) = *(_WORD*) (a1 + 1376 * i + 176);
        *(_BYTE*) (a1 + 1376 * i + 1373) = (unsigned __int64) *(float*) (*(_DWORD*) (a1 + 1376 * i + 192) + 44);
        if(*(float*) (*(_DWORD*) (a1 + 1376 * i + 192) + 44) > 8.0) {
            if(*(float*) (*(_DWORD*) (a1 + 1376 * i + 192) + 44) > 16.0) {
                if(*(float*) (*(_DWORD*) (a1 + 1376 * i + 192) + 44) > 32.0) {
                    *(_DWORD*) (a1 + 1376 * i + 1360) = 1107296256;
                    *(_DWORD*) (a1 + 1376 * i + 1364) = 1107296256;
                }
                else {
                    v2 = dword_46A6E8 [5 * i];
                    if(v2 == 519) {
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1093664768;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1093664768;
                    }
                    else if(v2 == 520) {
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1091567616;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1091567616;
                    }
                    else {
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1098907648;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1098907648;
                    }
                }
            }
            else {
                v3 = dword_46A6E8 [5 * i];
                switch(v3) {
                    case 514:
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1082130432;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1082130432;
                        break;
                    case 516:
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1084227584;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1084227584;
                        break;
                    case 517:
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1082130432;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1082130432;
                        break;
                    default:
                        *(_DWORD*) (a1 + 1376 * i + 1360) = 1086324736;
                        *(_DWORD*) (a1 + 1376 * i + 1364) = 1086324736;
                        break;
                }
            }
        }
        else {
            *(_DWORD*) (a1 + 1376 * i + 1360) = 1082130432;
            *(_DWORD*) (a1 + 1376 * i + 1364) = 1082130432;
        }
    }
    memset(byte_69E268, 0, 0x2894Cu);
    return 0;
}
// 46A6E8: using guessed type int dword_46A6E8[];
// 46A6EC: using guessed type int dword_46A6EC[];
// 46A6F0: using guessed type int dword_46A6F0[];
// 46A6F4: using guessed type int dword_46A6F4[];
// 46A6F8: using guessed type int dword_46A6F8[46];
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (00417270) --------------------------------------------------------
int sub_417270() {
    if(dword_6C6EA4 != 3) {
        sub_432030(dword_6D4588, 6);
        sub_432030(dword_6D4588, 7);
    }
    return 0;
}
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (004172B0) --------------------------------------------------------
void sub_4172B0() {
    sub_41CDE0(byte_69D918, (int) &unk_69BC10);
    sub_41CDE0(byte_69D918, (int) &unk_5A5FD8);
}

//----- (004172D3) --------------------------------------------------------
BOOL __thiscall sub_4172D3(_DWORD* this) {
    return *(__int16*) (this [1] + 9428) >= 0 && ((*(_DWORD*) (this [1] + 9380) >> 13) & 1) != 0;
}

//----- (00417314) --------------------------------------------------------
int __thiscall sub_417314(_DWORD* this) {
    int result; // eax

    result = this [1];
    *(_WORD*) (result + 8302) = 1;
    return result;
}

//----- (0041732C) --------------------------------------------------------
int __thiscall sub_41732C(_DWORD* this) {
    int result; // eax

    result = this [1];
    *(_WORD*) (result + 8574) = 1;
    return result;
}

//----- (00417344) --------------------------------------------------------
int __thiscall sub_417344(_DWORD* this) {
    return *(unsigned __int8*) (this [1] + 11224);
}

//----- (0041735A) --------------------------------------------------------
int __thiscall sub_41735A(_DWORD* this, int a2) {
    float* v2; // edi
    int result; // eax
    int v4; // [esp+Ch] [ebp-10h]

    v2 = (float*) (this [1] + 11236);
    *v2++ = 416.0;
    *v2 = 32.0;
    v2 [1] = 0.0;
    *(_DWORD*) (this [1] + 11252) = 1;
    v4 = this [1] + 11256;
    *(_DWORD*) (v4 + 8) = 0;
    *(float*) (v4 + 4) = 0.0;
    *(_DWORD*) v4 = -999;
    result = this [1];
    *(_DWORD*) (result + 11248) = a2;
    return result;
}

//----- (004173D9) --------------------------------------------------------
int __thiscall sub_4173D9(_DWORD* this, int a2) {
    float* v2; // edi
    int result; // eax
    int v4; // [esp+Ch] [ebp-10h]

    v2 = (float*) (this [1] + 11268);
    *v2++ = 416.0;
    *v2 = 232.0;
    v2 [1] = 0.0;
    *(_DWORD*) (this [1] + 11284) = 1;
    v4 = this [1] + 11288;
    *(_DWORD*) (v4 + 8) = 0;
    *(float*) (v4 + 4) = 0.0;
    *(_DWORD*) v4 = -999;
    result = this [1];
    *(_DWORD*) (result + 11280) = a2;
    return result;
}

//----- (00417458) --------------------------------------------------------
int __thiscall sub_417458(_DWORD* this, int a2) {
    float* v2; // edi
    int result; // eax
    int v4; // [esp+Ch] [ebp-10h]

    v2 = (float*) (this [1] + 11300);
    *v2++ = 224.0;
    *v2 = 16.0;
    v2 [1] = 0.0;
    *(_DWORD*) (this [1] + 11316) = 1;
    v4 = this [1] + 11320;
    *(_DWORD*) (v4 + 8) = 0;
    *(float*) (v4 + 4) = 0.0;
    *(_DWORD*) v4 = -999;
    result = this [1];
    *(_DWORD*) (result + 11312) = a2;
    return result;
}

//----- (004174D7) --------------------------------------------------------
int __usercall sub_4174D7(int a1, int a2) {
    if(!byte_69BCCC) {
        sub_4195BF(a2);
        sub_4188C9(*(_DWORD*) (a2 + 4), a1);
    }
    return 1;
}
// 69BCCC: using guessed type char byte_69BCCC;

//----- (00417502) --------------------------------------------------------
int __cdecl sub_417502(int a1) {
    int v1; // edx
    float v3; // [esp+0h] [ebp-54h]
    char Buffer; // [esp+24h] [ebp-30h] BYREF
    _BYTE v5 [35]; // [esp+25h] [ebp-2Fh] BYREF
    int v6; // [esp+48h] [ebp-Ch] BYREF
    float v7; // [esp+4Ch] [ebp-8h]
    float v8; // [esp+50h] [ebp-4h]
    unsigned int retaddr; // [esp+58h] [ebp+4h]

    *(_DWORD*) &v5 [31] = retaddr ^ dword_47A630;
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 8);
    if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 11228)) {
        *(float*) &v6 = 74.0;
        v7 = 128.0;
        v8 = 0.0;
        dword_481B24 = -192;
        if(*(int*) dword_69D6D4 >= 6)
            sub_401650(dword_47B900, &v6, "All Clear!\n\n");
        else
            sub_401650(dword_47B900, &v6, "Stage Clear\n\n");
        v7 = v7 + 32.0;
        dword_481B24 = -1;
        sub_401650(dword_47B900, &v6, "Stage * 1000 = %5d\n", 1000 * *(_DWORD*) dword_69D6D4);
        v7 = v7 + 16.0;
        dword_481B24 = -2039553;
        sub_401650(dword_47B900, &v6, "Power *  100 = %5d\n", 100 * (unsigned __int16) word_69D4B0);
        v7 = v7 + 16.0;
        dword_481B24 = -3092225;
        sub_401650(dword_47B900, &v6, "Graze *   10 = %5d\n", 10 * *(_DWORD*) dword_69BCB4);
        v7 = v7 + 16.0;
        dword_481B24 = -32640;
        sub_401650(dword_47B900, &v6, "    * Point Item %3d\n", (unsigned __int16) word_69D4B4);
        if(*(int*) dword_69D6D4 >= 6) {
            v7 = v7 + 16.0;
            dword_481B24 = -128;
            sub_401650(dword_47B900, &v6, "Player    = %8d\n", 3000000 * byte_69D4BA);
            v7 = v7 + 16.0;
            sub_401650(dword_47B900, &v6, "Bomb      = %8d\n", 1000000 * byte_69D4BB);
        }
        v7 = v7 + 32.0;
        if(dword_69BCB0) {
            switch(dword_69BCB0) {
                case 1:
                    dword_481B24 = -32640;
                    sub_401650(dword_47B900, &v6, "Normal Rank    * 1.0\n");
                    break;
                case 2:
                    dword_481B24 = -32640;
                    sub_401650(dword_47B900, &v6, "Hard Rank      * 1.2\n");
                    break;
                case 3:
                    dword_481B24 = -32640;
                    sub_401650(dword_47B900, &v6, "Lunatic Rank   * 1.5\n");
                    break;
                case 4:
                    dword_481B24 = -32640;
                    sub_401650(dword_47B900, &v6, "Extra Rank     * 2.0\n");
                    break;
            }
        }
        else {
            dword_481B24 = -32640;
            sub_401650(dword_47B900, &v6, "Easy Rank      * 0.5\n");
        }
        v7 = v7 + 16.0;
        if(dword_69BCB0 < 4 && !byte_69D4C3) {
            if(byte_6C6E7C == 3) {
                dword_481B24 = -32640;
                sub_401650(dword_47B900, &v6, "Player Penalty * 0.5\n");
                v7 = v7 + 16.0;
            }
            else if(byte_6C6E7C == 4) {
                dword_481B24 = -32640;
                sub_401650(dword_47B900, &v6, "Player Penalty * 0.2\n");
                v7 = v7 + 16.0;
            }
        }
        dword_481B24 = -1;
        sub_401650(dword_47B900, &v6, "Total     = %8d", *(_DWORD*) (*(_DWORD*) (a1 + 4) + 11232));
        dword_481B24 = -1;
    }
    sub_4190EC(*(_DWORD*) (a1 + 4));
    sub_41ADF3(a1);
    sub_419C99((float*) a1);
    dword_481B30 = 1;
    if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 11252)) {
        dword_481B24 = -128;
        sub_401650(
            dword_47B900,
            (_DWORD*) (*(_DWORD*) (a1 + 4) + 11236),
            "BONUS %8d",
            *(_DWORD*) (*(_DWORD*) (a1 + 4) + 11248));
        dword_481B24 = -1;
    }
    if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 11284)) {
        dword_481B24 = -4148993;
        sub_401650(
            dword_47B900,
            (_DWORD*) (*(_DWORD*) (a1 + 4) + 11268),
            "Full Power Mode!!",
            *(_DWORD*) (*(_DWORD*) (a1 + 4) + 11280));
        dword_481B24 = -1;
    }
    if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 11316)) {
        dword_481B24 = -65536;
        *(float*) (*(_DWORD*) (a1 + 4) + 11300) = (384.0 - 17.0 * 16.0) / 2.0 + 32.0;
        *(float*) (*(_DWORD*) (a1 + 4) + 11304) = 80.0;
        sub_401650(dword_47B900, (_DWORD*) (*(_DWORD*) (a1 + 4) + 11300), "Spell Card Bonus!");
        *(float*) (*(_DWORD*) (a1 + 4) + 11304) = *(float*) (*(_DWORD*) (a1 + 4) + 11304) + 16.0;
        sprintf(&Buffer, Format, *(_DWORD*) (*(_DWORD*) (a1 + 4) + 11312));
        v3 = (float) (unsigned int) (&v5 [strlen(&Buffer)] - v5);
        *(float*) (*(_DWORD*) (a1 + 4) + 11300) = (384.0 - v3 * 32.0) / 2.0 + 32.0;
        flt_481B28 = 2.0;
        flt_481B2C = 2.0;
        dword_481B24 = -32640;
        sub_401530(dword_47B900, v1, (_DWORD*) (*(_DWORD*) (a1 + 4) + 11300), &Buffer);
        flt_481B28 = 1.0;
        flt_481B2C = 1.0;
        dword_481B24 = -1;
    }
    dword_481B30 = 0;
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 4);
    return 1;
}
// 417A83: variable 'v1' is possibly undefined
// 47A630: using guessed type int dword_47A630;
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 481B28: using guessed type float flt_481B28;
// 481B2C: using guessed type float flt_481B2C;
// 481B30: using guessed type int dword_481B30;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B4: using guessed type __int16 word_69D4B4;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4C3: using guessed type char byte_69D4C3;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E7C: using guessed type char byte_6C6E7C;

//----- (00417ACD) --------------------------------------------------------
int* __thiscall sub_417ACD(int this, int a2, char* Format) {
    float v4; // [esp+0h] [ebp-30h]
    int* v6; // [esp+20h] [ebp-10h]
    int v7; // [esp+24h] [ebp-Ch]
    int* v8; // [esp+28h] [ebp-8h]
    int v9; // [esp+2Ch] [ebp-4h]

    v9 = *(_DWORD*) (this + 4) + 7620;
    v8 = (int*) dword_6D4588;
    *(_WORD*) (v9 + 180) = 1185;
    sub_432430(v8, (_DWORD*) v9, v8 [30446]);
    sub_4323A0((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7620, a2);
    v7 = *(_DWORD*) (this + 4) + 8164;
    v6 = (int*) dword_6D4588;
    *(_WORD*) (v7 + 180) = 1798;
    sub_432430(v6, (_DWORD*) v7, v6 [31059]);
    sub_434B60((_DWORD*) dword_6D4588, *(_DWORD*) (this + 4) + 8164, 0xF0F0FFu, 0, Format);
    v4 = (float) (12 * strlen(Format));
    *(float*) (this + 8) = v4 / 2.0 + 16.0;
    dword_6C6EB0 = 3;
    return sub_4311E0(dword_6D3F50, (int*) 0xE, 0);
}
// 6C6EB0: using guessed type int dword_6C6EB0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00417BFD) --------------------------------------------------------
int* __thiscall sub_417BFD(int this, int a2, char* Format) {
    char* v3; // edx
    char v4; // cl
    char* i; // eax
    char v7; // [esp+0h] [ebp-30h]
    float v8; // [esp+0h] [ebp-30h]
    int* v10; // [esp+20h] [ebp-10h]
    int v11; // [esp+24h] [ebp-Ch]
    int* v12; // [esp+28h] [ebp-8h]
    int v13; // [esp+2Ch] [ebp-4h]

    v13 = *(_DWORD*) (this + 4) + 7892;
    v12 = (int*) dword_6D4588;
    *(_WORD*) (v13 + 180) = 1187;
    sub_432430(v12, (_DWORD*) v13, v12 [30448]);
    sub_4323A0((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7892, a2 + 1192);
    v11 = *(_DWORD*) (this + 4) + 8436;
    v10 = (int*) dword_6D4588;
    *(_WORD*) (v11 + 180) = 1799;
    sub_432430(v10, (_DWORD*) v11, v10 [31060]);
    sub_434C40(dword_6D4588, *(_DWORD*) (this + 4) + 8436, 0xFFF0F0u, 0, Format, v7);
    v3 = Format;
    do
        v4 = *v3++;
    while(v4 == 32);
    for(i = v3; *i; ++i)
        ;
    v8 = (float) (unsigned int) (13 * (i - v3));
    *(float*) (this + 12) = v8 / 2.0 + 24.0;
    return sub_4311E0(dword_6D3F50, (int*) 0xE, 0);
}
// 417CC0: variable 'v7' is possibly undefined
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00417D29) --------------------------------------------------------
int __thiscall sub_417D29(int* this) {
    int v2; // eax
    int v3; // eax
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    int* v12; // [esp+10h] [ebp-58h]
    int v13; // [esp+14h] [ebp-54h]
    int* v14; // [esp+18h] [ebp-50h]
    int v15; // [esp+1Ch] [ebp-4Ch]
    int* v16; // [esp+20h] [ebp-48h]
    int v17; // [esp+24h] [ebp-44h]
    int* v18; // [esp+28h] [ebp-40h]
    int v19; // [esp+2Ch] [ebp-3Ch]
    int* v20; // [esp+30h] [ebp-38h]
    int v21; // [esp+34h] [ebp-34h]
    int* v22; // [esp+38h] [ebp-30h]
    int v23; // [esp+3Ch] [ebp-2Ch]
    int* v24; // [esp+40h] [ebp-28h]
    int v25; // [esp+44h] [ebp-24h]
    int* v26; // [esp+48h] [ebp-20h]
    int v27; // [esp+4Ch] [ebp-1Ch]
    int* v28; // [esp+50h] [ebp-18h]
    int v29; // [esp+54h] [ebp-14h]
    int* v30; // [esp+5Ch] [ebp-Ch]
    int v31; // [esp+60h] [ebp-8h]
    int i; // [esp+64h] [ebp-4h]

    if(dword_6C6EA4 == 3) {
        v31 = this [1] + 9252;
        v30 = (int*) dword_6D4588;
        *(_WORD*) (v31 + 180) = 1561;
        sub_432430(v30, (_DWORD*) v31, v30 [30822]);
        *(_WORD*) (this [1] + 9390) = 1;
    }
    else {
        memset((void*) this [1], 0, 0x2C44u);
        if(sub_431DC0((_DWORD*) dword_6D4588, 13, "data/front.anm", 1536))
            return -1;
        if(sub_431DC0((_DWORD*) dword_6D4588, 14, "data/loading.anm", 1561))
            return -1;
        *(_WORD*) (this [1] + 9428) = -1;
        if(byte_69D4BD) {
            if(byte_69D4BD == 1) {
                if(sub_431DC0((_DWORD*) dword_6D4588, 15, "data/face01a.anm", 1184))
                    return -1;
                if(sub_431DC0((_DWORD*) dword_6D4588, 16, "data/face01b.anm", 1186))
                    return -1;
                if(sub_431DC0((_DWORD*) dword_6D4588, 17, "data/face01c.anm", 1188))
                    return -1;
            }
        }
        else {
            if(sub_431DC0((_DWORD*) dword_6D4588, 15, "data/face00a.anm", 1184))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 16, "data/face00b.anm", 1186))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 17, "data/face00c.anm", 1188))
                return -1;
        }
    }
    switch(*(_DWORD*) dword_69D6D4) {
        case 1:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face03a.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face03b.anm", 1194))
                return -1;
            if(sub_418665(this, "data/msg1.dat"))
                return -1;
            break;
        case 2:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face05a.anm", 1192))
                return -1;
            if(sub_418665(this, "data/msg2.dat"))
                return -1;
            break;
        case 3:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face06a.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face06b.anm", 1194))
                return -1;
            if(sub_418665(this, "data/msg3.dat"))
                return -1;
            break;
        case 4:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face08a.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face08b.anm", 1194))
                return -1;
            if(sub_418665(this, "data/msg4.dat"))
                return -1;
            break;
        case 5:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face09a.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face09b.anm", 1194))
                return -1;
            if(sub_418665(this, "data/msg5.dat"))
                return -1;
            break;
        case 6:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face09b.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face10a.anm", 1194))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 20, "data/face10b.anm", 1195))
                return -1;
            if(sub_418665(this, "data/msg6.dat"))
                return -1;
            break;
        default:
            if(sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face08a.anm", 1192))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 19, "data/face12a.anm", 1194))
                return -1;
            if(sub_431DC0((_DWORD*) dword_6D4588, 20, "data/face12b.anm", 1195))
                return -1;
            if(sub_418665(this, "data/msg7.dat"))
                return -1;
            break;
    }
    if(dword_6C6EA4 != 3) {
        for(i = 0; i < 26; ++i) {
            v29 = this [1] + 272 * i;
            v28 = (int*) dword_6D4588;
            *(_WORD*) (v29 + 180) = i + 1536;
            sub_432430(v28, (_DWORD*) v29, v28 [i + 30797]);
        }
    }
    *((_BYTE*) this + 32) = 0;
    *(_BYTE*) (this [1] + 7072) = 0;
    *((float*) this + 9) = 0.0;
    *((float*) this + 10) = 0.0;
    v27 = this [1] + 7620;
    v26 = (int*) dword_6D4588;
    *(_WORD*) (v27 + 180) = 1185;
    sub_432430(v26, (_DWORD*) v27, v26 [30446]);
    v25 = this [1] + 7892;
    v24 = (int*) dword_6D4588;
    *(_WORD*) (v25 + 180) = 1187;
    sub_432430(v24, (_DWORD*) v25, v24 [30448]);
    v23 = this [1] + 8164;
    v22 = (int*) dword_6D4588;
    *(_WORD*) (v23 + 180) = 1798;
    sub_432430(v22, (_DWORD*) v23, v22 [31059]);
    v21 = this [1] + 8436;
    v20 = (int*) dword_6D4588;
    *(_WORD*) (v21 + 180) = 1799;
    sub_432430(v20, (_DWORD*) v21, v20 [31060]);
    v19 = this [1] + 8708;
    v18 = (int*) dword_6D4588;
    *(_WORD*) (v19 + 180) = 1559;
    sub_432430(v18, (_DWORD*) v19, v18 [30820]);
    v17 = this [1] + 8980;
    v16 = (int*) dword_6D4588;
    *(_WORD*) (v17 + 180) = 1560;
    sub_432430(v16, (_DWORD*) v17, v16 [30821]);
    *(_DWORD*) (this [1] + 7808) = 0;
    *(_DWORD*) (this [1] + 8352) = 0;
    *(_DWORD*) (this [1] + 8080) = 0;
    *(_DWORD*) (this [1] + 8624) = 0;
    v2 = *(_DWORD*) (this [1] + 7748);
    LOBYTE(v2) = v2 & 0xFE;
    *(_DWORD*) (this [1] + 7748) = v2;
    v3 = *(_DWORD*) (this [1] + 8292);
    LOBYTE(v3) = v3 & 0xFE;
    *(_DWORD*) (this [1] + 8292) = v3;
    v4 = *(_DWORD*) (this [1] + 8020);
    LOBYTE(v4) = v4 & 0xFE;
    *(_DWORD*) (this [1] + 8020) = v4;
    v5 = *(_DWORD*) (this [1] + 8564);
    LOBYTE(v5) = v5 & 0xFE;
    *(_DWORD*) (this [1] + 8564) = v5;
    *(_BYTE*) (this [1] + 8432) = 15;
    *(_BYTE*) (this [1] + 8433) = 15;
    *(_BYTE*) (this [1] + 8704) = 15;
    *(_BYTE*) (this [1] + 8705) = 15;
    v15 = this [1] + 7076;
    v14 = (int*) dword_6D4588;
    *(_WORD*) (v15 + 180) = 1792;
    sub_432430(v14, (_DWORD*) v15, v14 [31053]);
    v13 = this [1] + 7348;
    v12 = (int*) dword_6D4588;
    *(_WORD*) (v13 + 180) = 1793;
    sub_432430(v12, (_DWORD*) v13, v12 [31054]);
    sub_434B60((_DWORD*) dword_6D4588, this [1] + 7076, 0xE0FFFFu, 0, (char*) (dword_487B14 + 16));
    *(_BYTE*) (this [1] + 7616) = 16;
    *(_BYTE*) (this [1] + 7617) = 16;
    sub_434C40(dword_6D4588, this [1] + 7348, 0xE0FFFFu, 0, "%s", dword_487B14 - 112);
    *(_DWORD*) (this [1] + 9532) = -1;
    *(_DWORD*) (this [1] + 11228) = 0;
    *(_DWORD*) (this [1] + 11252) = 0;
    *(_DWORD*) (this [1] + 11284) = 0;
    *(_DWORD*) (this [1] + 11316) = 0;
    v6 = *this;
    LOBYTE(v6) = *this & 0xFC | 2;
    *this = v6;
    v7 = *this;
    LOBYTE(v7) = *this & 0xF3 | 8;
    *this = v7;
    v8 = *this;
    LOBYTE(v8) = *this & 0x3F | 0x80;
    *this = v8;
    v9 = *this;
    BYTE1(v9) = BYTE1(*this) & 0xFC | 2;
    *this = v9;
    v10 = *this;
    LOBYTE(v10) = *this & 0xCF | 0x20;
    *this = v10;
    return 0;
}
// 487B14: using guessed type int dword_487B14;
// 69D4BD: using guessed type char byte_69D4BD;
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (00418665) --------------------------------------------------------
int __thiscall sub_418665(_DWORD* this, char* Str) {
    int i; // [esp+4h] [ebp-4h]

    sub_41872A(this);
    *(_DWORD*) (this [1] + 9524) = sub_41E290(Str, 0);
    if(*(_DWORD*) (this [1] + 9524)) {
        *(_DWORD*) (this [1] + 9532) = -1;
        *(_DWORD*) (this [1] + 9528) = 0;
        for(i = 0; i < **(_DWORD**) (this [1] + 9524); ++i)
            *(_DWORD*) (*(_DWORD*) (this [1] + 9524) + 4 * i + 4) += *(_DWORD*) (this [1] + 9524);
        return 0;
    }
    else {
        sub_41E4D0((int) byte_69D998, aError_1, Str);
        return -1;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (0041872A) --------------------------------------------------------
int __thiscall sub_41872A(_DWORD* this) {
    int result; // eax

    result = this [1];
    if(*(_DWORD*) (result + 9524)) {
        free(*(void**) (this [1] + 9524));
        result = this [1];
        *(_DWORD*) (result + 9524) = 0;
    }
    return result;
}

//----- (00418768) --------------------------------------------------------
int __fastcall sub_418768(int a1, int a2, int a3) {
    int result; // eax

    result = sub_41878B(*(_DWORD*) (a1 + 4), a2, a3);
    dword_6C6EB0 = 3;
    return result;
}
// 6C6EB0: using guessed type int dword_6C6EB0;

//----- (0041878B) --------------------------------------------------------
int __fastcall sub_41878B(int a1, int a2, int a3) {
    int result; // eax
    int v4; // [esp+8h] [ebp-4h]

    result = **(_DWORD**) (a1 + 9524);
    if(result > a3) {
        v4 = *(_DWORD*) (a1 + 9524);
        memset((void*) (a1 + 9524), 0, 0x6A8u);
        *(_DWORD*) (a1 + 9532) = a3;
        *(_DWORD*) (a1 + 9524) = v4;
        *(_DWORD*) (a1 + 9528) = *(_DWORD*) (*(_DWORD*) (a1 + 9524) + 4 * a3 + 4);
        *(_WORD*) (a1 + 10276) = -1;
        *(_WORD*) (a1 + 10548) = -1;
        *(_DWORD*) (a1 + 11216) = 15;
        *(_DWORD*) (a1 + 11184) = 15266047;
        *(_DWORD*) (a1 + 11188) = 16771312;
        *(_DWORD*) (a1 + 11200) = 0;
        *(_DWORD*) (a1 + 11204) = 0;
        result = a1;
        *(_BYTE*) (a1 + 11224) = 1;
        if(*(_DWORD*) dword_69D6D4 == 6 && (!a3 || a3 == 10)) {
            return sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff06.anm", 691);
        }
        else if(*(_DWORD*) dword_69D6D4 == 7 && (!a3 || a3 == 10)) {
            sub_431DC0((_DWORD*) dword_6D4588, 11, "data/eff07.anm", 691);
            return sub_431DC0((_DWORD*) dword_6D4588, 18, "data/face12c.anm", 1192);
        }
    }
    return result;
}

//----- (004188C9) --------------------------------------------------------
int __usercall sub_4188C9(int a1, int a2) {
    char v3; // [esp+4h] [ebp-50h]
    int* v5; // [esp+14h] [ebp-40h]
    int* v6; // [esp+1Ch] [ebp-38h]
    int v7; // [esp+20h] [ebp-34h]
    int v8; // [esp+24h] [ebp-30h]
    int* v9; // [esp+28h] [ebp-2Ch]
    int* v10; // [esp+30h] [ebp-24h]
    int v11; // [esp+34h] [ebp-20h]
    int v12; // [esp+38h] [ebp-1Ch]
    int* v13; // [esp+3Ch] [ebp-18h]
    int v14; // [esp+40h] [ebp-14h]
    int v15; // [esp+44h] [ebp-10h]
    char* v16; // [esp+50h] [ebp-4h]
    char* v17; // [esp+50h] [ebp-4h]

    if(*(int*) (a1 + 9532) < 0)
        return -1;
    if(*(_DWORD*) (a1 + 11220))
        --* (_DWORD*) (a1 + 11220);
    if(*(_BYTE*) (a1 + 11224) && (word_69D904 & 0x100) != 0) {
        *(_DWORD*) (a1 + 9544) = **(unsigned __int16**) (a1 + 9528);
        *(float*) (a1 + 9540) = 0.0;
        *(_DWORD*) (a1 + 9536) = -999;
    }
    while(2) {
        if(*(_DWORD*) (a1 + 9544) >= (int) **(unsigned __int16**) (a1 + 9528)) {
            switch(*(_BYTE*) (*(_DWORD*) (a1 + 9528) + 2)) {
                case 0:
                    *(_DWORD*) (a1 + 9532) = -1;
                    return -1;
                case 1:
                    v15 = (*(_WORD*) (*(_DWORD*) (a1 + 9528) + 4) != 0 ? 1186 : 1184) + *(__int16*) (*(_DWORD*) (a1 + 9528) + 6);
                    v14 = a1 + 272 * *(__int16*) (*(_DWORD*) (a1 + 9528) + 4) + 9552;
                    v13 = (int*) dword_6D4588;
                    *(_WORD*) (v14 + 180) = v15;
                    sub_432430(v13, (_DWORD*) v14, v13 [v15 + 29261]);
                    goto LABEL_49;
                case 2:
                    sub_4323A0(
                        (int*) dword_6D4588,
                        a1 + 272 * *(__int16*) (*(_DWORD*) (a1 + 9528) + 4) + 9552,
                        (*(_WORD*) (*(_DWORD*) (a1 + 9528) + 4) != 0 ? 1192 : 1184) + *(__int16*) (*(_DWORD*) (a1 + 9528) + 6));
                    goto LABEL_49;
                case 3:
                    v16 = (char*) (*(_DWORD*) (a1 + 9528) + 4);
                    if(!*(_WORD*) (*(_DWORD*) (a1 + 9528) + 6) && *(__int16*) (a1 + 10548) >= 0)
                        sub_434B60(
                            (_DWORD*) dword_6D4588,
                            a1 + 10368,
                            *(_DWORD*) (a1 + 4 * *(__int16*) v16 + 11184),
                            *(_DWORD*) (a1 + 4 * *(__int16*) v16 + 11200),
                            " ");
                    v12 = *((__int16*) v16 + 1) + 1794;
                    v11 = a1 + 272 * *((__int16*) v16 + 1) + 10096;
                    v10 = (int*) dword_6D4588;
                    *(_WORD*) (v11 + 180) = v12;
                    sub_432430(v10, (_DWORD*) v11, v10 [v12 + 29261]);
                    *(_BYTE*) (a1 + 272 * *((__int16*) v16 + 1) + 10365) = *(_BYTE*) (a1 + 11216);
                    *(_BYTE*) (a1 + 272 * *((__int16*) v16 + 1) + 10364) = *(_BYTE*) (a1 + 272 * *((__int16*) v16 + 1) + 10365);
                    sub_434B60(
                        (_DWORD*) dword_6D4588,
                        a1 + 272 * *((__int16*) v16 + 1) + 10096,
                        *(_DWORD*) (a1 + 4 * *(__int16*) v16 + 11184),
                        *(_DWORD*) (a1 + 4 * *(__int16*) v16 + 11200),
                        v16 + 4);
                    *(_DWORD*) (a1 + 9548) = 0;
                    goto LABEL_49;
                case 4:
                    if(*(_BYTE*) (a1 + 11224) && (word_69D904 & 0x100) != 0
                       || (word_69D904 & 1) != 0 && (word_69D904 & 1) != (word_69D908 & 1) && *(int*) (a1 + 9548) >= 8
                       || *(_DWORD*) (a1 + 9548) >= *(_DWORD*) (*(_DWORD*) (a1 + 9528) + 4)) {
                        goto LABEL_49;
                    }
                    ++* (_DWORD*) (a1 + 9548);
                    goto LABEL_51;
                case 5:
                    if(*(__int16*) (*(_DWORD*) (a1 + 9528) + 4) >= 2)
                        *(_WORD*) (a1 + 272 * (*(__int16*) (*(_DWORD*) (a1 + 9528) + 4) - 2) + 10234) = *(unsigned __int8*) (*(_DWORD*) (a1 + 9528) + 6);
                    else
                        *(_WORD*) (a1 + 272 * *(__int16*) (*(_DWORD*) (a1 + 9528) + 4) + 9690) = *(unsigned __int8*) (*(_DWORD*) (a1 + 9528) + 6);
                    goto LABEL_49;
                case 6:
                    ++ * (_DWORD*) (a1 + 11220);
                    goto LABEL_49;
                case 7:
                    v9 = (int*) dword_6D4588;
                    *(_WORD*) (a1 + 7528) = 1793;
                    sub_432430(v9, (_DWORD*) (a1 + 7348), v9 [31054]);
                    *(_BYTE*) (a1 + 7616) = 16;
                    *(_BYTE*) (a1 + 7617) = 16;
                    sub_434C40(
                        dword_6D4588,
                        a1 + 7348,
                        0xE0FFFFu,
                        0,
                        "%s",
                        dword_487B14 + (*(_BYTE*) (*(_DWORD*) (a1 + 9528) + 4) << 7) - 112);
                    if(sub_424AE4(*(_DWORD*) (*(_DWORD*) (a1 + 9528) + 4)))
                        sub_424B5D(a2, (char*) (dword_487B14 + (*(_DWORD*) (*(_DWORD*) (a1 + 9528) + 4) << 7) + 656));
                    goto LABEL_49;
                case 8:
                    v17 = (char*) (*(_DWORD*) (a1 + 9528) + 4);
                    v8 = *(__int16*) (*(_DWORD*) (a1 + 9528) + 6) + 1796;
                    v7 = a1 + 272 * *(__int16*) (*(_DWORD*) (a1 + 9528) + 6) + 10640;
                    v6 = (int*) dword_6D4588;
                    *(_WORD*) (v7 + 180) = v8;
                    sub_432430(v6, (_DWORD*) v7, v6 [v8 + 29261]);
                    sub_434C40(
                        dword_6D4588,
                        a1 + 272 * *((__int16*) v17 + 1) + 10640,
                        *(_DWORD*) (a1 + 4 * *(__int16*) v17 + 11184),
                        *(_DWORD*) (a1 + 4 * *(__int16*) v17 + 11200),
                        v17 + 4,
                        v3);
                    *(_DWORD*) (a1 + 9548) = 0;
                    goto LABEL_49;
                case 9:
                    *(_DWORD*) (a1 + 11228) = 1;
                    if(*(int*) dword_69D6D4 >= 6) {
                        byte_69D4BC = -1;
                    }
                    else {
                        v5 = (int*) dword_6D4588;
                        *(_WORD*) (a1 + 9432) = 1561;
                        sub_432430(v5, (_DWORD*) (a1 + 9252), v5 [30822]);
                    }
                    goto LABEL_49;
                case 0xA:
                    goto LABEL_51;
                case 0xB:
                    *(_DWORD*) dword_69BCA0 = dword_69BCA4;
                    if(byte_69D4C3) {
                        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
                        dword_6C6EA4 = 7;
                    }
                    else if(*(int*) dword_69D6D4 < 5 || dword_69BCB0 && *(_DWORD*) dword_69D6D4 == 5) {
                        dword_6C6EA4 = 3;
                    }
                    else if(dword_69BCBC) {
                        dword_6C6EA4 = 8;
                    }
                    else if(dword_69BCB0 == 4) {
                        byte_69D4C2 = 1;
                        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
                        dword_6C6EA4 = 7;
                    }
                    else {
                        dword_6C6EA4 = 10;
                    }
                    goto LABEL_51;
                case 0xC:
                    sub_424D82((float*) &dword_6C6D18, 4.0);
                    goto LABEL_49;
                case 0xD:
                    *(_BYTE*) (a1 + 11224) = *(_BYTE*) (*(_DWORD*) (a1 + 9528) + 4);
                    goto LABEL_49;
                default:
                    LABEL_49:
                    *(_DWORD*) (a1 + 9528) += *(unsigned __int8*) (*(_DWORD*) (a1 + 9528) + 3) + 4;
                    continue;
            }
        }
        break;
    }
    sub_41B5AF((void*) (a1 + 9536));
    LABEL_51:
    sub_433960((int*) dword_6D4588, a1 + 9552);
    sub_433960((int*) dword_6D4588, a1 + 9824);
    sub_433960((int*) dword_6D4588, a1 + 10096);
    sub_433960((int*) dword_6D4588, a1 + 10368);
    sub_433960((int*) dword_6D4588, a1 + 10640);
    sub_433960((int*) dword_6D4588, a1 + 10912);
    if(*(int*) (a1 + 9544) < 60 && *(_BYTE*) (a1 + 11224) && (word_69D904 & 0x100) != 0) {
        *(_DWORD*) (a1 + 9544) = 60;
        *(float*) (a1 + 9540) = 0.0;
        *(_DWORD*) (a1 + 9536) = -999;
    }
    return 0;
}
// 418E64: variable 'v3' is possibly undefined
// 487B14: using guessed type int dword_487B14;
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4BC: using guessed type char byte_69D4BC;
// 69D4C2: using guessed type char byte_69D4C2;
// 69D4C3: using guessed type char byte_69D4C3;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (004190EC) --------------------------------------------------------
int __thiscall sub_4190EC(int this) {
    float v2; // [esp+8h] [ebp-C0h]
    float v4; // [esp+28h] [ebp-A0h]
    float v5; // [esp+2Ch] [ebp-9Ch]
    _DWORD* i; // [esp+30h] [ebp-98h]
    int v7; // [esp+38h] [ebp-90h]
    float v8; // [esp+50h] [ebp-78h]
    _DWORD v9 [21]; // [esp+70h] [ebp-58h] BYREF
    float v10; // [esp+C4h] [ebp-4h]

    if(*(int*) (this + 9532) < 0)
        return -1;
    if(*(_DWORD*) dword_69D6D4 == 6 && (*(_DWORD*) (this + 9532) == 1 || *(_DWORD*) (this + 9532) == 11))
        return 0;
    if(*(int*) (this + 9544) >= 60) {
        v10 = 48.0;
    }
    else {
        v2 = (float) *(int*) (this + 9544);
        v10 = (v2 + *(float*) (this + 9540)) * 48.0 / 60.0;
    }
    v7 = 4;
    for(i = v9; --v7 >= 0; i += 5)
        ;
    v5 = (flt_69D6E4 - 256.0) / 2.0 + flt_69D6DC - 16.0;
    *(float*) v9 = v5;
    *(float*) &v9 [1] = 384.0;
    *(float*) &v9 [2] = 0.0;
    v4 = (flt_69D6E4 - 256.0) / 2.0 + flt_69D6DC + 256.0 + 16.0;
    *(float*) &v9 [5] = v4;
    *(float*) &v9 [6] = 384.0;
    *(float*) &v9 [7] = 0.0;
    v8 = v10 + 384.0;
    *(float*) &v9 [10] = v5;
    *(float*) &v9 [11] = v8;
    *(float*) &v9 [12] = 0.0;
    *(float*) &v9 [15] = v4;
    *(float*) &v9 [16] = v8;
    *(float*) &v9 [17] = 0.0;
    v9 [9] = -805306368;
    v9 [4] = -805306368;
    v9 [19] = -1879048192;
    v9 [14] = -1879048192;
    *(float*) &v9 [18] = 1.0;
    *(float*) &v9 [13] = 1.0;
    *(float*) &v9 [8] = 1.0;
    *(float*) &v9 [3] = 1.0;
    sub_432AD0((void*) dword_6D4588, this + 9552);
    sub_432AD0((void*) dword_6D4588, this + 9824);
    if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 2);
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 2);
    }
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 0);
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 0);
    if((((unsigned int) dword_6C6E60 >> 6) & 1) == 0)
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 14, 0);
    (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 68);
    (*(void(__stdcall**)(int, int, int, _DWORD*, int))(*(_DWORD*) dword_6C6D20 + 288))(dword_6C6D20, 5, 2, v9, 20);
    *(_BYTE*) (dword_6D4588 + 135358) = -1;
    *(_BYTE*) (dword_6D4588 + 135357) = -1;
    *(_BYTE*) (dword_6D4588 + 135356) = -1;
    *(_BYTE*) (dword_6D4588 + 135359) = -1;
    if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 4);
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 4);
    }
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 2);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 2);
    sub_432AD0((void*) dword_6D4588, this + 10096);
    sub_432AD0((void*) dword_6D4588, this + 10368);
    sub_432AD0((void*) dword_6D4588, this + 10640);
    sub_432AD0((void*) dword_6D4588, this + 10912);
    return 0;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E4: using guessed type float flt_69D6E4;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00419572) --------------------------------------------------------
BOOL __thiscall sub_419572(_DWORD* this) {
    return !*(_DWORD*) (this [1] + 11220) && *(_DWORD*) (this [1] + 9532) >= 0;
}

//----- (004195A2) --------------------------------------------------------
BOOL __thiscall sub_4195A2(_DWORD* this) {
    return *(_DWORD*) (this [1] + 9532) >= 0;
}

//----- (004195BF) --------------------------------------------------------
int __thiscall sub_4195BF(int this) {
    int v1; // eax
    int v2; // eax
    int result; // eax
    float v4; // [esp+8h] [ebp-38h]
    float v5; // [esp+Ch] [ebp-34h]
    int* v7; // [esp+28h] [ebp-18h]
    int v8; // [esp+2Ch] [ebp-14h]
    int* v9; // [esp+30h] [ebp-10h]
    int v10; // [esp+34h] [ebp-Ch]
    int v11; // [esp+38h] [ebp-8h]
    int i; // [esp+3Ch] [ebp-4h]

    for(i = 0; i < 26; ++i) {
        if(i == 19 && *(int*) (*(_DWORD*) (this + 4) + 9532) < 0) {
            if(*(_BYTE*) (this + 32)) {
                if(*(_BYTE*) (*(_DWORD*) (this + 4) + 7072)) {
                    if(sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 5168))
                        *(_BYTE*) (*(_DWORD*) (this + 4) + 7072) = 2;
                    if(*(_DWORD*) (this + 16) >= 0xFCu)
                        *(_DWORD*) (this + 16) = 255;
                    else
                        *(_DWORD*) (this + 16) += 4;
                }
                else {
                    v10 = *(_DWORD*) (this + 4) + 5168;
                    v9 = (int*) dword_6D4588;
                    *(_WORD*) (v10 + 180) = 1555;
                    sub_432430(v9, (_DWORD*) v10, v9 [30816]);
                    *(_BYTE*) (*(_DWORD*) (this + 4) + 7072) = 1;
                    *(_DWORD*) (this + 16) = 0;
                }
            }
            else if(*(_BYTE*) (*(_DWORD*) (this + 4) + 7072)) {
                if(*(unsigned __int8*) (*(_DWORD*) (this + 4) + 7072) <= 2u) {
                    v8 = *(_DWORD*) (this + 4) + 5168;
                    v7 = (int*) dword_6D4588;
                    *(_WORD*) (v8 + 180) = 1556;
                    sub_432430(v7, (_DWORD*) v8, v7 [30817]);
                    *(_BYTE*) (*(_DWORD*) (this + 4) + 7072) = 3;
                }
                if(*(_DWORD*) (this + 16))
                    *(_DWORD*) (this + 16) -= 4;
                else
                    *(_DWORD*) (this + 16) = 0;
                if(sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 5168)) {
                    *(_BYTE*) (*(_DWORD*) (this + 4) + 7072) = 0;
                    *(float*) (this + 40) = 0.0;
                    *(_DWORD*) (this + 16) = 0;
                }
            }
            if(*(unsigned __int8*) (*(_DWORD*) (this + 4) + 7072) >= 2u) {
                if(*(float*) (this + 36) <= (double) *(float*) (this + 40)) {
                    if(*(float*) (this + 36) < (double) *(float*) (this + 40)) {
                        *(float*) (this + 40) = *(float*) (this + 40) - 0.02;
                        if(*(float*) (this + 36) > (double) *(float*) (this + 40))
                            *(float*) (this + 40) = *(float*) (this + 36);
                    }
                }
                else {
                    *(float*) (this + 40) = *(float*) (this + 40) + 0.0099999998;
                    if(*(float*) (this + 36) < (double) *(float*) (this + 40))
                        *(float*) (this + 40) = *(float*) (this + 36);
                }
            }
        }
        else {
            sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 272 * i);
        }
    }
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7076);
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7348);
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7620);
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 8164);
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 7892);
    sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 8436);
    if(*(__int16*) (*(_DWORD*) (this + 4) + 9428) >= 0 && sub_433960((int*) dword_6D4588, *(_DWORD*) (this + 4) + 9252))
        *(_WORD*) (*(_DWORD*) (this + 4) + 9428) = -1;
    if(*(_DWORD*) (*(_DWORD*) (this + 4) + 11252)) {
        if(*(int*) (*(_DWORD*) (this + 4) + 11264) >= 30) {
            *(float*) (*(_DWORD*) (this + 4) + 11236) = 104.0;
        }
        else {
            v1 = *(_DWORD*) (this + 4);
            v5 = (float) *(int*) (v1 + 11264);
            *(float*) (v1 + 11236) = (v5 + *(float*) (v1 + 11260)) * -312.0 / 30.0 + 416.0;
        }
        if(*(int*) (*(_DWORD*) (this + 4) + 11264) >= 250)
            *(_DWORD*) (*(_DWORD*) (this + 4) + 11252) = 0;
        sub_41B5AF((void*) (*(_DWORD*) (this + 4) + 11256));
    }
    if(*(_DWORD*) (*(_DWORD*) (this + 4) + 11284)) {
        if(*(int*) (*(_DWORD*) (this + 4) + 11296) >= 30) {
            *(float*) (*(_DWORD*) (this + 4) + 11268) = 104.0;
        }
        else {
            v2 = *(_DWORD*) (this + 4);
            v4 = (float) *(int*) (v2 + 11296);
            *(float*) (v2 + 11268) = (v4 + *(float*) (v2 + 11292)) * -312.0 / 30.0 + 416.0;
        }
        if(*(int*) (*(_DWORD*) (this + 4) + 11296) >= 180)
            *(_DWORD*) (*(_DWORD*) (this + 4) + 11284) = 0;
        sub_41B5AF((void*) (*(_DWORD*) (this + 4) + 11288));
    }
    if(*(_DWORD*) (*(_DWORD*) (this + 4) + 11316)) {
        if(*(int*) (*(_DWORD*) (this + 4) + 11328) >= 280)
            *(_DWORD*) (*(_DWORD*) (this + 4) + 11316) = 0;
        sub_41B5AF((void*) (*(_DWORD*) (this + 4) + 11320));
    }
    result = *(_DWORD*) (this + 4);
    if(*(_DWORD*) (result + 11228) == 1) {
        v11 = (unsigned __int16) word_69D4B4
            * (100 * (unsigned __int16) word_69D4B0 + 10 * *(_DWORD*) dword_69BCB4 + 1000 * *(_DWORD*) dword_69D6D4);
        if(*(int*) dword_69D6D4 >= 6)
            v11 += 1000000 * byte_69D4BB + 3000000 * byte_69D4BA;
        if(dword_69BCB0) {
            switch(dword_69BCB0) {
                case 2:
                    v11 = 12 * v11 / 10 - 12 * v11 / 10 % 10;
                    break;
                case 3:
                    v11 = 15 * v11 / 10 - 15 * v11 / 10 % 10;
                    break;
                case 4:
                    v11 = 2 * v11 - 2 * v11 % 10;
                    break;
            }
        }
        else {
            v11 = v11 / 2 - v11 / 2 % 10;
        }
        if(byte_6C6E7C == 3) {
            v11 = 5 * v11 / 10 - 5 * v11 / 10 % 10;
        }
        else if(byte_6C6E7C == 4) {
            v11 = 2 * v11 / 10 - 2 * v11 / 10 % 10;
        }
        *(_DWORD*) (*(_DWORD*) (this + 4) + 11232) = v11;
        dword_69BCA4 += v11;
        result = *(_DWORD*) (*(_DWORD*) (this + 4) + 11228) + 1;
        *(_DWORD*) (*(_DWORD*) (this + 4) + 11228) = result;
    }
    return result;
}
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B4: using guessed type __int16 word_69D4B4;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 6C6E7C: using guessed type char byte_6C6E7C;

//----- (00419C99) --------------------------------------------------------
int __thiscall sub_419C99(float* this) {
    int v1; // eax
    float* v2; // edi
    float* v3; // edi
    float* v4; // edi
    float* v5; // edi
    float v6; // eax
    float v7; // eax
    float v8; // eax
    float v9; // eax
    float v10; // eax
    float* v11; // edi
    float* v12; // edi
    float* v13; // edi
    float* v14; // edi
    float* v15; // edi
    float* v16; // edi
    float* v17; // edi
    float* v18; // edi
    float* v19; // edi
    float* v20; // edi
    float* v21; // edi
    float* v22; // edi
    float v23; // ecx
    int result; // eax
    float v25; // ecx
    float v26; // [esp+10h] [ebp-1ECh]
    int v27; // [esp+18h] [ebp-1E4h]
    float v29; // [esp+34h] [ebp-1C8h]
    float* k; // [esp+38h] [ebp-1C4h]
    int v31; // [esp+40h] [ebp-1BCh]
    int v32 [4]; // [esp+70h] [ebp-18Ch] BYREF
    float v33; // [esp+80h] [ebp-17Ch]
    float v34; // [esp+84h] [ebp-178h]
    float v35; // [esp+88h] [ebp-174h]
    float v36; // [esp+8Ch] [ebp-170h]
    float v37; // [esp+90h] [ebp-16Ch]
    float v38; // [esp+94h] [ebp-168h]
    float v39; // [esp+98h] [ebp-164h]
    float v40; // [esp+9Ch] [ebp-160h]
    float v41; // [esp+A0h] [ebp-15Ch]
    float v42; // [esp+A4h] [ebp-158h]
    float v43; // [esp+A8h] [ebp-154h]
    float v44; // [esp+ACh] [ebp-150h]
    float v45; // [esp+B0h] [ebp-14Ch]
    float v46; // [esp+B4h] [ebp-148h]
    float v47; // [esp+B8h] [ebp-144h]
    float v48; // [esp+BCh] [ebp-140h]
    float v49; // [esp+C0h] [ebp-13Ch]
    float v50; // [esp+C4h] [ebp-138h]
    float v51; // [esp+C8h] [ebp-134h]
    float v52; // [esp+CCh] [ebp-130h]
    float v53; // [esp+D0h] [ebp-12Ch]
    float v54; // [esp+D4h] [ebp-128h]
    float v55; // [esp+D8h] [ebp-124h]
    float v56; // [esp+DCh] [ebp-120h]
    float v57; // [esp+E0h] [ebp-11Ch]
    float v58; // [esp+E4h] [ebp-118h]
    float v59; // [esp+E8h] [ebp-114h]
    float v60; // [esp+ECh] [ebp-110h]
    float v61; // [esp+F0h] [ebp-10Ch]
    float v62; // [esp+F4h] [ebp-108h]
    float v63; // [esp+F8h] [ebp-104h]
    float v64; // [esp+FCh] [ebp-100h]
    float v65; // [esp+100h] [ebp-FCh]
    float v66; // [esp+104h] [ebp-F8h]
    float v67; // [esp+108h] [ebp-F4h]
    float v68; // [esp+10Ch] [ebp-F0h]
    float v69; // [esp+110h] [ebp-ECh]
    float v70; // [esp+114h] [ebp-E8h]
    float v71; // [esp+118h] [ebp-E4h]
    float v72; // [esp+11Ch] [ebp-E0h]
    float v73; // [esp+120h] [ebp-DCh]
    float v74; // [esp+124h] [ebp-D8h]
    float v75; // [esp+128h] [ebp-D4h]
    float v76; // [esp+12Ch] [ebp-D0h]
    float v77; // [esp+130h] [ebp-CCh]
    float v78; // [esp+134h] [ebp-C8h]
    float v79; // [esp+138h] [ebp-C4h]
    float v80; // [esp+13Ch] [ebp-C0h]
    float v81; // [esp+140h] [ebp-BCh]
    float v82; // [esp+144h] [ebp-B8h]
    float v83; // [esp+148h] [ebp-B4h]
    float v84; // [esp+14Ch] [ebp-B0h]
    float v85; // [esp+150h] [ebp-ACh]
    float v86; // [esp+154h] [ebp-A8h]
    float v87; // [esp+158h] [ebp-A4h]
    float v88; // [esp+15Ch] [ebp-A0h]
    float v89; // [esp+160h] [ebp-9Ch]
    float v90; // [esp+164h] [ebp-98h]
    float v91; // [esp+168h] [ebp-94h]
    float v92; // [esp+16Ch] [ebp-90h]
    float v93; // [esp+170h] [ebp-8Ch]
    float v94; // [esp+174h] [ebp-88h]
    int v95; // [esp+178h] [ebp-84h] BYREF
    float v96; // [esp+17Ch] [ebp-80h]
    float v97; // [esp+180h] [ebp-7Ch]
    float v98 [21]; // [esp+184h] [ebp-78h] BYREF
    int v99; // [esp+1D8h] [ebp-24h] BYREF
    float v100; // [esp+1DCh] [ebp-20h]
    float v101; // [esp+1E0h] [ebp-1Ch]
    int v102; // [esp+1E4h] [ebp-18h]
    char v103 [4]; // [esp+1E8h] [ebp-14h]
    unsigned int v104; // [esp+1ECh] [ebp-10h]
    int v105; // [esp+1F0h] [ebp-Ch]
    float j; // [esp+1F4h] [ebp-8h]
    float i; // [esp+1F8h] [ebp-4h]

    if(*(int*) (*((_DWORD*) this + 1) + 9532) < 0
       && *(unsigned __int8*) (*((_DWORD*) this + 1) + 7072) + *((unsigned __int8*) this + 32) > 0) {
        v104 = *((_DWORD*) this + 1) + 5168;
        sub_432AD0((void*) dword_6D4588, v104);
        v104 = *((_DWORD*) this + 1) + 5712;
        v1 = *(_DWORD*) (v104 + 128);
        BYTE1(v1) |= 3u;
        *(_DWORD*) (v104 + 128) = v1;
        *(float*) (v104 + 28) = this [10] * 288.0 / 14.0;
        *(float*) (v104 + 144) = 96.0;
        *(float*) (v104 + 148) = 24.0;
        *(float*) (v104 + 152) = 0.0;
        sub_432AD0((void*) dword_6D4588, v104);
        *(float*) &v99 = 80.0;
        v100 = 16.0;
        v101 = 0.0;
        dword_481B24 = (*((_DWORD*) this + 4) << 24) | 0xFFFF80;
        sub_401650(dword_47B900, &v99, "%d", *((_DWORD*) this + 5));
        v92 = 384.0;
        v93 = 16.0;
        v94 = 0.0;
        *(float*) &v99 = 384.0;
        v100 = 16.0;
        v101 = 0.0;
        if(*((int*) this + 6) < 20) {
            if(*((int*) this + 6) < 10) {
                if(*((int*) this + 6) < 5)
                    v102 = dword_4764AC;
                else
                    v102 = dword_4764A8;
            }
            else {
                v102 = dword_4764A4;
            }
        }
        else {
            v102 = dword_4764A0;
        }
        dword_481B24 = v102 | (*((_DWORD*) this + 4) << 24);
        if(*((int*) this + 6) <= 99)
            v27 = *((_DWORD*) this + 6);
        else
            v27 = 99;
        *(_DWORD*) v103 = v27;
        if(v27 < 10 && *((_DWORD*) this + 7) != *((_DWORD*) this + 6))
            sub_4311E0(dword_6D3F50, (int*) 0x1D, 0);
        sub_401650(dword_47B900, &v99, "%.2d", *(_DWORD*) v103);
        dword_481B24 = -1;
        this [7] = this [6];
    }
    dword_6C6DE0 = 0;
    dword_6C6DE4 = 0;
    dword_6C6DE8 = 640;
    dword_6C6DEC = 480;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    v104 = *((_DWORD*) this + 1) + 1632;
    if((((unsigned int) dword_6C6E60 >> 4) & 1) == 0
       && (*(_DWORD*) (v104 + 188)
       || dword_6C6EB0
       || ((unsigned int) dword_6C6E60 >> 4) & 1 | ((unsigned int) dword_6C6E60 >> 3) & 1)) {
        for(i = 0.0; i < 464.0; i = i + 32.0) {
            v89 = 0.0;
            v90 = i;
            v91 = 0.49000001;
            v2 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = 0.0;
            *++v2 = v90;
            v2 [1] = v91;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        for(j = 416.0; j < 624.0; j = j + 32.0) {
            for(i = 0.0; i < 464.0; i = i + 32.0) {
                v86 = j;
                v87 = i;
                v88 = 0.49000001;
                v3 = (float*) (v104 + 144);
                *(float*) (v104 + 144) = j;
                *++v3 = v87;
                v3 [1] = v88;
                sub_432AD0((void*) dword_6D4588, v104);
            }
        }
        v104 = *((_DWORD*) this + 1) + 1904;
        for(j = 32.0; j < 416.0; j = j + 32.0) {
            v83 = j;
            v84 = 0.0;
            v85 = 0.49000001;
            v4 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v4 = v84;
            v4 [1] = v85;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        v104 = *((_DWORD*) this + 1) + 2176;
        for(j = 32.0; j < 416.0; j = j + 32.0) {
            v80 = j;
            v81 = 464.0;
            v82 = 0.49000001;
            v5 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v5 = v81;
            v5 [1] = v82;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1) + 1360);
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1));
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1) + 272);
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1) + 816);
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1) + 1088);
        sub_432CC0((void*) dword_6D4588, *((_DWORD*) this + 1) + 544);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 2448);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 2720);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 2992);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 3264);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 3536);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 3808);
        sub_432AD0((void*) dword_6D4588, *((_DWORD*) this + 1) + 4080);
        v6 = *this;
        LOBYTE(v6) = *(_DWORD*) this & 0xFC | 2;
        *this = v6;
        v7 = *this;
        LOBYTE(v7) = *(_DWORD*) this & 0xF3 | 8;
        *this = v7;
        v8 = *this;
        LOBYTE(v8) = *(_DWORD*) this & 0x3F | 0x80;
        *this = v8;
        v9 = *this;
        BYTE1(v9) = BYTE1(*(_DWORD*) this) & 0xFC | 2;
        *this = v9;
        v10 = *this;
        LOBYTE(v10) = *(_DWORD*) this & 0xCF | 0x20;
        *this = v10;
    }
    if((((unsigned int) dword_6C6E60 >> 4) & 1) == 0) {
        v104 = *((_DWORD*) this + 1) + 5984;
        j = 496.0;
        v77 = 496.0;
        v78 = 58.0;
        v79 = 0.49000001;
        v11 = (float*) (v104 + 144);
        *(float*) (v104 + 144) = 496.0;
        *++v11 = v78;
        v11 [1] = v79;
        sub_432AD0((void*) dword_6D4588, v104);
        v74 = j;
        v75 = 82.0;
        v76 = 0.49000001;
        v12 = (float*) (v104 + 144);
        *(float*) (v104 + 144) = j;
        *++v12 = v75;
        v12 [1] = v76;
        sub_432AD0((void*) dword_6D4588, v104);
        if((*(_DWORD*) this & 3) != 0) {
            v71 = j;
            v72 = 122.0;
            v73 = 0.49000001;
            v13 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v13 = v72;
            v13 [1] = v73;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        if(((*(_DWORD*) this >> 2) & 3) != 0) {
            v68 = j;
            v69 = 146.0;
            v70 = 0.49000001;
            v14 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v14 = v69;
            v14 [1] = v70;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        if(((*(_DWORD*) this >> 4) & 3) != 0) {
            v65 = j;
            v66 = 186.0;
            v67 = 0.49000001;
            v15 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v15 = v66;
            v15 [1] = v67;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        if(((*(_DWORD*) this >> 6) & 3) != 0) {
            v62 = j;
            v63 = 206.0;
            v64 = 0.49000001;
            v16 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v16 = v63;
            v16 [1] = v64;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        if(((*(_DWORD*) this >> 8) & 3) != 0) {
            v59 = j;
            v60 = 226.0;
            v61 = 0.49000001;
            v17 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v17 = v60;
            v17 [1] = v61;
            sub_432AD0((void*) dword_6D4588, v104);
        }
        v56 = 488.0;
        v57 = 464.0;
        v58 = 0.49000001;
        v18 = (float*) (v104 + 144);
        *(float*) (v104 + 144) = 488.0;
        *++v18 = v57;
        v18 [1] = v58;
        sub_432AD0((void*) dword_6D4588, v104);
        v53 = 0.0;
        v54 = 464.0;
        v55 = 0.49000001;
        v19 = (float*) (v104 + 144);
        *(float*) (v104 + 144) = 0.0;
        *++v19 = v54;
        v19 [1] = v55;
        sub_432AD0((void*) dword_6D4588, v104);
    }
    if((*(_DWORD*) this & 3) != 0 || (((unsigned int) dword_6C6E60 >> 4) & 1) != 0) {
        v104 = *((_DWORD*) this + 1) + 4352;
        v105 = 0;
        j = 496.0;
        while(v105 < byte_69D4BA) {
            v50 = j;
            v51 = 122.0;
            v52 = 0.49000001;
            v20 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v20 = v51;
            v20 [1] = v52;
            sub_432AD0((void*) dword_6D4588, v104);
            ++v105;
            j = j + 16.0;
        }
    }
    if(((*(_DWORD*) this >> 2) & 3) != 0 || (((unsigned int) dword_6C6E60 >> 4) & 1) != 0) {
        v104 = *((_DWORD*) this + 1) + 4624;
        v105 = 0;
        j = 496.0;
        while(v105 < byte_69D4BB) {
            v47 = j;
            v48 = 146.0;
            v49 = 0.49000001;
            v21 = (float*) (v104 + 144);
            *(float*) (v104 + 144) = j;
            *++v21 = v48;
            v21 [1] = v49;
            sub_432AD0((void*) dword_6D4588, v104);
            ++v105;
            j = j + 16.0;
        }
    }
    if(((*(_DWORD*) this >> 4) & 3) != 0 || (((unsigned int) dword_6C6E60 >> 4) & 1) != 0) {
        v31 = 4;
        for(k = v98; --v31 >= 0; k += 5)
            ;
        if(word_69D4B0) {
            v44 = 496.0;
            v45 = 186.0;
            v46 = 0.1;
            v98 [0] = 496.0;
            v98 [1] = 186.0;
            v98 [2] = 0.1;
            v26 = (float) ((unsigned __int16) word_69D4B0 + 496);
            v29 = v26 + 0.0;
            v41 = v29;
            v42 = 186.0;
            v43 = 0.1;
            v98 [5] = v29;
            v98 [6] = 186.0;
            v98 [7] = 0.1;
            v38 = 496.0;
            v39 = 202.0;
            v40 = 0.1;
            v98 [10] = 496.0;
            v98 [11] = 202.0;
            v98 [12] = 0.1;
            v35 = v29;
            v36 = 202.0;
            v37 = 0.1;
            v98 [15] = v29;
            v98 [16] = 202.0;
            v98 [17] = 0.1;
            v98 [14] = -1.2963385e20;
            v98 [4] = -1.2963385e20;
            v98 [19] = -2.0651865e-38;
            v98 [9] = -2.0651865e-38;
            v98 [18] = 1.0;
            v98 [13] = 1.0;
            v98 [8] = 1.0;
            v98 [3] = 1.0;
            if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
                (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 2);
                (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 2);
            }
            (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 0);
            (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 0);
            if((((unsigned int) dword_6C6E60 >> 6) & 1) == 0) {
                (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 8);
                (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 14, 0);
            }
            (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 68);
            (*(void(__stdcall**)(int, int, int, float*, int))(*(_DWORD*) dword_6C6D20 + 288))(dword_6C6D20, 5, 2, v98, 20);
            *(_BYTE*) (dword_6D4588 + 135358) = -1;
            *(_BYTE*) (dword_6D4588 + 135357) = -1;
            *(_BYTE*) (dword_6D4588 + 135356) = -1;
            *(_BYTE*) (dword_6D4588 + 135359) = -1;
            if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
                (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 4);
                (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 4);
            }
            (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 2);
            (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 2);
            if((unsigned __int16) word_69D4B0 >= 0x80u) {
                v104 = *((_DWORD*) this + 1) + 4896;
                *(float*) &v32 [3] = 496.0;
                v33 = 186.0;
                v34 = 0.0;
                v22 = (float*) (v104 + 144);
                *(float*) (v104 + 144) = 496.0;
                *++v22 = v33;
                v22 [1] = v34;
                sub_432AD0((void*) dword_6D4588, v104);
            }
        }
        if((unsigned __int16) word_69D4B0 < 0x80u) {
            *(float*) v32 = 496.0;
            *(float*) &v32 [1] = 186.0;
            *(float*) &v32 [2] = 0.0;
            sub_401650(dword_47B900, v32, "%d", (unsigned __int16) word_69D4B0);
        }
    }
    *(float*) &v95 = 496.0;
    v96 = 82.0;
    v97 = 0.0;
    sub_401650(dword_47B900, &v95, "%.9d", *(_DWORD*) dword_69BCA0);
    *(float*) &v95 = 496.0;
    v96 = 58.0;
    v97 = 0.0;
    sub_401650(dword_47B900, &v95, "%.9d", *(_DWORD*) dword_69BCAC);
    if(((*(_DWORD*) this >> 6) & 3) != 0 || (((unsigned int) dword_6C6E60 >> 4) & 1) != 0) {
        *(float*) &v95 = 496.0;
        v96 = 206.0;
        v97 = 0.0;
        sub_401650(dword_47B900, &v95, "%d", *(_DWORD*) dword_69BCB4);
    }
    if(((*(_DWORD*) this >> 8) & 3) != 0 || (((unsigned int) dword_6C6E60 >> 4) & 1) != 0) {
        *(float*) &v95 = 496.0;
        v96 = 226.0;
        v97 = 0.0;
        sub_401650(dword_47B900, &v95, "%d", (unsigned __int16) word_69D4B4);
    }
    if((*(_DWORD*) this & 3) != 0)
        *(_DWORD*) this = ((*(_DWORD*) this & 3) - 1) & 3 | *(_DWORD*) this & 0xFFFFFFFC;
    if(((*(_DWORD*) this >> 4) & 3) != 0)
        *(_DWORD*) this = (16 * ((((*(_DWORD*) this >> 4) & 3) - 1) & 3)) | *(_DWORD*) this & 0xFFFFFFCF;
    if(((*(_DWORD*) this >> 2) & 3) != 0)
        *(_DWORD*) this = (4 * ((((*(_DWORD*) this >> 2) & 3) - 1) & 3)) | *(_DWORD*) this & 0xFFFFFFF3;
    if(((*(_DWORD*) this >> 6) & 3) != 0) {
        v23 = *this;
        LOBYTE(v23) = *(_DWORD*) this & 0x3F;
        *(_DWORD*) this = (((((*(_DWORD*) this >> 6) & 3) - 1) & 3) << 6) | LODWORD(v23);
    }
    result = (*(_DWORD*) this >> 8) & 3;
    if(result) {
        v25 = *this;
        BYTE1(v25) = BYTE1(*(_DWORD*) this) & 0xFC;
        result = (int) this;
        *(_DWORD*) this = ((((BYTE1(*(_DWORD*) this) & 3) - 1) & 3) << 8) | LODWORD(v25);
    }
    return result;
}
// 4764A0: using guessed type int dword_4764A0;
// 4764A4: using guessed type int dword_4764A4;
// 4764A8: using guessed type int dword_4764A8;
// 4764AC: using guessed type int dword_4764AC;
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B4: using guessed type __int16 word_69D4B4;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EB0: using guessed type int dword_6C6EB0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0041ADF3) --------------------------------------------------------
int __thiscall sub_41ADF3(int this) {
    _DWORD* v1; // esi
    _DWORD* v2; // edi
    _DWORD* v3; // esi
    _DWORD* v4; // edi
    int result; // eax
    int v7 [3]; // [esp+14h] [ebp-Ch] BYREF

    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 7204) & 1) != 0) {
        *(float*) v7 = 168.0;
        *(float*) &v7 [1] = 198.0;
        *(float*) &v7 [2] = 0.0;
        if(byte_69D4C4) {
            dword_481B24 = *(_DWORD*) (*(_DWORD*) (this + 4) + 7200) & 0xFF000000 | 0xFFFF40;
            *(float*) v7 = 136.0;
            sub_401650(dword_47B900, v7, " DEMO PLAY");
        }
        else {
            sub_433590(dword_6D4588, *(_DWORD*) (this + 4) + 7076);
            dword_481B24 = *(_DWORD*) (*(_DWORD*) (this + 4) + 7200) & 0xFF000000 | 0xFFFF40;
            if(*(int*) dword_69D6D4 >= 6) {
                *(float*) v7 = 136.0;
                if(*(_DWORD*) dword_69D6D4 == 6)
                    sub_401650(dword_47B900, v7, "FINAL STAGE");
                else
                    sub_401650(dword_47B900, v7, "EXTRA STAGE");
            }
            else {
                *(float*) v7 = 168.0;
                sub_401650(dword_47B900, v7, "STAGE %d", *(_DWORD*) dword_69D6D4);
            }
        }
        dword_481B24 = -1;
    }
    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 7476) & 1) != 0 && !byte_69D4C4)
        sub_433590(dword_6D4588, *(_DWORD*) (this + 4) + 7348);
    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 7748) & 1) != 0)
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 7620);
    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 8020) & 1) != 0)
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 7892);
    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 8292) & 1) != 0) {
        v1 = (_DWORD*) (*(_DWORD*) (this + 4) + 8308);
        v2 = (_DWORD*) (*(_DWORD*) (this + 4) + 8852);
        *v2 = *v1++;
        *++v2 = *v1;
        v2 [1] = v1 [1];
        *(float*) (*(_DWORD*) (this + 4) + 8852) = *(float*) (this + 8) * 16.0 / 15.0 / 2.0
            + -128.0
            - 16.0
            + *(float*) (*(_DWORD*) (this + 4) + 8852);
        *(float*) (*(_DWORD*) (this + 4) + 8736) = *(float*) (this + 8) / 14.0;
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 8708);
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 8164);
    }
    if((*(_DWORD*) (*(_DWORD*) (this + 4) + 8564) & 1) != 0) {
        v3 = (_DWORD*) (*(_DWORD*) (this + 4) + 8580);
        v4 = (_DWORD*) (*(_DWORD*) (this + 4) + 9124);
        *v4 = *v3++;
        *++v4 = *v3;
        v4 [1] = v3 [1];
        *(float*) (*(_DWORD*) (this + 4) + 9124) = 128.0
            - *(float*) (this + 12) * 16.0 / 15.0 / 2.0
            + *(float*) (*(_DWORD*) (this + 4) + 9124);
        *(float*) (*(_DWORD*) (this + 4) + 9008) = *(float*) (this + 12) / 14.0;
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 8980);
        sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 8436);
    }
    result = *(__int16*) (*(_DWORD*) (this + 4) + 9428);
    if(result >= 0) {
        dword_6C6DE0 = (unsigned __int64) flt_69D6DC;
        dword_6C6DE4 = (unsigned __int64) flt_69D6E0;
        dword_6C6DE8 = (unsigned __int64) flt_69D6E4;
        dword_6C6DEC = (unsigned __int64) flt_69D6E8;
        (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
        return sub_432AD0((void*) dword_6D4588, *(_DWORD*) (this + 4) + 9252);
    }
    return result;
}
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 69D4C4: using guessed type char byte_69D4C4;
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (0041B1A4) --------------------------------------------------------
int __cdecl sub_41B1A4(int* a1) {
    return sub_417D29(a1);
}

//----- (0041B1B1) --------------------------------------------------------
int __cdecl sub_41B1B1(int a1) {
    sub_432030(dword_6D4588, 18);
    sub_432030(dword_6D4588, 19);
    sub_432030(dword_6D4588, 20);
    sub_41872A((_DWORD*) a1);
    if(dword_6C6EA4 != 3) {
        sub_432030(dword_6D4588, 13);
        sub_432030(dword_6D4588, 14);
        sub_432030(dword_6D4588, 15);
        sub_432030(dword_6D4588, 16);
        sub_432030(dword_6D4588, 17);
        j__free(*(void**) (a1 + 4));
        *(_DWORD*) (a1 + 4) = 0;
    }
    return 0;
}
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (0041B252) --------------------------------------------------------
int sub_41B252() {
    _DWORD* v0; // eax
    _DWORD* v2; // [esp+4h] [ebp-1Ch]

    if(dword_6C6EA4 != 3) {
        memset(dword_69BC30, 0, 0x2Cu);
        v0 = operator new(0x2C44u);
        if(v0)
            v2 = sub_41B34B(v0);
        else
            v2 = 0;
        dword_69BC30 [1] = (int) v2;
    }
    dword_69BC80 = (int) sub_4174D7;
    dword_69BC84 = (int) sub_41B1A4;
    dword_69BC88 = (int) sub_41B1B1;
    dword_69BC98 = (int) dword_69BC30;
    if(sub_41C860(byte_69D918, (int) &unk_69BC7C, 12))
        return -1;
    dword_69BC60 = (int) sub_417502;
    dword_69BC64 = 0;
    dword_69BC68 = 0;
    dword_69BC78 = (int) dword_69BC30;
    sub_41C940((__int16*) byte_69D918, (int) &unk_69BC5C, 11);
    return 0;
}
// 69BC30: using guessed type int dword_69BC30[5];
// 69BC60: using guessed type int dword_69BC60;
// 69BC64: using guessed type int dword_69BC64;
// 69BC68: using guessed type int dword_69BC68;
// 69BC78: using guessed type int dword_69BC78;
// 69BC80: using guessed type int dword_69BC80;
// 69BC84: using guessed type int dword_69BC84;
// 69BC88: using guessed type int dword_69BC88;
// 69BC98: using guessed type int dword_69BC98;
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (0041B34B) --------------------------------------------------------
_DWORD* __thiscall sub_41B34B(_DWORD* this) {
    int i; // [esp+ACh] [ebp-Ch]
    int v4; // [esp+B4h] [ebp-4h]

    v4 = 26;
    for(i = (int) this; --v4 >= 0; i += 272)
        sub_403720(i);
    sub_403720((int) (this + 1769));
    sub_403720((int) (this + 1837));
    sub_403720((int) (this + 1905));
    sub_403720((int) (this + 1973));
    sub_403720((int) (this + 2041));
    sub_403720((int) (this + 2109));
    sub_403720((int) (this + 2177));
    sub_403720((int) (this + 2245));
    sub_403720((int) (this + 2313));
    sub_41B4C4(this + 2381);
    sub_424127(this + 2814);
    sub_424127(this + 2822);
    sub_424127(this + 2830);
    return this;
}

//----- (0041B4C4) --------------------------------------------------------
_DWORD* __thiscall sub_41B4C4(_DWORD* this) {
    int k; // [esp+4h] [ebp-58h]
    int v4; // [esp+Ch] [ebp-50h]
    int j; // [esp+20h] [ebp-3Ch]
    int v6; // [esp+28h] [ebp-34h]
    int i; // [esp+3Ch] [ebp-20h]
    int v8; // [esp+44h] [ebp-18h]

    sub_424127(this + 3);
    v8 = 2;
    for(i = (int) (this + 7); --v8 >= 0; i += 272)
        sub_403720(i);
    v6 = 2;
    for(j = (int) (this + 143); --v6 >= 0; j += 272)
        sub_403720(j);
    v4 = 2;
    for(k = (int) (this + 279); --v4 >= 0; k += 272)
        sub_403720(k);
    return this;
}

//----- (0041B58C) --------------------------------------------------------
void sub_41B58C() {
    sub_41CDE0(byte_69D918, (int) &unk_69BC7C);
    sub_41CDE0(byte_69D918, (int) &unk_69BC5C);
}

//----- (0041B5AF) --------------------------------------------------------
int __thiscall sub_41B5AF(void* this) {
    *(_DWORD*) this = *((_DWORD*) this + 2);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) this + 2, (float*) this + 1);
    return *((_DWORD*) this + 2);
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0041B5E1) --------------------------------------------------------
BOOL __stdcall sub_41B5E1(float a1, float a2, float a3, float a4) {
    if(a3 / 2.0 + a1 < 0.0)
        return 0;
    if(a1 - a3 / 2.0 > flt_69D6E4)
        return 0;
    if(a4 / 2.0 + a2 >= 0.0)
        return a2 - a4 / 2.0 <= flt_69D6E8;
    return 0;
}
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;

//----- (0041B663) --------------------------------------------------------
int __cdecl sub_41B663(int a1) {
    int v2; // edx
    int v3; // eax
    bool v4; // [esp+10h] [ebp-8h]
    unsigned int v5; // [esp+14h] [ebp-4h]
    unsigned int v6; // [esp+14h] [ebp-4h]

    if(*(_BYTE*) (a1 + 6180)) {
        if(word_69D904 && word_69D904 != word_69D908)
            dword_6C6EA4 = 1;
        if(++ * (_DWORD*) (a1 + 6184) == 3600)
            sub_42FD30(2, 120, 0, 0, 0);
        if(*(int*) (a1 + 6184) >= 3720)
            dword_6C6EA4 = 1;
    }
    if(!*(_BYTE*) (a1 + 6176)
       && !*(_BYTE*) (a1 + 6175)
       && !*(_BYTE*) (a1 + 6180)
       && (word_69D904 & 8) != 0
       && (word_69D904 & 8) != (word_69D908 & 8)) {
        *(_BYTE*) (a1 + 6175) = 1;
        flt_69D6DC = 32.0;
        flt_69D6E0 = 16.0;
        flt_69D6E4 = 384.0;
        flt_69D6E8 = 448.0;
        dword_6C6EB0 = 3;
    }
    v4 = !*(_BYTE*) (a1 + 6176) && !*(_BYTE*) (a1 + 6175);
    *(_BYTE*) (a1 + 6177) = v4;
    dword_6C6DE0 = (unsigned __int64) *(float*) (a1 + 6716);
    dword_6C6DE4 = (unsigned __int64) *(float*) (a1 + 6720);
    dword_6C6DE8 = (unsigned __int64) *(float*) (a1 + 6724);
    dword_6C6DEC = (unsigned __int64) *(float*) (a1 + 6728);
    *(float*) &dword_6C6DF0 = 0.5;
    *(float*) &dword_6C6DF4 = 1.0;
    sub_41C3F3(0.0);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    (*(void(__stdcall**)(int, _DWORD, _DWORD, int, int, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 144))(
        dword_6C6D20,
        0,
        0,
        2,
        dword_487B60,
        1.0,
        0);
    if(*(_BYTE*) (a1 + 6175) == 1 || *(_BYTE*) (a1 + 6175) == 2 || *(_BYTE*) (a1 + 6176))
        return 3;
    if(*(_DWORD*) (a1 + 4) >= 0x3B9ACA00u)
        *(_DWORD*) (a1 + 4) = 999999990;
    if(*(_DWORD*) a1 != *(_DWORD*) (a1 + 4)) {
        if(*(_DWORD*) (a1 + 4) < *(_DWORD*) a1)
            *(_DWORD*) (a1 + 4) = *(_DWORD*) a1;
        v5 = (unsigned int) (*(_DWORD*) (a1 + 4) - *(_DWORD*) a1) >> 5;
        if(v5 < 0x1343E) {
            if(v5 < 0xA)
                v5 = 10;
        }
        else {
            v5 = 78910;
        }
        v2 = v5 % 0xA;
        v6 = v5 - v5 % 0xA;
        if(*(_DWORD*) (a1 + 8) < v6)
            *(_DWORD*) (a1 + 8) = v6;
        if((unsigned int) (*(_DWORD*) (a1 + 8) + *(_DWORD*) a1) > *(_DWORD*) (a1 + 4))
            *(_DWORD*) (a1 + 8) = *(_DWORD*) (a1 + 4) - *(_DWORD*) a1;
        *(_DWORD*) a1 += *(_DWORD*) (a1 + 8);
        if(*(_DWORD*) a1 >= *(_DWORD*) (a1 + 4)) {
            *(_DWORD*) (a1 + 8) = 0;
            *(_DWORD*) a1 = *(_DWORD*) (a1 + 4);
        }
        if(*(char*) (a1 + 6172) >= 0 && (unsigned int) dword_4764B0 [*(char*) (a1 + 6172)] <= *(_DWORD*) a1) {
            if(*(char*) (a1 + 6170) < 8) {
                ++* (_BYTE*) (a1 + 6170);
                sub_4311E0(dword_6D3F50, (int*) 0x1C, 0);
            }
            v3 = dword_69BC30 [0];
            LOBYTE(v3) = dword_69BC30 [0] & 0xFC | 2;
            dword_69BC30 [0] = v3;
            ++* (_BYTE*) (a1 + 6172);
            sub_41C57E(dword_69BCA0, v2, 200);
        }
        if(*(_DWORD*) (a1 + 12) < *(_DWORD*) a1)
            *(_DWORD*) (a1 + 12) = *(_DWORD*) a1;
    }
    ++* (_DWORD*) (a1 + 6704);
    return 1;
}
// 41BA15: variable 'v2' is possibly undefined
// 4764B0: using guessed type int dword_4764B0[5];
// 487B60: using guessed type int dword_487B60;
// 69BC30: using guessed type int dword_69BC30[5];
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C6DF0: using guessed type int dword_6C6DF0;
// 6C6DF4: using guessed type int dword_6C6DF4;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C6EB0: using guessed type int dword_6C6EB0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0041BA4A) --------------------------------------------------------
int __cdecl sub_41BA4A(int a1) {
    if(*(_BYTE*) (a1 + 6175))
        *(_BYTE*) (a1 + 6175) = 2;
    return 1;
}

//----- (0041BA6A) --------------------------------------------------------
int sub_41BA6A() {
    dword_69D724 = (int) sub_41B663;
    dword_69D728 = (int) sub_41BB02;
    dword_69D72C = (int) sub_41C1F7;
    dword_69D73C = (int) dword_69BCA0;
    *(_DWORD*) &dword_69BCA0 [6704] = 0;
    if(sub_41C860(byte_69D918, (int) &unk_69D720, 4))
        return -1;
    dword_69D744 = (int) sub_41BA4A;
    dword_69D748 = 0;
    dword_69D74C = 0;
    dword_69D75C = (int) dword_69BCA0;
    sub_41C940((__int16*) byte_69D918, (int) &unk_69D740, 2);
    return 0;
}
// 69D724: using guessed type int dword_69D724;
// 69D728: using guessed type int dword_69D728;
// 69D72C: using guessed type int dword_69D72C;
// 69D73C: using guessed type int dword_69D73C;
// 69D744: using guessed type int dword_69D744;
// 69D748: using guessed type int dword_69D748;
// 69D74C: using guessed type int dword_69D74C;
// 69D75C: using guessed type int dword_69D75C;

//----- (0041BB02) --------------------------------------------------------
int __usercall sub_41BB02(int a1, int a2) {
    int v3; // [esp+0h] [ebp-28h]
    int v4; // [esp+10h] [ebp-18h]
    _DWORD* v5; // [esp+14h] [ebp-14h]
    unsigned int j; // [esp+18h] [ebp-10h]
    int i; // [esp+1Ch] [ebp-Ch]
    int v8; // [esp+20h] [ebp-8h]
    int v9; // [esp+24h] [ebp-4h]

    v9 = 0;
    (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) dword_6C6D20 + 20))(dword_6C6D20, 0);
    if(dword_6C6EA4 == 3) {
        *(_DWORD*) a2 = *(_DWORD*) (a2 + 4);
        *(_DWORD*) (a2 + 8) = 0;
    }
    else {
        byte_6C6E7D = byte_69D4BB;
        byte_6C6E7C = byte_69D4BA;
        *(float*) (a2 + 6716) = 32.0;
        *(float*) (a2 + 6720) = 16.0;
        *(float*) (a2 + 6724) = 384.0;
        *(float*) (a2 + 6728) = 448.0;
        *(float*) (a2 + 6732) = 8.0;
        *(float*) (a2 + 6736) = 16.0;
        *(float*) (a2 + 6740) = 368.0;
        *(float*) (a2 + 6744) = 416.0;
        *(_DWORD*) (a2 + 6764) = 0;
        *(_DWORD*) a2 = 0;
        *(_DWORD*) (a2 + 4) = 0;
        *(_DWORD*) (a2 + 8) = 0;
        *(_DWORD*) (a2 + 12) = 100000;
        *(_WORD*) (a2 + 6160) = 0;
        *(_BYTE*) (a2 + 6168) = 0;
        if(*(int*) (a2 + 6708) >= 6)
            *(_DWORD*) (a2 + 16) = 4;
        if(*(int*) (a2 + 16) >= 4)
            *(_BYTE*) (a2 + 6172) = 4;
        else
            *(_BYTE*) (a2 + 6172) = 0;
        byte_69D4B9 = 0;
        *(_DWORD*) (a2 + 6768) = 8;
        *(_DWORD*) (a2 + 24) = 0;
        *(_WORD*) (a2 + 6166) = 0;
        v8 = a2 + 48;
        for(i = 0; i < 64; ++i) {
            for(j = 0; j < 0x20; ++j)
                *(_WORD*) (v8 + 2 * j) = sub_41E780(&word_69D8F8);
            strcpy((char*) v8, "CATK@");
            *(_WORD*) (v8 + 6) = 64;
            *(_BYTE*) (v8 + 8) = 16;
            *(_WORD*) (v8 + 16) = i;
            *(_WORD*) (v8 + 60) = 0;
            *(_WORD*) (v8 + 62) = 0;
            v8 += 64;
        }
        v5 = sub_42B0D9("score.dat");
        *(_DWORD*) dword_69BCAC = sub_42B280(
            v5,
            0,
            (unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD,
            dword_69BCB0);
        sub_42B466((int) v5, a2 + 48);
        sub_42B502((int) v5, a2 + 4144);
        sub_42B65E((int) v5, (_DWORD*) (a2 + 4240));
        if(*(_BYTE*) (a2 + 6179))
            *(_DWORD*) dword_69BCAC = *(_DWORD*) (80 * *(_DWORD*) dword_69D6D4
                                                  + a2
                                                  + 480 * ((unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD)
                                                  + 4240
                                                  + 20 * dword_69BCB0
                                                  + 12);
        sub_42B7DC(v5);
        *(_DWORD*) (a2 + 6768) = dword_476564 [3 * dword_69BCB0];
        *(_DWORD*) (a2 + 6776) = dword_476568 [3 * dword_69BCB0];
        *(_DWORD*) (a2 + 6772) = dword_47656C [3 * dword_69BCB0];
        *(_DWORD*) (a2 + 32) = 0;
        *(_DWORD*) (a2 + 36) = 0;
        *(_DWORD*) (a2 + 40) = 0;
    }
    *(_DWORD*) (a2 + 6780) = 0;
    *(_WORD*) (a2 + 6164) = 0;
    *(_DWORD*) (a2 + 20) = 0;
    *(_BYTE*) (a2 + 6175) = 0;
    ++* (_DWORD*) (a2 + 6708);
    if(!dword_69BCBC) {
        v4 = (unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD;
        if(!*(_BYTE*) (a2 + 6168) && *(unsigned __int8*) (a2 + 24 * v4 + dword_69BCB0 + 4156) < *(_DWORD*) (a2 + 6708) - 1)
            *(_BYTE*) (a2 + 24 * v4 + dword_69BCB0 + 4156) = *(_BYTE*) (a2 + 6708) - 1;
        if(*(unsigned __int8*) (a2 + 24 * v4 + dword_69BCB0 + 4161) < *(_DWORD*) (a2 + 6708) - 1)
            *(_BYTE*) (a2 + 24 * v4 + dword_69BCB0 + 4161) = *(_BYTE*) (a2 + 6708) - 1;
    }
    if(*(_BYTE*) (a2 + 6179)) {
        v3 = *(_DWORD*) (a2 + 6708);
        if(v3 != 1) {
            if(v3 == 2)
                *(_WORD*) (a2 + 6160) = 64;
            else
                *(_WORD*) (a2 + 6160) = 128;
        }
    }
    sub_424375((int**) &dword_6C6D18, 4, "th06e_CM.dat");
    sub_424375((int**) &dword_6C6D18, 2, "th06e_ST.dat");
    if(dword_69BCBC == 1) {
        if(sub_42A240(1, (int) Destination))
            v9 = 1;
        while((unsigned int) dword_4764B0 [*(char*) (a2 + 6172)] <= *(_DWORD*) a2)
            ++* (_BYTE*) (a2 + 6172);
        *(_DWORD*) (a2 + 6776) = dword_47652C [3 * dword_69BCB0];
        *(_DWORD*) (a2 + 6772) = dword_476530 [3 * dword_69BCB0];
    }
    dword_69D8FC = 0;
    *(_WORD*) (a2 + 6700) = word_69D8F8;
    if(sub_4044C0(*(_DWORD*) (a2 + 6708))) {
        sub_41E4D0((int) byte_69D998, aError_2);
        return -1;
    }
    else if(sub_428780(0)) {
        sub_41E4D0((int) byte_69D998, aError_3);
        return -1;
    }
    else if(sub_4148F0((int) "data/etama.anm")) {
        sub_41E4D0((int) byte_69D998, aError_4);
        return -1;
    }
    else if(sub_412320((int) off_4764E8 [2 * *(_DWORD*) (a2 + 6708)], (int) off_4764EC [2 * *(_DWORD*) (a2 + 6708)])) {
        sub_41E4D0((int) byte_69D998, aError_5);
        return -1;
    }
    else if(sub_407340((__int16**) dword_487E50, (&off_4764C4) [*(_DWORD*) (a2 + 6708)])) {
        sub_41E4D0((int) byte_69D998, aError_6);
        return -1;
    }
    else if(sub_40F3F0()) {
        sub_41E4D0((int) byte_69D998, aError_7);
        return -1;
    }
    else if(sub_41B252()) {
        sub_41E4D0((int) byte_69D998, aError2d);
        return -1;
    }
    else {
        if(!dword_69BCBC)
            sub_42A240(0, (int) "replay/th6_00.rpy");
        if(!byte_69D4C4) {
            sub_424AAC(1, (char*) (dword_487B14 + 784));
            sub_424B5D(a1, (char*) (dword_487B14 + 656));
        }
        *(_BYTE*) (a2 + 6176) = 0;
        *(_BYTE*) (a2 + 6177) = 1;
        if(dword_6C6EA4 != 3) {
            flt_6C6ECC = 0.0;
            flt_6C6ED0 = 0.0;
        }
        *(_BYTE*) (a2 + 44) = 0;
        *(_DWORD*) (a2 + 4) = 0;
        *(_BYTE*) (a2 + 6178) = 0;
        sub_401410(dword_47B900);
        if(v9)
            dword_6C6EA4 = 1;
        dword_6C6EB0 = 3;
        return 0;
    }
}
// 4764B0: using guessed type int dword_4764B0[5];
// 4764E8: using guessed type char *off_4764E8[7];
// 4764EC: using guessed type char *off_4764EC[6];
// 47652C: using guessed type int dword_47652C[];
// 476530: using guessed type int dword_476530[13];
// 476564: using guessed type int dword_476564[];
// 476568: using guessed type int dword_476568[];
// 47656C: using guessed type int dword_47656C[13];
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 487B14: using guessed type int dword_487B14;
// 487E50: using guessed type _DWORD dword_487E50[2];
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4B9: using guessed type char byte_69D4B9;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D4C4: using guessed type char byte_69D4C4;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 69D8FC: using guessed type int dword_69D8FC;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E7C: using guessed type char byte_6C6E7C;
// 6C6E7D: using guessed type char byte_6C6E7D;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C6EB0: using guessed type int dword_6C6EB0;
// 6C6ECC: using guessed type float flt_6C6ECC;
// 6C6ED0: using guessed type float flt_6C6ED0;

//----- (0041C1F7) --------------------------------------------------------
int __cdecl sub_41C1F7(int a1) {
    (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) dword_6C6D20 + 20))(dword_6C6D20, 0);
    if(!byte_69D4C4)
        sub_424D38();
    sub_404650();
    sub_4172B0();
    sub_42A0E0();
    sub_413350();
    sub_407400((void**) dword_487E50);
    sub_40F4A0();
    sub_41B58C();
    sub_42AAB0();
    *(_BYTE*) (a1 + 6177) = 0;
    sub_401410(dword_47B900);
    return 0;
}
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 487E50: using guessed type _DWORD dword_487E50[2];
// 69D4C4: using guessed type char byte_69D4C4;
// 6C6D20: using guessed type int dword_6C6D20;

//----- (0041C269) --------------------------------------------------------
void sub_41C269() {
    sub_41CDE0(byte_69D918, (int) &unk_69D720);
    sub_41CDE0(byte_69D918, (int) &unk_69D740);
}

//----- (0041C28C) --------------------------------------------------------
int __cdecl sub_41C28C(float a1) {
    float X_4; // [esp+Ch] [ebp-74h]
    float v3; // [esp+10h] [ebp-70h]
    float v4; // [esp+14h] [ebp-6Ch]
    float v5; // [esp+30h] [ebp-50h]
    float v6; // [esp+3Ch] [ebp-44h]
    float v7 [3]; // [esp+48h] [ebp-38h] BYREF
    float v8; // [esp+54h] [ebp-2Ch] BYREF
    float v9; // [esp+58h] [ebp-28h]
    float v10; // [esp+5Ch] [ebp-24h]
    float v11 [3]; // [esp+60h] [ebp-20h] BYREF
    float v12; // [esp+6Ch] [ebp-14h]
    float v13; // [esp+70h] [ebp-10h]
    float v14; // [esp+74h] [ebp-Ch]
    float v15; // [esp+78h] [ebp-8h]
    float v16; // [esp+7Ch] [ebp-4h]

    v6 = (float) (unsigned int) dword_6C6DE8;
    v14 = v6 / 2.0;
    v5 = (float) (unsigned int) dword_6C6DEC;
    v15 = v5 / 2.0;
    v13 = v6 / v5;
    v12 = 0.52359879;
    v4 = tan((float) 0.52359879 / 2.0);
    v16 = v15 / v4;
    v11 [0] = 0.0;
    v11 [1] = 1.0;
    v11 [2] = 0.0;
    v8 = v14;
    v9 = -v15;
    v10 = 0.0;
    v7 [0] = v14;
    v7 [1] = v9;
    v7 [2] = -v16;
    sub_43F561(flt_6C6D60, v7, &v8, v11);
    v3 = fabs(v16);
    flt_69D6FC = v3;
    X_4 = a1 + 10000.0;
    sub_43EFEE(flt_6C6DA0, v12, v13, 100.0, X_4);
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 2, flt_6C6D60);
    return (*(int(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 3, flt_6C6DA0);
}
// 69D6FC: using guessed type float flt_69D6FC;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6D60: using guessed type float flt_6C6D60[16];
// 6C6DA0: using guessed type float flt_6C6DA0[16];
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (0041C3F3) --------------------------------------------------------
int __cdecl sub_41C3F3(float a1) {
    float X_4; // [esp+Ch] [ebp-80h]
    float v3; // [esp+10h] [ebp-7Ch]
    float v4; // [esp+14h] [ebp-78h]
    float v5; // [esp+30h] [ebp-5Ch]
    float v6; // [esp+3Ch] [ebp-50h]
    float v7; // [esp+48h] [ebp-44h]
    float v8; // [esp+4Ch] [ebp-40h]
    float v9; // [esp+50h] [ebp-3Ch]
    float v10 [3]; // [esp+54h] [ebp-38h] BYREF
    float v11 [3]; // [esp+60h] [ebp-2Ch] BYREF
    float v12 [3]; // [esp+6Ch] [ebp-20h] BYREF
    float v13; // [esp+78h] [ebp-14h]
    float v14; // [esp+7Ch] [ebp-10h]
    float v15; // [esp+80h] [ebp-Ch]
    float v16; // [esp+84h] [ebp-8h]
    float v17; // [esp+88h] [ebp-4h]

    v6 = (float) (unsigned int) dword_6C6DE8;
    v15 = v6 / 2.0;
    v5 = (float) (unsigned int) dword_6C6DEC;
    v16 = v5 / 2.0;
    v14 = v6 / v5;
    v13 = 0.52359879;
    v4 = tan((float) 0.52359879 / 2.0);
    v17 = v16 / v4;
    v12 [0] = 0.0;
    v12 [1] = 1.0;
    v12 [2] = 0.0;
    v9 = flt_69D704 - v16;
    v8 = v15 + flt_69D700;
    v11 [0] = v8;
    v11 [1] = v9;
    v11 [2] = 0.0;
    v7 = -v17 * flt_69D708;
    v10 [0] = v15;
    v10 [1] = -v16;
    v10 [2] = v7;
    sub_43F561(flt_6C6D60, v10, v11, v12);
    v3 = fabs(v17);
    flt_69D6FC = v3;
    X_4 = a1 + 10000.0;
    sub_43EFEE(flt_6C6DA0, v13, v14, 100.0, X_4);
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 2, flt_6C6D60);
    return (*(int(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 3, flt_6C6DA0);
}
// 69D6FC: using guessed type float flt_69D6FC;
// 69D700: using guessed type float flt_69D700;
// 69D704: using guessed type float flt_69D704;
// 69D708: using guessed type float flt_69D708;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6D60: using guessed type float flt_6C6D60[16];
// 6C6DA0: using guessed type float flt_6C6DA0[16];
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (0041C57E) --------------------------------------------------------
_DWORD* __fastcall sub_41C57E(_DWORD* a1, int a2, int a3) {
    _DWORD* result; // eax

    for(a1 [1695] += a3; (int) a1 [1695] >= 100; a1 [1695] -= 100)
        ++a1 [1692];
    result = (_DWORD*) a1 [1692];
    if((int) result > a1 [1693]) {
        result = a1;
        a1 [1692] = a1 [1693];
    }
    return result;
}

//----- (0041C5FA) --------------------------------------------------------
_DWORD* __fastcall sub_41C5FA(_DWORD* a1, int a2, int a3) {
    _DWORD* result; // eax

    for(a1 [1695] -= a3; (int) a1 [1695] < 0; a1 [1695] += 100)
        --a1 [1692];
    result = (_DWORD*) a1 [1692];
    if((int) result < a1 [1694]) {
        result = a1;
        a1 [1692] = a1 [1694];
    }
    return result;
}

//----- (0041C676) --------------------------------------------------------
float* __thiscall sub_41C676(float* this) {
    memset(this, 0, 0x1A80u);
    this [1679] = 32.0;
    this [1680] = 16.0;
    this [1681] = 384.0;
    this [1682] = 448.0;
    return this;
}

//----- (0041C6D0) --------------------------------------------------------
int __thiscall sub_41C6D0(void* this) {
    sub_41C790((int) this + 32);
    return sub_41C790((int) this);
}

//----- (0041C720) --------------------------------------------------------
_DWORD* __thiscall sub_41C720(_DWORD* this) {
    __int16 v1; // ax

    this [4] = 0;
    this [5] = 0;
    this [1] = 0;
    this [6] = this;
    this [2] = 0;
    this [3] = 0;
    *(_WORD*) this = 0;
    v1 = *((_WORD*) this + 1);
    LOBYTE(v1) = v1 & 0xFE;
    *((_WORD*) this + 1) = v1;
    return this;
}

//----- (0041C790) --------------------------------------------------------
int __thiscall sub_41C790(int this) {
    int result; // eax

    if(*(_DWORD*) (this + 12))
        (*(void(__cdecl**)(_DWORD))(this + 12))(*(_DWORD*) (this + 28));
    *(_DWORD*) (this + 16) = 0;
    *(_DWORD*) (this + 20) = 0;
    result = this;
    *(_DWORD*) (this + 4) = 0;
    *(_DWORD*) (this + 8) = 0;
    *(_DWORD*) (this + 12) = 0;
    return result;
}

//----- (0041C7F0) --------------------------------------------------------
_DWORD* __thiscall sub_41C7F0(_DWORD* this) {
    sub_41C720(this);
    sub_41C720(this + 8);
    this [16] = midiOutGetNumDevs();
    this [17] = 0;
    return this;
}

//----- (0041C860) --------------------------------------------------------
int __thiscall sub_41C860(_DWORD* this, int a2, int a3) {
    int result; // eax

    sub_41E940();
    *(_WORD*) a2 = a3;
    while(this [5] && *(__int16*) this <= a3)
        this = (_DWORD*) this [5];
    if(*(__int16*) this <= a3) {
        *(_DWORD*) (a2 + 20) = 0;
        *(_DWORD*) (a2 + 16) = this;
        this [5] = a2;
    }
    else {
        *(_DWORD*) (a2 + 20) = this;
        *(_DWORD*) (a2 + 16) = this [4];
        if(*(_DWORD*) (a2 + 16))
            *(_DWORD*) (*(_DWORD*) (a2 + 16) + 20) = a2;
        this [4] = a2;
    }
    if(!*(_DWORD*) (a2 + 8))
        return 0;
    result = (*(int(__cdecl**)(_DWORD))(a2 + 8))(*(_DWORD*) (a2 + 28));
    *(_DWORD*) (a2 + 8) = 0;
    return result;
}

//----- (0041C940) --------------------------------------------------------
int __thiscall sub_41C940(__int16* this, int a2, int a3) {
    __int16* v4; // [esp+4h] [ebp-4h]

    v4 = this + 16;
    sub_41E940();
    *(_WORD*) a2 = a3;
    while(*((_DWORD*) v4 + 5) && *v4 <= a3)
        v4 = (__int16*) *((_DWORD*) v4 + 5);
    if(*v4 <= a3) {
        *(_DWORD*) (a2 + 20) = 0;
        *(_DWORD*) (a2 + 16) = v4;
        *((_DWORD*) v4 + 5) = a2;
    }
    else {
        *(_DWORD*) (a2 + 20) = v4;
        *(_DWORD*) (a2 + 16) = *((_DWORD*) v4 + 4);
        if(*(_DWORD*) (a2 + 16))
            *(_DWORD*) (*(_DWORD*) (a2 + 16) + 20) = a2;
        *((_DWORD*) v4 + 4) = a2;
    }
    if(*(_DWORD*) (a2 + 8))
        return (*(int(__cdecl**)(_DWORD))(a2 + 8))(*(_DWORD*) (a2 + 28));
    else
        return 0;
}

//----- (0041CA10) --------------------------------------------------------
int __thiscall sub_41CA10(char* this) {
    int result; // eax
    int v3; // [esp+8h] [ebp-Ch]
    int v4; // [esp+Ch] [ebp-8h]
    char* i; // [esp+10h] [ebp-4h]

    LABEL_1:
    v4 = 0;
    for(i = this; ; i = (char*) *((_DWORD*) i + 5)) {
        LABEL_2:
        if(!i)
            return v4;
        if(*((_DWORD*) i + 1))
            break;
        LABEL_10:
        ;
    }
    while(2) {
        switch((*((int(__cdecl**)(_DWORD))i + 1))(*((_DWORD*) i + 7))) {
            case 0:
                v3 = (int) i;
                i = (char*) *((_DWORD*) i + 5);
                sub_41CDE0(this, v3);
                ++v4;
                goto LABEL_2;
            case 2:
                continue;
            case 3:
                result = 1;
                break;
            case 4:
                result = 0;
                break;
            case 5:
                result = -1;
                break;
            case 6:
                goto LABEL_1;
            default:
                ++v4;
                goto LABEL_10;
        }
        return result;
    }
}

//----- (0041CAD0) --------------------------------------------------------
int __thiscall sub_41CAD0(char* this) {
    int result; // eax
    int v3; // [esp+8h] [ebp-Ch]
    int v4; // [esp+Ch] [ebp-8h]
    _DWORD* i; // [esp+10h] [ebp-4h]

    v4 = 0;
    for(i = this + 32; ; i = (_DWORD*) i [5]) {
        LABEL_2:
        if(!i)
            return v4;
        if(i [1])
            break;
        LABEL_10:
        ;
    }
    while(2) {
        switch(((int(__cdecl*)(_DWORD))i [1])(i [7])) {
            case 0:
                v3 = (int) i;
                i = (_DWORD*) i [5];
                sub_41CDE0(this, v3);
                ++v4;
                goto LABEL_2;
            case 2:
                continue;
            case 3:
                result = 1;
                break;
            case 4:
                result = 0;
                break;
            case 5:
                result = -1;
                break;
            default:
                ++v4;
                goto LABEL_10;
        }
        return result;
    }
}

//----- (0041CB90) --------------------------------------------------------
int __thiscall sub_41CB90(char* this, int a2) {
    _DWORD* v3; // [esp+4h] [ebp-5Ch]
    _DWORD* v4; // [esp+8h] [ebp-58h]
    void* Block; // [esp+14h] [ebp-4Ch]
    _DWORD* v7; // [esp+18h] [ebp-48h]
    _DWORD* v8; // [esp+20h] [ebp-40h]
    _DWORD v9 [5]; // [esp+28h] [ebp-38h] BYREF
    _DWORD* v10; // [esp+3Ch] [ebp-24h]
    _DWORD* j; // [esp+48h] [ebp-18h]
    _DWORD* v12; // [esp+4Ch] [ebp-14h]
    _DWORD* i; // [esp+50h] [ebp-10h]
    int v14; // [esp+5Ch] [ebp-4h]

    sub_41C720(v9);
    v14 = 0;
    v8 = operator new(0x20u);
    LOBYTE(v14) = 1;
    if(v8)
        v4 = sub_41C720(v8);
    else
        v4 = 0;
    LOBYTE(v14) = 0;
    j = v4;
    v10 = v4;
    for(i = (_DWORD*) a2; i; i = (_DWORD*) i [5]) {
        j [6] = i;
        v7 = operator new(0x20u);
        LOBYTE(v14) = 2;
        if(v7)
            v3 = sub_41C720(v7);
        else
            v3 = 0;
        LOBYTE(v14) = 0;
        j [5] = v3;
        j = (_DWORD*) j [5];
    }
    for(i = v9; i; i = (_DWORD*) i [5])
        sub_41CDE0(this, i [6]);
    for(j = v10; j; j = v12) {
        v12 = (_DWORD*) j [5];
        Block = j;
        sub_41C790((int) j);
        j__free(Block);
    }
    v14 = -1;
    return sub_41C790((int) v9);
}
// 41CB90: using guessed type _DWORD var_38[5];

//----- (0041CD10) --------------------------------------------------------
int __thiscall sub_41CD10(char* this) {
    sub_41CB90(this, (int) this);
    return sub_41CB90(this, (int) (this + 32));
}

//----- (0041CD40) --------------------------------------------------------
_DWORD* __stdcall sub_41CD40(int a1) {
    __int16 v1; // cx
    _DWORD* v3; // [esp+0h] [ebp-20h]
    _DWORD* Block; // [esp+8h] [ebp-18h]

    Block = operator new(0x20u);
    if(Block)
        v3 = sub_41C720(Block);
    else
        v3 = 0;
    v3 [1] = a1;
    v3 [2] = 0;
    v3 [3] = 0;
    v1 = *((_WORD*) v3 + 1);
    LOBYTE(v1) = v1 | 1;
    *((_WORD*) v3 + 1) = v1;
    return v3;
}

//----- (0041CDE0) --------------------------------------------------------
void __thiscall sub_41CDE0(char* this, int a2) {
    void(__cdecl * v2)(_DWORD); // [esp+10h] [ebp-Ch]
    char* i; // [esp+14h] [ebp-8h]
    char* j; // [esp+14h] [ebp-8h]

    if(a2) {
        for(i = this; i; i = (char*) *((_DWORD*) i + 5)) {
            if(i == (char*) a2) {
                LABEL_11:
                sub_41E940();
                if(*(_DWORD*) (a2 + 16)) {
                    *(_DWORD*) (a2 + 4) = 0;
                    *(_DWORD*) (*(_DWORD*) (a2 + 16) + 20) = *(_DWORD*) (a2 + 20);
                    if(*(_DWORD*) (a2 + 20))
                        *(_DWORD*) (*(_DWORD*) (a2 + 20) + 16) = *(_DWORD*) (a2 + 16);
                    *(_DWORD*) (a2 + 16) = 0;
                    *(_DWORD*) (a2 + 20) = 0;
                    if((*(_WORD*) (a2 + 2) & 1) != 0) {
                        sub_41C790(a2);
                        j__free((void*) a2);
                    }
                    else if(*(_DWORD*) (a2 + 12)) {
                        v2 = *(void(__cdecl**)(_DWORD))(a2 + 12);
                        *(_DWORD*) (a2 + 12) = 0;
                        v2(*(_DWORD*) (a2 + 28));
                    }
                }
                return;
            }
        }
        for(j = this + 32; j; j = (char*) *((_DWORD*) j + 5)) {
            if(j == (char*) a2)
                goto LABEL_11;
        }
    }
}
// 41CEF3: conditional instruction was optimized away because %arg_0.4!=0

//----- (0041CF60) --------------------------------------------------------
__int16 sub_41CF60() {
    struct joyinfoex_tag pji; // [esp+0h] [ebp-34h] BYREF

    pji.dwSize = 52;
    pji.dwFlags = 255;
    if(joyGetPosEx(0, &pji)) {
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B028);
        return 1;
    }
    else {
        joyGetDevCapsA(0, &pjc, 0x194u);
        return 0;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (0041CFC0) --------------------------------------------------------
__int16 __cdecl sub_41CFC0(__int16 a1) {
    __int16 v2; // ax
    int v3; // [esp+4h] [ebp-15Ch]
    int v4 [69]; // [esp+8h] [ebp-158h] BYREF
    int v5; // [esp+11Ch] [ebp-44h]
    int v6; // [esp+120h] [ebp-40h]
    int v7; // [esp+124h] [ebp-3Ch]
    UINT v8; // [esp+128h] [ebp-38h]
    struct joyinfoex_tag pji; // [esp+12Ch] [ebp-34h] BYREF
    unsigned int retaddr; // [esp+164h] [ebp+4h]

    v4 [68] = retaddr ^ dword_47A630;
    if(dword_6C6D2C) {
        v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 100))(dword_6C6D2C);
        if(v5 >= 0) {
            memset(v4, 0, 0x110u);
            v5 = (*(int(__stdcall**)(int, int, int*))(*(_DWORD*) dword_6C6D2C + 36))(dword_6C6D2C, 272, v4);
            if(v5 >= 0) {
                v6 = sub_41D580(&a1, word_6C6E2C, 1u, (int) &v4 [12]);
                if(word_4765A0 == word_4765A4) {
                    if(v6) {
                        if((unsigned __int16) word_69D8F4 < 0x10u)
                            ++word_69D8F4;
                        if((unsigned __int16) word_69D8F4 >= 8u)
                            a1 |= 4u;
                    }
                    else if((unsigned __int16) word_69D8F4 <= 8u) {
                        word_69D8F4 = 0;
                    }
                    else {
                        word_69D8F4 -= 8;
                    }
                }
                else {
                    sub_41D580(&a1, word_6C6E30, 4u, (int) &v4 [12]);
                }
                sub_41D580(&a1, word_6C6E2E, 2u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E32, 8u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E34, 0x10u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E36, 0x20u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E38, 0x40u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E3A, 0x80u, (int) &v4 [12]);
                sub_41D580(&a1, word_6C6E3C, 0x100u, (int) &v4 [12]);
                a1 |= v4 [0] <= word_6C6E4C ? 0 : 0x80;
                a1 |= v4 [0] >= -word_6C6E4C ? 0 : 0x40;
                a1 |= v4 [1] <= word_6C6E4E ? 0 : 0x20;
                return (v4 [1] >= -word_6C6E4E ? 0 : 0x10) | a1;
            }
            else {
                return a1;
            }
        }
        else {
            v3 = 0;
            sub_41E940();
            v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 28))(dword_6C6D2C);
            while(v5 == -2147024866) {
                v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 28))(dword_6C6D2C);
                sub_41E940();
                if(++v3 >= 400)
                    return a1;
            }
            return a1;
        }
    }
    else {
        memset(&pji, 0, sizeof(pji));
        pji.dwSize = 52;
        pji.dwFlags = 255;
        if(joyGetPosEx(0, &pji)) {
            return a1;
        }
        else {
            v7 = sub_41D600(&a1, word_4765A0, 1u, pji.dwButtons);
            if(word_4765A0 == word_4765A4) {
                if(v7) {
                    if((unsigned __int16) word_69D8F4 < 0x10u)
                        ++word_69D8F4;
                    if((unsigned __int16) word_69D8F4 >= 8u) {
                        HIBYTE(v2) = HIBYTE(a1);
                        LOBYTE(v2) = a1 | 4;
                        a1 = v2;
                    }
                }
                else if((unsigned __int16) word_69D8F4 <= 8u) {
                    word_69D8F4 = 0;
                }
                else {
                    word_69D8F4 -= 8;
                }
            }
            else {
                sub_41D600(&a1, word_4765A4, 4u, pji.dwButtons);
            }
            sub_41D600(&a1, word_6C6E2E, 2u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E32, 8u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E34, 0x10u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E36, 0x20u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E38, 0x40u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E3A, 0x80u, pji.dwButtons);
            sub_41D600(&a1, word_6C6E3C, 0x100u, pji.dwButtons);
            v8 = (pjc.wXmax - pjc.wXmin) >> 2;
            a1 |= v8 + ((pjc.wXmax + pjc.wXmin) >> 1) < pji.dwXpos ? 0x80 : 0;
            a1 |= pji.dwXpos < ((pjc.wXmax + pjc.wXmin) >> 1) - v8 ? 0x40 : 0;
            v8 = (pjc.wYmax - pjc.wYmin) >> 2;
            a1 |= v8 + ((pjc.wYmax + pjc.wYmin) >> 1) < pji.dwYpos ? 0x20 : 0;
            return (pji.dwYpos < ((pjc.wYmax + pjc.wYmin) >> 1) - v8 ? 0x10 : 0) | a1;
        }
    }
}
// 4765A0: using guessed type __int16 word_4765A0;
// 4765A4: using guessed type __int16 word_4765A4;
// 47A630: using guessed type int dword_47A630;
// 69D8F4: using guessed type __int16 word_69D8F4;
// 6C6D2C: using guessed type int dword_6C6D2C;
// 6C6E2C: using guessed type __int16 word_6C6E2C;
// 6C6E2E: using guessed type __int16 word_6C6E2E;
// 6C6E30: using guessed type __int16 word_6C6E30;
// 6C6E32: using guessed type __int16 word_6C6E32;
// 6C6E34: using guessed type __int16 word_6C6E34;
// 6C6E36: using guessed type __int16 word_6C6E36;
// 6C6E38: using guessed type __int16 word_6C6E38;
// 6C6E3A: using guessed type __int16 word_6C6E3A;
// 6C6E3C: using guessed type __int16 word_6C6E3C;
// 6C6E4C: using guessed type __int16 word_6C6E4C;
// 6C6E4E: using guessed type __int16 word_6C6E4E;

//----- (0041D580) --------------------------------------------------------
int __cdecl sub_41D580(_WORD* a1, __int16 a2, unsigned __int16 a3, int a4) {
    unsigned __int16 v6; // [esp+4h] [ebp-4h]

    if(a2 < 0)
        return 0;
    if((*(_BYTE*) (a4 + a2) & 0x80) != 0)
        v6 = a3;
    else
        v6 = 0;
    *a1 |= v6;
    if((*(_BYTE*) (a4 + a2) & 0x80) != 0)
        return a3;
    else
        return 0;
}

//----- (0041D600) --------------------------------------------------------
int __cdecl sub_41D600(_WORD* a1, __int16 a2, unsigned __int16 a3, int a4) {
    unsigned __int16 v6; // [esp+4h] [ebp-8h]

    if(a2 < 0)
        return 0;
    if(((1 << a2) & a4) != 0)
        v6 = a3;
    else
        v6 = 0;
    *a1 |= v6;
    if(((1 << a2) & a4) != 0)
        return a3;
    else
        return 0;
}

//----- (0041D680) --------------------------------------------------------
char* sub_41D680() {
    int v1; // [esp+8h] [ebp-15Ch]
    char v2 [48]; // [esp+Ch] [ebp-158h] BYREF
    char v3 [128]; // [esp+3Ch] [ebp-128h] BYREF
    unsigned int v4; // [esp+120h] [ebp-44h]
    int v5; // [esp+124h] [ebp-40h]
    unsigned int v6; // [esp+128h] [ebp-3Ch]
    DWORD dwButtons; // [esp+12Ch] [ebp-38h]
    struct joyinfoex_tag pji; // [esp+130h] [ebp-34h] BYREF
    unsigned int retaddr; // [esp+168h] [ebp+4h]

    v4 = retaddr ^ dword_47A630;
    memset(byte_69E1B0, 0, sizeof(byte_69E1B0));
    if(dword_6C6D2C) {
        v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 100))(dword_6C6D2C);
        if(v5 >= 0) {
            (*(void(__stdcall**)(int, int, char*))(*(_DWORD*) dword_6C6D2C + 36))(dword_6C6D2C, 272, v2);
            if(v5 >= 0)
                qmemcpy(byte_69E1B0, v3, sizeof(byte_69E1B0));
            return byte_69E1B0;
        }
        else {
            v1 = 0;
            sub_41E940();
            v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 28))(dword_6C6D2C);
            while(v5 == -2147024866) {
                v5 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D2C + 28))(dword_6C6D2C);
                sub_41E940();
                if(++v1 >= 400)
                    return byte_69E1B0;
            }
            return byte_69E1B0;
        }
    }
    else {
        memset(&pji, 0, sizeof(pji));
        pji.dwSize = 52;
        pji.dwFlags = 255;
        if(joyGetPosEx(0, &pji)) {
            return byte_69E1B0;
        }
        else {
            dwButtons = pji.dwButtons;
            v6 = 0;
            while(v6 < 0x20) {
                if((dwButtons & 1) != 0)
                    byte_69E1B0 [v6] = 0x80;
                ++v6;
                dwButtons >>= 1;
            }
            return byte_69E1B0;
        }
    }
}
// 47A630: using guessed type int dword_47A630;
// 6C6D2C: using guessed type int dword_6C6D2C;
// 41D680: using guessed type char var_158[48];

//----- (0041D820) --------------------------------------------------------
__int16 sub_41D820() {
    __int16 v1; // [esp+4h] [ebp-10Ch]
    __int16 v2; // [esp+4h] [ebp-10Ch]
    __int16 v3; // [esp+4h] [ebp-10Ch]
    BYTE KeyState [16]; // [esp+8h] [ebp-108h] BYREF
    char v5; // [esp+18h] [ebp-F8h]
    char v6; // [esp+19h] [ebp-F7h]
    char v7; // [esp+23h] [ebp-EDh]
    char v8; // [esp+24h] [ebp-ECh]
    char v9; // [esp+25h] [ebp-EBh]
    int v10; // [esp+27h] [ebp-E9h]
    char v11; // [esp+2Ch] [ebp-E4h]
    char v12; // [esp+2Dh] [ebp-E3h]
    char v13; // [esp+2Eh] [ebp-E2h]
    char v14; // [esp+2Fh] [ebp-E1h]
    char v15; // [esp+30h] [ebp-E0h]
    char v16; // [esp+32h] [ebp-DEh]
    char v17; // [esp+34h] [ebp-DCh]
    char v18; // [esp+35h] [ebp-DBh]
    int v19; // [esp+3Eh] [ebp-D2h]
    char v20; // [esp+4Fh] [ebp-C1h]
    char v21; // [esp+50h] [ebp-C0h]
    char v22; // [esp+51h] [ebp-BFh]
    char v23; // [esp+53h] [ebp-BDh]
    char v24; // [esp+55h] [ebp-BBh]
    char v25; // [esp+57h] [ebp-B9h]
    char v26; // [esp+58h] [ebp-B8h]
    char v27; // [esp+59h] [ebp-B7h]
    char v28; // [esp+5Bh] [ebp-B5h]
    char v29; // [esp+60h] [ebp-B0h]
    int v30; // [esp+62h] [ebp-AEh]
    char v31; // [esp+69h] [ebp-A7h]
    char v32; // [esp+6Ah] [ebp-A6h]
    char v33; // [esp+6Bh] [ebp-A5h]
    char v34; // [esp+6Ch] [ebp-A4h]
    char v35; // [esp+6Eh] [ebp-A2h]
    char v36; // [esp+6Fh] [ebp-A1h]
    char v37; // [esp+70h] [ebp-A0h]
    char v38; // [esp+71h] [ebp-9Fh]
    int v39; // [esp+A5h] [ebp-6Bh]
    char v40; // [esp+CFh] [ebp-41h]
    char v41; // [esp+D0h] [ebp-40h]
    char v42; // [esp+D3h] [ebp-3Dh]
    char v43; // [esp+D5h] [ebp-3Bh]
    int v44; // [esp+D8h] [ebp-38h]
    unsigned int v45; // [esp+10Ch] [ebp-4h]
    unsigned int retaddr; // [esp+114h] [ebp+4h]

    v45 = retaddr ^ dword_47A630;
    if(dword_6C6D28) {
        if((*(int(__stdcall**)(int, int, BYTE*))(*(_DWORD*) dword_6C6D28 + 36))(dword_6C6D28, 256, KeyState) == -2147024866) {
            (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D28 + 28))(dword_6C6D28);
            return sub_41CFC0(0);
        }
        v3 = ((KeyState [1] & 0x80) != 0 ? 8 : 0) | ((v19 & 0x80) != 0 ? 4 : 0) | ((v16 & 0x80) != 0 ? 4 : 0) | ((v18 & 0x80) != 0 ? 2 : 0) | ((v17 & 0x80) != 0) | ((v40 & 0x80) != 0 ? 0x800 : 0) | ((v27 & 0x80) != 0 ? 0xA0 : 0) | ((v25 & 0x80) != 0 ? 0x60 : 0) | ((v22 & 0x80) != 0 ? 0x90 : 0) | ((v20 & 0x80) != 0 ? 0x50 : 0) | ((v24 & 0x80) != 0 ? 0x80 : 0) | ((v23 & 0x80) != 0 ? 0x40 : 0) | ((v26 & 0x80) != 0 ? 0x20 : 0) | ((v21 & 0x80) != 0 ? 0x10 : 0) | ((v43 & 0x80) != 0 ? 0x80 : 0) | ((v42 & 0x80) != 0 ? 0x40 : 0) | ((v44 & 0x80) != 0 ? 0x20 : 0) | ((v41 & 0x80) != 0 ? 0x10 : 0);
        v2 = ((v8 & 0x80) != 0 ? 0x1000 : 0) | ((v10 & 0x80) != 0 ? 0x400 : 0) | ((v5 & 0x80) != 0 ? 0x200 : 0) | ((v39 & 0x80) != 0 ? 0x100 : 0) | ((v9 & 0x80) != 0 ? 0x100 : 0) | v3;
    }
    else {
        GetKeyboardState(KeyState);
        v1 = ((v6 & 0x80) != 0 ? 0x100 : 0) | ((v7 & 0x80) != 0 ? 8 : 0) | ((v5 & 0x80) != 0 ? 4 : 0) | ((v29 & 0x80) != 0 ? 2 : 0) | ((v30 & 0x80) != 0) | ((v11 & 0x80) != 0 ? 0x800 : 0) | ((v33 & 0x80) != 0 ? 0xA0 : 0) | ((v31 & 0x80) != 0 ? 0x60 : 0) | ((v38 & 0x80) != 0 ? 0x90 : 0) | ((v36 & 0x80) != 0 ? 0x50 : 0) | ((v35 & 0x80) != 0 ? 0x80 : 0) | ((v34 & 0x80) != 0 ? 0x40 : 0) | ((v32 & 0x80) != 0 ? 0x20 : 0) | ((v37 & 0x80) != 0 ? 0x10 : 0) | ((v14 & 0x80) != 0 ? 0x80 : 0) | ((v12 & 0x80) != 0 ? 0x40 : 0) | ((v15 & 0x80) != 0 ? 0x20 : 0) | ((v13 & 0x80) != 0 ? 0x10 : 0);
        v2 = ((KeyState [13] & 0x80) != 0 ? 0x1000 : 0) | ((v28 & 0x80) != 0 ? 0x400 : 0) | ((v27 & 0x80) != 0 ? 0x200 : 0) | v1;
    }
    return sub_41CFC0(v2);
}
// 47A630: using guessed type int dword_47A630;
// 6C6D28: using guessed type int dword_6C6D28;

//----- (0041E0C0) --------------------------------------------------------
BOOL sub_41E0C0() {
    int i; // [esp+0h] [ebp-10Ch]
    BYTE KeyState [260]; // [esp+4h] [ebp-108h] BYREF
    unsigned int v3; // [esp+108h] [ebp-4h]
    unsigned int retaddr; // [esp+110h] [ebp+4h]

    v3 = retaddr ^ dword_47A630;
    GetKeyboardState(KeyState);
    for(i = 0; i < 256; ++i)
        KeyState [i] &= ~0x80u;
    return SetKeyboardState(KeyState);
}
// 47A630: using guessed type int dword_47A630;
// 41E0C0: using guessed type BYTE KeyState[260];

//----- (0041E150) --------------------------------------------------------
HFONT __thiscall sub_41E150(_DWORD* this, int a2, int cWidth, int cHeight) {
    HFONT result; // eax
    HGDIOBJ v6; // [esp+4h] [ebp-Ch]
    HFONT h; // [esp+8h] [ebp-8h]
    HDC hdc; // [esp+Ch] [ebp-4h]

    hdc = CreateCompatibleDC(0);
    result = CreateFontA(cHeight, cWidth, 0, 0, 400, 0, 0, 0, 0x80u, 0, 0, 0, 0, "Arial");
    h = result;
    if(result) {
        v6 = SelectObject(hdc, result);
        if(sub_43F745(a2, h, this + 1) >= 0) {
            SelectObject(hdc, v6);
            return (HFONT) DeleteObject(h);
        }
        else {
            return (HFONT) MessageBoxA(0, "D3DXCreateFontIndirect FALSE", "ok", 0);
        }
    }
    return result;
}

//----- (0041E210) --------------------------------------------------------
int __thiscall sub_41E210(_DWORD** this, int a2, int a3, int a4, int a5) {
    int v6 [4]; // [esp+4h] [ebp-10h] BYREF

    v6 [0] = a3;
    v6 [2] = 640;
    v6 [1] = a4;
    v6 [3] = 480;
    return (*(int(__stdcall**)(_DWORD*, int, int, int*, int, int))(*this [1] + 24))(this [1], a2, -1, v6, 64, a5);
}

//----- (0041E260) --------------------------------------------------------
_DWORD** __thiscall sub_41E260(_DWORD** this) {
    _DWORD** result; // eax

    result = this;
    if(this [1]) {
        (*(void(__stdcall**)(_DWORD*))(*this [1] + 8))(this [1]);
        result = this;
        this [1] = 0;
    }
    return result;
}

//----- (0041E290) --------------------------------------------------------
void* __cdecl sub_41E290(char* Str, int a2) {
    char* v2; // eax
    FILE* Stream; // [esp+0h] [ebp-18h]
    void* Buffer; // [esp+4h] [ebp-14h]
    int Size; // [esp+8h] [ebp-10h]
    int v7; // [esp+Ch] [ebp-Ch]
    char* v8; // [esp+10h] [ebp-8h]
    char* v9; // [esp+10h] [ebp-8h]
    int i; // [esp+14h] [ebp-4h]

    v7 = -1;
    if(!a2) {
        v9 = strrchr(Str, 92);
        if(v9)
            v2 = strrchr(v9 + 1, 47);
        else
            v2 = strrchr(Str, 47);
        if(v2)
            v8 = v2 + 1;
        else
            v8 = Str;
        if(dword_69D900) {
            for(i = 0; i < 16; ++i) {
                if(*(_DWORD*) (dword_69D900 + 4 * i)) {
                    v7 = sub_43C920(*(_DWORD**) (dword_69D900 + 4 * i), v8);
                    if(v7 >= 0)
                        break;
                }
            }
        }
        if(v7 < 0)
            return 0;
    }
    if(v7 < 0) {
        sub_41E940();
        Stream = fopen(Str, "rb");
        if(!Stream) {
            sub_41E940();
            return 0;
        }
        fseek(Stream, 0, 2);
        Size = ftell(Stream);
        dword_69D914 = Size;
        fseek(Stream, 0, 0);
        Buffer = malloc(Size);
        sub_45C6E8(Buffer, 1u, Size, Stream);
        fclose(Stream);
    }
    else {
        sub_41E940();
        Buffer = sub_43CB40(*(_DWORD**) (dword_69D900 + 4 * i), v7, (int) v8);
        dword_69D914 = sub_43C990(*(_DWORD**) (dword_69D900 + 4 * i), v7);
    }
    return Buffer;
}
// 41E37E: variable 'i' is possibly undefined
// 41E381: variable 'v8' is possibly undefined
// 69D900: using guessed type int dword_69D900;
// 69D914: using guessed type int dword_69D914;

//----- (0041E460) --------------------------------------------------------
int __cdecl sub_41E460(char* FileName, void* Buffer, size_t ElementCount) {
    FILE* Stream; // [esp+0h] [ebp-4h]

    Stream = fopen(FileName, "wb");
    if(!Stream)
        return -1;
    if(sub_45CB54(Buffer, 1u, ElementCount, Stream) == ElementCount) {
        fclose(Stream);
        return 0;
    }
    else {
        fclose(Stream);
        return -2;
    }
}

//----- (0041E4D0) --------------------------------------------------------
char* sub_41E4D0(int a1, char* Format, ...) {
    unsigned int v2; // kr00_4
    char v3; // dl
    _BYTE* v5; // [esp+8h] [ebp-224h]
    char* v6; // [esp+Ch] [ebp-220h]
    char Buffer [512]; // [esp+24h] [ebp-208h] BYREF
    unsigned int v8; // [esp+224h] [ebp-8h]
    va_list ArgList; // [esp+228h] [ebp-4h]
    unsigned int retaddr; // [esp+230h] [ebp+4h]
    va_list va; // [esp+23Ch] [ebp+10h] BYREF

    va_start(va, Format);
    v8 = retaddr ^ dword_47A630;
    va_copy(ArgList, va);
    vsprintf(Buffer, Format, va);
    v2 = strlen(Buffer);
    if(v2 + *(_DWORD*) (a1 + 2048) < a1 + 2047) {
        v6 = Buffer;
        v5 = *(_BYTE**) (a1 + 2048);
        do {
            v3 = *v6;
            *v5++ = *v6++;
        }
        while(v3);
        *(_DWORD*) (a1 + 2048) += v2;
        **(_BYTE**) (a1 + 2048) = 0;
    }
    return Format;
}
// 47A630: using guessed type int dword_47A630;

//----- (0041E620) --------------------------------------------------------
char* sub_41E620(int a1, char* Format, ...) {
    unsigned int v2; // kr00_4
    char v3; // dl
    _BYTE* v5; // [esp+8h] [ebp-224h]
    char* v6; // [esp+Ch] [ebp-220h]
    char Buffer [512]; // [esp+24h] [ebp-208h] BYREF
    unsigned int v8; // [esp+224h] [ebp-8h]
    va_list ArgList; // [esp+228h] [ebp-4h]
    unsigned int retaddr; // [esp+230h] [ebp+4h]
    va_list va; // [esp+23Ch] [ebp+10h] BYREF

    va_start(va, Format);
    v8 = retaddr ^ dword_47A630;
    va_copy(ArgList, va);
    vsprintf(Buffer, Format, va);
    v2 = strlen(Buffer);
    if(v2 + *(_DWORD*) (a1 + 2048) < a1 + 2047) {
        v6 = Buffer;
        v5 = *(_BYTE**) (a1 + 2048);
        do {
            v3 = *v6;
            *v5++ = *v6++;
        }
        while(v3);
        *(_DWORD*) (a1 + 2048) += v2;
        **(_BYTE**) (a1 + 2048) = 0;
    }
    *(_BYTE*) (a1 + 2052) = 1;
    return Format;
}
// 47A630: using guessed type int dword_47A630;

//----- (0041E780) --------------------------------------------------------
__int16 __thiscall sub_41E780(_DWORD* this) {
    *(_WORD*) this = ((((*(_WORD*) this ^ 0x9630) - 25939) & 0xC000) >> 14) + 4 * ((*(_WORD*) this ^ 0x9630) - 25939);
    ++this [1];
    return *(_WORD*) this;
}

//----- (0041E7F0) --------------------------------------------------------
int __thiscall sub_41E7F0(_DWORD* this) {
    int v1; // esi

    v1 = (unsigned __int16) sub_41E780(this) << 16;
    return v1 | (unsigned __int16) sub_41E780(this);
}

//----- (0041E820) --------------------------------------------------------
double __thiscall sub_41E820(_DWORD* this) {
    float v2; // [esp+0h] [ebp-10h]

    v2 = (float) (unsigned int) sub_41E7F0(this);
    return v2 / 4294967300.0;
}

//----- (0041E850) --------------------------------------------------------
double __cdecl sub_41E850(float a1, float a2) {
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    int v6; // eax
    int v7; // edx
    int v9; // [esp+0h] [ebp-4h]
    float v10; // [esp+Ch] [ebp+8h]

    v9 = 0;
    v10 = a1 + a2;
    do {
        v3 = v10 < 3.1415927;
        v4 = 0;
        v5 = v10 == 3.1415927;
        if((v2 & 0x4100) != 0)
            break;
        v10 = v10 - 6.2831855;
        v6 = v9++;
    }
    while(v6 <= 16);
    do {
        if(v10 >= -3.1415927)
            break;
        v10 = v10 + 6.2831855;
        v7 = v9++;
    }
    while(v7 <= 16);
    return v10;
}

//----- (0041E8D0) --------------------------------------------------------
float* __cdecl sub_41E8D0(float* a1, float* a2, float a3) {
    float* result; // eax
    float v4; // [esp+8h] [ebp-10h]
    float v5; // [esp+Ch] [ebp-Ch]

    v5 = sin(a3);
    v4 = cos(a3);
    *a1 = v4 * *a2 + v5 * a2 [1];
    result = a2;
    a1 [1] = v4 * a2 [1] - v5 * *a2;
    return result;
}

//----- (0041E940) --------------------------------------------------------
void sub_41E940() {
    ;
}

//----- (0041E945) --------------------------------------------------------
_DWORD* __thiscall sub_41E945(_DWORD* this) {
    *this = -1;
    this [1] = 0;
    this [2] = 0;
    this [5] = 0;
    this [7] = 0;
    this [6] = 0;
    this [8] = 0;
    return this;
}

//----- (0041E981) --------------------------------------------------------
char __thiscall sub_41E981(void* this) {
    return sub_41E992(this);
}

//----- (0041E992) --------------------------------------------------------
char __thiscall sub_41E992(void* this) {
    if(!*((_DWORD*) this + 5))
        return 0;
    SelectObject(*((HDC*) this + 5), *((HGDIOBJ*) this + 6));
    DeleteDC(*((HDC*) this + 5));
    DeleteObject(*((HGDIOBJ*) this + 7));
    *(_DWORD*) this = -1;
    *((_DWORD*) this + 1) = 0;
    *((_DWORD*) this + 2) = 0;
    *((_DWORD*) this + 5) = 0;
    *((_DWORD*) this + 7) = 0;
    *((_DWORD*) this + 6) = 0;
    *((_DWORD*) this + 8) = 0;
    return 1;
}

//----- (0041EA04) --------------------------------------------------------
char __thiscall sub_41EA04(int* this, int a2, int a3, int a4) {
    if(sub_41EA63(this, a2, a3, a4))
        return 1;
    if(a4 == 25 || a4 == 26)
        return sub_41EA63(this, a2, a3, 21);
    if(a4 == 23)
        return sub_41EA63(this, a2, a3, 22);
    return 0;
}

//----- (0041EA63) --------------------------------------------------------
char __thiscall sub_41EA63(int* this, int a2, int a3, int a4) {
    void* ppvBits; // [esp+4h] [ebp-8Ch] BYREF
    HGDIOBJ h; // [esp+8h] [ebp-88h]
    int* v8; // [esp+Ch] [ebp-84h]
    _BYTE pbmi [108]; // [esp+10h] [ebp-80h] BYREF
    HGDIOBJ v10; // [esp+84h] [ebp-Ch]
    HDC hdc; // [esp+88h] [ebp-8h]
    int v12; // [esp+8Ch] [ebp-4h]

    sub_41E992(this);
    memset(pbmi, 0, sizeof(pbmi));
    v8 = sub_41EC22(a4);
    if(!v8)
        return 0;
    v12 = 4 * ((v8 [1] * a2 / 8 + 3) / 4);
    *(_DWORD*) pbmi = 108;
    *(_DWORD*) &pbmi [4] = a2;
    *(_DWORD*) &pbmi [8] = -(a3 + 1);
    *(_WORD*) &pbmi [12] = 1;
    *(_WORD*) &pbmi [14] = *((_WORD*) v8 + 2);
    *(_DWORD*) &pbmi [20] = v12 * a3;
    if(a4 != 24 && a4 != 22) {
        *(_DWORD*) &pbmi [16] = 3;
        *(_DWORD*) &pbmi [40] = v8 [3];
        *(_DWORD*) &pbmi [44] = v8 [4];
        *(_DWORD*) &pbmi [48] = v8 [5];
        *(_DWORD*) &pbmi [52] = v8 [2];
    }
    h = CreateDIBSection(0, (const BITMAPINFO*) pbmi, 0, &ppvBits, 0, 0);
    if(!h)
        return 0;
    memset(ppvBits, 0, *(size_t*) &pbmi [20]);
    hdc = CreateCompatibleDC(0);
    v10 = SelectObject(hdc, h);
    this [5] = (int) hdc;
    this [7] = (int) h;
    this [8] = (int) ppvBits;
    this [3] = *(_DWORD*) &pbmi [20];
    this [6] = (int) v10;
    this [1] = a2;
    this [2] = a3;
    *this = a4;
    this [4] = v12;
    return 1;
}

//----- (0041EC22) --------------------------------------------------------
int* __stdcall sub_41EC22(int a1) {
    int i; // [esp+4h] [ebp-4h]

    for(i = 0; dword_4765B8 [6 * i] != -1 && dword_4765B8 [6 * i] != a1; ++i)
        ;
    if(a1 == -1)
        return 0;
    else
        return &dword_4765B8 [6 * i];
}
// 4765B8: using guessed type int dword_4765B8[42];

//----- (0041EC72) --------------------------------------------------------
char __thiscall sub_41EC72(int* this, int a2, int a3, int a4, int a5) {
    __int16 v5; // ax
    __int16 v6; // ax
    int v8; // [esp+4h] [ebp-1Ch]
    __int16* v9; // [esp+10h] [ebp-10h]
    int v10; // [esp+14h] [ebp-Ch]
    int i; // [esp+18h] [ebp-8h]
    int j; // [esp+18h] [ebp-8h]
    int k; // [esp+18h] [ebp-8h]
    int v14; // [esp+1Ch] [ebp-4h]

    v10 = 2 * a5 * a4;
    v14 = this [8] + 2 * a4 * a3;
    v8 = *this;
    if(*this == 21) {
        for(i = 3; i < v10; i += 4)
            *(_BYTE*) (i + v14) = ~*(_BYTE*) (i + v14);
    }
    else if(v8 == 25) {
        v9 = (__int16*) (this [8] + 2 * a4 * a3);
        for(j = 0; j < v10; j += 2) {
            *v9 = ((*v9 >= 0) << 15) | *v9 & 0x7FFF;
            if(*v9 >= 0) {
                *v9 = (((31 - (unsigned __int8) (31 * j / v10 / 2)) & 0x1F) << 10) | *v9 & 0x83FF;
                *v9 = (32 * ((31 - (unsigned __int8) (31 * j / v10 / 2)) & 0x1F)) | *v9 & 0xFC1F;
                v6 = *v9;
                LOBYTE(v6) = *v9 & 0xE0;
                *v9 = (31 - (unsigned __int8) (31 * j / v10 / 4)) & 0x1F | v6;
            }
            else {
                *v9 = ((((((unsigned __int16) *v9 >> 10) & 0x1F)
                       - (unsigned __int8) (j * (((unsigned __int16) *v9 >> 10) & 0x1F) / v10 / 2)) & 0x1F) << 10) | *v9 & 0x83FF;
                *v9 = (32
                       * (((((unsigned __int16) *v9 >> 5) & 0x1F)
                       - (unsigned __int8) (j * (((unsigned __int16) *v9 >> 5) & 0x1F) / v10 / 2)) & 0x1F)) | *v9 & 0xFC1F;
                v5 = *v9;
                LOBYTE(v5) = *v9 & 0xE0;
                *v9 = ((*v9 & 0x1F) - (unsigned __int8) (j * (*v9 & 0x1F) / v10 / 4)) & 0x1F | v5;
            }
            ++v9;
        }
    }
    else {
        if(v8 != 26)
            return 0;
        for(k = 1; k < v10; k += 2)
            *(_BYTE*) (k + v14) ^= 0xF0u;
    }
    return 1;
}

//----- (0041EF11) --------------------------------------------------------
char __thiscall sub_41EF11(void* this, int a2) {
    int v4 [2]; // [esp+14h] [ebp-4Ch] BYREF
    void* Src; // [esp+1Ch] [ebp-44h]
    int v6 [8]; // [esp+20h] [ebp-40h] BYREF
    size_t Size; // [esp+40h] [ebp-20h]
    int i; // [esp+44h] [ebp-1Ch]
    int v9 [4]; // [esp+48h] [ebp-18h] BYREF
    int v10; // [esp+58h] [ebp-8h]
    void* v11; // [esp+5Ch] [ebp-4h]

    if(!*((_DWORD*) this + 7))
        return 0;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) a2 + 32))(a2, v6);
    v9 [0] = 0;
    v9 [1] = 0;
    v9 [2] = *((_DWORD*) this + 1);
    v9 [3] = *((_DWORD*) this + 2);
    if((*(int(__stdcall**)(int, int*, int*, _DWORD))(*(_DWORD*) a2 + 36))(a2, v4, v9, 0))
        return 0;
    v10 = v4 [0];
    Size = *((_DWORD*) this + 4);
    Src = (void*) *((_DWORD*) this + 8);
    v11 = (void*) v4 [1];
    if(v6 [0] == *(_DWORD*) this) {
        for(i = 0; i < *((_DWORD*) this + 2); ++i) {
            memcpy(v11, Src, Size);
            Src = (char*) Src + Size;
            v11 = (char*) v11 + v10;
        }
    }
    (*(void(__stdcall**)(int))(*(_DWORD*) a2 + 40))(a2);
    return 1;
}
// 41EF11: using guessed type int var_40[8];

//----- (0041F008) --------------------------------------------------------
int sub_41F008() {
    return (*(int(__stdcall**)(int, int, int, int, int*))(*(_DWORD*) dword_6C6D20 + 108))(
        dword_6C6D20,
        640,
        64,
        25,
        &dword_69E230);
}
// 69E230: using guessed type int dword_69E230;
// 6C6D20: using guessed type int dword_6C6D20;

//----- (0041F02B) --------------------------------------------------------
int sub_41F02B() {
    int result; // eax

    if(dword_69E230) {
        result = (*(int(__stdcall**)(int))(*(_DWORD*) dword_69E230 + 8))(dword_69E230);
        dword_69E230 = 0;
    }
    return result;
}
// 69E230: using guessed type int dword_69E230;

//----- (0041F050) --------------------------------------------------------
char __cdecl sub_41F050(
    int a1,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6,
    COLORREF a7,
    COLORREF color,
    LPCSTR lpString,
    int a10) {
    int v10; // eax
    int v11; // eax
    int v13; // [esp+0h] [ebp-80h] BYREF
    int v14 [4]; // [esp+4h] [ebp-7Ch] BYREF
    int v15 [4]; // [esp+14h] [ebp-6Ch] BYREF
    int v16 [5]; // [esp+24h] [ebp-5Ch] BYREF
    HDC v17; // [esp+38h] [ebp-48h]
    HGDIOBJ v18; // [esp+48h] [ebp-38h]
    int v19 [8]; // [esp+4Ch] [ebp-34h] BYREF
    HGDIOBJ h; // [esp+6Ch] [ebp-14h]
    HDC hdc; // [esp+70h] [ebp-10h]
    int v22; // [esp+7Ch] [ebp-4h]

    h = CreateFontA(2 * a5, 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 4u, 0, "Arial");
    sub_41E945(v16);
    v22 = 0;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_69E230 + 32))(dword_69E230, v19);
    sub_41EA04(v16, v19 [6], v19 [7], v19 [0]);
    hdc = v17;
    v18 = SelectObject(v17, h);
    sub_41EC72(v16, 0, 0, 2 * a3, 2 * a5 + 6);
    SetBkMode(hdc, 1);
    if(color != -1) {
        SetTextColor(hdc, color);
        v10 = strlen(lpString);
        TextOutA(hdc, 2 * a1 + 3, 2, lpString, v10);
    }
    SetTextColor(hdc, a7);
    v11 = strlen(lpString);
    TextOutA(hdc, 2 * a1, 0, lpString, v11);
    SelectObject(hdc, v18);
    sub_41EC72(v16, 0, 0, 2 * a3, 2 * a5 + 6);
    sub_41EF11(v16, dword_69E230);
    SelectObject(hdc, v18);
    DeleteObject(h);
    v14 [0] = 0;
    v14 [1] = a2;
    v14 [2] = a3;
    v14 [3] = a2 + 16;
    v15 [0] = 0;
    v15 [1] = 0;
    v15 [2] = 2 * a3 - 2;
    v15 [3] = 2 * a5 - 2;
    (*(void(__stdcall**)(int, _DWORD, int*))(*(_DWORD*) a10 + 60))(a10, 0, &v13);
    sub_43FF78(v13, 0, v14, dword_69E230, 0, v15, (float*) 4, 0);
    if(v13) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v13 + 8))(v13);
        v13 = 0;
    }
    v22 = -1;
    return sub_41E981(v16);
}
// 69E230: using guessed type int dword_69E230;
// 41F050: using guessed type int var_5C[5];

//----- (0041F230) --------------------------------------------------------
void* __thiscall sub_41F230(void* this) {
    int i; // [esp+4h] [ebp-20h]
    int v4; // [esp+Ch] [ebp-18h]

    v4 = 513;
    for(i = (int) this; --v4 >= 0; i += 324) {
        sub_403720(i);
        sub_424127((_DWORD*) (i + 308));
    }
    return this;
}

//----- (0041F290) --------------------------------------------------------
int __thiscall sub_41F290(_DWORD* this, _DWORD* a2, int a3, int a4) {
    int result; // eax
    int* v5; // [esp+4h] [ebp-14h]
    _DWORD* v6; // [esp+10h] [ebp-8h]
    int i; // [esp+14h] [ebp-4h]

    result = (int) this;
    v6 = &this [81 * this [41553]];
    for(i = 0; i < 512; ++i) {
        ++this [41553];
        if(!*((_BYTE*) v6 + 321)) {
            if((int) this [41553] >= 512)
                this [41553] = 0;
            *((_BYTE*) v6 + 321) = 1;
            v6 [68] = *a2;
            v6 [69] = a2 [1];
            v6 [70] = a2 [2];
            v6 [71] = 0;
            v6 [72] = -1072902963;
            v6 [73] = 0;
            *((_BYTE*) v6 + 320) = a3;
            *((_BYTE*) v6 + 323) = a4;
            v6 [79] = 0;
            v6 [78] = 0;
            v6 [77] = -999;
            if(a4 == 2) {
                *((float*) v6 + 74) = sub_41E820(&word_69D8F8) * 288.0 + 48.0;
                *((float*) v6 + 75) = sub_41E820(&word_69D8F8) * 192.0 - 64.0;
                v6 [76] = 0;
                v6 [71] = v6 [68];
                v6 [72] = v6 [69];
                v6 [73] = v6 [70];
            }
            v5 = (int*) dword_6D4588;
            *((_WORD*) v6 + 90) = a3 + 533;
            result = sub_432430(v5, v6, v5 [a3 + 29794]);
            v6 [31] = -1;
            *((_BYTE*) v6 + 322) = 1;
            return result;
        }
        if((int) this [41553] < 512) {
            v6 += 81;
        }
        else {
            this [41553] = 0;
            v6 = this;
        }
        result = i + 1;
    }
    return result;
}
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0041F4A0) --------------------------------------------------------
int __fastcall sub_41F4A0(int a1) {
    int result; // eax
    int v2; // ecx
    int v3; // edx
    int v4; // eax
    int v5; // ecx
    int v6; // eax
    int v7; // ecx
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    int v11; // edx
    int v12; // edx
    int v13; // [esp+0h] [ebp-E8h]
    int v14; // [esp+4h] [ebp-E4h]
    int v15; // [esp+8h] [ebp-E0h]
    int v16; // [esp+Ch] [ebp-DCh]
    float v17; // [esp+18h] [ebp-D0h]
    float v19; // [esp+3Ch] [ebp-ACh]
    float v20; // [esp+40h] [ebp-A8h]
    float v21; // [esp+44h] [ebp-A4h]
    float v22; // [esp+50h] [ebp-98h]
    float v23; // [esp+54h] [ebp-94h]
    float v24; // [esp+58h] [ebp-90h]
    float v25; // [esp+60h] [ebp-88h]
    float v26; // [esp+64h] [ebp-84h]
    float v27; // [esp+68h] [ebp-80h]
    float v28; // [esp+70h] [ebp-78h]
    float v29; // [esp+74h] [ebp-74h]
    float v30; // [esp+78h] [ebp-70h]
    float v31; // [esp+7Ch] [ebp-6Ch]
    int v32; // [esp+C0h] [ebp-28h]
    int k; // [esp+C4h] [ebp-24h]
    int v34; // [esp+C8h] [ebp-20h]
    int j; // [esp+CCh] [ebp-1Ch]
    float v36; // [esp+D0h] [ebp-18h]
    int v37; // [esp+D4h] [ebp-14h]
    int v38; // [esp+D8h] [ebp-10h]
    float v39; // [esp+DCh] [ebp-Ch]
    int v40; // [esp+E0h] [ebp-8h]
    int i; // [esp+E4h] [ebp-4h]

    v37 = a1;
    if((dword_69E240 & 1) == 0) {
        dword_69E240 |= 1u;
        dword_69E234 = 1098907648;
        dword_69E238 = 1098907648;
        dword_69E23C = 1098907648;
    }
    v38 = 0;
    result = a1;
    *(_DWORD*) (a1 + 166216) = 0;
    for(i = 0; i < 512; ++i) {
        result = v37;
        if(!*(_BYTE*) (v37 + 321))
            goto LABEL_4;
        ++* (_DWORD*) (a1 + 166216);
        if(*(_BYTE*) (v37 + 323) == 2) {
            if(*(int*) (v37 + 316) < 60) {
                v17 = (float) *(int*) (v37 + 316);
                v36 = (v17 + *(float*) (v37 + 312)) / 60.0;
                v28 = 1.0 - v36;
                v31 = v28 * *(float*) (v37 + 292);
                v30 = v28 * *(float*) (v37 + 288);
                v29 = v28 * *(float*) (v37 + 284);
                v27 = v36 * *(float*) (v37 + 304);
                v26 = v36 * *(float*) (v37 + 300);
                v25 = v36 * *(float*) (v37 + 296);
                v24 = v27 + v31;
                v23 = v26 + v30;
                v22 = v25 + v29;
                *(float*) (v37 + 272) = v22;
                *(float*) (v37 + 276) = v23;
                *(float*) (v37 + 280) = v24;
                goto LABEL_24;
            }
            if(*(_DWORD*) (v37 + 316) == 60) {
                *(_DWORD*) (v37 + 284) = 0;
                *(_DWORD*) (v37 + 288) = 0;
                *(_DWORD*) (v37 + 292) = 0;
            }
        }
        else if(*(_BYTE*) (v37 + 323) == 1 || (unsigned __int16) word_69D4B0 >= 0x80u && flt_6CAA6C < 128.0) {
            v39 = sub_428700(flt_6CA628, (float*) (v37 + 272));
            *(float*) (v37 + 284) = cos(v39) * 8.0;
            *(float*) (v37 + 288) = sin(v39) * 8.0;
            *(_BYTE*) (v37 + 323) = 1;
        }
        else {
            *(_DWORD*) (v37 + 284) = 0;
            *(_DWORD*) (v37 + 292) = 0;
            if(*(float*) (v37 + 288) < -2.2)
                *(_DWORD*) (v37 + 288) = -1072902963;
        }
        v21 = flt_6C6EC0 * *(float*) (v37 + 292);
        v20 = flt_6C6EC0 * *(float*) (v37 + 288);
        v19 = flt_6C6EC0 * *(float*) (v37 + 284);
        *(float*) (v37 + 272) = v19 + *(float*) (v37 + 272);
        *(float*) (v37 + 276) = v20 + *(float*) (v37 + 276);
        *(float*) (v37 + 280) = v21 + *(float*) (v37 + 280);
        if(flt_69D6E8 + 16.0 <= *(float*) (v37 + 276)) {
            *(_BYTE*) (v37 + 321) = 0;
            result = (int) sub_41C5FA(dword_69BCA0, v37 + 272, 3);
            goto LABEL_4;
        }
        if(*(float*) (v37 + 288) >= 3.0)
            *(_DWORD*) (v37 + 288) = 1077936128;
        else
            *(float*) (v37 + 288) = 0.029999999 * flt_6C6EC0 + *(float*) (v37 + 288);
        LABEL_24:
        if(sub_426FD0((int) flt_6CA628, (float*) (v37 + 272), (float*) &dword_69E234)) {
            result = *(char*) (v37 + 320);
            switch(*(_BYTE*) (v37 + 320)) {
                case 0:
                    if((unsigned __int16) word_69D4B0 < 0x80u) {
                        for(j = 0; (unsigned __int16) word_69D4B0 >= dword_4766DC [j]; ++j)
                            ;
                        v34 = j;
                        byte_69D4B9 = 0;
                        if((unsigned __int16)++word_69D4B0 >= 0x80u) {
                            word_69D4B0 = 128;
                            sub_414340((char*) dword_5A5FF8);
                            sub_4173D9(dword_69BC30, 0);
                        }
                        dword_69BCA4 += 10;
                        dword_69BC30 [0] = dword_69BC30 [0] & 0xFFFFFFCF | 0x20;
                        while((unsigned __int16) word_69D4B0 >= dword_4766DC [j])
                            ++j;
                        if(j == v34) {
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), 10, -1);
                        }
                        else {
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), -1, -8339201);
                            sub_4311E0(dword_6D3F50, (int*) 0x1F, 0);
                        }
                    }
                    else {
                        if((unsigned int)++byte_69D4B9 >= 0x1F)
                            byte_69D4B9 = 30;
                        v40 = dword_476660 [byte_69D4B9];
                        dword_69BCA4 += v40;
                        v2 = (v40 < 12800) - 1;
                        LOBYTE(v2) = v2 & 1;
                        sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v40, v2 - 1);
                    }
                    result = (int) sub_41C57E(dword_69BCA0, v3, 1);
                    break;
                case 1:
                    switch(dword_69BCB0) {
                        case 0:
                        case 1:
                            if((int) (unsigned __int64) *(float*) (v37 + 276) >= 128)
                                v16 = 60000 - 100 * ((unsigned __int64) *(float*) (v37 + 276) - 128);
                            else
                                v16 = 100000;
                            v40 = v16;
                            v4 = (v16 < 100000) - 1;
                            LOBYTE(v4) = v4 & 1;
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v16, v4 - 1);
                            break;
                        case 2:
                            if((int) (unsigned __int64) *(float*) (v37 + 276) >= 128)
                                v15 = 100000 - 180 * ((unsigned __int64) *(float*) (v37 + 276) - 128);
                            else
                                v15 = 150000;
                            v40 = v15;
                            v5 = (v15 < 150000) - 1;
                            LOBYTE(v5) = v5 & 1;
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v15, v5 - 1);
                            break;
                        case 3:
                            if((int) (unsigned __int64) *(float*) (v37 + 276) >= 128)
                                v14 = 150000 - 270 * ((unsigned __int64) *(float*) (v37 + 276) - 128);
                            else
                                v14 = 200000;
                            v40 = v14;
                            v6 = (v14 < 200000) - 1;
                            LOBYTE(v6) = v6 & 1;
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v14, v6 - 1);
                            break;
                        case 4:
                            if((int) (unsigned __int64) *(float*) (v37 + 276) >= 128)
                                v13 = 200000 - 400 * ((unsigned __int64) *(float*) (v37 + 276) - 128);
                            else
                                v13 = 300000;
                            v40 = v13;
                            v7 = (v13 < 300000) - 1;
                            LOBYTE(v7) = v7 & 1;
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v13, v7 - 1);
                            break;
                        default:
                            break;
                    }
                    dword_69BCA4 += v40;
                    ++word_69D4B4;
                    ++word_69D4B6;
                    v8 = dword_69BC30 [0];
                    BYTE1(v8) = BYTE1(dword_69BC30 [0]) & 0xFC | 2;
                    dword_69BC30 [0] = v8;
                    if(*(float*) (v37 + 276) >= 128.0)
                        result = (int) sub_41C57E(dword_69BCA0, v37, 3);
                    else
                        result = (int) sub_41C57E(dword_69BCA0, v37, 30);
                    break;
                case 2:
                    if((unsigned __int16) word_69D4B0 < 0x80u) {
                        for(k = 0; (unsigned __int16) word_69D4B0 >= dword_4766DC [k]; ++k)
                            ;
                        v32 = k;
                        word_69D4B0 += 8;
                        if((unsigned __int16) word_69D4B0 >= 0x80u) {
                            word_69D4B0 = 128;
                            sub_414340((char*) dword_5A5FF8);
                            sub_4173D9(dword_69BC30, 0);
                        }
                        v10 = dword_69BC30 [0];
                        LOBYTE(v10) = dword_69BC30 [0] & 0xCF | 0x20;
                        dword_69BC30 [0] = v10;
                        dword_69BCA4 += 10;
                        while((unsigned __int16) word_69D4B0 >= dword_4766DC [k])
                            ++k;
                        if(k == v32) {
                            result = (int) sub_401940(dword_47B900, (_DWORD*) (v37 + 272), 10, -1);
                        }
                        else {
                            sub_401940(dword_47B900, (_DWORD*) (v37 + 272), -1, -8339201);
                            result = (int) sub_4311E0(dword_6D3F50, (int*) 0x1F, 0);
                        }
                    }
                    else {
                        byte_69D4B9 += 8;
                        if((unsigned int) byte_69D4B9 >= 0x1F)
                            byte_69D4B9 = 30;
                        v40 = dword_476660 [byte_69D4B9];
                        dword_69BCA4 += v40;
                        v9 = (v40 < 12800) - 1;
                        LOBYTE(v9) = v9 & 1;
                        result = (int) sub_401940(dword_47B900, (_DWORD*) (v37 + 272), v40, v9 - 1);
                    }
                    break;
                case 3:
                    v11 = byte_69D4BB;
                    if(byte_69D4BB < 8) {
                        ++byte_69D4BB;
                        dword_69BC30 [0] = dword_69BC30 [0] & 0xFFFFFFF3 | 8;
                    }
                    result = (int) sub_41C57E(dword_69BCA0, v11, 5);
                    break;
                case 4:
                    if((unsigned __int16) word_69D4B0 < 0x80u) {
                        sub_414340((char*) dword_5A5FF8);
                        sub_4173D9(dword_69BC30, 0);
                        sub_4311E0(dword_6D3F50, (int*) 0x1F, 0);
                        sub_401940(dword_47B900, (_DWORD*) (v37 + 272), -1, -8339201);
                    }
                    word_69D4B0 = 128;
                    dword_69BCA4 += 1000;
                    sub_401940(dword_47B900, (_DWORD*) (v37 + 272), 1000, -1);
                    result = dword_69BC30 [0];
                    LOBYTE(result) = dword_69BC30 [0] & 0xCF | 0x20;
                    dword_69BC30 [0] = result;
                    break;
                case 5:
                    v12 = byte_69D4BA;
                    if(byte_69D4BA < 8) {
                        ++byte_69D4BA;
                        dword_69BC30 [0] = dword_69BC30 [0] & 0xFFFFFFFC | 2;
                    }
                    sub_41C57E(dword_69BCA0, v12, 200);
                    result = (int) sub_4311E0(dword_6D3F50, (int*) 0x1C, 0);
                    break;
                case 6:
                    v40 = 10 * (*(_DWORD*) dword_69BCB4 / 3) + 500;
                    if(dword_6D1BF0)
                        v40 = 100;
                    dword_69BCA4 += v40;
                    result = (int) sub_401A60(dword_47B900, (_DWORD*) (v37 + 272), v40, -1);
                    break;
                default:
                    break;
            }
            *(_BYTE*) (v37 + 321) = 0;
            v38 = 1;
        }
        else {
            *(_DWORD*) (v37 + 308) = *(_DWORD*) (v37 + 316);
            sub_424285((float*) &dword_6C6D18, (_DWORD*) (v37 + 316), (float*) (v37 + 312));
            result = sub_433960((int*) dword_6D4588, v37);
        }
        LABEL_4:
        v37 += 324;
    }
    if(v38)
        return (int) sub_4311E0(dword_6D3F50, (int*) 0x15, 0);
    return result;
}
// 41FADC: variable 'v3' is possibly undefined
// 41FD09: variable 'v40' is possibly undefined
// 476660: using guessed type int dword_476660[31];
// 4766DC: using guessed type int dword_4766DC[11];
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B4: using guessed type __int16 word_69D4B4;
// 69D4B6: using guessed type __int16 word_69D4B6;
// 69D4B9: using guessed type char byte_69D4B9;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D6E8: using guessed type float flt_69D6E8;
// 69E234: using guessed type int dword_69E234;
// 69E238: using guessed type int dword_69E238;
// 69E23C: using guessed type int dword_69E23C;
// 69E240: using guessed type int dword_69E240;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6CA628: using guessed type float flt_6CA628[272];
// 6CAA6C: using guessed type float flt_6CAA6C;
// 6D1BF0: using guessed type int dword_6D1BF0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00420130) --------------------------------------------------------
void* __thiscall sub_420130(char* this) {
    void* result; // eax
    char* v2; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    result = this;
    v2 = this;
    for(i = 0; i < 512; ++i) {
        result = v2;
        if(v2 [321])
            v2 [323] = 1;
        v2 += 324;
    }
    return result;
}

//----- (00420190) --------------------------------------------------------
int __thiscall sub_420190(void* this) {
    int result; // eax
    unsigned int v2; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]
    int v4; // [esp+Ch] [ebp-4h]

    result = (int) this;
    v2 = (unsigned int) this;
    for(i = 0; i < 512; ++i) {
        result = v2;
        if(*(_BYTE*) (v2 + 321)) {
            *(float*) (v2 + 144) = flt_69D6DC + *(float*) (v2 + 272);
            *(float*) (v2 + 148) = flt_69D6E0 + *(float*) (v2 + 276);
            *(_DWORD*) (v2 + 152) = 1008981770;
            if(*(float*) (v2 + 276) >= -8.0) {
                if(!*(_BYTE*) (v2 + 322)) {
                    sub_4323A0((int*) dword_6D4588, v2, *(char*) (v2 + 320) + 512);
                    *(_BYTE*) (v2 + 322) = 1;
                    *(_DWORD*) (v2 + 124) = -1;
                }
            }
            else {
                *(float*) (v2 + 148) = flt_69D6E0 + 8.0;
                if(*(_BYTE*) (v2 + 322)) {
                    sub_4323A0((int*) dword_6D4588, v2, *(char*) (v2 + 320) + 519);
                    *(_BYTE*) (v2 + 322) = 0;
                }
                v4 = 255 - (unsigned __int64) ((8.0 - *(float*) (v2 + 276)) * 255.0 / 128.0);
                if(v4 < 64)
                    v4 = 64;
                *(_DWORD*) (v2 + 124) = (v4 << 24) | *(_DWORD*) (v2 + 124) & 0xFFFFFF;
            }
            result = sub_432AD0((void*) dword_6D4588, v2);
        }
        v2 += 324;
    }
    return result;
}
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00420330) --------------------------------------------------------
int __stdcall sub_420330(HINSTANCE hInstance, int a2, int a3, int a4) {
    void* v5; // [esp+0h] [ebp-58h]
    int v6; // [esp+4h] [ebp-54h]
    void* Block; // [esp+24h] [ebp-34h]
    void* v8; // [esp+28h] [ebp-30h]
    struct tagMSG Msg; // [esp+34h] [ebp-24h] BYREF
    int v10; // [esp+50h] [ebp-8h]
    int v11; // [esp+54h] [ebp-4h]

    v11 = 0;
    if(sub_421900())
        goto LABEL_2;
    dword_6C6D18 = (int) hInstance;
    if(sub_42464D(&dword_6C6D18, "th06e.cfg")) {
        sub_421950((int) byte_69D998);
        return -1;
    }
    else {
        if(sub_420BD0()) {
            LABEL_2:
            sub_421950((int) byte_69D998);
            return 1;
        }
        SystemParametersInfoA(0x10u, 0, &uiParam, 0);
        SystemParametersInfoA(0x53u, 0, &dword_6C6BEC, 0);
        SystemParametersInfoA(0x54u, 0, &dword_6C6BF0, 0);
        SystemParametersInfoA(0x11u, 0, 0, 2u);
        SystemParametersInfoA(0x55u, 0, 0, 2u);
        SystemParametersInfoA(0x56u, 0, 0, 2u);
        while(1) {
            sub_420C10(hInstance);
            if(sub_420E60()) {
                sub_421950((int) byte_69D998);
                return 1;
            }
            sub_430270(dword_6D3F50, hWnd);
            sub_41CF60();
            sub_41E0C0();
            v8 = operator new(0x2112Cu);
            if(v8)
                v6 = sub_431470((int) v8);
            else
                v6 = 0;
            dword_6D4588 = v6;
            if(!sub_42386B()) {
                if(!byte_6C6E4A)
                    ShowCursor(0);
                byte_6C6BE4 = 0;
                while(!dword_6C6BD8) {
                    if(PeekMessageA(&Msg, 0, 0, 0, 1u)) {
                        TranslateMessage(&Msg);
                        DispatchMessageA(&Msg);
                    }
                    else {
                        v10 = (*(int(__stdcall**)(int))(*(_DWORD*) dword_6C6D20 + 12))(dword_6C6D20);
                        if(v10) {
                            if(v10 == -2005530519) {
                                sub_4219D0((_DWORD**) dword_6D4588);
                                if((*(int(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8))
                                    break;
                                sub_421420();
                                dword_6C6EB0 = 3;
                            }
                        }
                        else {
                            v11 = sub_4206E0((int) &hWnd);
                            if(v11)
                                break;
                        }
                    }
                }
            }
            sub_41CD10(byte_69D918);
            sub_430510((int) dword_6D3F50);
            Block = (void*) dword_6D4588;
            if(dword_6D4588) {
                unknown_libname_2(dword_6D4588, v5);
                j__free(Block);
                v5 = Block;
            }
            else {
                v5 = 0;
            }
            dword_6D4588 = 0;
            if(dword_6C6D20) {
                (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D20 + 8))(dword_6C6D20);
                dword_6C6D20 = 0;
            }
            ShowWindow(hWnd, 0);
            MoveWindow(hWnd, 0, 0, 0, 0, 0);
            DestroyWindow(hWnd);
            if(v11 != 2)
                break;
            dword_69E198 = (int) byte_69D998;
            byte_69D998 [0] = 0;
            sub_41E4D0((int) byte_69D998, (char*) &byte_46B150);
            if(!byte_6C6E4A)
                ShowCursor(1);
        }
        sub_41E460("th06e.cfg", &word_6C6E2C, 0x38u);
        SystemParametersInfoA(0x11u, uiParam, 0, 2u);
        SystemParametersInfoA(0x55u, dword_6C6BEC, 0, 2u);
        SystemParametersInfoA(0x56u, dword_6C6BF0, 0, 2u);
        if(dword_6C6D1C) {
            (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D1C + 8))(dword_6C6D1C);
            dword_6C6D1C = 0;
        }
        ShowCursor(1);
        sub_421950((int) byte_69D998);
        return 0;
    }
}
// 420585: variable 'v5' is possibly undefined
// 423330: using guessed type int __thiscall unknown_libname_2(_DWORD, _DWORD);
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 69E198: using guessed type int dword_69E198;
// 6C6BD8: using guessed type int dword_6C6BD8;
// 6C6BE4: using guessed type char byte_6C6BE4;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6D1C: using guessed type int dword_6C6D1C;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E2C: using guessed type __int16 word_6C6E2C;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6EB0: using guessed type int dword_6C6EB0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (004206E0) --------------------------------------------------------
int __thiscall sub_4206E0(int this) {
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    __int16 v6; // fps
    bool v7; // c0
    char v8; // c2
    bool v9; // c3
    void* v10; // ecx
    __int16 v11; // fps
    bool v12; // c0
    char v13; // c2
    bool v14; // c3
    __int16 v15; // fps
    bool v16; // c0
    char v17; // c2
    bool v18; // c3
    DWORD v22; // [esp+78h] [ebp-3Ch]
    double v23; // [esp+7Ch] [ebp-38h]
    double v24; // [esp+7Ch] [ebp-38h]
    double v25; // [esp+84h] [ebp-30h]
    double Time; // [esp+8Ch] [ebp-28h]
    int v27 [6]; // [esp+98h] [ebp-1Ch] BYREF
    int v28; // [esp+B0h] [ebp-4h]

    if(!*(_DWORD*) (this + 8))
        return 0;
    if(*(_BYTE*) (this + 16))
        goto LABEL_13;
    while(1) {
        while(1) {
            if((unsigned __int8) byte_6C6E4B <= (int) *(unsigned __int8*) (this + 16)) {
                if(((unsigned int) dword_6C6E60 >> 4) & 1 | ((unsigned int) dword_6C6E60 >> 3) & 1) {
                    v27 [0] = 0;
                    v27 [1] = 0;
                    v27 [2] = 640;
                    v27 [3] = 480;
                    v27 [4] = 0;
                    v27 [5] = 1065353216;
                    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, v27);
                    (*(void(__stdcall**)(int, _DWORD, _DWORD, int, int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 144))(
                        dword_6C6D20,
                        0,
                        0,
                        3,
                        dword_487B60,
                        1065353216,
                        0);
                    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
                }
                (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D20 + 136))(dword_6C6D20);
                sub_41CAD0(byte_69D918);
                (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D20 + 140))(dword_6C6D20);
                (*(void(__stdcall**)(int, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 244))(dword_6C6D20, 0, 0);
            }
            dword_6C6DE0 = 0;
            dword_6C6DE4 = 0;
            dword_6C6DE8 = 640;
            dword_6C6DEC = 480;
            (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
            v28 = sub_41CA10(byte_69D918);
            sub_431270(dword_6D3F50);
            if(!v28)
                return 1;
            if(v28 == -1)
                return 2;
            ++* (_BYTE*) (this + 16);
            LABEL_13:
            if(!byte_6C6E4A && ((((unsigned int) dword_6C6E60 >> 7) & 1) == 0 || !dword_6C6EB8))
                break;
            if(!*(_BYTE*) (this + 16))
                break;
            dword_6C6EC4 = 1065353216;
            timeBeginPeriod(1u);
            Time = (double) timeGetTime();
            if(Time < dbl_6C6BF8)
                dbl_6C6BF8 = Time;
            v25 = fabs(Time - dbl_6C6BF8);
            timeEndPeriod(1u);
            v3 = v25 < 16.66666666666667;
            v4 = 0;
            v5 = v25 == 16.66666666666667;
            if((v2 & 0x100) != 0)
                break;
            do {
                dbl_6C6BF8 = dbl_6C6BF8 + 16.66666666666667;
                v25 = v25 - 16.66666666666667;
                v7 = v25 < 16.66666666666667;
                v8 = 0;
                v9 = v25 == 16.66666666666667;
            }
            while((v6 & 0x100) == 0);
            v10 = (void*) (unsigned __int8) byte_6C6E4B;
            if((unsigned __int8) byte_6C6E4B < (int) *(unsigned __int8*) (this + 16))
                goto LABEL_34;
        }
        if(byte_6C6E4A)
            return 0;
        if((((unsigned int) dword_6C6E60 >> 7) & 1) != 0 && dword_6C6EB8)
            return 0;
        v10 = (void*) this;
        if((unsigned __int8) byte_6C6E4B < (int) *(unsigned __int8*) (this + 16))
            break;
        sub_420B50((void*) this);
    }
    LABEL_34:
    sub_420B50(v10);
    if(*(float*) &dword_6C6EC4 == 0.0) {
        if(dword_6C6BF4 >= 2) {
            timeBeginPeriod(1u);
            v22 = timeGetTime();
            if(v22 < dword_6C6EBC)
                dword_6C6EBC = v22;
            v23 = (double) (v22 - dword_6C6EBC) * 60.0 / 2.0 / 1000.0 / (double) ((unsigned __int8) byte_6C6E4B + 1);
            v12 = v23 < 0.865;
            v13 = 0;
            v14 = v23 == 0.865;
            if((v11 & 0x100) != 0) {
                v16 = v23 < 0.6;
                v17 = 0;
                v18 = v23 == 0.6;
                if((v15 & 0x100) != 0)
                    v24 = 0.5;
                else
                    v24 = 0.8;
            }
            else {
                v24 = 1.0;
            }
            flt_6C6EC0 = v24;
            dword_6C6EBC = v22;
            timeEndPeriod(1u);
            dword_6C6BF4 = 0;
        }
    }
    else {
        LODWORD(flt_6C6EC0) = dword_6C6EC4;
    }
    *(_BYTE*) (this + 16) = 0;
    ++dword_6C6BF4;
    return 0;
}
// 487B60: using guessed type int dword_487B60;
// 6C6BF4: using guessed type int dword_6C6BF4;
// 6C6BF8: using guessed type double dbl_6C6BF8;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EB8: using guessed type int dword_6C6EB8;
// 6C6EBC: using guessed type int dword_6C6EBC;
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00420B50) --------------------------------------------------------
int __thiscall sub_420B50(void* this) {
    int result; // eax

    if((*(int(__stdcall**)(int, _DWORD, _DWORD, _DWORD, _DWORD, void*))(*(_DWORD*) dword_6C6D20 + 60))(
        dword_6C6D20,
        0,
        0,
        0,
        0,
        this) < 0) {
        sub_4219D0((_DWORD**) dword_6D4588);
        (*(void(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8);
        sub_421420();
        dword_6C6EB0 = 2;
    }
    result = sub_421A40(dword_6D4588);
    if(dword_6C6EB0)
        return --dword_6C6EB0;
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6EB0: using guessed type int dword_6C6EB0;

//----- (00420BD0) --------------------------------------------------------
int sub_420BD0() {
    dword_6C6D1C = Direct3DCreate8(120);
    if(dword_6C6D1C)
        return 0;
    sub_41E620((int) byte_69D998, aDirect3d);
    return 1;
}
// 43EBAC: using guessed type int __stdcall Direct3DCreate8(_DWORD);
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D1C: using guessed type int dword_6C6D1C;

//----- (00420C10) --------------------------------------------------------
HWND __cdecl sub_420C10(HINSTANCE hInstance) {
    HWND result; // eax
    int SystemMetrics; // esi
    WNDCLASSA WndClass; // [esp+8h] [ebp-30h] BYREF
    int nWidth; // [esp+30h] [ebp-8h]
    int nHeight; // [esp+34h] [ebp-4h]

    memset(&WndClass, 0, sizeof(WndClass));
    WndClass.hbrBackground = (HBRUSH) GetStockObject(0);
    WndClass.hCursor = LoadCursorA(0, (LPCSTR) 0x7F00);
    WndClass.hInstance = hInstance;
    WndClass.lpfnWndProc = (WNDPROC) sub_420D40;
    dword_6C6BDC = 0;
    dword_6C6BE0 = 0;
    WndClass.lpszClassName = "BASE";
    RegisterClassA(&WndClass);
    if(byte_6C6E4A) {
        nWidth = 2 * GetSystemMetrics(7) + 640;
        SystemMetrics = GetSystemMetrics(8);
        nHeight = GetSystemMetrics(4) + 2 * SystemMetrics + 480;
        result = CreateWindowExA(
            0,
            "BASE",
            "Touhou koumakyou ~ the Embodiment of Scarlet Devil",
            0x100A0000u,
            0x80000000,
            0x80000000,
            nWidth,
            nHeight,
            0,
            0,
            hInstance,
            0);
    }
    else {
        nWidth = 640;
        nHeight = 480;
        result = CreateWindowExA(
            0,
            "BASE",
            "Touhou koumakyou ~ the Embodiment of Scarlet Devil",
            0xCF0000u,
            0,
            0,
            640,
            480,
            0,
            0,
            hInstance,
            0);
    }
    hWnd = result;
    lpParameter = (DWORD_PTR) result;
    return result;
}
// 6C6BDC: using guessed type int dword_6C6BDC;
// 6C6BE0: using guessed type int dword_6C6BE0;
// 6C6E4A: using guessed type char byte_6C6E4A;

//----- (00420D40) --------------------------------------------------------
LRESULT __stdcall sub_420D40(HWND hWnd, UINT Msg, int wParam, struct midihdr_tag* lParam) {
    HCURSOR CursorA; // eax

    if(Msg > 0x20) {
        if(Msg == 969 && dword_6C6EC8)
            sub_422560((HMIDIOUT*) dword_6C6EC8, lParam);
        return DefWindowProcA(hWnd, Msg, wParam, (LPARAM) lParam);
    }
    if(Msg != 32) {
        if(Msg == 16) {
            dword_6C6BD8 = 1;
            return 1;
        }
        if(Msg == 28) {
            dword_6C6BDC = wParam;
            dword_6C6BE0 = wParam == 0;
        }
        return DefWindowProcA(hWnd, Msg, wParam, (LPARAM) lParam);
    }
    if(byte_6C6E4A || dword_6C6BE0) {
        CursorA = LoadCursorA(0, (LPCSTR) 0x7F00);
        SetCursor(CursorA);
        ShowCursor(1);
    }
    else {
        ShowCursor(0);
        SetCursor(0);
    }
    return 1;
}
// 6C6BD8: using guessed type int dword_6C6BD8;
// 6C6BDC: using guessed type int dword_6C6BDC;
// 6C6BE0: using guessed type int dword_6C6BE0;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6EC8: using guessed type int dword_6C6EC8;

//----- (00420E60) --------------------------------------------------------
int sub_420E60() {
    int v1; // ecx
    BOOL v2; // [esp+38h] [ebp-88h]
    float v3; // [esp+3Ch] [ebp-84h]
    int v4 [3]; // [esp+40h] [ebp-80h] BYREF
    int v5; // [esp+4Ch] [ebp-74h] BYREF
    int v6; // [esp+50h] [ebp-70h]
    int v7; // [esp+54h] [ebp-6Ch]
    int v8 [3]; // [esp+58h] [ebp-68h] BYREF
    float v9; // [esp+64h] [ebp-5Ch]
    float v10; // [esp+68h] [ebp-58h]
    int v11; // [esp+6Ch] [ebp-54h]
    int v12; // [esp+70h] [ebp-50h]
    float v13; // [esp+74h] [ebp-4Ch]
    int v14 [13]; // [esp+78h] [ebp-48h] BYREF
    char v15 [12]; // [esp+ACh] [ebp-14h] BYREF
    int v16; // [esp+B8h] [ebp-8h]
    char v17; // [esp+BFh] [ebp-1h]

    v17 = 1;
    memset(v14, 0, sizeof(v14));
    (*(void(__stdcall**)(int, _DWORD, char*))(*(_DWORD*) dword_6C6D1C + 32))(dword_6C6D1C, 0, v15);
    if(byte_6C6E4A) {
        v14 [2] = v16;
        v14 [5] = 3;
        v14 [7] = 1;
    }
    else {
        if((((unsigned int) dword_6C6E60 >> 2) & 1) == 1) {
            v14 [2] = 23;
            byte_6C6E46 = 1;
        }
        else if((unsigned __int8) byte_6C6E46 == 255) {
            if(v16 == 22 || v16 == 21) {
                v14 [2] = 22;
                byte_6C6E46 = 0;
                sub_41E4D0((int) byte_69D998, (char*) &byte_46B4B4);
            }
            else {
                v14 [2] = 23;
                byte_6C6E46 = 1;
                sub_41E4D0((int) byte_69D998, (char*) &byte_46B488);
            }
        }
        else if(byte_6C6E46) {
            v14 [2] = 23;
        }
        else {
            v14 [2] = 22;
        }
        if((((unsigned int) dword_6C6E60 >> 7) & 1) != 0) {
            v14 [11] = 60;
            v14 [12] = 1;
            sub_41E4D0((int) byte_69D998, (char*) &byte_46B460);
        }
        else {
            v14 [12] = 1;
        }
        if(byte_6C6E4B)
            v14 [5] = 4;
        else
            v14 [5] = 2;
    }
    v14 [0] = 640;
    v14 [1] = 480;
    v14 [8] = 1;
    v14 [9] = 80;
    v14 [10] = 1;
    byte_6C7115 = 1;
    qmemcpy(&unk_6C6DF8, v14, 0x34u);
    while(1) {
        if((((unsigned int) dword_6C6E60 >> 9) & 1) != 0)
            goto LABEL_24;
        if((*(int(__stdcall**)(int, _DWORD, int, HWND, int, int*, int*))(*(_DWORD*) dword_6C6D1C + 60))(
            dword_6C6D1C,
            0,
            1,
            hWnd,
            64,
            v14,
            &dword_6C6D20) >= 0)
            break;
        sub_41E4D0((int) byte_69D998, aTLHal);
        if((*(int(__stdcall**)(int, _DWORD, int, HWND, int, int*, int*))(*(_DWORD*) dword_6C6D1C + 60))(
            dword_6C6D1C,
            0,
            1,
            hWnd,
            32,
            v14,
            &dword_6C6D20) >= 0) {
            sub_41E4D0((int) byte_69D998, aHal_0);
            byte_6C7114 = 0;
            goto LABEL_36;
        }
        sub_41E4D0((int) byte_69D998, aHal);
        LABEL_24:
        if((*(int(__stdcall**)(int, _DWORD, int, HWND, int, int*, int*))(*(_DWORD*) dword_6C6D1C + 60))(
            dword_6C6D1C,
            0,
            2,
            hWnd,
            32,
            v14,
            &dword_6C6D20) >= 0) {
            sub_41E4D0((int) byte_69D998, aRef);
            byte_6C7114 = 0;
            v17 = 0;
            goto LABEL_36;
        }
        if((((unsigned int) dword_6C6E60 >> 7) & 1) == 0 || dword_6C6EB8) {
            if(v14 [10] != 1) {
                sub_41E620((int) byte_69D998, aDirect3d_0);
                if(dword_6C6D1C) {
                    (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D1C + 8))(dword_6C6D1C);
                    dword_6C6D1C = 0;
                }
                return 1;
            }
            sub_41E4D0((int) byte_69D998, (char*) &byte_46B3B8);
            v14 [10] = 0;
            byte_6C7115 = 0;
        }
        else {
            sub_41E4D0((int) byte_69D998, (char*) &byte_46B3E4);
            v14 [11] = 0;
            dword_6C6EB8 = 1;
            v14 [12] = 0x80000000;
        }
    }
    sub_41E4D0((int) byte_69D998, aTLHal_0);
    byte_6C7114 = 1;
    LABEL_36:
    v11 = 1134559232;
    v12 = 1131413504;
    v10 = 1.3333334;
    v9 = 0.52359879;
    v3 = tan(0.52359879 / 2.0);
    v13 = 240.0 / v3;
    v8 [0] = 0;
    v8 [1] = 1065353216;
    v8 [2] = 0;
    v5 = 1134559232;
    *(float*) &v6 = -240.0;
    v7 = 0;
    v4 [0] = 1134559232;
    v4 [1] = v6;
    *(float*) &v4 [2] = -v13;
    sub_43F561(flt_6C6D60, (float*) v4, (float*) &v5, (float*) v8);
    sub_43EFEE(flt_6C6DA0, v9, v10, 100.0, 10000.0);
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 2, flt_6C6D60);
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 3, flt_6C6DA0);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 164))(dword_6C6D20, &dword_6C6DE0);
    (*(void(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 28))(dword_6C6D20, &unk_6C711C);
    if((dword_6C6E60 & 1) == 0 && (dword_6C71AC & 0x40) == 0) {
        sub_41E4D0((int) byte_69D998, aD3dtexopcapsAd);
        dword_6C6E60 |= 1u;
    }
    v2 = (((unsigned int) dword_6C6E60 >> 7) & 1) != 0 && dword_6C6EB8;
    if(v2 && dword_6C7130 >= 0) {
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B270);
        v1 = dword_6C6E60;
        LOBYTE(v1) = dword_6C6E60 & 0x7F;
        dword_6C6E60 = v1;
    }
    if((((unsigned int) dword_6C6E60 >> 2) & 1) == 0 && v17) {
        if((*(int(__stdcall**)(int, _DWORD, int, int, _DWORD, int, int))(*(_DWORD*) dword_6C6D1C + 40))(
            dword_6C6D1C,
            0,
            1,
            v14 [2],
            0,
            3,
            21)) {
            byte_6C7116 = 0;
            dword_6C6E60 |= 4u;
            sub_41E4D0((int) byte_69D998, aD3dfmtA8r8g8b8);
        }
        else {
            byte_6C7116 = 1;
        }
    }
    sub_421420();
    sub_42F790(0);
    dword_6C6BD8 = 0;
    dword_6C6EBC = 0;
    dword_6C6EC4 = 0;
    return 0;
}
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6BD8: using guessed type int dword_6C6BD8;
// 6C6D1C: using guessed type int dword_6C6D1C;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6D60: using guessed type float flt_6C6D60[16];
// 6C6DA0: using guessed type float flt_6C6DA0[16];
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6E46: using guessed type char byte_6C6E46;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EB8: using guessed type int dword_6C6EB8;
// 6C6EBC: using guessed type int dword_6C6EBC;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6C7114: using guessed type char byte_6C7114;
// 6C7115: using guessed type char byte_6C7115;
// 6C7116: using guessed type char byte_6C7116;
// 6C7130: using guessed type int dword_6C7130;
// 6C71AC: using guessed type int dword_6C71AC;
// 420E60: using guessed type char var_14[12];

//----- (00421420) --------------------------------------------------------
int sub_421420() {
    int result; // eax

    if((((unsigned int) dword_6C6E60 >> 6) & 1) != 0)
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 7, 0);
    else
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 7, 1);
    (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 137, 0);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 22, 1);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 27, 1);
    if((((unsigned int) dword_6C6E60 >> 5) & 1) != 0)
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 9, 1);
    else
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 9, 2);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 19, 5);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 20, 6);
    if((((unsigned int) dword_6C6E60 >> 6) & 1) != 0)
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 8);
    else
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 4);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 15, 1);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 24, 4);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 25, 7);
    if((((unsigned int) dword_6C6E60 >> 10) & 1) != 0)
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 28, 0);
    else
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 28, 1);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 38, 1065353216);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 35, 3);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 34, -6250336);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 36, 1148846080);
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 37, 1167867904);
    if((((unsigned int) dword_6C6E60 >> 8) & 1) != 0)
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 2);
    else
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 4);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 2);
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0)
        (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 6, 0);
    else
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 6, 3);
    if((((unsigned int) dword_6C6E60 >> 8) & 1) != 0)
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 2);
    else
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 4);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 2);
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0)
        (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 3, 0);
    else
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 3, 3);
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 18, 0);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 16, 2);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 17, 2);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 24, 2);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 25, 3);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 13, 1);
    result = (*(int(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 14, 1);
    if(dword_6D4588) {
        *(_BYTE*) (dword_6D4588 + 135356) = -1;
        *(_BYTE*) (dword_6D4588 + 135357) = -1;
        *(_BYTE*) (dword_6D4588 + 135358) = -1;
        result = dword_6D4588;
        *(_DWORD*) (dword_6D4588 + 135352) = 0;
    }
    byte_487B8C = 1;
    return result;
}
// 487B8C: using guessed type char byte_487B8C;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00421900) --------------------------------------------------------
int sub_421900() {
    dword_6C6C00 = (int) CreateMutexA(0, 1, "Touhou Koumakyou App");
    if(!dword_6C6C00)
        return -1;
    if(GetLastError() != 183)
        return 0;
    sub_41E620((int) byte_69D998, (char*) &byte_46B4E0);
    return -1;
}
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6C00: using guessed type int dword_6C6C00;

//----- (00421950) --------------------------------------------------------
int __thiscall sub_421950(int this) {
    int result; // eax
    FILE* Stream; // [esp+4h] [ebp-4h]

    result = this;
    if(*(_DWORD*) (this + 2048) != this) {
        sub_41E4D0(this, "---------------------------------------------------------- \n");
        if(*(_BYTE*) (this + 2052))
            MessageBoxA(0, (LPCSTR) this, off_46B520, 0x10u);
        Stream = fopen("./log.txt", "wt");
        sub_45D30D(Stream, (char*) this, this);
        return fclose(Stream);
    }
    return result;
}

//----- (004219D0) --------------------------------------------------------
int __thiscall sub_4219D0(_DWORD** this) {
    int result; // eax
    int i; // [esp+4h] [ebp-4h]

    for(i = 0; i < 32; ++i) {
        if(this [i + 33613]) {
            (*(void(__stdcall**)(_DWORD*))(*this [i + 33613] + 8))(this [i + 33613]);
            this [i + 33613] = 0;
        }
        result = i + 1;
    }
    return result;
}

//----- (00421A40) --------------------------------------------------------
int __thiscall sub_421A40(int this) {
    int result; // eax

    result = this;
    if(*(int*) (this + 135448) >= 0) {
        result = sub_435670(
            (_DWORD**) this,
            *(_DWORD*) (this + 135448),
            *(_DWORD*) (this + 135452),
            *(_DWORD*) (this + 135456),
            *(_DWORD*) (this + 135460),
            *(_DWORD*) (this + 135464));
        *(_DWORD*) (this + 135448) = -1;
    }
    return result;
}

//----- (00421AD0) --------------------------------------------------------
int __thiscall sub_421AD0(HMIDIOUT* this) {
    return sub_421B50(this);
}

//----- (00421AF0) --------------------------------------------------------
BOOL __thiscall sub_421AF0(int this, UINT uDeviceID) {
    if(*(_DWORD*) this) {
        if(*(_DWORD*) (this + 4) == uDeviceID)
            return 0;
        sub_421B50((HMIDIOUT*) this);
    }
    *(_DWORD*) (this + 4) = uDeviceID;
    return midiOutOpen((LPHMIDIOUT) this, uDeviceID, lpParameter, 0, 0x10000u) != 0;
}

//----- (00421B50) --------------------------------------------------------
int __thiscall sub_421B50(HMIDIOUT* this) {
    if(!*this)
        return -1;
    midiOutReset(*this);
    midiOutClose(*this);
    *this = 0;
    return 0;
}

//----- (00421B90) --------------------------------------------------------
BOOL __thiscall sub_421B90(HMIDIOUT* this, LPMIDIHDR pmh) {
    if(!*this)
        return 0;
    if(midiOutPrepareHeader(*this, pmh, 0x40u))
        return 1;
    return midiOutLongMsg(*this, pmh, 0x40u) != 0;
}

//----- (00421BE0) --------------------------------------------------------
BOOL __thiscall sub_421BE0(HMIDIOUT* this, char a2, char a3, char a4) {
    DWORD dwMsg; // [esp+4h] [ebp-4h]

    if(!*this)
        return 0;
    LOBYTE(dwMsg) = a2;
    BYTE1(dwMsg) = a3;
    BYTE2(dwMsg) = a4;
    return midiOutShortMsg(*this, dwMsg) != 0;
}
// 421C11: variable 'dwMsg' is possibly undefined

//----- (00421C30) --------------------------------------------------------
struct timecaps_tag* __thiscall sub_421C30(struct timecaps_tag* this) {
    this->wPeriodMin = (UINT) off_46B564;
    timeGetDevCaps(this + 1, 8u);
    this->wPeriodMax = 0;
    return this;
}
// 46B564: using guessed type int (*off_46B564[2])();

//----- (00421C60) --------------------------------------------------------
MMRESULT __thiscall sub_421C60(UINT* this) {
    *this = (UINT) off_46B564;
    sub_421D10(this);
    return timeEndPeriod(this [2]);
}
// 46B564: using guessed type int (*off_46B564[2])();

//----- (00421C90) --------------------------------------------------------
UINT __thiscall sub_421C90(UINT* this, UINT uDelay, LPTIMECALLBACK fptc, DWORD_PTR dwUser) {
    MMRESULT v4; // eax

    sub_421D10(this);
    timeBeginPeriod(this [2]);
    if(fptc)
        v4 = timeSetEvent(uDelay, this [2], fptc, dwUser, 1u);
    else
        v4 = timeSetEvent(uDelay, this [2], (LPTIMECALLBACK)::fptc, (DWORD_PTR) this, 1u);
    this [1] = v4;
    return this [1];
}

//----- (00421D10) --------------------------------------------------------
int __thiscall sub_421D10(UINT* this) {
    if(this [1])
        timeKillEvent(this [1]);
    timeEndPeriod(this [2]);
    this [1] = 0;
    return 1;
}

//----- (00421D50) --------------------------------------------------------
void __stdcall fptc(
    UINT uTimerID,
    UINT uMsg,
    void(__thiscall*** dwUser)(_DWORD, _DWORD),
    DWORD_PTR dw1,
    DWORD_PTR dw2) {
    (**dwUser)(dwUser, dwUser);
}

//----- (00421D70) --------------------------------------------------------
__int16 __cdecl sub_421D70(__int16 a1) {
    __int16 v2; // [esp+0h] [ebp-4h]

    LOBYTE(v2) = HIBYTE(a1);
    HIBYTE(v2) = a1;
    return v2;
}

//----- (00421D90) --------------------------------------------------------
int __cdecl sub_421D90(_DWORD* a1) {
    char v2; // [esp+3h] [ebp-5h]
    int v3; // [esp+4h] [ebp-4h]

    v3 = 0;
    do {
        v2 = *(_BYTE*) (*a1)++;
        v3 = (v2 & 0x7F) + (v3 << 7);
    }
    while((v2 & 0x80) != 0);
    return v3;
}

//----- (00421DF0) --------------------------------------------------------
int __thiscall sub_421DF0(int this) {
    int j; // [esp+4h] [ebp-14h]
    int i; // [esp+8h] [ebp-10h]

    sub_421C30((struct timecaps_tag*) this);
    *(_DWORD*) this = &off_46B568;
    unknown_libname_1(this + 316);
    *(_DWORD*) (this + 312) = 0;
    *(_DWORD*) (this + 284) = 0;
    *(_DWORD*) (this + 288) = 0;
    *(_DWORD*) (this + 276) = 0;
    *(_BYTE*) (this + 708) = 0;
    *(_DWORD*) (this + 712) = 0;
    *(_DWORD*) (this + 716) = 0;
    *(_DWORD*) (this + 720) = 0;
    *(_DWORD*) (this + 724) = 0;
    *(_DWORD*) (this + 728) = 0;
    *(_DWORD*) (this + 732) = 0;
    *(_DWORD*) (this + 736) = 0;
    for(i = 0; i < 32; ++i)
        *(_DWORD*) (this + 4 * i + 148) = 0;
    for(j = 0; j < 32; ++j)
        *(_DWORD*) (this + 4 * j + 16) = 0;
    *(_DWORD*) (this + 144) = 0;
    return this;
}
// 421AA0: using guessed type int __thiscall unknown_libname_1(_DWORD);
// 46B568: using guessed type int (*off_46B568)();

//----- (00421F50) --------------------------------------------------------
MMRESULT __thiscall sub_421F50(int this) {
    int i; // [esp+4h] [ebp-10h]

    *(_DWORD*) this = &off_46B568;
    sub_4224E0(this);
    sub_4220B0(this);
    for(i = 0; i < 32; ++i)
        sub_422070((void**) this, i);
    sub_421AD0((HMIDIOUT*) (this + 316));
    return sub_421C60((UINT*) this);
}
// 46B568: using guessed type int (*off_46B568)();

//----- (00421FF0) --------------------------------------------------------
int __thiscall sub_421FF0(void** this, int a2, char* Str) {
    if(byte_6C6E47 != 2)
        return 0;
    sub_4224E0((int) this);
    sub_422070(this, a2);
    this [a2 + 37] = sub_41E290(Str, 0);
    if(this [a2 + 37])
        return 0;
    sub_41E4D0((int) byte_69D998, aErrorMidiFile, Str);
    return -1;
}
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6E47: using guessed type char byte_6C6E47;

//----- (00422070) --------------------------------------------------------
int __thiscall sub_422070(void** this, int a2) {
    int result; // eax

    free(this [a2 + 37]);
    this [a2 + 37] = 0;
    return result;
}

//----- (004220B0) --------------------------------------------------------
int __thiscall sub_4220B0(int this) {
    int result; // eax
    int i; // [esp+Ch] [ebp-4h]

    for(i = 0; i < *(_DWORD*) (this + 276); ++i)
        free(*(void**) (*(_DWORD*) (this + 312) + 32 * i + 16));
    free(*(void**) (this + 312));
    *(_DWORD*) (this + 312) = 0;
    result = this;
    *(_DWORD*) (this + 276) = 0;
    return result;
}

//----- (00422140) --------------------------------------------------------
int __thiscall sub_422140(int this, int a2) {
    size_t v4; // [esp+10h] [ebp-34h]
    int v5; // [esp+18h] [ebp-2Ch]
    __int16* v6; // [esp+1Ch] [ebp-28h]
    char* v7; // [esp+38h] [ebp-Ch]
    int v8; // [esp+3Ch] [ebp-8h]
    char* v9; // [esp+3Ch] [ebp-8h]
    char* v10; // [esp+3Ch] [ebp-8h]
    int i; // [esp+40h] [ebp-4h]

    sub_4220B0(this);
    v8 = *(_DWORD*) (this + 4 * a2 + 148);
    if(v8) {
        LOBYTE(v5) = HIBYTE(*(_DWORD*) (v8 + 4));
        BYTE1(v5) = BYTE2(*(_DWORD*) (v8 + 4));
        BYTE2(v5) = BYTE1(*(_DWORD*) (v8 + 4));
        HIBYTE(v5) = *(_DWORD*) (v8 + 4);
        v6 = (__int16*) (v8 + 8);
        v9 = (char*) (v5 + v8 + 8);
        *(_DWORD*) (this + 280) = (unsigned __int16) sub_421D70(*v6);
        *(_DWORD*) (this + 284) = (unsigned __int16) sub_421D70(v6 [2]);
        *(_DWORD*) (this + 276) = (unsigned __int16) sub_421D70(v6 [1]);
        *(_DWORD*) (this + 312) = malloc(32 * *(_DWORD*) (this + 276));
        memset(*(void**) (this + 312), 0, 32 * *(_DWORD*) (this + 276));
        for(i = 0; i < *(_DWORD*) (this + 276); ++i) {
            v7 = v9;
            v10 = v9 + 8;
            LOBYTE(v4) = HIBYTE(*((_DWORD*) v7 + 1));
            BYTE1(v4) = BYTE2(*((_DWORD*) v7 + 1));
            BYTE2(v4) = BYTE1(*((_DWORD*) v7 + 1));
            HIBYTE(v4) = *((_DWORD*) v7 + 1);
            *(_DWORD*) (*(_DWORD*) (this + 312) + 32 * i + 8) = v4;
            *(_DWORD*) (*(_DWORD*) (this + 312) + 32 * i + 16) = malloc(v4);
            *(_DWORD*) (32 * i + *(_DWORD*) (this + 312)) = 1;
            qmemcpy(*(void**) (*(_DWORD*) (this + 312) + 32 * i + 16), v10, v4);
            v9 = &v10 [v4];
        }
        *(_DWORD*) (this + 288) = 1000000;
        return 0;
    }
    else {
        sub_41E940();
        return -1;
    }
}
// 47A630: using guessed type int dword_47A630;

//----- (00422380) --------------------------------------------------------
int __thiscall sub_422380(void** this, char* Str) {
    if(sub_421FF0(this, 31, Str))
        return -1;
    sub_422140((int) this, 31);
    sub_422070(this, 31);
    return 0;
}

//----- (004223C0) --------------------------------------------------------
_DWORD* __thiscall sub_4223C0(_DWORD* this) {
    _DWORD* result; // eax
    _DWORD* v3; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    v3 = (_DWORD*) this [78];
    this [178] = 1065353216;
    this [183] = 0;
    this [184] = 0;
    this [74] = 0;
    this [75] = 0;
    this [76] = 0;
    this [77] = 0;
    for(i = 0; ; ++i) {
        result = this;
        if(i >= this [69])
            break;
        v3 [5] = v3 [4];
        v3 [6] = v3 [5];
        *v3 = 1;
        v3 [1] = sub_421D90(v3 + 5);
        v3 += 8;
    }
    return result;
}

//----- (00422490) --------------------------------------------------------
int __thiscall sub_422490(UINT* this) {
    if(!this [78])
        return -1;
    sub_4223C0(this);
    sub_421AF0((int) (this + 79), 0xFFFFFFFF);
    sub_421C90(this, 1u, 0, 0);
    return 0;
}

//----- (004224E0) --------------------------------------------------------
int __thiscall sub_4224E0(int this) {
    int i; // [esp+4h] [ebp-4h]

    if(!*(_DWORD*) (this + 312))
        return -1;
    for(i = 0; i < 32; ++i) {
        if(*(_DWORD*) (this + 4 * *(_DWORD*) (this + 144) + 16))
            sub_422560((HMIDIOUT*) this, *(LPMIDIHDR*) (this + 4 * *(_DWORD*) (this + 144) + 16));
    }
    sub_421D10((UINT*) this);
    sub_421B50((HMIDIOUT*) (this + 316));
    return 0;
}

//----- (00422560) --------------------------------------------------------
int __thiscall sub_422560(HMIDIOUT* this, LPMIDIHDR pmh) {
    int i; // [esp+8h] [ebp-8h]

    if(!pmh)
        sub_41E940();
    if(!this [79])
        sub_41E940();
    for(i = 0; ; ++i) {
        if(i >= 32)
            return -1;
        if(this [i + 4] == (HMIDIOUT) pmh)
            break;
    }
    this [i + 4] = 0;
    if(midiOutUnprepareHeader(this [79], pmh, 0x40u))
        sub_41E940();
    free(pmh->lpData);
    free(pmh);
    return 0;
}

//----- (00422630) --------------------------------------------------------
int __thiscall sub_422630(_DWORD* this, int a2) {
    this [178] = 0;
    this [185] = a2;
    this [186] = 0;
    this [183] = 0;
    this [184] = 1;
    return 0;
}

//----- (00422680) --------------------------------------------------------
_DWORD* __thiscall sub_422680(int this) {
    _DWORD* result; // eax
    __int64 v2; // kr08_8
    float v3; // [esp+Ch] [ebp-20h]
    float v4; // [esp+10h] [ebp-1Ch]
    int v6; // [esp+18h] [ebp-14h]
    unsigned __int64 v7; // [esp+1Ch] [ebp-10h]
    int i; // [esp+28h] [ebp-4h]

    v6 = 0;
    v7 = 1000 * *(_QWORD*) (this + 296) * *(int*) (this + 284) / (unsigned __int64) *(int*) (this + 288)
        + *(_QWORD*) (this + 304);
    if(*(_DWORD*) (this + 736)) {
        result = (_DWORD*) this;
        if(*(_DWORD*) (this + 744) >= *(_DWORD*) (this + 740)) {
            *(_DWORD*) (this + 712) = 0;
            return result;
        }
        v4 = (float) *(int*) (this + 744);
        v3 = (float) *(int*) (this + 740);
        *(float*) (this + 712) = 1.0 - v4 / v3;
        if((unsigned int) (unsigned __int64) (*(float*) (this + 712) * 128.0) != *(_DWORD*) (this + 716))
            sub_423260(this, 0);
        *(_DWORD*) (this + 716) = (unsigned __int64) (*(float*) (this + 712) * 128.0);
        ++* (_DWORD*) (this + 744);
    }
    for(i = 0; i < *(_DWORD*) (this + 276); ++i) {
        if(*(_DWORD*) (32 * i + *(_DWORD*) (this + 312))) {
            v6 = 1;
            while(*(_DWORD*) (32 * i + *(_DWORD*) (this + 312)) && *(int*) (*(_DWORD*) (this + 312) + 32 * i + 4) <= v7) {
                sub_422900(this, *(_DWORD*) (this + 312) + 32 * i);
                v7 = 1000 * *(_QWORD*) (this + 296) * *(int*) (this + 284) / (unsigned __int64) *(int*) (this + 288)
                    + *(_QWORD*) (this + 304);
            }
        }
    }
    v2 = *(_QWORD*) (this + 296) + 1i64;
    result = (_DWORD*) HIDWORD(v2);
    *(_QWORD*) (this + 296) = v2;
    if(!v6)
        return sub_4223C0((_DWORD*) this);
    return result;
}

//----- (00422900) --------------------------------------------------------
int __thiscall sub_422900(int this, int a2) {
    int result; // eax
    float v3; // [esp+8h] [ebp-4Ch]
    _DWORD* v5; // [esp+28h] [ebp-2Ch]
    _DWORD* v6; // [esp+2Ch] [ebp-28h]
    char pmh; // [esp+37h] [ebp-1Dh]
    LPMIDIHDR pmh_1; // [esp+38h] [ebp-1Ch]
    int v9; // [esp+3Ch] [ebp-18h]
    unsigned __int8 v10; // [esp+40h] [ebp-14h]
    unsigned __int8 v11; // [esp+41h] [ebp-13h]
    unsigned __int8 v12; // [esp+43h] [ebp-11h]
    int v13; // [esp+44h] [ebp-10h]
    unsigned __int8 v14; // [esp+4Bh] [ebp-9h]
    int i; // [esp+4Ch] [ebp-8h]
    int j; // [esp+4Ch] [ebp-8h]
    int k; // [esp+4Ch] [ebp-8h]
    int m; // [esp+4Ch] [ebp-8h]
    int v19; // [esp+50h] [ebp-4h]

    v11 = **(_BYTE**) (a2 + 20);
    if(v11 >= 0x80u)
        ++* (_DWORD*) (a2 + 20);
    else
        v11 = *(_BYTE*) (a2 + 12);
    v12 = v11 & 0xF;
    switch(v11 & 0xF0) {
        case 0x80:
        case 0x90:
        case 0xA0:
        case 0xB0:
        case 0xE0:
            v10 = *(_BYTE*) (*(_DWORD*) (a2 + 20))++;
            v14 = *(_BYTE*) (*(_DWORD*) (a2 + 20))++;
            goto LABEL_26;
        case 0xC0:
        case 0xD0:
            v10 = *(_BYTE*) (*(_DWORD*) (a2 + 20))++;
            v14 = 0;
            goto LABEL_26;
        case 0xF0:
            if(v11 == 240) {
                if(*(_DWORD*) (this + 4 * *(_DWORD*) (this + 144) + 16))
                    sub_422560((HMIDIOUT*) this, *(LPMIDIHDR*) (this + 4 * *(_DWORD*) (this + 144) + 16));
                *(_DWORD*) (this + 4 * *(_DWORD*) (this + 144) + 16) = malloc(0x40u);
                pmh_1 = *(LPMIDIHDR*) (this + 4 * *(_DWORD*) (this + 144) + 16);
                v9 = sub_421D90((_DWORD*) (a2 + 20));
                memset(pmh_1, 0, sizeof(struct midihdr_tag));
                pmh_1->lpData = (LPSTR) malloc(v9 + 1);
                *pmh_1->lpData = -16;
                pmh_1->dwFlags = 0;
                pmh_1->dwBufferLength = v9 + 1;
                for(i = 0; i < v9; ++i)
                    pmh_1->lpData [i + 1] = *(_BYTE*) (*(_DWORD*) (a2 + 20))++;
                if(sub_421B90((HMIDIOUT*) (this + 316), pmh_1)) {
                    free(pmh_1->lpData);
                    free(pmh_1);
                    *(_DWORD*) (this + 4 * *(_DWORD*) (this + 144) + 16) = 0;
                }
                ++* (_DWORD*) (this + 144);
                *(int*) (this + 144) %= 32;
            }
            else if(v11 == 255) {
                pmh = *(_BYTE*) (*(_DWORD*) (a2 + 20))++;
                result = sub_421D90((_DWORD*) (a2 + 20));
                if(pmh == 47) {
                    *(_DWORD*) a2 = 0;
                    return result;
                }
                if(pmh == 81) {
                    *(_QWORD*) (this + 304) += 1000
                        * *(_QWORD*) (this + 296)
                        * *(int*) (this + 284)
                        / (unsigned __int64) *(int*) (this + 288);
                    *(_DWORD*) (this + 296) = 0;
                    *(_DWORD*) (this + 300) = 0;
                    *(_DWORD*) (this + 288) = 0;
                    for(j = 0; j < result; ++j)
                        *(_DWORD*) (this + 288) += *(unsigned __int8*) (*(_DWORD*) (a2 + 20))++ + (*(_DWORD*) (this + 288) << 8);
                }
                else {
                    *(_DWORD*) (a2 + 20) += result;
                }
            }
            LABEL_26:
            switch(v11 & 0xF0) {
                case 0x80:
                    goto LABEL_29;
                case 0x90:
                    if(v14) {
                        v10 += *(_BYTE*) (this + 708);
                        *(_BYTE*) (this + 23 * v12 + 340 + ((int) v10 >> 3)) |= 1 << (v10 & 7);
                    }
                    else {
                        LABEL_29:
                        v10 += *(_BYTE*) (this + 708);
                        *(_BYTE*) (this + 23 * v12 + 340 + ((int) v10 >> 3)) &= ~(1 << (v10 & 7));
                    }
                    break;
                case 0xB0:
                    switch(v10) {
                        case 0u:
                            *(_BYTE*) (this + 23 * v12 + 357) = v14;
                            break;
                        case 2u:
                            v6 = *(_DWORD**) (this + 312);
                            for(k = 0; k < *(_DWORD*) (this + 276); ++k) {
                                v6 [6] = v6 [5];
                                v6 [7] = v6 [1];
                                v6 += 8;
                            }
                            *(_DWORD*) (this + 748) = *(_DWORD*) (this + 288);
                            *(_DWORD*) (this + 752) = *(_DWORD*) (this + 296);
                            *(_DWORD*) (this + 756) = *(_DWORD*) (this + 300);
                            *(_DWORD*) (this + 760) = *(_DWORD*) (this + 304);
                            *(_DWORD*) (this + 764) = *(_DWORD*) (this + 308);
                            break;
                        case 4u:
                            v5 = *(_DWORD**) (this + 312);
                            for(m = 0; m < *(_DWORD*) (this + 276); ++m) {
                                v5 [5] = v5 [6];
                                v5 [1] = v5 [7];
                                v5 += 8;
                            }
                            *(_DWORD*) (this + 288) = *(_DWORD*) (this + 748);
                            *(_DWORD*) (this + 296) = *(_DWORD*) (this + 752);
                            *(_DWORD*) (this + 300) = *(_DWORD*) (this + 756);
                            *(_DWORD*) (this + 304) = *(_DWORD*) (this + 760);
                            *(_DWORD*) (this + 308) = *(_DWORD*) (this + 764);
                            break;
                        case 7u:
                            *(_BYTE*) (this + 23 * v12 + 361) = v14;
                            v3 = (float) v14;
                            v13 = (unsigned __int64) (v3 * *(float*) (this + 712));
                            if(v13 >= 0) {
                                if(v13 > 127)
                                    LOBYTE(v13) = 127;
                            }
                            else {
                                LOBYTE(v13) = 0;
                            }
                            *(_BYTE*) (this + 23 * v12 + 362) = v13;
                            v14 = v13;
                            break;
                        case 0xAu:
                            *(_BYTE*) (this + 23 * v12 + 358) = v14;
                            break;
                        case 0x5Bu:
                            *(_BYTE*) (this + 23 * v12 + 359) = v14;
                            break;
                        case 0x5Du:
                            *(_BYTE*) (this + 23 * v12 + 360) = v14;
                            break;
                        default:
                            goto LABEL_49;
                    }
                    break;
                case 0xC0:
                    *(_BYTE*) (this + 23 * v12 + 356) = v10;
                    break;
                default:
                    break;
            }
            LABEL_49:
            if(v11 < 0xF0u)
                sub_421BE0((HMIDIOUT*) (this + 316), v11, v10, v14);
            *(_BYTE*) (a2 + 12) = v11;
            v19 = sub_421D90((_DWORD*) (a2 + 20));
            result = a2;
            *(_DWORD*) (a2 + 4) += v19;
            return result;
        default:
            goto LABEL_26;
    }
}
// 422D1D: variable 'v14' is possibly undefined
// 422D37: variable 'v10' is possibly undefined

//----- (00423260) --------------------------------------------------------
BOOL __thiscall sub_423260(int this, int a2) {
    BOOL result; // eax
    float v3; // [esp+0h] [ebp-20h]
    int v5; // [esp+Ch] [ebp-14h]
    int i; // [esp+18h] [ebp-8h]

    result = this;
    if(!*(_DWORD*) (this + 724)) {
        for(i = 0; i < 16; ++i) {
            v3 = (float) *(unsigned __int8*) (this + 23 * i + 361);
            v5 = a2 + (unsigned __int64) (v3 * *(float*) (this + 712));
            if(v5 >= 0) {
                if(v5 > 127)
                    LOBYTE(v5) = 127;
            }
            else {
                LOBYTE(v5) = 0;
            }
            result = sub_421BE0((HMIDIOUT*) (this + 316), i - 80, 7, v5);
        }
    }
    return result;
}

//----- (0042333B) --------------------------------------------------------
int __cdecl sub_42333B(_DWORD* a1) {
    int v2; // [esp+0h] [ebp-1Ch]
    int v3; // [esp+4h] [ebp-18h]
    int v4; // [esp+8h] [ebp-14h]
    int v5; // [esp+Ch] [ebp-10h]
    int v6; // [esp+10h] [ebp-Ch]
    int v7; // [esp+14h] [ebp-8h]
    int v8; // [esp+18h] [ebp-4h]

    if(dword_6D457C)
        sub_43B4D0(dword_6D457C);
    word_69D908 = word_69D904;
    word_69D904 = sub_41D820();
    word_69D90C = 0;
    if(word_69D908 == word_69D904) {
        if((unsigned __int16) word_69D910 >= 0x1Eu) {
            word_69D90C = (unsigned __int16) word_69D910 % 8 == 0;
            if((unsigned __int16) word_69D910 >= 0x26u)
                word_69D910 = 30;
        }
        ++word_69D910;
    }
    else {
        word_69D910 = 0;
    }
    if(a1 [98] == a1 [99])
        goto LABEL_88;
    a1 [100] = a1 [98];
    v8 = a1 [98];
    if(!v8)
        goto LABEL_18;
    if(v8 == 1) {
        v7 = a1 [99];
        switch(v7) {
            case 2:
                if(sub_41BA6A())
                    return 4;
                break;
            case 4:
                return 4;
            case 5:
                return 5;
            case 6:
                if(sub_42D773(0))
                    return 4;
                break;
            case 9:
                if(sub_42523A())
                    return 4;
                break;
            case 10:
                sub_41C269();
                if(sub_4107B0())
                    return 4;
                break;
        }
        goto LABEL_87;
    }
    if(v8 != 2) {
        switch(v8) {
            case 6:
                v6 = a1 [99];
                if(v6 != 1) {
                    if(v6 == 4)
                        return 4;
                    goto LABEL_87;
                }
                a1 [99] = 0;
                break;
            case 7:
                v4 = a1 [99];
                if(v4 != 1) {
                    if(v4 == 4) {
                        sub_42AB30(0, 0);
                        return 4;
                    }
                    goto LABEL_87;
                }
                a1 [99] = 0;
                sub_42AB30(0, 0);
                break;
            case 9:
                v3 = a1 [99];
                if(v3 != 1) {
                    if(v3 == 4)
                        return 4;
                    goto LABEL_87;
                }
                a1 [99] = 0;
                break;
            case 10:
                v2 = a1 [99];
                if(v2 != 1) {
                    if(v2 == 4)
                        return 4;
                    if(v2 == 7 && sub_42D773(1))
                        return 4;
                    goto LABEL_87;
                }
                a1 [99] = 0;
                break;
            default:
                goto LABEL_87;
        }
        LABEL_18:
        a1 [99] = 1;
        (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) dword_6C6D20 + 20))(dword_6C6D20, 0);
        if(sub_43A338(0))
            return 4;
        goto LABEL_87;
    }
    v5 = a1 [99];
    if(v5 == 1)
        goto LABEL_55;
    if(v5 != 3) {
        switch(v5) {
            case 4:
                return 4;
            case 7:
                sub_41C269();
                if(sub_42D773(1))
                    return 4;
                break;
            case 8:
                sub_41C269();
                a1 [99] = 0;
                sub_42AB30(0, 0);
                a1 [99] = 1;
                (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) dword_6C6D20 + 20))(dword_6C6D20, 0);
                if(sub_43A338(1))
                    return 4;
                break;
            case 10:
                sub_41C269();
                if(sub_4107B0())
                    return 4;
                break;
        }
        goto LABEL_87;
    }
    sub_41C269();
    if(sub_41BA6A())
        return 4;
    if(a1 [99] == 1) {
        LABEL_55:
        sub_41C269();
        a1 [99] = 0;
        sub_42AB30(0, 0);
        goto LABEL_18;
    }
    a1 [99] = 2;
    LABEL_87:
    word_69D90C = 0;
    word_69D908 = 0;
    word_69D904 = 0;
    LABEL_88:
    a1 [98] = a1 [99];
    ++a1 [97];
    return 1;
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 69D910: using guessed type __int16 word_69D910;
// 6C6D20: using guessed type int dword_6C6D20;
// 6D457C: using guessed type int dword_6D457C;

//----- (00423785) --------------------------------------------------------
int sub_423785() {
    *(_BYTE*) (dword_6D4588 + 135358) = -1;
    *(_DWORD*) (dword_6D4588 + 135360) = 0;
    *(_DWORD*) (dword_6D4588 + 135352) = 0;
    *(_BYTE*) (dword_6D4588 + 135357) = -1;
    *(_BYTE*) (dword_6D4588 + 135356) = -1;
    *(_BYTE*) (dword_6D4588 + 135359) = -1;
    sub_423F3F();
    return 1;
}

//----- (00423801) --------------------------------------------------------
BOOL __stdcall sub_423801(int a1, int a2) {
    BOOL result; // eax
    int v3 [6]; // [esp+4h] [ebp-18h] BYREF

    result = 1;
    if((*(_DWORD*) (a1 + 24) & 3) != 0) {
        v3 [0] = 24;
        v3 [1] = 16;
        v3 [3] = 2;
        v3 [2] = *(_DWORD*) (a1 + 24);
        v3 [4] = -1000;
        v3 [5] = 1000;
        if((*(int(__stdcall**)(int, int, int*))(*(_DWORD*) dword_6C6D2C + 24))(dword_6C6D2C, 4, v3) < 0)
            return 0;
    }
    return result;
}
// 6C6D2C: using guessed type int dword_6C6D2C;

//----- (0042386B) --------------------------------------------------------
int sub_42386B() {
    _DWORD* v1; // [esp+4h] [ebp-4h]
    _DWORD* v2; // [esp+4h] [ebp-4h]

    *(&dword_6C6D18 + 98) = 0;
    *(&dword_6C6D18 + 99) = -1;
    *(&dword_6C6D18 + 97) = 0;
    v1 = sub_41CD40((int) sub_42333B);
    v1 [7] = &dword_6C6D18;
    v1 [2] = sub_42390A;
    v1 [3] = sub_423DDF;
    if(sub_41C860(byte_69D918, (int) v1, 0))
        return -1;
    v2 = sub_41CD40((int) sub_423785);
    v2 [7] = &dword_6C6D18;
    sub_41C940((__int16*) byte_69D918, (int) v2, 14);
    return 0;
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0042390A) --------------------------------------------------------
int __cdecl sub_42390A(int a1) {
    void* v2; // eax
    int v3; // [esp+0h] [ebp-20h]
    int i; // [esp+10h] [ebp-10h]

    for(i = 0; i < 16; ++i)
        *(_DWORD*) (a1 + 4 * i + 444) = 0;
    dword_69D900 = a1 + 444;
    if(sub_424375((int**) a1, 0, "th06e_IN.dat"))
        return -1;
    dword_4760DC = (int) sub_41E290("spellcards.eng", 0);
    sub_435010((_DWORD**) dword_6D4588, 0, "data/title/th06logo.jpg");
    sub_435300((_DWORD*) dword_6D4588, 0, 0, 0, 0, 0);
    if((*(int(__stdcall**)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 60))(
        dword_6C6D20,
        0,
        0,
        0,
        0) < 0)
        (*(void(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8);
    sub_435300((_DWORD*) dword_6D4588, 0, 0, 0, 0, 0);
    if((*(int(__stdcall**)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 60))(
        dword_6C6D20,
        0,
        0,
        0,
        0) < 0)
        (*(void(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8);
    sub_435270((_DWORD**) dword_6D4588, 0);
    *(_DWORD*) (a1 + 1024) = timeGetTime();
    sub_423B14(a1);
    v2 = operator new(0x300u);
    if(v2)
        v3 = sub_421DF0((int) v2);
    else
        v3 = 0;
    *(_DWORD*) (a1 + 432) = v3;
    word_69D8F8 = timeGetTime();
    dword_69D8FC = 0;
    sub_431080(dword_6D3F50);
    if(sub_431DC0((_DWORD*) dword_6D4588, 0, "data/text.anm", 1792))
        return -1;
    if(sub_4012C0()) {
        sub_41E4D0((int) byte_69D998, aError_8);
        return -1;
    }
    else {
        *(_DWORD*) (a1 + 408) = 0;
        sub_431660(dword_6D4588);
        sub_41F008();
        sub_4242F3((int**) a1, 0);
        if(sub_424375((int**) &dword_6C6D18, 1, "th06e_MD.dat"))
            return -1;
        else
            return 0;
    }
}
// 4760DC: using guessed type int dword_4760DC;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 69D8FC: using guessed type int dword_69D8FC;
// 69D900: using guessed type int dword_69D900;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6D20: using guessed type int dword_6C6D20;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00423B14) --------------------------------------------------------
int __cdecl sub_423B14(int a1) {
    HINSTANCE hinst; // [esp+0h] [ebp-4h]

    hinst = (HINSTANCE) GetWindowLongA(*(HWND*) (a1 + 68), -6);
    if(((*(_DWORD*) (a1 + 328) >> 11) & 1) != 0)
        return -1;
    if(DirectInput8Create(hinst, 0x800u, &riidltf, (LPVOID*) (a1 + 12), 0) >= 0) {
        if((*(int(__stdcall**)(_DWORD, void*, int, _DWORD))(**(_DWORD**) (a1 + 12) + 12))(
            *(_DWORD*) (a1 + 12),
            &unk_46FE20,
            a1 + 16,
            0) >= 0) {
            if((*(int(__stdcall**)(_DWORD, void*))(**(_DWORD**) (a1 + 16) + 44))(*(_DWORD*) (a1 + 16), &unk_46D004) >= 0) {
                if((*(int(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**) (a1 + 16) + 52))(
                    *(_DWORD*) (a1 + 16),
                    *(_DWORD*) (a1 + 68),
                    22) >= 0) {
                    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 16) + 28))(*(_DWORD*) (a1 + 16));
                    sub_41E4D0((int) byte_69D998, aDirectinput_0);
                    (*(void(__stdcall**)(_DWORD, int, BOOL(__stdcall*)(int, int), _DWORD, int))(**(_DWORD**) (a1 + 12) + 16))(
                        *(_DWORD*) (a1 + 12),
                        4,
                        sub_423DA0,
                        0,
                        1);
                    if(*(_DWORD*) (a1 + 20)) {
                        (*(void(__stdcall**)(_DWORD, void*))(**(_DWORD**) (a1 + 20) + 44))(*(_DWORD*) (a1 + 20), &unk_46CDFC);
                        (*(void(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**) (a1 + 20) + 52))(
                            *(_DWORD*) (a1 + 20),
                            *(_DWORD*) (a1 + 68),
                            5);
                        dword_6C6D30 = 44;
                        (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**) (a1 + 20) + 12))(*(_DWORD*) (a1 + 20), &dword_6C6D30);
                        (*(void(__stdcall**)(_DWORD, BOOL(__stdcall*)(int, int), _DWORD, _DWORD))(**(_DWORD**) (a1 + 20) + 16))(
                            *(_DWORD*) (a1 + 20),
                            sub_423801,
                            0,
                            0);
                        sub_41E4D0((int) byte_69D998, (char*) &byte_46B64C);
                    }
                    return 0;
                }
                else {
                    if(*(_DWORD*) (a1 + 16)) {
                        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 16) + 8))(*(_DWORD*) (a1 + 16));
                        *(_DWORD*) (a1 + 16) = 0;
                    }
                    if(*(_DWORD*) (a1 + 12)) {
                        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 12) + 8))(*(_DWORD*) (a1 + 12));
                        *(_DWORD*) (a1 + 12) = 0;
                    }
                    sub_41E4D0((int) byte_69D998, aDirectinputSet_0);
                    return -1;
                }
            }
            else {
                if(*(_DWORD*) (a1 + 16)) {
                    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 16) + 8))(*(_DWORD*) (a1 + 16));
                    *(_DWORD*) (a1 + 16) = 0;
                }
                if(*(_DWORD*) (a1 + 12)) {
                    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 12) + 8))(*(_DWORD*) (a1 + 12));
                    *(_DWORD*) (a1 + 12) = 0;
                }
                sub_41E4D0((int) byte_69D998, aDirectinputSet);
                return -1;
            }
        }
        else {
            if(*(_DWORD*) (a1 + 12)) {
                (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 12) + 8))(*(_DWORD*) (a1 + 12));
                *(_DWORD*) (a1 + 12) = 0;
            }
            sub_41E4D0((int) byte_69D998, aDirectinput);
            return -1;
        }
    }
    else {
        *(_DWORD*) (a1 + 12) = 0;
        sub_41E4D0((int) byte_69D998, aDirectinput);
        return -1;
    }
}
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D30: using guessed type int dword_6C6D30;

//----- (00423DA0) --------------------------------------------------------
BOOL __stdcall sub_423DA0(int a1, int a2) {
    return !dword_6C6D2C
        && (*(int(__stdcall**)(int, int, int*, _DWORD))(*(_DWORD*) dword_6C6D24 + 12))(
            dword_6C6D24,
            a1 + 4,
            &dword_6C6D2C,
            0) < 0;
}
// 6C6D24: using guessed type int dword_6C6D24;
// 6C6D2C: using guessed type int dword_6C6D2C;

//----- (00423DDF) --------------------------------------------------------
int __cdecl sub_423DDF(int a1) {
    void* Block; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    sub_4240F0((_DWORD**) dword_6D4588);
    for(i = 0; i < 16; ++i)
        sub_4242F3((int**) a1, i);
    sub_432030(dword_6D4588, 0);
    sub_401500();
    sub_430F80((int) dword_6D3F50);
    if(*(_DWORD*) (a1 + 432)) {
        sub_4224E0(*(_DWORD*) (a1 + 432));
        Block = *(void**) (a1 + 432);
        if(Block) {
            sub_421F50((int) Block);
            j__free(Block);
        }
        *(_DWORD*) (a1 + 432) = 0;
    }
    sub_42AB30(0, 0);
    sub_41F02B();
    if(*(_DWORD*) (a1 + 16))
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 16) + 32))(*(_DWORD*) (a1 + 16));
    if(*(_DWORD*) (a1 + 16)) {
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 16) + 8))(*(_DWORD*) (a1 + 16));
        *(_DWORD*) (a1 + 16) = 0;
    }
    if(*(_DWORD*) (a1 + 20))
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 20) + 32))(*(_DWORD*) (a1 + 20));
    if(*(_DWORD*) (a1 + 20)) {
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 20) + 8))(*(_DWORD*) (a1 + 20));
        *(_DWORD*) (a1 + 20) = 0;
    }
    if(*(_DWORD*) (a1 + 12)) {
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 12) + 8))(*(_DWORD*) (a1 + 12));
        *(_DWORD*) (a1 + 12) = 0;
    }
    return 0;
}
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00423F3F) --------------------------------------------------------
void sub_423F3F() {
    int v0; // eax
    int v1; // edx
    double v2; // st7
    float v3; // [esp+8h] [ebp-34h]
    float v4; // [esp+14h] [ebp-28h]
    float v5 [3]; // [esp+20h] [ebp-1Ch] BYREF
    float v6; // [esp+2Ch] [ebp-10h]
    float v7; // [esp+30h] [ebp-Ch]
    float v8; // [esp+34h] [ebp-8h]
    DWORD Time; // [esp+38h] [ebp-4h]

    if((dword_6C6D10 & 1) == 0) {
        v0 = dword_6C6D10;
        LOBYTE(v0) = dword_6C6D10 | 1;
        dword_6C6D10 = v0;
        dword_6C6D0C = timeGetTime();
    }
    Time = timeGetTime();
    dword_6C6D08 += (unsigned __int8) byte_6C6E4B + 1;
    if(Time - dword_6C6D0C >= 0x1F4) {
        v4 = (float) (Time - dword_6C6D0C);
        v6 = v4 / 1000.0;
        v3 = (float) (unsigned int) dword_6C6D08;
        v7 = v3 / v6;
        dword_6C6D0C = Time;
        dword_6C6D08 = 0;
        sprintf(Buffer, "%.02ffps", v7);
        if(byte_69D4C1) {
            v8 = 60.0 / *(float*) &dword_6C6EC4;
            flt_6C6ED0 = flt_6C6ED0 + v8;
            if(v8 * 0.89999998 >= v7) {
                if(v8 * 0.69999999 >= v7) {
                    if(v8 * 0.5 >= v7)
                        v2 = v8 * 0.5 + flt_6C6ECC;
                    else
                        v2 = v8 * 0.60000002 + flt_6C6ECC;
                    flt_6C6ECC = v2;
                }
                else {
                    flt_6C6ECC = v8 * 0.80000001 + flt_6C6ECC;
                }
            }
            else {
                flt_6C6ECC = flt_6C6ECC + v8;
            }
        }
    }
    if(!dword_6C6EB4) {
        v5 [0] = 512.0;
        v5 [1] = 464.0;
        v5 [2] = 0.0;
        sub_401530(dword_47B900, v1, v5, Buffer);
    }
}
// 4240E9: variable 'v1' is possibly undefined
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 69D4C1: using guessed type char byte_69D4C1;
// 6C6D08: using guessed type int dword_6C6D08;
// 6C6D0C: using guessed type int dword_6C6D0C;
// 6C6D10: using guessed type int dword_6C6D10;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6C6EB4: using guessed type int dword_6C6EB4;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6C6ECC: using guessed type float flt_6C6ECC;
// 6C6ED0: using guessed type float flt_6C6ED0;

//----- (004240F0) --------------------------------------------------------
_DWORD** __thiscall sub_4240F0(_DWORD** this) {
    _DWORD** result; // eax

    result = this;
    if(this [33841]) {
        (*(void(__stdcall**)(_DWORD*))(*this [33841] + 8))(this [33841]);
        result = this;
        this [33841] = 0;
    }
    return result;
}

//----- (00424127) --------------------------------------------------------
_DWORD* __thiscall sub_424127(_DWORD* this) {
    _DWORD* result; // eax

    this [2] = 0;
    *this = -1;
    result = this;
    *((float*) this + 1) = 0.0;
    return result;
}

//----- (00424145) --------------------------------------------------------
void __thiscall sub_424145(float* this, int a2) {
    float v2; // [esp+0h] [ebp-8h]

    if(*(float*) &dword_6C6EC4 <= 0.99000001) {
        if(a2 >= 0) {
            *this = this [2];
            v2 = (float) a2;
            for(this [1] = flt_6C6EC0 * v2 + this [1]; this [1] >= 1.0; this [1] = this [1] - 1.0)
                ++* ((_DWORD*) this + 2);
        }
        else {
            sub_4241E5((int) this, -a2);
        }
    }
    else {
        *((_DWORD*) this + 2) += a2;
    }
}
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6C6EC4: using guessed type int dword_6C6EC4;

//----- (004241E5) --------------------------------------------------------
void __thiscall sub_4241E5(int this, int a2) {
    float v2; // [esp+0h] [ebp-8h]

    if(*(float*) &dword_6C6EC4 <= 0.99000001) {
        if(a2 >= 0) {
            *(_DWORD*) this = *(_DWORD*) (this + 8);
            v2 = (float) a2;
            for(*(float*) (this + 4) = *(float*) (this + 4) - flt_6C6EC0 * v2;
                *(float*) (this + 4) < 0.0;
                *(float*) (this + 4) = *(float*) (this + 4) + 1.0) {
                --* (_DWORD*) (this + 8);
            }
        }
        else {
            sub_424145((float*) this, -a2);
        }
    }
    else {
        *(_DWORD*) (this + 8) -= a2;
    }
}
// 6C6EC0: using guessed type float flt_6C6EC0;
// 6C6EC4: using guessed type int dword_6C6EC4;

//----- (00424285) --------------------------------------------------------
void __thiscall sub_424285(float* this, _DWORD* a2, float* a3) {
    if(this [107] > 0.99000001) {
        ++* a2;
    }
    else {
        *a3 = *a3 + this [106];
        if(*a3 >= 1.0) {
            ++* a2;
            *a3 = *a3 - 1.0;
        }
    }
}

//----- (004242F3) --------------------------------------------------------
int __thiscall sub_4242F3(int** this, int a2) {
    int result; // eax
    int* Block; // [esp+Ch] [ebp-4h]

    result = a2;
    if(this [a2 + 111]) {
        sub_43C8D0(this [a2 + 111]);
        Block = this [a2 + 111];
        if(Block) {
            sub_43CA80(Block);
            j__free(Block);
        }
        result = a2;
        this [a2 + 111] = 0;
    }
    return result;
}

//----- (00424375) --------------------------------------------------------
int __thiscall sub_424375(int** this, int a2, LPCSTR lpFileName) {
    _DWORD* v3; // eax
    CHAR v4; // cl
    int** v6; // [esp+Ch] [ebp-C8h]
    LPCSTR v7; // [esp+10h] [ebp-C4h]
    int* v8; // [esp+14h] [ebp-C0h]
    int* Block; // [esp+34h] [ebp-A0h]
    char Buffer [128]; // [esp+40h] [ebp-94h] BYREF
    unsigned int v12; // [esp+C0h] [ebp-14h]
    int v13; // [esp+C4h] [ebp-10h]
    int v14; // [esp+D0h] [ebp-4h]
    unsigned int retaddr; // [esp+D8h] [ebp+4h]

    v12 = retaddr ^ dword_47A630;
    if(!this [a2 + 111] || strcmp(lpFileName, (const char*) &this [8 * a2 + 127])) {
        sub_4242F3(this, a2);
        v3 = operator new(0x14u);
        v14 = 0;
        if(v3)
            v8 = sub_43C770(v3);
        else
            v8 = 0;
        v14 = -1;
        this [a2 + 111] = v8;
        sub_42F6C4();
        if(sub_43CA90(this [a2 + 111], lpFileName)) {
            v7 = lpFileName;
            v6 = &this [8 * a2 + 127];
            do {
                v4 = *v7;
                *(_BYTE*) v6 = *v7++;
                v6 = (int**) ((char*) v6 + 1);
            }
            while(v4);
            sprintf(Buffer, "ver%.4x.dat", 258);
            v13 = sub_43C920(this [a2 + 111], Buffer);
            if(v13 < 0) {
                sub_41E620((int) byte_69D998, aError_9);
                return 1;
            }
        }
        else {
            Block = this [a2 + 111];
            if(Block) {
                sub_43CA80(Block);
                j__free(Block);
            }
            this [a2 + 111] = 0;
            this [a2 + 111] = 0;
        }
    }
    return 0;
}
// 47A630: using guessed type int dword_47A630;
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (0042464D) --------------------------------------------------------
int __thiscall sub_42464D(_DWORD* this, char* FileName) {
    int v2; // eax
    void* v3; // eax
    FILE* v4; // eax
    FILE* v5; // eax
    void* Block; // [esp+14h] [ebp-4h]

    memset(&word_6C6E2C, 0, 0x38u);
    v2 = dword_6C6E60;
    LOBYTE(v2) = dword_6C6E60 | 1;
    dword_6C6E60 = v2;
    v3 = sub_41E290(FileName, 1);
    Block = v3;
    if(v3) {
        qmemcpy(&word_6C6E2C, v3, 0x38u);
        if((unsigned __int8) byte_6C6E44 >= 5u
           || (unsigned __int8) byte_6C6E45 >= 4u
           || (unsigned __int8) byte_6C6E46 >= 2u
           || (unsigned __int8) byte_6C6E47 >= 3u
           || (unsigned __int8) byte_6C6E49 >= 5u
           || (unsigned __int8) byte_6C6E48 >= 2u
           || (unsigned __int8) byte_6C6E4A >= 2u
           || (unsigned __int8) byte_6C6E4B >= 3u
           || dword_6C6E40 != 258
           || dword_69D914 != 56) {
            byte_6C6E44 = 2;
            byte_6C6E45 = 3;
            byte_6C6E46 = -1;
            dword_6C6E40 = 258;
            word_6C6E4C = 600;
            word_6C6E4E = 600;
            v5 = fopen("bgm/th06_01.wav", "rb");
            if(v5) {
                byte_6C6E47 = 1;
                fclose(v5);
            }
            else {
                byte_6C6E47 = 2;
                sub_42F6C4();
            }
            byte_6C6E48 = 1;
            byte_6C6E49 = 1;
            byte_6C6E4A = 0;
            byte_6C6E4B = 0;
            *(_DWORD*) &word_6C6E2C = *(_DWORD*) &word_4765A0;
            *((_DWORD*) &word_6C6E2C + 1) = *((_DWORD*) &word_4765A0 + 1);
            *((_DWORD*) &word_6C6E2C + 2) = *((_DWORD*) &word_4765A0 + 2);
            *((_DWORD*) &word_6C6E2C + 3) = *((_DWORD*) &word_4765A0 + 3);
            *(&word_6C6E2C + 8) = *(&word_4765A0 + 8);
            dword_6C6E60 = 1;
            sub_41E4D0((int) byte_69D998, (char*) &byte_46B9A8);
        }
        *(_DWORD*) &word_4765A0 = *(_DWORD*) &word_6C6E2C;
        *((_DWORD*) &word_4765A0 + 1) = *((_DWORD*) &word_6C6E2C + 1);
        *((_DWORD*) &word_4765A0 + 2) = *((_DWORD*) &word_6C6E2C + 2);
        *((_DWORD*) &word_4765A0 + 3) = *((_DWORD*) &word_6C6E2C + 3);
        *(&word_4765A0 + 8) = *(&word_6C6E2C + 8);
        free(Block);
    }
    else {
        byte_6C6E44 = 2;
        byte_6C6E45 = 3;
        byte_6C6E46 = -1;
        dword_6C6E40 = 258;
        word_6C6E4C = 600;
        word_6C6E4E = 600;
        v4 = fopen("bgm/th06_01.wav", "rb");
        if(v4) {
            byte_6C6E47 = 1;
            fclose(v4);
        }
        else {
            byte_6C6E47 = 2;
            sub_42F6C4();
        }
        byte_6C6E48 = 1;
        byte_6C6E49 = 1;
        byte_6C6E4A = 0;
        byte_6C6E4B = 0;
        *(_DWORD*) &word_6C6E2C = *(_DWORD*) &word_4765A0;
        *((_DWORD*) &word_6C6E2C + 1) = *((_DWORD*) &word_4765A0 + 1);
        *((_DWORD*) &word_6C6E2C + 2) = *((_DWORD*) &word_4765A0 + 2);
        *((_DWORD*) &word_6C6E2C + 3) = *((_DWORD*) &word_4765A0 + 3);
        *(&word_6C6E2C + 8) = *(&word_4765A0 + 8);
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B9E0);
    }
    if(((this [82] >> 1) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B988);
    if(((this [82] >> 10) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B96C);
    if(((this [82] >> 2) & 1) != 0)
        sub_41E4D0((int) byte_69D998, a16bit);
    if((this [82] >> 4) & 1 | (this [82] >> 3) & 1)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B920);
    if(((this [82] >> 4) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B8F8);
    if(((this [82] >> 5) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B8D4);
    if(((this [82] >> 6) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B8B8);
    if(((this [82] >> 7) & 1) != 0) {
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B898);
        this [104] = 0;
    }
    if(((this [82] >> 8) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B878);
    if(((this [82] >> 8) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B858);
    if(((this [82] >> 9) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B830);
    if(((this [82] >> 11) & 1) != 0)
        sub_41E4D0((int) byte_69D998, (char*) &byte_46B7F8);
    if(!sub_41E460(FileName, &word_6C6E2C, 0x38u))
        return 0;
    sub_41E620((int) byte_69D998, (char*) &byte_46B7D8, FileName);
    sub_41E620((int) byte_69D998, (char*) &byte_46B780);
    return -1;
}
// 4765A0: using guessed type __int16 word_4765A0;
// 69D914: using guessed type int dword_69D914;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6E2C: using guessed type __int16 word_6C6E2C;
// 6C6E40: using guessed type int dword_6C6E40;
// 6C6E44: using guessed type char byte_6C6E44;
// 6C6E45: using guessed type char byte_6C6E45;
// 6C6E46: using guessed type char byte_6C6E46;
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6E48: using guessed type char byte_6C6E48;
// 6C6E49: using guessed type char byte_6C6E49;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6C6E4C: using guessed type __int16 word_6C6E4C;
// 6C6E4E: using guessed type __int16 word_6C6E4E;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00424AAC) --------------------------------------------------------
int __stdcall sub_424AAC(int a1, char* Str) {
    if(byte_6C6E47 != 2)
        return 1;
    if(dword_6C6EC8)
        sub_421FF0((void**) dword_6C6EC8, a1, Str);
    return 0;
}
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6EC8: using guessed type int dword_6C6EC8;

//----- (00424AE4) --------------------------------------------------------
int __stdcall sub_424AE4(int a1) {
    UINT* v2; // [esp+4h] [ebp-4h]

    if(byte_6C6E47 != 2)
        return 1;
    if(dword_6C6EC8) {
        v2 = (UINT*) dword_6C6EC8;
        sub_4224E0(dword_6C6EC8);
        sub_422140((int) v2, a1);
        sub_422490(v2);
    }
    return 0;
}
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6EC8: using guessed type int dword_6C6EC8;

//----- (00424B2F) --------------------------------------------------------
int __stdcall sub_424B2F(int a1) {
    if(byte_6C6E47 == 2 || byte_6C6E47 == 1)
        return 0;
    else
        return -1;
}
// 6C6E47: using guessed type char byte_6C6E47;

//----- (00424B5D) --------------------------------------------------------
int __userpurge sub_424B5D(int a1, char* a2) {
    char v2; // cl
    char v3; // cl
    char* v5; // [esp+8h] [ebp-228h]
    char* v6; // [esp+Ch] [ebp-224h]
    char* v7; // [esp+18h] [ebp-218h]
    char* v8; // [esp+1Ch] [ebp-214h]
    void** v9; // [esp+24h] [ebp-20Ch]
    char Str [256]; // [esp+28h] [ebp-208h] BYREF
    char v11 [256]; // [esp+128h] [ebp-108h] BYREF
    unsigned int v12; // [esp+228h] [ebp-8h]
    char* v13; // [esp+22Ch] [ebp-4h]
    unsigned int retaddr; // [esp+234h] [ebp+4h]

    v12 = retaddr ^ dword_47A630;
    if(byte_6C6E47 == 2) {
        if(dword_6C6EC8) {
            v9 = (void**) dword_6C6EC8;
            sub_4224E0(dword_6C6EC8);
            sub_422380(v9, a2);
            sub_422490((UINT*) v9);
        }
    }
    else {
        if(byte_6C6E47 != 1)
            return -1;
        v8 = a2;
        v7 = Str;
        do {
            v2 = *v8;
            *v7++ = *v8++;
        }
        while(v2);
        v6 = a2;
        v5 = v11;
        do {
            v3 = *v6;
            *v5++ = *v6++;
        }
        while(v3);
        v13 = strrchr(Str, 46);
        v13 [1] = 119;
        v13 [2] = 97;
        v13 [3] = 118;
        v13 = strrchr(v11, 46);
        v13 [1] = 112;
        v13 [2] = 111;
        v13 [3] = 115;
        sub_430A50((int) dword_6D3F50, a1, Str);
        if(sub_430E10(dword_6D3F50, v11) >= 0)
            sub_430EC0((int) dword_6D3F50, a1, 1);
        else
            sub_430EC0((int) dword_6D3F50, a1, 0);
    }
    return 0;
}
// 47A630: using guessed type int dword_47A630;
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6EC8: using guessed type int dword_6C6EC8;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00424D38) --------------------------------------------------------
int sub_424D38() {
    if(byte_6C6E47 == 2) {
        if(dword_6C6EC8)
            sub_4224E0(dword_6C6EC8);
    }
    else {
        if(byte_6C6E47 != 1)
            return -1;
        sub_430F80((int) dword_6D3F50);
    }
    return 0;
}
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6EC8: using guessed type int dword_6C6EC8;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00424D82) --------------------------------------------------------
int __thiscall sub_424D82(float* this, float a2) {
    float v3; // [esp+0h] [ebp-14h]

    if(byte_6C6E47 == 2) {
        if(dword_6C6EC8)
            sub_422630((_DWORD*) dword_6C6EC8, (unsigned __int64) (1000.0 * a2));
    }
    else {
        if(byte_6C6E47 != 1)
            return -1;
        if(this [106] == 0.0 || this [106] > 1.0) {
            sub_424E41(dword_6D3F50, a2);
        }
        else {
            v3 = a2 / this [106];
            sub_424E41(dword_6D3F50, v3);
        }
    }
    return 0;
}
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6EC8: using guessed type int dword_6C6EC8;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00424E41) --------------------------------------------------------
_DWORD* __thiscall sub_424E41(_DWORD* this, float a2) {
    _DWORD* result; // eax
    _DWORD* v3; // [esp+4h] [ebp-4h]

    result = this;
    if(this [395]) {
        v3 = (_DWORD*) this [395];
        v3 [7] = 1;
        v3 [5] = (unsigned __int64) (a2 * 60.0);
        result = v3;
        v3 [6] = v3 [5];
    }
    return result;
}

//----- (00424E8F) --------------------------------------------------------
int __thiscall sub_424E8F(int* this) {
    if(this [2] >= 8)
        this [3] = 1;
    return 0;
}

//----- (00424EAD) --------------------------------------------------------
int __usercall sub_424EAD(_DWORD* a1, int a2) {
    char* v2; // esi
    int v3; // edi
    int v4; // eax
    int v5; // eax
    float v7; // [esp+8h] [ebp-74h]
    float v8; // [esp+10h] [ebp-6Ch]
    int i; // [esp+74h] [ebp-8h]

    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)) {
        if((int)--a1 [4] >= 0) {
            if(a1 [6] > a1 [4])
                a1 [6] = a1 [4];
        }
        else {
            a1 [4] = a1 [7] - 1;
            a1 [6] = a1 [7] - 10;
        }
    }
    if((word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)) {
        if(++a1 [4] < a1 [7]) {
            if(a1 [6] <= a1 [4] - 10)
                a1 [6] = a1 [4] - 9;
        }
        else {
            a1 [4] = 0;
            a1 [6] = 0;
        }
    }
    if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
        a1 [5] = a1 [4];
        sub_424B5D(a2, (char*) (a1 [8] + 626 * a1 [5]));
        for(i = 0; i < 16; ++i) {
            v2 = (char*) (626 * a1 [5] + a1 [8] + 66 * (i / 2) + 98);
            v3 = a1 [68 * i + 2301];
            if(i % 2)
                *(_DWORD*) (v3 + 4) = -1015611392;
            v4 = a1 [68 * i + 2285];
            LOBYTE(v4) = v4 | 2;
            a1 [68 * i + 2285] = v4;
            sub_434B60((_DWORD*) dword_6D4588, (int) &a1 [68 * i + 2253], 0xFFE0C0u, 0x300000u, v2);
            *(_DWORD*) (v3 + 4) = 0;
            v8 = (float) (i % 2);
            *(float*) &a1 [68 * i + 2289] = v8 * 248.0 + 96.0;
            v7 = (float) (16 * (i / 2));
            *(float*) &a1 [68 * i + 2290] = v7 + 320.0;
            *(float*) &a1 [68 * i + 2291] = 0.0;
            v5 = a1 [68 * i + 2285];
            BYTE1(v5) |= 3u;
            a1 [68 * i + 2285] = v5;
        }
    }
    if((word_69D904 & 0xA) == 0 || (word_69D904 & 0xA) == (word_69D908 & 0xA))
        return 0;
    dword_6C6EA4 = 1;
    return 1;
}
// 47A630: using guessed type int dword_47A630;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (0042523A) --------------------------------------------------------
int sub_42523A() {
    int v0; // eax

    if((dword_6CA624 & 1) == 0) {
        v0 = dword_6CA624;
        LOBYTE(v0) = dword_6CA624 | 1;
        dword_6CA624 = v0;
        sub_425318(dword_6C71F0);
    }
    memset(dword_6C71F0, 0, 0x3434u);
    dword_6C71F0 [0] = (int) sub_41CD40((int) sub_4253DD);
    *(_DWORD*) (dword_6C71F0 [0] + 28) = dword_6C71F0;
    *(_DWORD*) (dword_6C71F0 [0] + 8) = sub_42564C;
    *(_DWORD*) (dword_6C71F0 [0] + 12) = sub_425D97;
    if(sub_41C860(byte_69D918, dword_6C71F0 [0], 2))
        return -1;
    dword_6C71F0 [1] = (int) sub_41CD40((int) sub_42545A);
    *(_DWORD*) (dword_6C71F0 [1] + 28) = dword_6C71F0;
    sub_41C940((__int16*) byte_69D918, dword_6C71F0 [1], 0);
    return 0;
}
// 6C71F0: using guessed type int dword_6C71F0[214];
// 6CA624: using guessed type int dword_6CA624;

//----- (00425318) --------------------------------------------------------
void* __thiscall sub_425318(void* this) {
    int k; // [esp+8h] [ebp-54h]
    int v4; // [esp+10h] [ebp-4Ch]
    int j; // [esp+24h] [ebp-38h]
    int v6; // [esp+2Ch] [ebp-30h]
    int i; // [esp+40h] [ebp-1Ch]
    int v8; // [esp+48h] [ebp-14h]

    v8 = 1;
    for(i = (int) this + 36; --v8 >= 0; i += 272)
        sub_403720(i);
    v6 = 32;
    for(j = (int) this + 308; --v6 >= 0; j += 272)
        sub_403720(j);
    v4 = 16;
    for(k = (int) this + 9012; --v4 >= 0; k += 272)
        sub_403720(k);
    memset(this, 0, 0x3434u);
    return this;
}

//----- (004253DD) --------------------------------------------------------
int __usercall sub_4253DD(int a1, int* a2) {
    int v3; // [esp+0h] [ebp-8h]
    int v4; // [esp+4h] [ebp-4h]

    v4 = a2 [3];
    while(1) {
        v3 = a2 [3];
        if(v3)
            break;
        if(!sub_424E8F(a2))
            goto LABEL_9;
    }
    if(v3 == 1 && sub_424EAD(a2, a1))
        return 0;
    LABEL_9:
    if(v4 == a2 [3])
        ++a2 [2];
    else
        a2 [2] = 0;
    sub_433960((int*) dword_6D4588, (int) (a2 + 9));
    return 1;
}

//----- (0042545A) --------------------------------------------------------
int __cdecl sub_42545A(int a1) {
    int v1; // edx
    float v3; // [esp+8h] [ebp-20h]
    float v4 [3]; // [esp+14h] [ebp-14h] BYREF
    char v5 [4]; // [esp+20h] [ebp-8h] BYREF
    int i; // [esp+24h] [ebp-4h]

    v5 [0] = 127;
    v5 [1] = 0;
    *(_DWORD*) (dword_6D4588 + 135352) = 0;
    sub_435300((_DWORD*) dword_6D4588, 0, 0, 0, 0, 0);
    sub_432AD0((void*) dword_6D4588, a1 + 36);
    for(i = *(_DWORD*) (a1 + 24); i < *(_DWORD*) (a1 + 24) + 10; ++i) {
        if(*(_DWORD*) (a1 + 16) == i) {
            *(_DWORD*) (a1 + 272 * i + 432) = -1;
            dword_481B24 = -1;
        }
        else {
            *(_DWORD*) (a1 + 272 * i + 432) = -528449408;
            dword_481B24 = -528449408;
        }
        *(float*) (a1 + 272 * i + 452) = 93.0;
        v3 = (float) (18 * (i + 1 - *(_DWORD*) (a1 + 24)));
        *(float*) (a1 + 272 * i + 456) = v3 + 104.0 - 20.0;
        *(float*) (a1 + 272 * i + 460) = 0.0;
        sub_432AD0((void*) dword_6D4588, a1 + 272 * i + 308);
        v4 [0] = *(float*) (a1 + 272 * i + 452);
        v4 [1] = *(float*) (a1 + 272 * i + 456);
        v4 [2] = *(float*) (a1 + 272 * i + 460);
        v4 [0] = v4 [0] - 60.0;
        if(*(_DWORD*) (a1 + 16) == i)
            sub_401530(dword_47B900, v1, v4, v5);
        v4 [0] = v4 [0] + 15.0;
        sub_401650(dword_47B900, v4, "%2d.", i + 1);
    }
    for(i = 0; i < 16; ++i)
        sub_432AD0((void*) dword_6D4588, a1 + 272 * i + 9012);
    dword_481B24 = -1;
    return 1;
}
// 4255D2: variable 'v1' is possibly undefined
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 42545A: using guessed type float var_14[3];

//----- (0042564C) --------------------------------------------------------
int __cdecl sub_42564C(int a1) {
    _WORD* v2; // eax
    _WORD* v3; // edi
    int v4; // eax
    char* v5; // esi
    int v6; // edi
    int v7; // eax
    int v8; // eax
    float v9; // [esp+8h] [ebp-B0h]
    float v10; // [esp+10h] [ebp-A8h]
    float v11; // [esp+28h] [ebp-90h]
    _WORD* v12; // [esp+30h] [ebp-88h]
    int* v13; // [esp+34h] [ebp-84h]
    int* v14; // [esp+3Ch] [ebp-7Ch]
    _WORD* i; // [esp+44h] [ebp-74h]
    int v16; // [esp+4Ch] [ebp-6Ch]
    int* v17; // [esp+50h] [ebp-68h]
    _BYTE* Block; // [esp+A4h] [ebp-14h]
    int v19; // [esp+A8h] [ebp-10h]
    int v20; // [esp+A8h] [ebp-10h]
    int v21; // [esp+A8h] [ebp-10h]
    _BYTE* v22; // [esp+ACh] [ebp-Ch]
    int j; // [esp+B0h] [ebp-8h]
    int v24; // [esp+B4h] [ebp-4h]
    int k; // [esp+B4h] [ebp-4h]
    int m; // [esp+B4h] [ebp-4h]

    if(sub_435010((_DWORD**) dword_6D4588, 0, "data/result/music.jpg"))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 41, "data/music00.anm", 256))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 42, "data/music01.anm", 257))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 43, "data/music02.anm", 273))
        return -1;
    v17 = (int*) dword_6D4588;
    *(_WORD*) (a1 + 216) = 256;
    sub_432430(v17, (_DWORD*) (a1 + 36), v17 [29517]);
    *(_DWORD*) (a1 + 8) = 0;
    v22 = sub_41E290("data/musiccmt.txt", 0);
    Block = v22;
    if(!v22)
        return -1;
    v2 = operator new(0x4E40u);
    if(v2) {
        v16 = 32;
        for(i = v2; --v16 >= 0; i += 313) {
            memset(i, 0, 0x270u);
            i [312] = 0;
        }
        v12 = v2;
    }
    else {
        v12 = 0;
    }
    *(_DWORD*) (a1 + 32) = v12;
    v24 = -1;
    while(v22 - Block < dword_69D914) {
        if(*v22 == 64) {
            ++v22;
            ++v24;
            v19 = 0;
            while(*v22 != 10 && *v22 != 13) {
                *(_BYTE*) (*(_DWORD*) (a1 + 32) + 626 * v24 + v19++) = *v22++;
                if(v22 - Block >= dword_69D914)
                    goto LABEL_53;
            }
            while(*v22 == 10 || *v22 == 13) {
                if(++v22 - Block >= dword_69D914)
                    goto LABEL_53;
            }
            v20 = 0;
            while(*v22 != 10 && *v22 != 13) {
                *(_BYTE*) (*(_DWORD*) (a1 + 32) + 626 * v24 + v20++ + 64) = *v22++;
                if(v22 - Block >= dword_69D914)
                    goto LABEL_53;
            }
            while(*v22 == 10 && *v22 == 13) {
                if(++v22 - Block >= dword_69D914)
                    goto LABEL_53;
            }
            for(j = 0; j < 8 && *v22 != 64; ++j) {
                v3 = (_WORD*) (626 * v24 + *(_DWORD*) (a1 + 32) + 66 * j + 98);
                memset(v3, 0, 0x40u);
                v3 [32] = 0;
                v21 = 0;
                while(*v22 != 10 && *v22 != 13) {
                    *(_BYTE*) (66 * j + 626 * v24 + *(_DWORD*) (a1 + 32) + v21++ + 98) = *v22++;
                    if(v22 - Block >= dword_69D914)
                        goto LABEL_53;
                }
                while(*v22 == 10 || *v22 == 13) {
                    if(++v22 - Block >= dword_69D914)
                        goto LABEL_53;
                }
            }
        }
        else {
            ++v22;
        }
    }
    LABEL_53:
    *(_DWORD*) (a1 + 28) = v24 + 1;
    for(k = 0; k < *(_DWORD*) (a1 + 28); ++k) {
        v14 = (int*) dword_6D4588;
        sub_403580((_DWORD*) (a1 + 272 * k + 308));
        sub_4323A0(v14, a1 + 272 * k + 308, k + 257);
        sub_434B60(
            (_DWORD*) dword_6D4588,
            a1 + 272 * k + 308,
            0xC0E0FFu,
            0x302080u,
            (char*) (*(_DWORD*) (a1 + 32) + 626 * k + 64));
        *(float*) (a1 + 272 * k + 452) = 93.0;
        v11 = (float) (18 * (k + 1));
        *(float*) (a1 + 272 * k + 456) = v11 + 104.0 - 20.0;
        *(float*) (a1 + 272 * k + 460) = 0.0;
        v4 = *(_DWORD*) (a1 + 272 * k + 436);
        BYTE1(v4) |= 3u;
        *(_DWORD*) (a1 + 272 * k + 436) = v4;
    }
    for(m = 0; m < 16; ++m) {
        v13 = (int*) dword_6D4588;
        sub_403580((_DWORD*) (a1 + 272 * m + 9012));
        sub_4323A0(v13, a1 + 272 * m + 9012, m + 1800);
        v5 = (char*) (626 * *(_DWORD*) (a1 + 20) + *(_DWORD*) (a1 + 32) + 66 * (m / 2) + 98);
        v6 = *(_DWORD*) (a1 + 272 * m + 9204);
        if(m % 2)
            *(_DWORD*) (v6 + 4) = -1015611392;
        v7 = *(_DWORD*) (a1 + 272 * m + 9140);
        LOBYTE(v7) = v7 | 2;
        *(_DWORD*) (a1 + 272 * m + 9140) = v7;
        sub_434B60((_DWORD*) dword_6D4588, a1 + 272 * m + 9012, 0xFFE0C0u, 0x300000u, v5);
        *(_DWORD*) (v6 + 4) = 0;
        v10 = (float) (m % 2);
        *(float*) (a1 + 272 * m + 9156) = v10 * 248.0 + 96.0;
        v9 = (float) (16 * (m / 2));
        *(float*) (a1 + 272 * m + 9160) = v9 + 320.0;
        *(float*) (a1 + 272 * m + 9164) = 0.0;
        v8 = *(_DWORD*) (a1 + 272 * m + 9140);
        BYTE1(v8) |= 3u;
        *(_DWORD*) (a1 + 272 * m + 9140) = v8;
    }
    free(Block);
    return 0;
}
// 47A630: using guessed type int dword_47A630;
// 69D914: using guessed type int dword_69D914;

//----- (00425D97) --------------------------------------------------------
int __cdecl sub_425D97(int a1) {
    j__free(*(void**) (a1 + 32));
    *(_DWORD*) (a1 + 32) = 0;
    sub_435270((_DWORD**) dword_6D4588, 0);
    sub_432030(dword_6D4588, 41);
    sub_432030(dword_6D4588, 42);
    sub_432030(dword_6D4588, 43);
    sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 4));
    *(_DWORD*) (a1 + 4) = 0;
    return 0;
}

//----- (00425E10) --------------------------------------------------------
_DWORD* __thiscall sub_425E10(_DWORD* this) {
    int ii; // [esp+44h] [ebp-60h]
    int v4; // [esp+4Ch] [ebp-58h]
    _DWORD* n; // [esp+58h] [ebp-4Ch]
    int v6; // [esp+60h] [ebp-44h]
    _DWORD* m; // [esp+64h] [ebp-40h]
    int v8; // [esp+6Ch] [ebp-38h]
    _DWORD* k; // [esp+70h] [ebp-34h]
    int v10; // [esp+78h] [ebp-2Ch]
    _DWORD* j; // [esp+7Ch] [ebp-28h]
    int v12; // [esp+84h] [ebp-20h]
    int i; // [esp+88h] [ebp-1Ch]
    int v14; // [esp+90h] [ebp-14h]

    sub_403720((int) this);
    v14 = 3;
    for(i = (int) (this + 68); --v14 >= 0; i += 272)
        sub_403720(i);
    v12 = 2;
    for(j = this + 296; --v12 >= 0; j += 3)
        ;
    v10 = 32;
    for(k = this + 302; --v10 >= 0; k += 3)
        ;
    v8 = 32;
    for(m = this + 398; --v8 >= 0; m += 3)
        ;
    v6 = 2;
    for(n = this + 622; --v6 >= 0; n += 3)
        sub_424127(n);
    sub_424127(this + 634);
    v4 = 80;
    for(ii = (int) (this + 650); --v4 >= 0; ii += 344) {
        sub_403720(ii);
        sub_424127((_DWORD*) (ii + 320));
    }
    sub_424127(this + 7530);
    sub_424127(this + 7533);
    sub_426000(this + 7538);
    return this;
}

//----- (00426000) --------------------------------------------------------
_DWORD* __thiscall sub_426000(_DWORD* this) {
    int k; // [esp+4h] [ebp-38h]
    int v4; // [esp+Ch] [ebp-30h]
    _DWORD* j; // [esp+20h] [ebp-1Ch]
    int v6; // [esp+28h] [ebp-14h]
    _DWORD* i; // [esp+2Ch] [ebp-10h]
    int v8; // [esp+34h] [ebp-8h]

    sub_424127(this + 2);
    v8 = 8;
    for(i = this + 23; --v8 >= 0; i += 3)
        ;
    v6 = 8;
    for(j = this + 47; --v6 >= 0; j += 3)
        ;
    v4 = 32;
    for(k = (int) (this + 71); --v4 >= 0; k += 272)
        sub_403720(k);
    return this;
}

//----- (00426100) --------------------------------------------------------
int __cdecl sub_426100(_DWORD* a1, int a2, int a3, int a4, _DWORD* a5) {
    _DWORD* v5; // edx
    float v7; // [esp+8h] [ebp-44h]
    float v8; // [esp+Ch] [ebp-40h]
    int* v9; // [esp+24h] [ebp-28h]
    int v10; // [esp+28h] [ebp-24h]
    _DWORD* v11; // [esp+2Ch] [ebp-20h]
    int v12; // [esp+44h] [ebp-8h]
    __int16* v13; // [esp+48h] [ebp-4h]

    while((unsigned __int16) word_69D4B0 >= (int) a5 [1])
        a5 += 3;
    v13 = (__int16*) (a5 [2] + 36 * a3);
    if(*((_BYTE*) v13 + 31) != 3) {
        if(a4 % *v13 == v13 [1])
            goto LABEL_8;
        LABEL_14:
        if(a3 < *a5 - 1)
            return -1;
        else
            return -2;
    }
    v12 = v13 [1];
    if(a1 [3 * v12 + 624])
        goto LABEL_14;
    v11 = &a1 [3 * v12 + 622];
    a1 [3 * v12 + 624] = *v13;
    v11 [1] = 0;
    *v11 = -999;
    *(_WORD*) (a2 + 338) = v12;
    *(_WORD*) (a2 + 340) = *((unsigned __int8*) v13 + 30);
    *(_DWORD*) (a2 + 304) = *((_DWORD*) v13 + 1);
    *(_DWORD*) (a2 + 308) = *((_DWORD*) v13 + 2);
    LABEL_8:
    v10 = v13 [16];
    v9 = (int*) dword_6D4588;
    *(_WORD*) (a2 + 180) = v10;
    sub_432430(v9, (_DWORD*) a2, v9 [v10 + 29261]);
    if(*((_BYTE*) v13 + 30)) {
        v5 = &a1 [3 * *((unsigned __int8*) v13 + 30) + 293];
        *(_DWORD*) (a2 + 272) = *v5;
        *(_DWORD*) (a2 + 276) = v5 [1];
        *(_DWORD*) (a2 + 280) = v5 [2];
    }
    else {
        *(_DWORD*) (a2 + 272) = a1 [272];
        *(_DWORD*) (a2 + 276) = a1 [273];
        *(_DWORD*) (a2 + 280) = a1 [274];
    }
    *(float*) (a2 + 272) = *(float*) (a2 + 272) + *((float*) v13 + 1);
    *(float*) (a2 + 276) = *(float*) (a2 + 276) + *((float*) v13 + 2);
    *(_DWORD*) (a2 + 280) = 1056796836;
    *(_DWORD*) (a2 + 284) = *((_DWORD*) v13 + 3);
    *(_DWORD*) (a2 + 288) = *((_DWORD*) v13 + 4);
    *(_DWORD*) (a2 + 292) = 1065353216;
    *(_DWORD*) (a2 + 316) = *((_DWORD*) v13 + 5);
    *(_DWORD*) (a2 + 312) = *((_DWORD*) v13 + 6);
    v8 = cos(*((float*) v13 + 5));
    *(float*) (a2 + 296) = v8 * *((float*) v13 + 6);
    v7 = sin(*((float*) v13 + 5));
    *(float*) (a2 + 300) = v7 * *((float*) v13 + 6);
    *(_DWORD*) (a2 + 328) = 0;
    *(_DWORD*) (a2 + 324) = 0;
    *(_DWORD*) (a2 + 320) = -999;
    *(_WORD*) (a2 + 336) = *((unsigned __int8*) v13 + 31);
    *(_WORD*) (a2 + 332) = v13 [14];
    if(v13 [17] >= 0)
        sub_4311E0(dword_6D3F50, (int*) v13 [17], 0);
    return a3 >= *a5 - 1;
}
// 69D4B0: using guessed type __int16 word_69D4B0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (004264B0) --------------------------------------------------------
int __thiscall sub_4264B0(int this, float* a2, float* a3, _DWORD* a4) {
    __int16 v4; // fps
    bool v5; // c0
    char v6; // c2
    bool v7; // c3
    __int16 v8; // fps
    bool v9; // c0
    char v10; // c2
    bool v11; // c3
    int v12; // edx
    __int16 v13; // fps
    bool v14; // c0
    char v15; // c2
    bool v16; // c3
    __int16 v17; // fps
    bool v18; // c0
    char v19; // c2
    bool v20; // c3
    int v22; // [esp+4h] [ebp-D0h]
    float v24; // [esp+10h] [ebp-C4h]
    float v25; // [esp+14h] [ebp-C0h]
    float v26; // [esp+18h] [ebp-BCh]
    float v27; // [esp+20h] [ebp-B4h]
    float v28; // [esp+24h] [ebp-B0h]
    float v29; // [esp+28h] [ebp-ACh]
    float v30; // [esp+34h] [ebp-A0h]
    float v31; // [esp+38h] [ebp-9Ch]
    float v32; // [esp+3Ch] [ebp-98h]
    float v33; // [esp+44h] [ebp-90h]
    float v34; // [esp+48h] [ebp-8Ch]
    float v35; // [esp+4Ch] [ebp-88h]
    float v36; // [esp+50h] [ebp-84h]
    int* v37; // [esp+54h] [ebp-80h]
    float v38; // [esp+98h] [ebp-3Ch] BYREF
    float v39; // [esp+9Ch] [ebp-38h]
    float v40; // [esp+A0h] [ebp-34h]
    int v41; // [esp+A4h] [ebp-30h]
    float v42; // [esp+A8h] [ebp-2Ch]
    float v43; // [esp+ACh] [ebp-28h]
    float v44; // [esp+B4h] [ebp-20h]
    float v45; // [esp+B8h] [ebp-1Ch]
    float v46; // [esp+BCh] [ebp-18h]
    float v47; // [esp+C0h] [ebp-14h]
    float v48; // [esp+C4h] [ebp-10h]
    int i; // [esp+CCh] [ebp-8h]
    float* v50; // [esp+D0h] [ebp-4h]

    v41 = 0;
    v42 = *a2 - *a3 / 2.0;
    v43 = a2 [1] - a3 [1] / 2.0;
    v47 = *a3 / 2.0 + *a2;
    v48 = a3 [1] / 2.0 + a2 [1];
    v50 = (float*) (this + 2600);
    if(a4)
        *a4 = 0;
    i = 0;
    while(i < 80) {
        if(*((_WORD*) v50 + 167) && (*((_WORD*) v50 + 167) == 1 || *((_WORD*) v50 + 168) == 2)) {
            v38 = v50 [68] - v50 [71] / 2.0;
            v39 = v50 [69] - v50 [72] / 2.0;
            v44 = v50 [71] / 2.0 + v50 [68];
            v45 = v50 [72] / 2.0 + v50 [69];
            v5 = v39 < (double) v48;
            v6 = 0;
            v7 = v39 == v48;
            if((v4 & 0x4100) != 0) {
                v9 = v38 < (double) v47;
                v10 = 0;
                v11 = v38 == v47;
                if((v8 & 0x4100) != 0 && v45 >= (double) v43 && v44 >= (double) v42) {
                    if(*(_DWORD*) (this + 30152)) {
                        if(*((__int16*) v50 + 166) / 3)
                            v22 = *((__int16*) v50 + 166) / 3;
                        else
                            v22 = 1;
                        v41 += v22;
                    }
                    else {
                        v41 += *((__int16*) v50 + 166);
                    }
                    if(*((_WORD*) v50 + 168) == 2) {
                        *((__int16*) v50 + 166) /= 4;
                        if(!*((_WORD*) v50 + 166))
                            *((_WORD*) v50 + 166) = 1;
                        switch(*((_WORD*) v50 + 90)) {
                            case 0x441:
                                v50 [71] = 32.0;
                                v50 [72] = 32.0;
                                break;
                            case 0x442:
                                v50 [71] = 42.0;
                                v50 [72] = 42.0;
                                break;
                            case 0x443:
                                v50 [71] = 48.0;
                                v50 [72] = 48.0;
                                break;
                            case 0x444:
                                v50 [71] = 48.0;
                                v50 [72] = 48.0;
                                break;
                            default:
                                break;
                        }
                        if(!(*((_DWORD*) v50 + 82) % 6))
                            sub_40EF50(dword_487FE0, 5, (_DWORD*) v50 + 68, 1, -1);
                    }
                    if(*((_WORD*) v50 + 168) == 3) {
                        if((++ * (_BYTE*) (this + 2532) & 7) == 0) {
                            v38 = *a2;
                            v39 = a2 [1];
                            v40 = a2 [2];
                            v38 = v50 [68];
                            sub_40EF50(dword_487FE0, 5, &v38, 1, -1);
                        }
                    }
                    else {
                        if(*((_WORD*) v50 + 167) == 1) {
                            v12 = *((__int16*) v50 + 90);
                            v37 = (int*) dword_6D4588;
                            *((_WORD*) v50 + 90) = v12 + 32;
                            sub_432430(v37, v50, v37 [v12 + 29293]);
                            sub_40EF50(dword_487FE0, 5, (_DWORD*) v50 + 68, 1, -1);
                            v50 [70] = 0.1;
                        }
                        *((_WORD*) v50 + 167) = 2;
                        v50 [74] = v50 [74] / 8.0;
                        v50 [75] = v50 [75] / 8.0;
                    }
                }
            }
        }
        ++i;
        v50 += 86;
    }
    for(i = 0; i < 32; ++i) {
        if(*(float*) (this + 12 * i + 1592) > 0.0) {
            v36 = 1.0 / 2.0;
            v35 = v36 * *(float*) (this + 12 * i + 1600);
            v34 = v36 * *(float*) (this + 12 * i + 1596);
            v33 = v36 * *(float*) (this + 12 * i + 1592);
            v32 = *(float*) (this + 12 * i + 1216) - v35;
            v31 = *(float*) (this + 12 * i + 1212) - v34;
            v30 = *(float*) (this + 12 * i + 1208) - v33;
            v38 = v30;
            v39 = v31;
            v40 = v32;
            v29 = v36 * *(float*) (this + 12 * i + 1600);
            v28 = v36 * *(float*) (this + 12 * i + 1596);
            v27 = v36 * *(float*) (this + 12 * i + 1592);
            v26 = v29 + *(float*) (this + 12 * i + 1216);
            v25 = v28 + *(float*) (this + 12 * i + 1212);
            v24 = v27 + *(float*) (this + 12 * i + 1208);
            v44 = v24;
            v45 = v25;
            v46 = v26;
            v14 = v30 < (double) v47;
            v15 = 0;
            v16 = v30 == v47;
            if((v13 & 0x4100) != 0 && v44 >= (double) v42) {
                v18 = v39 < (double) v48;
                v19 = 0;
                v20 = v39 == v48;
                if((v17 & 0x4100) != 0 && v45 >= (double) v43) {
                    v41 += *(_DWORD*) (this + 4 * i + 1976);
                    *(_DWORD*) (this + 4 * i + 2104) += *(_DWORD*) (this + 4 * i + 1976);
                    if((++ * (_BYTE*) (this + 2532) & 3) == 0)
                        sub_40EF50(dword_487FE0, 3, a2, 1, -1);
                    if(*(_DWORD*) (this + 30152) && a4)
                        *a4 = 1;
                }
            }
        }
    }
    return v41;
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];

//----- (00426C40) --------------------------------------------------------
int __thiscall sub_426C40(int this, float* a2, float* a3) {
    __int16 v3; // fps
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    __int16 v7; // fps
    bool v8; // c0
    char v9; // c2
    bool v10; // c3
    __int16 v12; // fps
    double v13; // st7
    bool v14; // c0
    char v15; // c2
    bool v16; // c3
    __int16 v17; // fps
    double v18; // st7
    bool v19; // c0
    char v20; // c2
    bool v21; // c3
    float v22; // [esp+4h] [ebp-38h]
    float v23; // [esp+8h] [ebp-34h]
    float* v24; // [esp+10h] [ebp-2Ch]
    float v25; // [esp+14h] [ebp-28h]
    float v26; // [esp+18h] [ebp-24h]
    float v27; // [esp+20h] [ebp-1Ch]
    float v28; // [esp+24h] [ebp-18h]
    int i; // [esp+2Ch] [ebp-10h]
    float v30; // [esp+30h] [ebp-Ch]
    float v31; // [esp+34h] [ebp-8h]

    v24 = (float*) (this + 2232);
    v25 = *a2 - *a3 / 2.0;
    v26 = a2 [1] - a3 [1] / 2.0;
    v27 = *a3 / 2.0 + *a2;
    v28 = a3 [1] / 2.0 + a2 [1];
    for(i = 0; i < 16; ++i) {
        if(v24 [2] != 0.0) {
            v30 = *v24 - v24 [2] / 2.0;
            v31 = v24 [1] - v24 [3] / 2.0;
            v4 = v30 < (double) v27;
            v5 = 0;
            v6 = v30 == v27;
            if((v3 & 0x4100) != 0) {
                v22 = v24 [2] / 2.0 + *v24;
                if(v22 >= (double) v25) {
                    v8 = v31 < (double) v28;
                    v9 = 0;
                    v10 = v31 == v28;
                    if((v7 & 0x4100) != 0) {
                        v23 = v24 [3] / 2.0 + v24 [1];
                        if(v23 >= (double) v26)
                            return 2;
                    }
                }
            }
        }
        v24 += 4;
    }
    v13 = *(float*) (this + 1112);
    v14 = v13 < v27;
    v15 = 0;
    v16 = v13 == v27;
    if((v12 & 0x4100) == 0)
        return 0;
    v18 = *(float*) (this + 1116);
    v19 = v18 < v28;
    v20 = 0;
    v21 = v18 == v28;
    if((v17 & 0x4100) == 0 || *(float*) (this + 1124) < (double) v25 || *(float*) (this + 1128) < (double) v26)
        return 0;
    if(!*(_BYTE*) (this + 2528))
        sub_427770(this);
    return 1;
}

//----- (00426DF0) --------------------------------------------------------
int __thiscall sub_426DF0(int this, float* a2, float* a3) {
    __int16 v3; // fps
    bool v4; // c0
    char v5; // c2
    bool v6; // c3
    __int16 v7; // fps
    bool v8; // c0
    char v9; // c2
    bool v10; // c3
    __int16 v12; // fps
    double v13; // st7
    bool v14; // c0
    char v15; // c2
    bool v16; // c3
    __int16 v17; // fps
    double v18; // st7
    bool v19; // c0
    char v20; // c2
    bool v21; // c3
    float v22; // [esp+4h] [ebp-38h]
    float v23; // [esp+8h] [ebp-34h]
    float* v24; // [esp+10h] [ebp-2Ch]
    float v25; // [esp+14h] [ebp-28h]
    float v26; // [esp+18h] [ebp-24h]
    float v27; // [esp+20h] [ebp-1Ch]
    float v28; // [esp+24h] [ebp-18h]
    int i; // [esp+2Ch] [ebp-10h]
    float v30; // [esp+30h] [ebp-Ch]
    float v31; // [esp+34h] [ebp-8h]

    v25 = *a2 - *a3 / 2.0 - 20.0;
    v26 = a2 [1] - a3 [1] / 2.0 - 20.0;
    v27 = *a3 / 2.0 + *a2 + 20.0;
    v28 = a3 [1] / 2.0 + a2 [1] + 20.0;
    v24 = (float*) (this + 2232);
    for(i = 0; i < 16; ++i) {
        if(v24 [2] != 0.0) {
            v30 = *v24 - v24 [2] / 2.0;
            v31 = v24 [1] - v24 [3] / 2.0;
            v4 = v30 < (double) v27;
            v5 = 0;
            v6 = v30 == v27;
            if((v3 & 0x4100) != 0) {
                v22 = v24 [2] / 2.0 + *v24;
                if(v22 >= (double) v25) {
                    v8 = v31 < (double) v28;
                    v9 = 0;
                    v10 = v31 == v28;
                    if((v7 & 0x4100) != 0) {
                        v23 = v24 [3] / 2.0 + v24 [1];
                        if(v23 >= (double) v26)
                            return 2;
                    }
                }
            }
        }
        v24 += 4;
    }
    if(*(_BYTE*) (this + 2528) == 2 || *(_BYTE*) (this + 2528) == 1)
        return 0;
    v13 = *(float*) (this + 1112);
    v14 = v13 < v27;
    v15 = 0;
    v16 = v13 == v27;
    if((v12 & 0x4100) == 0)
        return 0;
    if(*(float*) (this + 1124) < (double) v25)
        return 0;
    v18 = *(float*) (this + 1116);
    v19 = v18 < v28;
    v20 = 0;
    v21 = v18 == v28;
    if((v17 & 0x4100) == 0 || *(float*) (this + 1128) < (double) v26)
        return 0;
    sub_427630((float*) this, a2);
    return 1;
}

//----- (00426FD0) --------------------------------------------------------
int __thiscall sub_426FD0(int this, float* a2, float* a3) {
    __int16 v4; // fps
    double v5; // st7
    bool v6; // c0
    char v7; // c2
    bool v8; // c3
    __int16 v9; // fps
    double v10; // st7
    bool v11; // c0
    char v12; // c2
    bool v13; // c3
    float v14; // [esp+4h] [ebp-80h]
    float v15; // [esp+8h] [ebp-7Ch]
    float v16; // [esp+10h] [ebp-74h]
    float v17; // [esp+14h] [ebp-70h]
    float v18; // [esp+20h] [ebp-64h]
    float v19; // [esp+24h] [ebp-60h]
    float v20; // [esp+2Ch] [ebp-58h]
    float v21; // [esp+30h] [ebp-54h]
    float v22; // [esp+38h] [ebp-4Ch]

    if(*(_BYTE*) (this + 2528) && *(_BYTE*) (this + 2528) != 3)
        return 0;
    v22 = 1.0 / 2.0;
    v17 = v22 * a3 [1];
    v16 = v22 * *a3;
    v15 = v17 + a2 [1];
    v14 = v16 + *a2;
    v5 = *(float*) (this + 1136);
    v6 = v5 < v14;
    v7 = 0;
    v8 = v5 == v14;
    if((v4 & 0x4100) == 0)
        return 0;
    v20 = v22 * *a3;
    v18 = *a2 - v20;
    if(*(float*) (this + 1148) < (double) v18)
        return 0;
    v10 = *(float*) (this + 1140);
    v11 = v10 < v15;
    v12 = 0;
    v13 = v10 == v15;
    if((v9 & 0x4100) != 0 && (v21 = v22 * a3 [1], v19 = a2 [1] - v21, *(float*) (this + 1152) >= (double) v19))
        return 1;
    else
        return 0;
}

//----- (00427190) --------------------------------------------------------
int __thiscall sub_427190(int this, float* a2, float* a3, float* a4, float a5, int a6) {
    __int16 v6; // fps
    bool v7; // c0
    char v8; // c2
    bool v9; // c3
    __int16 v10; // fps
    bool v11; // c0
    char v12; // c2
    bool v13; // c3
    __int16 v15; // fps
    bool v16; // c0
    char v17; // c2
    bool v18; // c3
    __int16 v19; // fps
    bool v20; // c0
    char v21; // c2
    bool v22; // c3
    int v24; // [esp+4h] [ebp-104h]
    float v25; // [esp+8h] [ebp-100h]
    float v26; // [esp+Ch] [ebp-FCh]
    float v27; // [esp+10h] [ebp-F8h]
    float v28; // [esp+14h] [ebp-F4h]
    float v29; // [esp+18h] [ebp-F0h]
    int v30; // [esp+20h] [ebp-E8h]
    float v31; // [esp+24h] [ebp-E4h]
    float v32; // [esp+28h] [ebp-E0h]
    float v33; // [esp+2Ch] [ebp-DCh]
    float v34; // [esp+30h] [ebp-D8h]
    float v35; // [esp+34h] [ebp-D4h]
    float v36; // [esp+38h] [ebp-D0h]
    float v37; // [esp+40h] [ebp-C8h]
    float v38; // [esp+44h] [ebp-C4h]
    float v39; // [esp+50h] [ebp-B8h]
    float v40; // [esp+54h] [ebp-B4h]
    float v41; // [esp+58h] [ebp-B0h]
    int v42; // [esp+5Ch] [ebp-ACh]
    float v43; // [esp+60h] [ebp-A8h]
    float v44; // [esp+64h] [ebp-A4h]
    int v45; // [esp+6Ch] [ebp-9Ch]
    float v46; // [esp+70h] [ebp-98h]
    float v47; // [esp+74h] [ebp-94h]
    int v48; // [esp+E4h] [ebp-24h] BYREF
    float v49; // [esp+E8h] [ebp-20h]
    float v50; // [esp+ECh] [ebp-1Ch]
    int v51; // [esp+F0h] [ebp-18h] BYREF
    float v52; // [esp+F4h] [ebp-14h]
    float v53; // [esp+F8h] [ebp-10h]
    float v54; // [esp+FCh] [ebp-Ch]
    float v55; // [esp+100h] [ebp-8h]
    float v56; // [esp+104h] [ebp-4h]

    v47 = *(float*) (this + 1096) - a4 [2];
    v46 = *(float*) (this + 1092) - a4 [1];
    *(float*) &v45 = *(float*) (this + 1088) - *a4;
    v48 = v45;
    v49 = v46;
    v50 = v47;
    sub_41E8D0((float*) &v51, (float*) &v48, a5);
    v53 = 0.0;
    v44 = a4 [2] + 0.0;
    v43 = v52 + a4 [1];
    *(float*) &v42 = *(float*) &v51 + *a4;
    v48 = v42;
    v49 = v43;
    v50 = v44;
    v41 = v44 - *(float*) (this + 1168);
    v40 = v43 - *(float*) (this + 1164);
    v39 = *(float*) &v42 - *(float*) (this + 1160);
    v54 = v39;
    v55 = v40;
    v56 = v41;
    v38 = v43 + *(float*) (this + 1164);
    v37 = *(float*) &v42 + *(float*) (this + 1160);
    v36 = 1.0 / 2.0;
    v35 = v36 * a3 [2];
    v34 = v36 * a3 [1];
    v33 = v36 * *a3;
    v32 = a2 [2] - v35;
    v31 = a2 [1] - v34;
    *(float*) &v30 = *a2 - v33;
    v48 = v30;
    v49 = v31;
    v50 = v32;
    v29 = v36 * a3 [2];
    v28 = v36 * a3 [1];
    v27 = v36 * *a3;
    v26 = v29 + a2 [2];
    v25 = v28 + a2 [1];
    *(float*) &v24 = v27 + *a2;
    v51 = v24;
    v52 = v25;
    v53 = v26;
    v7 = v39 < (double) *(float*) &v24;
    v8 = 0;
    v9 = v39 == *(float*) &v24;
    if((v6 & 0x4100) != 0
       && v37 >= (double) *(float*) &v48
       && (v11 = v55 < (double) v52, v12 = 0, v13 = v55 == v52, (v10 & 0x4100) != 0)
       && v38 >= (double) v49) {
        if(*(_BYTE*) (this + 2528)) {
            return 0;
        }
        else {
            sub_427770(this);
            return 1;
        }
    }
    else if(a6) {
        *(float*) &v48 = *(float*) &v48 - 48.0;
        v49 = v49 - 48.0;
        *(float*) &v51 = *(float*) &v51 + 48.0;
        v52 = v52 + 48.0;
        v16 = v54 < (double) *(float*) &v51;
        v17 = 0;
        v18 = v54 == *(float*) &v51;
        if((v15 & 0x4100) != 0
           && v37 >= (double) *(float*) &v48
           && (v20 = v55 < (double) v52, v21 = 0, v22 = v55 == v52, (v19 & 0x4100) != 0)
           && v38 >= (double) v49) {
            if(*(_BYTE*) (this + 2528) == 2 || *(_BYTE*) (this + 2528) == 1) {
                return 0;
            }
            else {
                sub_427630((float*) this, (float*) (this + 1088));
                return 2;
            }
        }
        else {
            return 0;
        }
    }
    else {
        return 0;
    }
}

//----- (00427630) --------------------------------------------------------
int* __thiscall sub_427630(float* this, float* a2) {
    int v2; // edx
    int v3; // edx
    float v5; // [esp+8h] [ebp-44h]
    int v6; // [esp+Ch] [ebp-40h]
    int v7; // [esp+10h] [ebp-3Ch]
    float v8; // [esp+14h] [ebp-38h]
    float v9; // [esp+1Ch] [ebp-30h]
    float v10; // [esp+20h] [ebp-2Ch]
    float v11; // [esp+24h] [ebp-28h]
    int v12 [3]; // [esp+40h] [ebp-Ch] BYREF

    if(!dword_6D1BF0) {
        if(*(int*) dword_69BCB4 < 9999)
            ++* (_DWORD*) dword_69BCB4;
        if(dword_69BCB8 < 999999)
            ++dword_69BCB8;
    }
    v11 = this [274] + a2 [2];
    v10 = this [273] + a2 [1];
    v9 = this [272] + *a2;
    v8 = 1.0 / 2.0;
    *(float*) &v7 = v11 * v8;
    *(float*) &v6 = v10 * v8;
    v5 = v9 * v8;
    *(float*) v12 = v5;
    v12 [1] = v6;
    v12 [2] = v7;
    sub_40EF50(dword_487FE0, 8, v12, 1, -1);
    dword_69BCA4 += 500;
    sub_41C57E(dword_69BCA0, v2, 6);
    v3 = dword_69BC30 [0];
    LOBYTE(v3) = dword_69BC30 [0] & 0x3F | 0x80;
    dword_69BC30 [0] = v3;
    return sub_4311E0(dword_6D3F50, (int*) 0x1E, 0);
}
// 42773E: variable 'v2' is possibly undefined
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB8: using guessed type int dword_69BCB8;
// 6D1BF0: using guessed type int dword_6D1BF0;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00427770) --------------------------------------------------------
int* __thiscall sub_427770(int this) {
    int* result; // eax
    int i; // [esp+Ch] [ebp-4h]

    dword_5A5F8C = 0;
    sub_40EF50(dword_487FE0, 12, (_DWORD*) (this + 1088), 1, -12566273);
    sub_40EF50(dword_487FE0, 6, (_DWORD*) (this + 1088), 16, -1);
    *(_BYTE*) (this + 2528) = 2;
    *(_DWORD*) (this + 30140) = 0;
    *(_DWORD*) (this + 30136) = 0;
    *(_DWORD*) (this + 30132) = -999;
    result = sub_4311E0(dword_6D3F50, (int*) 4, 0);
    ++* (_DWORD*) dword_69BCC0;
    for(i = 0; i < 2; ++i) {
        result = (int*) (this + 12 * i + 2488);
        *(_DWORD*) (this + 12 * i + 2496) = 2;
        result [1] = 0;
        *result = -999;
    }
    return result;
}
// 487FE0: using guessed type _DWORD dword_487FE0[48737];
// 5A5F8C: using guessed type int dword_5A5F8C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00427860) --------------------------------------------------------
int __thiscall sub_427860(int this) {
    double v1; // st7
    double v2; // st7
    double v3; // st7
    double v4; // st7
    __int16 v5; // fps
    double v6; // st7
    bool v7; // c0
    char v8; // c2
    bool v9; // c3
    __int16 v10; // fps
    bool v11; // c0
    char v12; // c2
    bool v13; // c3
    __int16 v14; // fps
    double v15; // st7
    bool v16; // c0
    char v17; // c2
    bool v18; // c3
    float v20; // [esp+0h] [ebp-F0h]
    float v21; // [esp+4h] [ebp-ECh]
    float v23; // [esp+50h] [ebp-A0h]
    float v24; // [esp+54h] [ebp-9Ch]
    float v25; // [esp+58h] [ebp-98h]
    float v26; // [esp+64h] [ebp-8Ch]
    float v27; // [esp+68h] [ebp-88h]
    float v28; // [esp+6Ch] [ebp-84h]
    float v29; // [esp+78h] [ebp-78h]
    float v30; // [esp+7Ch] [ebp-74h]
    float v31; // [esp+80h] [ebp-70h]
    float v32; // [esp+8Ch] [ebp-64h]
    float v33; // [esp+90h] [ebp-60h]
    float v34; // [esp+94h] [ebp-5Ch]
    int* v35; // [esp+98h] [ebp-58h]
    int* v36; // [esp+9Ch] [ebp-54h]
    int* v37; // [esp+A0h] [ebp-50h]
    int* v38; // [esp+A4h] [ebp-4Ch]
    float v39; // [esp+D8h] [ebp-18h]
    float v40; // [esp+D8h] [ebp-18h]
    float v41; // [esp+D8h] [ebp-18h]
    float v42; // [esp+D8h] [ebp-18h]
    float v43; // [esp+D8h] [ebp-18h]
    float v44; // [esp+DCh] [ebp-14h]
    float v45; // [esp+E0h] [ebp-10h]
    float v46; // [esp+E4h] [ebp-Ch]
    float v47; // [esp+E8h] [ebp-8h]

    v46 = 0.0;
    v47 = 0.0;
    *(_DWORD*) (this + 2572) = 0;
    if((word_69D904 & 0x10) != 0) {
        *(_DWORD*) (this + 2572) = 1;
        if((word_69D904 & 0x40) != 0)
            *(_DWORD*) (this + 2572) = 5;
        if((word_69D904 & 0x80) != 0)
            *(_DWORD*) (this + 2572) = 6;
    }
    else if((word_69D904 & 0x20) != 0) {
        *(_DWORD*) (this + 2572) = 2;
        if((word_69D904 & 0x40) != 0)
            *(_DWORD*) (this + 2572) = 7;
        if((word_69D904 & 0x80) != 0)
            *(_DWORD*) (this + 2572) = 8;
    }
    else {
        if((word_69D904 & 0x40) != 0)
            *(_DWORD*) (this + 2572) = 3;
        if((word_69D904 & 0x80) != 0)
            *(_DWORD*) (this + 2572) = 4;
    }
    *(_BYTE*) (this + 2531) = (word_69D904 & 4) != 0;
    switch(*(_DWORD*) (this + 2572)) {
        case 1:
            if((word_69D904 & 4) != 0)
                v2 = -*(float*) (this + 2552);
            else
                v2 = -*(float*) (this + 2548);
            v47 = v2;
            break;
        case 2:
            if((word_69D904 & 4) != 0)
                v47 = *(float*) (this + 2552);
            else
                v47 = *(float*) (this + 2548);
            break;
        case 3:
            if((word_69D904 & 4) != 0)
                v1 = -*(float*) (this + 2552);
            else
                v1 = -*(float*) (this + 2548);
            v46 = v1;
            break;
        case 4:
            if((word_69D904 & 4) != 0)
                v46 = *(float*) (this + 2552);
            else
                v46 = *(float*) (this + 2548);
            break;
        case 5:
            if((word_69D904 & 4) != 0)
                v3 = -*(float*) (this + 2560);
            else
                v3 = -*(float*) (this + 2556);
            v46 = v3;
            v47 = v46;
            break;
        case 6:
            if((word_69D904 & 4) != 0)
                v46 = *(float*) (this + 2560);
            else
                v46 = *(float*) (this + 2556);
            v47 = -v46;
            break;
        case 7:
            if((word_69D904 & 4) != 0)
                v4 = -*(float*) (this + 2560);
            else
                v4 = -*(float*) (this + 2556);
            v46 = v4;
            v47 = -v46;
            break;
        case 8:
            if((word_69D904 & 4) != 0)
                v46 = *(float*) (this + 2560);
            else
                v46 = *(float*) (this + 2556);
            v47 = v46;
            break;
        default:
            break;
    }
    if(v46 >= 0.0 || (v6 = *(float*) (this + 2576), v7 = v6 < 0.0, v8 = 0, v9 = v6 == 0.0, (v5 & 0x100) != 0)) {
        if(v46 == 0.0 && *(float*) (this + 2576) < 0.0) {
            v37 = (int*) dword_6D4588;
            *(_WORD*) (this + 180) = 1026;
            sub_432430(v37, (_DWORD*) this, v37 [30287]);
        }
    }
    else {
        v38 = (int*) dword_6D4588;
        *(_WORD*) (this + 180) = 1025;
        sub_432430(v38, (_DWORD*) this, v38 [30286]);
    }
    v11 = v46 < 0.0;
    v12 = 0;
    v13 = v46 == 0.0;
    if((v10 & 0x4100) != 0 || *(float*) (this + 2576) > 0.0) {
        if(v46 == 0.0) {
            v15 = *(float*) (this + 2576);
            v16 = v15 < 0.0;
            v17 = 0;
            v18 = v15 == 0.0;
            if((v14 & 0x4100) == 0) {
                v35 = (int*) dword_6D4588;
                *(_WORD*) (this + 180) = 1028;
                sub_432430(v35, (_DWORD*) this, v35 [30289]);
            }
        }
    }
    else {
        v36 = (int*) dword_6D4588;
        *(_WORD*) (this + 180) = 1027;
        sub_432430(v36, (_DWORD*) this, v36 [30288]);
    }
    *(float*) (this + 2576) = v46;
    *(float*) (this + 2580) = v47;
    *(float*) (this + 1088) = v46 * *(float*) (this + 2512) * flt_6C6EC0 + *(float*) (this + 1088);
    *(float*) (this + 1092) = v47 * *(float*) (this + 2516) * flt_6C6EC0 + *(float*) (this + 1092);
    if(*(float*) (this + 1088) >= (double) flt_69D6EC) {
        if(flt_69D6EC + *(float*) &dword_69D6F4 < *(float*) (this + 1088))
            *(float*) (this + 1088) = flt_69D6EC + *(float*) &dword_69D6F4;
    }
    else {
        *(float*) (this + 1088) = flt_69D6EC;
    }
    if(*(float*) (this + 1092) >= (double) flt_69D6F0) {
        if(flt_69D6F0 + *(float*) &dword_69D6F8 < *(float*) (this + 1092))
            *(float*) (this + 1092) = flt_69D6F0 + *(float*) &dword_69D6F8;
    }
    else {
        *(float*) (this + 1092) = flt_69D6F0;
    }
    v34 = *(float*) (this + 1096) - *(float*) (this + 1168);
    v33 = *(float*) (this + 1092) - *(float*) (this + 1164);
    v32 = *(float*) (this + 1088) - *(float*) (this + 1160);
    *(float*) (this + 1112) = v32;
    *(float*) (this + 1116) = v33;
    *(float*) (this + 1120) = v34;
    v31 = *(float*) (this + 1096) + *(float*) (this + 1168);
    v30 = *(float*) (this + 1092) + *(float*) (this + 1164);
    v29 = *(float*) (this + 1088) + *(float*) (this + 1160);
    *(float*) (this + 1124) = v29;
    *(float*) (this + 1128) = v30;
    *(float*) (this + 1132) = v31;
    v28 = *(float*) (this + 1096) - *(float*) (this + 1180);
    v27 = *(float*) (this + 1092) - *(float*) (this + 1176);
    v26 = *(float*) (this + 1088) - *(float*) (this + 1172);
    *(float*) (this + 1136) = v26;
    *(float*) (this + 1140) = v27;
    *(float*) (this + 1144) = v28;
    v25 = *(float*) (this + 1096) + *(float*) (this + 1180);
    v24 = *(float*) (this + 1092) + *(float*) (this + 1176);
    v23 = *(float*) (this + 1088) + *(float*) (this + 1172);
    *(float*) (this + 1148) = v23;
    *(float*) (this + 1152) = v24;
    *(float*) (this + 1156) = v25;
    *(_DWORD*) (this + 1184) = *(_DWORD*) (this + 1088);
    *(_DWORD*) (this + 1188) = *(_DWORD*) (this + 1092);
    *(_DWORD*) (this + 1192) = *(_DWORD*) (this + 1096);
    *(_DWORD*) (this + 1196) = *(_DWORD*) (this + 1088);
    *(_DWORD*) (this + 1200) = *(_DWORD*) (this + 1092);
    *(_DWORD*) (this + 1204) = *(_DWORD*) (this + 1096);
    v45 = 0.0;
    v44 = 0.0;
    if((unsigned __int16) word_69D4B0 >= 8u) {
        if(!*(_BYTE*) (this + 2530))
            *(_BYTE*) (this + 2530) = 1;
    }
    else {
        *(_BYTE*) (this + 2530) = 0;
    }
    switch(*(_BYTE*) (this + 2530)) {
        case 0:
            *(_DWORD*) (this + 2544) = 0;
            *(_DWORD*) (this + 2540) = 0;
            *(_DWORD*) (this + 2536) = -999;
            goto LABEL_92;
        case 1:
            v44 = 24.0;
            *(_DWORD*) (this + 2544) = 0;
            *(_DWORD*) (this + 2540) = 0;
            *(_DWORD*) (this + 2536) = -999;
            if(*(_BYTE*) (this + 2531)) {
                *(_BYTE*) (this + 2530) = 2;
                goto LABEL_80;
            }
            goto LABEL_92;
        case 2:
            goto LABEL_80;
        case 3:
            v44 = 8.0;
            v45 = -32.0;
            *(_DWORD*) (this + 2544) = 0;
            *(_DWORD*) (this + 2540) = 0;
            *(_DWORD*) (this + 2536) = -999;
            if(*(_BYTE*) (this + 2531))
                goto LABEL_92;
            *(_BYTE*) (this + 2530) = 4;
            while(1) {
                LABEL_88:
                *(_DWORD*) (this + 2536) = *(_DWORD*) (this + 2544);
                sub_424285((float*) &dword_6C6D18, (_DWORD*) (this + 2544), (float*) (this + 2540));
                v20 = (float) *(int*) (this + 2544);
                v41 = (v20 + *(float*) (this + 2540)) / 8.0;
                v45 = 32.0 * v41 + -32.0;
                v42 = v41 * v41;
                v43 = 1.0 - v42;
                v44 = -16.0 * v43 + 24.0;
                if(*(int*) (this + 2544) >= 8)
                    *(_BYTE*) (this + 2530) = 1;
                if(!*(_BYTE*) (this + 2531))
                    break;
                *(_BYTE*) (this + 2530) = 2;
                *(_DWORD*) (this + 2544) = 8 - *(_DWORD*) (this + 2544);
                *(_DWORD*) (this + 2540) = 0;
                *(_DWORD*) (this + 2536) = -999;
                LABEL_80:
                *(_DWORD*) (this + 2536) = *(_DWORD*) (this + 2544);
                sub_424285((float*) &dword_6C6D18, (_DWORD*) (this + 2544), (float*) (this + 2540));
                v21 = (float) *(int*) (this + 2544);
                v39 = (v21 + *(float*) (this + 2540)) / 8.0;
                v45 = (1.0 - v39) * 32.0 + -32.0;
                v40 = v39 * v39;
                v44 = -16.0 * v40 + 24.0;
                if(*(int*) (this + 2544) >= 8)
                    *(_BYTE*) (this + 2530) = 3;
                if(*(_BYTE*) (this + 2531))
                    break;
                *(_BYTE*) (this + 2530) = 4;
                *(_DWORD*) (this + 2544) = 8 - *(_DWORD*) (this + 2544);
                *(_DWORD*) (this + 2540) = 0;
                *(_DWORD*) (this + 2536) = -999;
            }
            LABEL_92:
            *(float*) (this + 1184) = *(float*) (this + 1184) - v44;
            *(float*) (this + 1196) = v44 + *(float*) (this + 1196);
            *(float*) (this + 1188) = v45 + *(float*) (this + 1188);
            *(float*) (this + 1200) = v45 + *(float*) (this + 1200);
            if((word_69D904 & 1) != 0 && !sub_4195A2(dword_69BC30))
                sub_428630((_DWORD*) this);
            *(_WORD*) (this + 2584) = word_69D904;
            return 0;
        case 4:
            goto LABEL_88;
        default:
            goto LABEL_92;
    }
}
// 69BC30: using guessed type int dword_69BC30[5];
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D6EC: using guessed type float flt_69D6EC;
// 69D6F0: using guessed type float flt_69D6F0;
// 69D6F4: using guessed type int dword_69D6F4;
// 69D6F8: using guessed type int dword_69D6F8;
// 69D904: using guessed type __int16 word_69D904;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;

//----- (00428630) --------------------------------------------------------
_DWORD* __cdecl sub_428630(_DWORD* a1) {
    _DWORD* result; // eax

    result = a1;
    if((int) a1 [7532] < 0) {
        result = a1 + 7530;
        a1 [7532] = 0;
        a1 [7531] = 0;
        a1 [7530] = -999;
    }
    return result;
}

//----- (00428680) --------------------------------------------------------
double __thiscall sub_428680(float* this, float* a2) {
    float v3; // [esp+18h] [ebp-8h]
    float v4; // [esp+1Ch] [ebp-4h]

    v3 = *a2 - this [272];
    v4 = a2 [1] - this [273];
    if(v4 == 0.0 && v3 == 0.0)
        return 1.5707964;
    sub_45BE40(v4, v3);
    return v4;
}

//----- (00428700) --------------------------------------------------------
double __thiscall sub_428700(float* this, float* a2) {
    float v3; // [esp+18h] [ebp-8h]
    float v4; // [esp+1Ch] [ebp-4h]

    v3 = this [272] - *a2;
    v4 = this [273] - a2 [1];
    if(v4 == 0.0 && v3 == 0.0)
        return 1.5707964;
    sub_45BE40(v4, v3);
    return v4;
}

//----- (00428780) --------------------------------------------------------
int __cdecl sub_428780(char a1) {
    memset(flt_6CA628, 0, 0x98F0u);
    flt_6CA628 [7535] = 0.0;
    flt_6CA628 [7534] = 0.0;
    flt_6CA628 [7533] = NAN;
    BYTE1(flt_6CA628 [632]) = a1;
    LODWORD(flt_6CA628 [9785]) = sub_41CD40((int) sub_4288C0);
    LODWORD(flt_6CA628 [9786]) = sub_41CD40((int) sub_429930);
    LODWORD(flt_6CA628 [9787]) = sub_41CD40((int) sub_429B90);
    *(_DWORD*) (LODWORD(flt_6CA628 [9785]) + 28) = flt_6CA628;
    *(_DWORD*) (LODWORD(flt_6CA628 [9786]) + 28) = flt_6CA628;
    *(_DWORD*) (LODWORD(flt_6CA628 [9787]) + 28) = flt_6CA628;
    *(_DWORD*) (LODWORD(flt_6CA628 [9785]) + 8) = sub_429C50;
    *(_DWORD*) (LODWORD(flt_6CA628 [9785]) + 12) = sub_42A0B0;
    if(sub_41C860(byte_69D918, LODWORD(flt_6CA628 [9785]), 7))
        return -1;
    sub_41C940((__int16*) byte_69D918, LODWORD(flt_6CA628 [9786]), 5);
    sub_41C940((__int16*) byte_69D918, LODWORD(flt_6CA628 [9787]), 7);
    return 0;
}
// 6CA628: using guessed type float flt_6CA628[272];

//----- (004288C0) --------------------------------------------------------
int __cdecl sub_4288C0(int a1) {
    int v2; // eax
    int v3; // edx
    int v4; // edx
    int v5; // eax
    float v6; // [esp+0h] [ebp-5Ch]
    float v7; // [esp+4h] [ebp-58h]
    float v8; // [esp+8h] [ebp-54h]
    int* v9; // [esp+2Ch] [ebp-30h]
    float v10; // [esp+50h] [ebp-Ch]
    float v11; // [esp+54h] [ebp-8h]
    int i; // [esp+58h] [ebp-4h]
    int j; // [esp+58h] [ebp-4h]

    if(byte_69BCCC)
        return 1;
    for(i = 0; i < 32; ++i)
        *(_DWORD*) (a1 + 12 * i + 1592) = 0;
    for(j = 0; j < 16; ++j)
        *(_DWORD*) (a1 + 16 * j + 2240) = 0;
    if(*(_DWORD*) (a1 + 30152)) {
        (*(void(__cdecl**)(int))(a1 + 30172))(a1);
    }
    else if(!sub_4195A2(dword_69BC30)
            && *(_DWORD*) (a1 + 2520)
            && byte_69D4BB > 0
            && (word_69D904 & 2) != 0
            && (word_69D904 & 2) != (word_69D908 & 2)
            && *(_DWORD*) (a1 + 30172)) {
        ++* (_DWORD*) dword_69BCC4;
        --byte_69D4BB;
        v2 = dword_69BC30 [0];
        LOBYTE(v2) = dword_69BC30 [0] & 0xF3 | 8;
        dword_69BC30 [0] = v2;
        *(_DWORD*) (a1 + 30152) = 1;
        *(_DWORD*) (a1 + 30168) = 0;
        *(_DWORD*) (a1 + 30164) = 0;
        *(_DWORD*) (a1 + 30160) = -999;
        *(_DWORD*) (a1 + 30156) = 999;
        (*(void(__cdecl**)(int))(a1 + 30172))(a1);
        dword_5A5F8C = 0;
        sub_41C5FA(dword_69BCA0, v3, 200);
        dword_5A5F9C = dword_5A5F90;
    }
    if(*(_BYTE*) (a1 + 2528) != 2) {
        if(*(_BYTE*) (a1 + 2528) != 1)
            goto LABEL_41;
        goto LABEL_39;
    }
    if(*(_DWORD*) (a1 + 2520)) {
        if(!-- * (_DWORD*) (a1 + 2520)) {
            byte_69D4B9 = 0;
            if(byte_69D4BA <= 0) {
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 4, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 4, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 4, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 4, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 4, 2);
                word_69D4B0 = 0;
                v4 = dword_69BC30 [0] & 0xFFFFFFCF | 0x20;
                dword_69BC30 [0] = v4;
                byte_69D4BC = -1;
            }
            else {
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 2, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 0, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 0, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 0, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 0, 2);
                sub_41F290(byte_69E268, (_DWORD*) (a1 + 1088), 0, 2);
                if((unsigned __int16) word_69D4B0 > 0x10u)
                    word_69D4B0 -= 16;
                else
                    word_69D4B0 = 0;
                v4 = dword_69BC30 [0] & 0xFFFFFFCF | 0x20;
                dword_69BC30 [0] = v4;
            }
            sub_41C5FA(dword_69BCA0, v4, 1600);
        }
        goto LABEL_41;
    }
    v8 = (float) *(int*) (a1 + 30140);
    v11 = (v8 + *(float*) (a1 + 30136)) / 30.0;
    *(float*) (a1 + 24) = 3.0 * v11 + 1.0;
    *(float*) (a1 + 28) = 1.0 - 1.0 * v11;
    v7 = (float) *(int*) (a1 + 30140);
    *(_DWORD*) (a1 + 124) = ((unsigned int) (unsigned __int64) (255.0 - (v7 + *(float*) (a1 + 30136)) * 255.0 / 30.0) << 24) | 0xFFFFFF;
    *(_DWORD*) (a1 + 128) |= 4u;
    *(_DWORD*) (a1 + 2576) = 0;
    *(_DWORD*) (a1 + 2580) = 0;
    if(*(int*) (a1 + 30140) >= 30) {
        *(_BYTE*) (a1 + 2528) = 1;
        *(float*) (a1 + 1088) = flt_69D6E4 / 2.0;
        *(float*) (a1 + 1092) = flt_69D6E8 - 64.0;
        *(_DWORD*) (a1 + 1096) = 1045220557;
        *(_DWORD*) (a1 + 30140) = 0;
        *(_DWORD*) (a1 + 30136) = 0;
        *(_DWORD*) (a1 + 30132) = -999;
        *(_DWORD*) (a1 + 28) = 1077936128;
        *(_DWORD*) (a1 + 24) = 1077936128;
        v9 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 180) = 1024;
        sub_432430(v9, (_DWORD*) a1, v9 [30285]);
        if(byte_69D4BA <= 0) {
            byte_69D4C0 = 1;
            goto LABEL_41;
        }
        --byte_69D4BA;
        dword_69BC30 [0] = dword_69BC30 [0] & 0xFFFFFFFC | 2;
        if(dword_69BCB0 >= 4 || byte_69D4C3)
            byte_69D4BB = 3;
        else
            byte_69D4BB = byte_6C6E7D;
        dword_69BC30 [0] = dword_69BC30 [0] & 0xFFFFFFF3 | 8;
        LABEL_39:
        *(_DWORD*) (a1 + 2524) = 90;
        v6 = (float) *(int*) (a1 + 30140);
        v10 = 1.0 - (v6 + *(float*) (a1 + 30136)) / 30.0;
        *(float*) (a1 + 24) = 2.0 * v10 + 1.0;
        *(float*) (a1 + 28) = 1.0 - 1.0 * v10;
        *(_DWORD*) (a1 + 128) |= 4u;
        *(_DWORD*) (a1 + 2516) = 1065353216;
        *(_DWORD*) (a1 + 2512) = 1065353216;
        *(_DWORD*) (a1 + 124) = ((255 * *(_DWORD*) (a1 + 30140) / 30) << 24) | 0xFFFFFF;
        *(_DWORD*) (a1 + 2520) = 0;
        if(*(int*) (a1 + 30140) >= 30) {
            *(_BYTE*) (a1 + 2528) = 3;
            *(_DWORD*) (a1 + 28) = 1065353216;
            *(_DWORD*) (a1 + 24) = 1065353216;
            *(_DWORD*) (a1 + 124) = -1;
            *(_DWORD*) (a1 + 128) &= ~4u;
            *(_DWORD*) (a1 + 30140) = 240;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            *(_DWORD*) (a1 + 2520) = 6;
        }
    }
    LABEL_41:
    if(*(_DWORD*) (a1 + 2524)) {
        --* (_DWORD*) (a1 + 2524);
        sub_414160((char*) dword_5A5FF8, 0);
    }
    if(*(_BYTE*) (a1 + 2528) == 3) {
        sub_4241E5(a1 + 30132, 1);
        if(*(int*) (a1 + 30140) > 0) {
            if(*(_DWORD*) (a1 + 30140) % 8 >= 2) {
                *(_DWORD*) (a1 + 128) &= ~8u;
                *(_DWORD*) (a1 + 124) = -1;
            }
            else {
                v5 = *(_DWORD*) (a1 + 128);
                LOBYTE(v5) = v5 | 8;
                *(_DWORD*) (a1 + 128) = v5;
                *(_DWORD*) (a1 + 124) = -12566464;
            }
        }
        else {
            *(_BYTE*) (a1 + 2528) = 0;
            *(_DWORD*) (a1 + 30140) = 0;
            *(_DWORD*) (a1 + 30136) = 0;
            *(_DWORD*) (a1 + 30132) = -999;
            *(_DWORD*) (a1 + 128) &= ~8u;
            *(_DWORD*) (a1 + 124) = -1;
        }
    }
    else {
        *(_DWORD*) (a1 + 30132) = *(_DWORD*) (a1 + 30140);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30140), (float*) (a1 + 30136));
    }
    if(*(_BYTE*) (a1 + 2528) != 2 && *(_BYTE*) (a1 + 2528) != 1)
        sub_427860(a1);
    sub_433960((int*) dword_6D4588, a1);
    sub_4291B0(a1);
    if(*(_BYTE*) (a1 + 2530)) {
        sub_433960((int*) dword_6D4588, a1 + 272);
        sub_433960((int*) dword_6D4588, a1 + 544);
    }
    *(_DWORD*) (a1 + 2588) = -998653952;
    *(_DWORD*) (a1 + 2592) = -998653952;
    *(_DWORD*) (a1 + 2596) = 0;
    sub_429710(a1);
    return 1;
}
// 428A5F: variable 'v3' is possibly undefined
// 5A5F8C: using guessed type int dword_5A5F8C;
// 5A5F90: using guessed type int dword_5A5F90;
// 5A5F9C: using guessed type int dword_5A5F9C;
// 5A5FF8: using guessed type _DWORD dword_5A5FF8[5504];
// 69BC30: using guessed type int dword_69BC30[5];
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCCC: using guessed type char byte_69BCCC;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B9: using guessed type char byte_69D4B9;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BC: using guessed type char byte_69D4BC;
// 69D4C0: using guessed type char byte_69D4C0;
// 69D4C3: using guessed type char byte_69D4C3;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6E7D: using guessed type char byte_6C6E7D;

//----- (004291B0) --------------------------------------------------------
void __cdecl sub_4291B0(int a1) {
    __int16 v1; // fps
    double v2; // st7
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    __int16 v6; // fps
    bool v7; // c0
    char v8; // c2
    bool v9; // c3
    _DWORD* v10; // ecx
    float v11; // [esp+10h] [ebp-38h]
    int v12; // [esp+14h] [ebp-34h]
    float v13; // [esp+18h] [ebp-30h]
    float v14; // [esp+1Ch] [ebp-2Ch]
    int v15; // [esp+20h] [ebp-28h]
    int v16; // [esp+34h] [ebp-14h]
    float v17; // [esp+38h] [ebp-10h]
    int i; // [esp+3Ch] [ebp-Ch]
    int j; // [esp+3Ch] [ebp-Ch]
    float v20; // [esp+40h] [ebp-8h]
    float v21; // [esp+40h] [ebp-8h]
    float v22; // [esp+40h] [ebp-8h]
    float v23; // [esp+44h] [ebp-4h]
    float v24; // [esp+44h] [ebp-4h]
    float v25; // [esp+44h] [ebp-4h]

    for(i = 0; i < 2; ++i) {
        if(*(_DWORD*) (a1 + 12 * i + 2496))
            sub_4241E5(a1 + 12 * i + 2488, 1);
    }
    v16 = a1 + 2600;
    for(j = 0; j < 80; ++j) {
        if(*(_WORD*) (v16 + 334)) {
            v15 = *(__int16*) (v16 + 336);
            switch(v15) {
                case 1:
                    if(*(_WORD*) (v16 + 334) == 1) {
                        v2 = *(float*) (a1 + 2588);
                        v3 = v2 < -100.0;
                        v4 = 0;
                        v5 = v2 == -100.0;
                        if((v1 & 0x4100) != 0 || *(int*) (v16 + 328) >= 40 || *(_DWORD*) (v16 + 328) == *(_DWORD*) (v16 + 320)) {
                            if(*(float*) (v16 + 312) < 10.0) {
                                *(float*) (v16 + 312) = *(float*) (v16 + 312) + 0.33333334;
                                v22 = *(float*) (v16 + 296);
                                v25 = *(float*) (v16 + 300);
                                v11 = sqrt(v25 * v25 + v22 * v22);
                                *(float*) (v16 + 296) = v22 * *(float*) (v16 + 312) / v11;
                                *(float*) (v16 + 300) = v25 * *(float*) (v16 + 312) / v11;
                            }
                        }
                        else {
                            v20 = *(float*) (a1 + 2588) - *(float*) (v16 + 272);
                            v23 = *(float*) (a1 + 2592) - *(float*) (v16 + 276);
                            v14 = sqrt(v23 * v23 + v20 * v20);
                            v17 = v14 / (*(float*) (v16 + 312) / 4.0);
                            if(v17 < 1.0)
                                v17 = 1.0;
                            v21 = v20 / v17 + *(float*) (v16 + 296);
                            v24 = v23 / v17 + *(float*) (v16 + 300);
                            v13 = sqrt(v24 * v24 + v21 * v21);
                            v7 = v13 < 10.0;
                            v8 = 0;
                            v9 = v13 == 10.0;
                            if((v6 & 0x4100) != 0)
                                v12 = LODWORD(v13);
                            else
                                v12 = 1092616192;
                            *(_DWORD*) (v16 + 312) = v12;
                            if(*(float*) (v16 + 312) < 1.0)
                                *(_DWORD*) (v16 + 312) = 1065353216;
                            *(float*) (v16 + 296) = v21 * *(float*) (v16 + 312) / v13;
                            *(float*) (v16 + 300) = v24 * *(float*) (v16 + 312) / v13;
                        }
                    }
                    break;
                case 2:
                    if(*(_WORD*) (v16 + 334) == 1)
                        *(float*) (v16 + 300) = *(float*) (v16 + 300) - 0.30000001;
                    break;
                case 3:
                    if(*(_DWORD*) (a1 + 12 * *(__int16*) (v16 + 338) + 2496) == 70) {
                        *(_WORD*) (v16 + 138) = 1;
                    }
                    else if(*(_DWORD*) (a1 + 12 * *(__int16*) (v16 + 338) + 2496) == 1) {
                        *(_WORD*) (v16 + 138) = 1;
                    }
                    v10 = (_DWORD*) (a1 + 12 * (*(__int16*) (v16 + 340) - 1) + 1184);
                    *(_DWORD*) (v16 + 272) = *v10;
                    *(_DWORD*) (v16 + 276) = v10 [1];
                    *(_DWORD*) (v16 + 280) = v10 [2];
                    *(float*) (v16 + 272) = *(float*) (v16 + 272) + *(float*) (v16 + 304);
                    *(float*) (v16 + 276) = *(float*) (v16 + 276) / 2.0;
                    *(_DWORD*) (v16 + 280) = 1054951342;
                    *(float*) (v16 + 24) = (*(float*) (v16 + 276) + *(float*) (v16 + 276)) / 14.0;
                    *(float*) (v16 + 288) = *(float*) (v16 + 276) + *(float*) (v16 + 276);
                    break;
            }
            *(float*) (v16 + 272) = flt_6C6EC0 * *(float*) (v16 + 296) + *(float*) (v16 + 272);
            *(_DWORD*) (v16 + 144) = *(_DWORD*) (v16 + 272);
            *(float*) (v16 + 276) = flt_6C6EC0 * *(float*) (v16 + 300) + *(float*) (v16 + 276);
            *(_DWORD*) (v16 + 148) = *(_DWORD*) (v16 + 276);
            *(_DWORD*) (v16 + 152) = *(_DWORD*) (v16 + 280);
            if(*(_WORD*) (v16 + 336) != 3
               && !sub_41B5E1(
               *(float*) (v16 + 272),
               *(float*) (v16 + 276),
               *(float*) (*(_DWORD*) (v16 + 192) + 48),
               *(float*) (*(_DWORD*) (v16 + 192) + 44))) {
                *(_WORD*) (v16 + 334) = 0;
            }
            if(sub_433960((int*) dword_6D4588, v16))
                *(_WORD*) (v16 + 334) = 0;
            *(_DWORD*) (v16 + 320) = *(_DWORD*) (v16 + 328);
            sub_424285((float*) &dword_6C6D18, (_DWORD*) (v16 + 328), (float*) (v16 + 324));
        }
        v16 += 344;
    }
}
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;

//----- (00429710) --------------------------------------------------------
int __cdecl sub_429710(int a1) {
    if(*(int*) (a1 + 30128) < 0)
        return 0;
    if(*(_DWORD*) (a1 + 30128) != *(_DWORD*) (a1 + 30120) && (!dword_6D1BF0 || byte_69D4BD != 1 || byte_69D4BE != 1))
        sub_429820(a1, *(_DWORD*) (a1 + 30128));
    *(_DWORD*) (a1 + 30120) = *(_DWORD*) (a1 + 30128);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 30128), (float*) (a1 + 30124));
    if(*(int*) (a1 + 30128) >= 30 || *(_BYTE*) (a1 + 2528) == 2 || *(_BYTE*) (a1 + 2528) == 1) {
        *(_DWORD*) (a1 + 30128) = -1;
        *(_DWORD*) (a1 + 30124) = 0;
        *(_DWORD*) (a1 + 30120) = -999;
    }
    return 0;
}
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 6C6D18: using guessed type int dword_6C6D18;
// 6D1BF0: using guessed type int dword_6D1BF0;

//----- (00429820) --------------------------------------------------------
int __cdecl sub_429820(int a1, int a2) {
    int result; // eax
    int v3; // [esp+0h] [ebp-10h]
    int v4; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]
    int v6; // [esp+Ch] [ebp-4h]

    v6 = 0;
    result = a1 + 2600;
    v4 = a1 + 2600;
    for(i = 0; i < 80; ++i) {
        result = v4;
        if(!*(_WORD*) (v4 + 334)) {
            do {
                result = *(_BYTE*) (a1 + 2531)
                    ? (*(int(__cdecl**)(int, int, int, int))(a1 + 30148))(a1, v4, v6, a2)
                    : (*(int(__cdecl**)(int, int, int, int))(a1 + 30144))(a1, v4, v6, a2);
                v3 = result;
                if(result >= 0) {
                    *(_DWORD*) (v4 + 144) = *(_DWORD*) (v4 + 272);
                    *(_DWORD*) (v4 + 148) = *(_DWORD*) (v4 + 276);
                    *(_DWORD*) (v4 + 152) = 1056796836;
                    result = v4;
                    *(_WORD*) (v4 + 334) = 1;
                }
                if(v3 == -2 || v3 > 0)
                    return result;
                ++v6;
            }
            while(v3 == -1);
        }
        v4 += 344;
    }
    return result;
}

//----- (00429930) --------------------------------------------------------
int __cdecl sub_429930(unsigned int a1) {
    sub_429B00(a1);
    if(*(_DWORD*) (a1 + 30152) && *(_DWORD*) (a1 + 30176))
        (*(void(__cdecl**)(unsigned int))(a1 + 30176))(a1);
    *(float*) (a1 + 144) = flt_69D6DC + *(float*) (a1 + 1088);
    *(float*) (a1 + 148) = flt_69D6E0 + *(float*) (a1 + 1092);
    *(_DWORD*) (a1 + 152) = 1056629064;
    if(!byte_69D4C0) {
        sub_432AD0((void*) dword_6D4588, a1);
        if(*(_BYTE*) (a1 + 2530)) {
            if(!*(_BYTE*) (a1 + 2528) || *(_BYTE*) (a1 + 2528) == 3) {
                *(_DWORD*) (a1 + 416) = *(_DWORD*) (a1 + 1184);
                *(_DWORD*) (a1 + 420) = *(_DWORD*) (a1 + 1188);
                *(_DWORD*) (a1 + 424) = *(_DWORD*) (a1 + 1192);
                *(_DWORD*) (a1 + 688) = *(_DWORD*) (a1 + 1196);
                *(_DWORD*) (a1 + 692) = *(_DWORD*) (a1 + 1200);
                *(_DWORD*) (a1 + 696) = *(_DWORD*) (a1 + 1204);
                *(float*) (a1 + 416) = flt_69D6DC + *(float*) (a1 + 416);
                *(float*) (a1 + 420) = flt_69D6E0 + *(float*) (a1 + 420);
                *(float*) (a1 + 688) = flt_69D6DC + *(float*) (a1 + 688);
                *(float*) (a1 + 692) = flt_69D6E0 + *(float*) (a1 + 692);
                *(_DWORD*) (a1 + 424) = 1056662618;
                *(_DWORD*) (a1 + 696) = 1056662618;
                sub_432CC0((void*) dword_6D4588, a1 + 272);
                sub_432CC0((void*) dword_6D4588, a1 + 544);
            }
        }
    }
    return 1;
}
// 69D4C0: using guessed type char byte_69D4C0;
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;

//----- (00429B00) --------------------------------------------------------
int __cdecl sub_429B00(int a1) {
    int result; // eax
    unsigned int v2; // [esp+0h] [ebp-8h]
    int i; // [esp+4h] [ebp-4h]

    result = a1 + 2600;
    v2 = a1 + 2600;
    for(i = 0; i < 80; ++i) {
        result = v2;
        if(*(_WORD*) (v2 + 334) == 1) {
            if(*(_WORD*) (v2 + 136))
                *(float*) (v2 + 8) = 1.5707964 - sub_41E850(*(float*) (v2 + 316), 3.1415927);
            result = sub_433590(dword_6D4588, v2);
        }
        v2 += 344;
    }
    return result;
}

//----- (00429B90) --------------------------------------------------------
int __cdecl sub_429B90(int a1) {
    sub_429BB0(a1);
    return 1;
}

//----- (00429BB0) --------------------------------------------------------
int __cdecl sub_429BB0(int a1) {
    int result; // eax
    unsigned int v2; // [esp+0h] [ebp-8h]
    int i; // [esp+4h] [ebp-4h]

    result = a1 + 2600;
    v2 = a1 + 2600;
    for(i = 0; i < 80; ++i) {
        result = v2;
        if(*(_WORD*) (v2 + 334) == 2) {
            if(*(_WORD*) (v2 + 136))
                *(float*) (v2 + 8) = 1.5707964 - sub_41E850(*(float*) (v2 + 316), 3.1415927);
            *(_DWORD*) (v2 + 152) = 1053609165;
            result = sub_433590(dword_6D4588, v2);
        }
        v2 += 344;
    }
    return result;
}

//----- (00429C50) --------------------------------------------------------
int __cdecl sub_429C50(int a1) {
    float v2; // [esp+10h] [ebp-38h]
    float v3; // [esp+14h] [ebp-34h]
    _DWORD* v4; // [esp+1Ch] [ebp-2Ch]
    int* v5; // [esp+24h] [ebp-24h]
    int* v6; // [esp+2Ch] [ebp-1Ch]
    int* v7; // [esp+38h] [ebp-10h]
    int* v8; // [esp+3Ch] [ebp-Ch]
    int v9; // [esp+40h] [ebp-8h]
    int i; // [esp+44h] [ebp-4h]
    int j; // [esp+44h] [ebp-4h]
    int k; // [esp+44h] [ebp-4h]

    if(byte_69D4BD) {
        if(byte_69D4BD == 1) {
            if(dword_6C6EA4 != 3 && sub_431DC0((_DWORD*) dword_6D4588, 5, "data/player01.anm", 1024))
                return -1;
            v7 = (int*) dword_6D4588;
            *(_WORD*) (a1 + 180) = 1024;
            sub_432430(v7, (_DWORD*) a1, v7 [30285]);
        }
    }
    else {
        if(dword_6C6EA4 != 3 && sub_431DC0((_DWORD*) dword_6D4588, 5, "data/player00.anm", 1024))
            return -1;
        v8 = (int*) dword_6D4588;
        *(_WORD*) (a1 + 180) = 1024;
        sub_432430(v8, (_DWORD*) a1, v8 [30285]);
    }
    *(float*) (a1 + 1088) = flt_69D6E4 / 2.0;
    *(float*) (a1 + 1092) = flt_69D6E8 - 64.0;
    *(_DWORD*) (a1 + 1096) = 1056629064;
    *(_DWORD*) (a1 + 1192) = 1056629064;
    *(_DWORD*) (a1 + 1204) = 1056629064;
    for(i = 0; i < 32; ++i)
        *(_DWORD*) (a1 + 12 * i + 1592) = 0;
    *(_DWORD*) (a1 + 1160) = 1067450368;
    *(_DWORD*) (a1 + 1164) = 1067450368;
    *(_DWORD*) (a1 + 1168) = 1084227584;
    *(_DWORD*) (a1 + 1172) = 1094713344;
    *(_DWORD*) (a1 + 1176) = 1094713344;
    *(_DWORD*) (a1 + 1180) = 1084227584;
    *(_DWORD*) (a1 + 2572) = 0;
    qmemcpy(
        (void*) (a1 + 2548),
        (char*) &unk_476728 + 48 * (unsigned __int8) byte_69D4BD + 24 * (unsigned __int8) byte_69D4BE,
        0x18u);
    v3 = sqrt(2.0);
    *(float*) (a1 + 2556) = *(float*) (a1 + 2548) / v3;
    v2 = sqrt(2.0);
    *(float*) (a1 + 2560) = *(float*) (a1 + 2552) / v2;
    *(_DWORD*) (a1 + 30144) = *(_DWORD*) (a1 + 2564);
    *(_DWORD*) (a1 + 30148) = *(_DWORD*) (a1 + 2568);
    *(_BYTE*) (a1 + 2528) = 1;
    *(_DWORD*) (a1 + 30140) = 120;
    *(_DWORD*) (a1 + 30136) = 0;
    *(_DWORD*) (a1 + 30132) = -999;
    *(_BYTE*) (a1 + 2530) = 0;
    v6 = (int*) dword_6D4588;
    *(_WORD*) (a1 + 452) = 1152;
    sub_432430(v6, (_DWORD*) (a1 + 272), v6 [30413]);
    v5 = (int*) dword_6D4588;
    *(_WORD*) (a1 + 724) = 1153;
    sub_432430(v5, (_DWORD*) (a1 + 544), v5 [30414]);
    v9 = a1 + 2600;
    for(j = 0; j < 80; ++j) {
        *(_WORD*) (v9 + 334) = 0;
        v9 += 344;
    }
    *(_DWORD*) (a1 + 30128) = -1;
    *(_DWORD*) (a1 + 30124) = 0;
    *(_DWORD*) (a1 + 30120) = -999;
    *(_DWORD*) (a1 + 30172) = *(&off_476708 [4 * (unsigned __int8) byte_69D4BD] + 2 * (unsigned __int8) byte_69D4BE);
    *(_DWORD*) (a1 + 30176) = *(&off_47670C [4 * (unsigned __int8) byte_69D4BD] + 2 * (unsigned __int8) byte_69D4BE);
    *(_DWORD*) (a1 + 30152) = 0;
    for(k = 0; k < 2; ++k) {
        v4 = (_DWORD*) (a1 + 12 * k + 2488);
        *(_DWORD*) (a1 + 12 * k + 2496) = 0;
        v4 [1] = 0;
        *v4 = -999;
    }
    *(_DWORD*) (a1 + 2516) = 1065353216;
    *(_DWORD*) (a1 + 2512) = 1065353216;
    *(_DWORD*) (a1 + 2520) = 8;
    return 0;
}
// 476708: using guessed type int (__cdecl *off_476708[8])(int);
// 47670C: using guessed type int (__cdecl *off_47670C[7])(int);
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (0042A0B0) --------------------------------------------------------
int sub_42A0B0() {
    if(dword_6C6EA4 != 3)
        sub_432030(dword_6D4588, 5);
    return 0;
}
// 6C6EA4: using guessed type int dword_6C6EA4;

//----- (0042A0E0) --------------------------------------------------------
void sub_42A0E0() {
    sub_41CDE0(byte_69D918, dword_6D3F0C);
    dword_6D3F0C = 0;
    sub_41CDE0(byte_69D918, dword_6D3F10);
    dword_6D3F10 = 0;
    sub_41CDE0(byte_69D918, dword_6D3F14);
    dword_6D3F14 = 0;
}
// 6D3F0C: using guessed type int dword_6D3F0C;
// 6D3F10: using guessed type int dword_6D3F10;
// 6D3F14: using guessed type int dword_6D3F14;

//----- (0042A140) --------------------------------------------------------
int __cdecl sub_42A140(int a1, int a2) {
    unsigned __int8* v3; // [esp+0h] [ebp-18h]
    int v4; // [esp+4h] [ebp-14h]
    _BYTE* v5; // [esp+8h] [ebp-10h]
    char v6; // [esp+Fh] [ebp-9h]
    int i; // [esp+14h] [ebp-4h]
    int j; // [esp+14h] [ebp-4h]

    if(!a1)
        return -1;
    if(*(_DWORD*) a1 != 1347565140)
        return -1;
    v5 = (_BYTE*) (a1 + 15);
    v6 = *(_BYTE*) (a1 + 14);
    for(i = 0; i < a2 - 15; ++i) {
        *v5 -= v6;
        v6 += 7;
        ++v5;
    }
    v3 = (unsigned __int8*) (a1 + 14);
    v4 = 1056965400;
    for(j = 0; j < a2 - 14; ++j)
        v4 += *v3++;
    if(v4 != *(_DWORD*) (a1 + 8))
        return -1;
    if(*(_WORD*) (a1 + 4) == 258)
        return 0;
    return -1;
}

//----- (0042A240) --------------------------------------------------------
int __cdecl sub_42A240(int a1, int a2) {
    _DWORD* v3; // [esp+8h] [ebp-10h]
    _DWORD* v4; // [esp+Ch] [ebp-Ch]

    if(*(float*) &dword_6C6EC4 < 0.99000001 && !a1)
        return 0;
    dword_6C6EC4 = 1065353216;
    if(dword_6D3F18) {
        if(a1) {
            if(a1 == 1)
                return sub_42A840(dword_6D3F18);
        }
        else {
            sub_42A680(dword_6D3F18);
        }
    }
    else {
        v4 = operator new(0x74u);
        if(v4)
            v3 = v4;
        else
            v3 = 0;
        dword_6D3F18 = (int) v3;
        v3 [1] = 0;
        v3 [2] = a1;
        v3 [3] = a2;
        if(a1) {
            if(a1 == 1) {
                v3 [26] = sub_41CD40((int) sub_42A570);
                *(_DWORD*) (v3 [26] + 8) = sub_42A840;
                *(_DWORD*) (v3 [26] + 12) = sub_42AA20;
                v3 [27] = sub_41CD40((int) unknown_libname_3);
                *(_DWORD*) (v3 [26] + 28) = v3;
                if(sub_41C860(byte_69D918, v3 [26], 5))
                    return -1;
                v3 [28] = sub_41CD40((int) sub_42A510);
                *(_DWORD*) (v3 [28] + 28) = v3;
                sub_41C860(byte_69D918, v3 [28], 16);
            }
        }
        else {
            v3 [26] = sub_41CD40((int) sub_42A470);
            *(_DWORD*) (v3 [26] + 8) = sub_42A680;
            *(_DWORD*) (v3 [26] + 12) = sub_42AA20;
            v3 [27] = sub_41CD40((int) unknown_libname_3);
            *(_DWORD*) (v3 [26] + 28) = v3;
            if(sub_41C860(byte_69D918, v3 [26], 15))
                return -1;
            v3 [28] = 0;
        }
        *(_DWORD*) (v3 [27] + 28) = v3;
        sub_41C940((__int16*) byte_69D918, v3 [27], 13);
    }
    return 0;
}
// 42A670: using guessed type int unknown_libname_3();
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6D3F18: using guessed type int dword_6D3F18;

//----- (0042A470) --------------------------------------------------------
int __cdecl sub_42A470(_DWORD* a1) {
    __int16 v2; // [esp+0h] [ebp-4h]

    if(!byte_69D4C1)
        return 1;
    v2 = word_69D904 & 0x1F7;
    if((word_69D904 & 0x1F7) != *(_WORD*) (a1 [18] + 4)) {
        a1 [18] += 8;
        a1 [*(_DWORD*) dword_69D6D4 + 18] = a1 [18] + 8;
        *(_DWORD*) a1 [18] = *a1;
        *(_WORD*) (a1 [18] + 4) = v2;
    }
    ++* a1;
    return 1;
}
// 69D4C1: using guessed type char byte_69D4C1;
// 69D904: using guessed type __int16 word_69D904;

//----- (0042A510) --------------------------------------------------------
int __cdecl sub_42A510(_DWORD* a1) {
    if(!byte_69D4C1)
        return 1;
    if(sub_4195A2(dword_69BC30) && sub_417344(dword_69BC30) && *a1 % 3 != 2)
        return 6;
    return 1;
}
// 69BC30: using guessed type int dword_69BC30[5];
// 69D4C1: using guessed type char byte_69D4C1;

//----- (0042A570) --------------------------------------------------------
int __cdecl sub_42A570(_DWORD* a1) {
    if(!byte_69D4C1)
        return 1;
    while(*a1 >= *(_DWORD*) (a1 [18] + 8))
        a1 [18] += 8;
    word_69D904 = *(_WORD*) (a1 [18] + 4) | word_69D904 & 0xFE08;
    word_69D90C = 0;
    if(word_69D908 == word_69D904) {
        if((unsigned __int16) word_69D910 >= 0x1Eu) {
            word_69D90C = (word_69D910 & 7) == 0;
            if((unsigned __int16) word_69D910 >= 0x26u)
                word_69D910 = 30;
        }
        ++word_69D910;
    }
    else {
        word_69D910 = 0;
    }
    ++* a1;
    return 1;
}
// 69D4C1: using guessed type char byte_69D4C1;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 69D910: using guessed type __int16 word_69D910;

//----- (0042A680) --------------------------------------------------------
int __cdecl sub_42A680(int a1) {
    _DWORD* v2; // [esp+8h] [ebp-Ch]
    int i; // [esp+Ch] [ebp-8h]
    int v4; // [esp+10h] [ebp-4h]

    *(_DWORD*) a1 = 0;
    if(*(_DWORD*) (a1 + 4)) {
        v2 = *(_DWORD**) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 44);
        if(!v2)
            return -1;
        *v2 = dword_69BCA4;
    }
    else {
        *(_DWORD*) (a1 + 4) = operator new(0x50u);
        **(_DWORD**) (a1 + 4) = 1347565140;
        *(_BYTE*) (*(_DWORD*) (a1 + 4) + 6) = byte_69D4BE + 2 * byte_69D4BD;
        *(_WORD*) (*(_DWORD*) (a1 + 4) + 4) = 258;
        *(_BYTE*) (*(_DWORD*) (a1 + 4) + 7) = dword_69BCB0;
        *(_DWORD*) (*(_DWORD*) (a1 + 4) + 25) = 1310740302;
        for(i = 0; i < 7; ++i)
            *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * i + 52) = 0;
    }
    if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48))
        sub_41E940();
    *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48) = malloc(0x69780u);
    v4 = *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48);
    *(_BYTE*) (v4 + 10) = byte_69D4BB;
    *(_BYTE*) (v4 + 9) = byte_69D4BA;
    *(_BYTE*) (v4 + 8) = word_69D4B0;
    *(_BYTE*) (v4 + 11) = dword_69D710;
    *(_WORD*) (v4 + 6) = word_69D4B6;
    *(_WORD*) (v4 + 4) = word_69D6CC;
    *(_BYTE*) (v4 + 12) = byte_69D4B9;
    *(_DWORD*) (a1 + 72) = v4 + 16;
    **(_DWORD**) (a1 + 72) = 0;
    *(_WORD*) (*(_DWORD*) (a1 + 72) + 4) = 0;
    *(_WORD*) (a1 + 68) = 0;
    return 0;
}
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B6: using guessed type __int16 word_69D4B6;
// 69D4B9: using guessed type char byte_69D4B9;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D6CC: using guessed type __int16 word_69D6CC;
// 69D710: using guessed type int dword_69D710;

//----- (0042A840) --------------------------------------------------------
int __cdecl sub_42A840(int a1) {
    int i; // [esp+4h] [ebp-8h]
    int v3; // [esp+8h] [ebp-4h]

    *(_DWORD*) a1 = 0;
    if(!*(_DWORD*) (a1 + 4)) {
        *(_DWORD*) (a1 + 4) = sub_41E290(*(char**) (a1 + 12), byte_69D4C4 == 0);
        if(sub_42A140(*(_DWORD*) (a1 + 4), dword_69D914))
            return -1;
        for(i = 0; i < 7; ++i) {
            if(*(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * i + 52))
                *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * i + 52) += *(_DWORD*) (a1 + 4);
        }
    }
    if(!*(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48))
        return -1;
    v3 = *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48);
    byte_69D4BD = *(unsigned __int8*) (*(_DWORD*) (a1 + 4) + 6) / 2;
    byte_69D4BE = *(_BYTE*) (*(_DWORD*) (a1 + 4) + 6) & 1;
    dword_69BCB0 = *(unsigned __int8*) (*(_DWORD*) (a1 + 4) + 7);
    word_69D4B6 = *(_WORD*) (v3 + 6);
    word_69D8F8 = *(_WORD*) (v3 + 4);
    dword_69D8FC = 0;
    dword_69D710 = *(unsigned __int8*) (v3 + 11);
    byte_69D4BA = *(_BYTE*) (v3 + 9);
    byte_69D4BB = *(_BYTE*) (v3 + 10);
    word_69D4B0 = *(unsigned __int8*) (v3 + 8);
    *(_DWORD*) (a1 + 72) = v3 + 16;
    byte_69D4B9 = *(_BYTE*) (v3 + 12);
    if(*(int*) dword_69D6D4 >= 2 && *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 44)) {
        dword_69BCA4 = **(_DWORD**) (*(_DWORD*) (a1 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 44);
        *(_DWORD*) dword_69BCA0 = dword_69BCA4;
    }
    return 0;
}
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4B0: using guessed type __int16 word_69D4B0;
// 69D4B6: using guessed type __int16 word_69D4B6;
// 69D4B9: using guessed type char byte_69D4B9;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D4C4: using guessed type char byte_69D4C4;
// 69D710: using guessed type int dword_69D710;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 69D8FC: using guessed type int dword_69D8FC;
// 69D914: using guessed type int dword_69D914;

//----- (0042AA20) --------------------------------------------------------
int __cdecl sub_42AA20(int a1) {
    sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 108));
    *(_DWORD*) (a1 + 108) = 0;
    if(*(_DWORD*) (a1 + 112)) {
        sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 112));
        *(_DWORD*) (a1 + 112) = 0;
    }
    free(*(void**) (dword_6D3F18 + 4));
    j__free((void*) dword_6D3F18);
    dword_6D3F18 = 0;
    return 0;
}
// 6D3F18: using guessed type int dword_6D3F18;

//----- (0042AAB0) --------------------------------------------------------
int sub_42AAB0() {
    int result; // eax
    int v1; // [esp+0h] [ebp-4h]

    result = dword_6D3F18;
    v1 = dword_6D3F18;
    if(dword_6D3F18) {
        *(_DWORD*) (dword_6D3F18 + 72) += 8;
        **(_DWORD**) (v1 + 72) = *(_DWORD*) v1;
        *(_WORD*) (*(_DWORD*) (v1 + 72) + 4) = 0;
        *(_DWORD*) (v1 + 72) += 8;
        **(_DWORD**) (v1 + 72) = 9999999;
        *(_WORD*) (*(_DWORD*) (v1 + 72) + 4) = 0;
        result = *(_DWORD*) (v1 + 72) + 8;
        *(_DWORD*) (v1 + 4 * *(_DWORD*) dword_69D6D4 + 72) = result;
    }
    return result;
}
// 6D3F18: using guessed type int dword_6D3F18;

//----- (0042AB30) --------------------------------------------------------
void __cdecl sub_42AB30(char* FileName, char* a2) {
    __int16 v2; // fps
    bool v3; // c0
    char v4; // c2
    bool v5; // c3
    char v6; // [esp+1Bh] [ebp-95h]
    char* v7; // [esp+20h] [ebp-90h]
    _BYTE* v9; // [esp+30h] [ebp-80h]
    _BYTE* v10; // [esp+30h] [ebp-80h]
    int k; // [esp+34h] [ebp-7Ch]
    char v12; // [esp+3Bh] [ebp-75h]
    unsigned __int8* v13; // [esp+3Ch] [ebp-74h]
    unsigned __int8* v14; // [esp+3Ch] [ebp-74h]
    int v15; // [esp+40h] [ebp-70h]
    int j; // [esp+44h] [ebp-6Ch]
    FILE* Stream; // [esp+48h] [ebp-68h]
    int v18; // [esp+4Ch] [ebp-64h]
    int v19 [21]; // [esp+50h] [ebp-60h] BYREF
    float v20; // [esp+A4h] [ebp-Ch]
    int v21; // [esp+A8h] [ebp-8h]
    int i; // [esp+ACh] [ebp-4h]
    unsigned int retaddr; // [esp+B4h] [ebp+4h]

    v19 [20] = retaddr ^ dword_47A630;
    if(dword_6D3F18) {
        v21 = dword_6D3F18;
        if(!*(_DWORD*) (dword_6D3F18 + 8)) {
            if(FileName) {
                qmemcpy(v19, *(const void**) (v21 + 4), 0x50u);
                sub_42AAB0();
                v18 = 80;
                for(i = 0; i < 7; ++i) {
                    if(*(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52)) {
                        v19 [i + 13] = v18;
                        v18 += *(_DWORD*) (v21 + 4 * i + 76) - *(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52);
                    }
                }
                sub_41E940();
                v19 [9] = *(_DWORD*) dword_69BCA0;
                v20 = flt_6C6ECC / flt_6C6ED0 - 0.5 + flt_6C6ECC / flt_6C6ED0 - 0.5;
                if(v20 >= 0.0) {
                    v3 = v20 < 1.0;
                    v4 = 0;
                    v5 = v20 == 1.0;
                    if((v2 & 0x100) == 0)
                        v20 = 1.0;
                }
                else {
                    v20 = 0.0;
                }
                *(float*) &v19 [11] = (1.0 - v20) * 100.0;
                *(float*) &v19 [10] = *(float*) &v19 [11] + 1.12;
                *(float*) &v19 [12] = *(float*) &v19 [11] + 2.3399999;
                **(_DWORD**) (*(_DWORD*) (v21 + 4) + 4 * *(_DWORD*) dword_69D6D4 + 48) = dword_69BCA4;
                v7 = (char*) &v19 [6] + 1;
                do {
                    v6 = *a2;
                    *v7++ = *a2++;
                }
                while(v6);
                _strdate((char*) &v19 [4]);
                BYTE2(v19 [3]) = (unsigned __int16) sub_41E780(&word_69D8F8) % 128 + 64;
                HIBYTE(v19 [3]) = (unsigned __int16) sub_41E780(&word_69D8F8) % 256;
                LOBYTE(v19 [3]) = (unsigned __int16) sub_41E780(&word_69D8F8) % 256;
                BYTE1(v19 [3]) = (unsigned __int16) sub_41E780(&word_69D8F8) % 256;
                v13 = (unsigned __int8*) &v19 [3] + 2;
                v15 = 1056965400;
                i = 0;
                while((unsigned int) i < 0x42) {
                    v15 += *v13;
                    ++i;
                    ++v13;
                }
                for(i = 0; i < 7; ++i) {
                    if(*(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52)) {
                        v14 = *(unsigned __int8**) (*(_DWORD*) (v21 + 4) + 4 * i + 52);
                        for(j = 0; j < *(_DWORD*) (v21 + 4 * i + 76) - *(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52); ++j)
                            v15 += *v14++;
                    }
                }
                v19 [2] = v15;
                v9 = (char*) &v19 [3] + 3;
                v12 = BYTE2(v19 [3]);
                i = 0;
                while((unsigned int) i < 0x41) {
                    *v9 += v12;
                    v12 += 7;
                    ++i;
                    ++v9;
                }
                for(i = 0; i < 7; ++i) {
                    if(*(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52)) {
                        v10 = *(_BYTE**) (*(_DWORD*) (v21 + 4) + 4 * i + 52);
                        for(k = 0; k < *(_DWORD*) (v21 + 4 * i + 76) - *(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52); ++k) {
                            *v10 += v12;
                            v12 += 7;
                            ++v10;
                        }
                    }
                }
                Stream = fopen(FileName, "wb");
                sub_45CB54(v19, 0x50u, 1u, Stream);
                for(i = 0; i < 7; ++i) {
                    if(*(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52))
                        sub_45CB54(
                            *(void**) (*(_DWORD*) (v21 + 4) + 4 * i + 52),
                            1u,
                            *(_DWORD*) (v21 + 4 * i + 76) - *(_DWORD*) (*(_DWORD*) (v21 + 4) + 4 * i + 52),
                            Stream);
                }
                fclose(Stream);
            }
            for(i = 0; i < 7; ++i) {
                if(*(_DWORD*) (*(_DWORD*) (dword_6D3F18 + 4) + 4 * i + 52)) {
                    sub_41E940();
                    free(*(void**) (*(_DWORD*) (dword_6D3F18 + 4) + 4 * i + 52));
                }
            }
        }
        sub_41CDE0(byte_69D918, *(_DWORD*) (dword_6D3F18 + 104));
    }
}
// 47A630: using guessed type int dword_47A630;
// 69BCA4: using guessed type int dword_69BCA4;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6ECC: using guessed type float flt_6C6ECC;
// 6C6ED0: using guessed type float flt_6C6ED0;
// 6D3F18: using guessed type int dword_6D3F18;

//----- (0042B0D9) --------------------------------------------------------
_DWORD* __cdecl sub_42B0D9(char* Str) {
    char* v1; // eax
    int i; // [esp+8h] [ebp-20h]
    char* v4; // [esp+Ch] [ebp-1Ch]
    int v5; // [esp+10h] [ebp-18h]
    _BYTE* v6; // [esp+14h] [ebp-14h]
    unsigned __int16 v7; // [esp+18h] [ebp-10h]
    char v8; // [esp+1Fh] [ebp-9h]
    int v9; // [esp+20h] [ebp-8h]
    _DWORD* Block; // [esp+24h] [ebp-4h]

    v1 = (char*) sub_41E290(Str, 1);
    Block = v1;
    if(!v1)
        goto LABEL_2;
    if((unsigned int) dword_69D914 < 0x14)
        goto LABEL_16;
    v5 = dword_69D914 - 2;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v6 = v1 + 1;
    while(v5 > 0) {
        v8 = (8 * ((*v6 + v8) & 0x1F)) | (((*v6 + v8) & 0xE0) >> 5);
        v6 [1] ^= v8;
        if(v9 >= 2)
            v7 += (unsigned __int8) v6 [1];
        ++v6;
        --v5;
        ++v9;
    }
    if(*((unsigned __int16*) v1 + 1) != v7)
        goto LABEL_16;
    v4 = &v1 [*((_DWORD*) v1 + 2)];
    for(i = *((_DWORD*) v1 + 4) - *((_DWORD*) v1 + 2);
        i > 0 && *(_DWORD*) v4 != 1261848660;
        i -= *((unsigned __int16*) v4 + 2)) {
        v4 += *((unsigned __int16*) v4 + 2);
    }
    if(i <= 0) {
        LABEL_16:
        free(v1);
        LABEL_2:
        Block = malloc(0x14u);
        Block [2] = 20;
        Block [4] = 20;
    }
    Block [3] = malloc(0xCu);
    *(_DWORD*) (Block [3] + 4) = 0;
    *(_DWORD*) (Block [3] + 8) = 0;
    *(_DWORD*) Block [3] = 0;
    return Block;
}
// 69D914: using guessed type int dword_69D914;

//----- (0042B280) --------------------------------------------------------
int __cdecl sub_42B280(_DWORD* a1, int a2, int a3, int a4) {
    int v7; // [esp+Ch] [ebp-8h]
    int v8; // [esp+10h] [ebp-4h]

    if(!a2) {
        sub_42B437((_DWORD*) a1 [3]);
        *(_DWORD*) (a1 [3] + 4) = 0;
        *(_DWORD*) (a1 [3] + 8) = 0;
        *(_DWORD*) a1 [3] = 0;
    }
    v8 = (int) a1 + a1 [2];
    v7 = a1 [4] - a1 [2];
    while(v7 > 0) {
        if(*(_DWORD*) v8 == 1380143944
           && *(_BYTE*) (v8 + 8) == 16
           && *(unsigned __int8*) (v8 + 16) == a3
           && *(unsigned __int8*) (v8 + 17) == a4) {
            if(a2)
                sub_42B3A6(a2, v8);
            else
                sub_42B3A6(a1 [3], v8);
        }
        v7 -= *(unsigned __int16*) (v8 + 4);
        v8 += *(unsigned __int16*) (v8 + 4);
    }
    if(!*(_DWORD*) (a1 [3] + 4))
        return 1000000;
    if(*(_DWORD*) (*(_DWORD*) (*(_DWORD*) (a1 [3] + 4) + 8) + 12) <= 0xF4240u)
        return 1000000;
    else
        return *(_DWORD*) (*(_DWORD*) (*(_DWORD*) (a1 [3] + 4) + 8) + 12);
}

//----- (0042B3A6) --------------------------------------------------------
int __cdecl sub_42B3A6(int a1, int a2) {
    int v3; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h]
    int v5; // [esp+14h] [ebp+8h]

    v4 = 0;
    while(*(_DWORD*) (a1 + 4)
          && (!*(_DWORD*) (*(_DWORD*) (a1 + 4) + 8)
          || *(_DWORD*) (*(_DWORD*) (*(_DWORD*) (a1 + 4) + 8) + 12) > *(_DWORD*) (a2 + 12))) {
        a1 = *(_DWORD*) (a1 + 4);
        ++v4;
    }
    v3 = *(_DWORD*) (a1 + 4);
    *(_DWORD*) (a1 + 4) = malloc(0xCu);
    **(_DWORD**) (a1 + 4) = a1;
    v5 = *(_DWORD*) (a1 + 4);
    *(_DWORD*) (v5 + 8) = a2;
    *(_DWORD*) (v5 + 4) = v3;
    return v4;
}

//----- (0042B437) --------------------------------------------------------
_DWORD* __cdecl sub_42B437(_DWORD* Block) {
    _DWORD* result; // eax
    int v2; // [esp+0h] [ebp-4h]
    _DWORD* Blocka; // [esp+Ch] [ebp+8h]

    result = (_DWORD*) Block [1];
    for(Blocka = result; Blocka; Blocka = (_DWORD*) v2) {
        v2 = Blocka [1];
        free(Blocka);
        result = (_DWORD*) v2;
    }
    return result;
}

//----- (0042B466) --------------------------------------------------------
int __cdecl sub_42B466(int a1, int a2) {
    int v3; // [esp+Ch] [ebp-8h]
    _DWORD* v4; // [esp+10h] [ebp-4h]

    if(!a2)
        return -1;
    v4 = (_DWORD*) (*(_DWORD*) (a1 + 8) + a1);
    v3 = *(_DWORD*) (a1 + 16) - *(_DWORD*) (a1 + 8);
    while(v3 > 0) {
        if(*v4 == 1263812931 && *((_BYTE*) v4 + 8) == 16) {
            if(*((unsigned __int16*) v4 + 8) >= 0x40u)
                return 0;
            qmemcpy((void*) ((*((unsigned __int16*) v4 + 8) << 6) + a2), v4, 0x40u);
        }
        v3 -= *((unsigned __int16*) v4 + 2);
        v4 = (_DWORD*) ((char*) v4 + *((unsigned __int16*) v4 + 2));
    }
    return 0;
}

//----- (0042B502) --------------------------------------------------------
int __cdecl sub_42B502(int a1, int a2) {
    int j; // [esp+Ch] [ebp-10h]
    int v4; // [esp+10h] [ebp-Ch]
    int i; // [esp+14h] [ebp-8h]
    _DWORD* v6; // [esp+18h] [ebp-4h]

    if(!a2)
        return -1;
    for(i = 0; i < 4; ++i) {
        memset((void*) (24 * i + a2), 0, 0x18u);
        *(_DWORD*) (a2 + 24 * i) = 1146244163;
        *(_WORD*) (a2 + 24 * i + 6) = 24;
        *(_WORD*) (a2 + 24 * i + 4) = 24;
        *(_BYTE*) (a2 + 24 * i + 8) = 16;
        *(_BYTE*) (a2 + 24 * i + 22) = i;
        for(j = 0; j < 5; ++j) {
            *(_BYTE*) (24 * i + a2 + j + 12) = 1;
            *(_BYTE*) (24 * i + a2 + j + 17) = 1;
        }
    }
    v6 = (_DWORD*) (*(_DWORD*) (a1 + 8) + a1);
    v4 = *(_DWORD*) (a1 + 16) - *(_DWORD*) (a1 + 8);
    while(v4 > 0) {
        if(*v6 == 1146244163 && *((_BYTE*) v6 + 8) == 16) {
            if(*((unsigned __int8*) v6 + 22) >= 4u)
                return 0;
            qmemcpy((void*) (24 * *((unsigned __int8*) v6 + 22) + a2), v6, 0x18u);
        }
        v4 -= *((unsigned __int16*) v6 + 2);
        v6 = (_DWORD*) ((char*) v6 + *((unsigned __int16*) v6 + 2));
    }
    return 0;
}

//----- (0042B65E) --------------------------------------------------------
int __cdecl sub_42B65E(int a1, _DWORD* a2) {
    int k; // [esp+Ch] [ebp-18h]
    int v4; // [esp+10h] [ebp-14h]
    int j; // [esp+14h] [ebp-10h]
    int i; // [esp+18h] [ebp-Ch]
    _DWORD* v7; // [esp+1Ch] [ebp-8h]
    _DWORD* v8; // [esp+20h] [ebp-4h]

    if(!a2)
        return -1;
    v8 = a2;
    for(i = 0; i < 4; ++i) {
        for(j = 0; j < 6; ++j) {
            for(k = 0; k < 4; ++k) {
                memset(v8, 0, 0x14u);
                *v8 = 1380143952;
                *((_WORD*) v8 + 3) = 20;
                *((_WORD*) v8 + 2) = 20;
                *((_BYTE*) v8 + 8) = 16;
                *((_BYTE*) v8 + 16) = i;
                *((_BYTE*) v8 + 17) = k;
                *((_BYTE*) v8 + 18) = j;
                v8 += 5;
            }
        }
    }
    v7 = (_DWORD*) (*(_DWORD*) (a1 + 8) + a1);
    v4 = *(_DWORD*) (a1 + 16) - *(_DWORD*) (a1 + 8);
    while(v4 > 0) {
        if(*v7 == 1380143952 && *((_BYTE*) v7 + 8) == 16) {
            if(*((unsigned __int8*) v7 + 16) >= 4u
               || *((unsigned __int8*) v7 + 17) >= 5u
               || *((unsigned __int8*) v7 + 18) >= 7u) {
                return 0;
            }
            qmemcpy(
                &a2 [120 * *((unsigned __int8*) v7 + 16) + 20 * *((unsigned __int8*) v7 + 18) + 5 * *((unsigned __int8*) v7 + 17)],
                v7,
                0x14u);
        }
        v4 -= *((unsigned __int16*) v7 + 2);
        v7 = (_DWORD*) ((char*) v7 + *((unsigned __int16*) v7 + 2));
    }
    return 0;
}

//----- (0042B7DC) --------------------------------------------------------
void __cdecl sub_42B7DC(void* a1) {
    sub_42B437(*((_DWORD**) a1 + 3));
    free(*((void**) a1 + 3));
    free(a1);
}

//----- (0042B809) --------------------------------------------------------
void __cdecl sub_42B809(int a1) {
    char* v1; // [esp+10h] [ebp-3Ch]
    char v2; // [esp+17h] [ebp-35h]
    char v3; // [esp+17h] [ebp-35h]
    int mm; // [esp+18h] [ebp-34h]
    int v5; // [esp+18h] [ebp-34h]
    char v6; // [esp+1Fh] [ebp-2Dh]
    int kk; // [esp+20h] [ebp-2Ch]
    int jj; // [esp+24h] [ebp-28h]
    _DWORD* v9; // [esp+28h] [ebp-24h]
    _DWORD* v10; // [esp+2Ch] [ebp-20h]
    _WORD* Src; // [esp+30h] [ebp-1Ch]
    int j; // [esp+34h] [ebp-18h]
    int v13; // [esp+38h] [ebp-14h]
    signed int ElementCount; // [esp+3Ch] [ebp-10h]
    char* Block; // [esp+40h] [ebp-Ch]
    int k; // [esp+44h] [ebp-8h]
    int i; // [esp+48h] [ebp-4h]
    int m; // [esp+48h] [ebp-4h]
    int n; // [esp+48h] [ebp-4h]
    int ii; // [esp+48h] [ebp-4h]

    Block = (char*) malloc(0xA0000u);
    memcpy(Block, *(const void**) a1, 0x14u);
    *(_DWORD*) (a1 + 20892) = 1261848660;
    *(_WORD*) (a1 + 20898) = 12;
    *(_WORD*) (a1 + 20896) = 12;
    *(_BYTE*) (a1 + 20900) = 16;
    memcpy(Block + 20, (const void*) (a1 + 20892), 0xCu);
    ElementCount = 32;
    for(i = 0; i < 5; ++i) {
        for(j = 0; j < 4; ++j) {
            v13 = *(_DWORD*) (a1 + 48 * i + 15024 + 12 * j + 4);
            for(k = 0; k < 10; ++k) {
                if(!v13)
                    break;
                if(**(_DWORD**) (v13 + 8) == 1380143944) {
                    *(_BYTE*) (*(_DWORD*) (v13 + 8) + 16) = j;
                    *(_BYTE*) (*(_DWORD*) (v13 + 8) + 17) = i;
                    *(_WORD*) (*(_DWORD*) (v13 + 8) + 6) = 28;
                    *(_WORD*) (*(_DWORD*) (v13 + 8) + 4) = 28;
                    *(_BYTE*) (*(_DWORD*) (v13 + 8) + 8) = 16;
                    *(_BYTE*) (*(_DWORD*) (v13 + 8) + 9) = 0;
                    memcpy(&Block [ElementCount], *(const void**) (v13 + 8), 0x1Cu);
                    ElementCount += 28;
                }
                v13 = *(_DWORD*) (v13 + 4);
            }
        }
    }
    Src = &unk_69CCD0;
    for(m = 0; m < 4; ++m) {
        *(_DWORD*) Src = 1146244163;
        Src [3] = 24;
        Src [2] = 24;
        *((_BYTE*) Src + 8) = 16;
        memcpy(&Block [ElementCount], Src, 0x18u);
        ElementCount += 24;
        Src += 12;
    }
    v10 = &unk_69BCD0;
    for(n = 0; n < 64; ++n) {
        if(*v10 == 1263812931) {
            *((_WORD*) v10 + 8) = n;
            *((_WORD*) v10 + 3) = 64;
            *((_WORD*) v10 + 2) = 64;
            *((_BYTE*) v10 + 8) = 16;
            memcpy(&Block [ElementCount], v10, 0x40u);
            ElementCount += 64;
        }
        v10 += 16;
    }
    v9 = dword_69CD30;
    for(ii = 0; ii < 4; ++ii) {
        for(jj = 0; jj < 6; ++jj) {
            for(kk = 0; kk < 4; ++kk) {
                if(v9 [3]) {
                    memcpy(&Block [ElementCount], v9, 0x14u);
                    ElementCount += 20;
                }
                v9 += 5;
            }
        }
    }
    *((_DWORD*) Block + 2) = 20;
    *((_DWORD*) Block + 4) = ElementCount;
    *((_WORD*) Block + 1) = 0;
    Block [1] = (unsigned __int16) sub_41E780(&word_69D8F8) % 256;
    Block [6] = (unsigned __int16) sub_41E780(&word_69D8F8) % 256;
    *((_WORD*) Block + 2) = 16;
    for(mm = 4; mm < ElementCount; ++mm)
        *((_WORD*) Block + 1) += (unsigned __int8) Block [mm];
    v1 = Block + 1;
    v5 = ElementCount - 2;
    v2 = Block [1];
    while(v5 > 0) {
        v6 = v1 [1];
        v3 = (8 * (v2 & 0x1F)) | ((v2 & 0xE0) >> 5);
        v1 [1] = v3 ^ v6;
        v2 = v6 + v3;
        ++v1;
        --v5;
    }
    sub_41E460("score.dat", Block, ElementCount);
    free(Block);
}
// 69CD30: using guessed type _DWORD dword_69CD30[480];
// 69D8F8: using guessed type __int16 word_69D8F8;

//----- (0042BC2D) --------------------------------------------------------
int __thiscall sub_42BC2D(void* this, int a2, int a3, int a4) {
    return sub_42B3A6((int) this + 48 * a3 + 12 * a4 + 15024, a2);
}

//----- (0042BC5B) --------------------------------------------------------
_DWORD* __thiscall sub_42BC5B(_DWORD* this, int a2, int a3) {
    return sub_42B437(&this [12 * a2 + 3756 + 3 * a3]);
}

//----- (0042BC85) --------------------------------------------------------
int __thiscall sub_42BC85(int this) {
    int v2; // [esp+0h] [ebp-1Ch]
    int v3; // [esp+4h] [ebp-18h]
    int v5; // [esp+14h] [ebp-8h]
    int v6; // [esp+14h] [ebp-8h]
    int i; // [esp+18h] [ebp-4h]
    int j; // [esp+18h] [ebp-4h]

    if(!*(_DWORD*) (this + 4)) {
        *(_DWORD*) (this + 36) = (unsigned __int8) byte_69D4BD;
        *(_DWORD*) (this + 44) = dword_69BCB0;
        v5 = this + 64;
        for(i = 0; i < 38; ++i) {
            *(_WORD*) (v5 + 138) = *(_DWORD*) (this + 44) + 3;
            v5 += 272;
        }
        sub_434E20((_DWORD*) dword_6D4588, this + 10400, 0xFFFFFFu, 0, (&off_4784D8) [2 * *(_DWORD*) (this + 36)]);
        if(byte_69D4BE)
            *(_DWORD*) (this + 10524) = -2130706433;
        sub_434E20((_DWORD*) dword_6D4588, this + 10672, 0xFFFFFFu, 0, (&off_4784DC) [2 * *(_DWORD*) (this + 36)]);
        if(byte_69D4BE != 1)
            *(_DWORD*) (this + 10796) = -2130706433;
        *(_BYTE*) (this + 20880) = byte_69D4BE + 2 * *(_DWORD*) (this + 36);
        *(_BYTE*) (this + 20881) = *(_BYTE*) (this + 44);
        *(_DWORD*) (this + 20876) = dword_69BCA4;
        *(_BYTE*) (this + 20872) = 16;
        *(_DWORD*) (this + 20864) = 1380143944;
        if(byte_69D4C2)
            *(_BYTE*) (this + 20882) = 99;
        else
            *(_BYTE*) (this + 20882) = dword_69D6D4 [0];
        *(_BYTE*) (this + 20873) = 1;
        strcpy((char*) (this + 20883), "        ");
        if(sub_42BC2D(
            (void*) this,
            this + 20864,
            *(_DWORD*) (this + 44),
            (unsigned __int8) byte_69D4BE + 2 * *(_DWORD*) (this + 36)) >= 10)
            goto LABEL_79;
        *(_DWORD*) (this + 16) = 0;
        strcpy((char*) (this + 52), byte_46BC09);
    }
    if(*(int*) (this + 4) < 30)
        return 0;
    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
       || (word_69D904 & 0x10) != 0 && word_69D90C) {
        do {
            *(_DWORD*) (this + 32) -= 16;
            if(*(int*) (this + 32) < 0)
                *(_DWORD*) (this + 32) += 96;
        }
        while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    if((word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)
       || (word_69D904 & 0x20) != 0 && word_69D90C) {
        do {
            *(_DWORD*) (this + 32) += 16;
            if(*(int*) (this + 32) >= 96)
                *(_DWORD*) (this + 32) -= 96;
        }
        while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    if((word_69D904 & 0x40) != 0 && (word_69D904 & 0x40) != (word_69D908 & 0x40)
       || (word_69D904 & 0x40) != 0 && word_69D90C) {
        do {
            if(-- * (_DWORD*) (this + 32) % 16 == 15)
                *(_DWORD*) (this + 32) += 16;
            if(*(int*) (this + 32) < 0)
                *(_DWORD*) (this + 32) = 15;
        }
        while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    if((word_69D904 & 0x80) != 0 && (word_69D904 & 0x80) != (word_69D908 & 0x80)
       || (word_69D904 & 0x80) != 0 && word_69D90C) {
        do {
            if(!(++ * (_DWORD*) (this + 32) % 16))
                *(_DWORD*) (this + 32) -= 16;
        }
        while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    if(((word_69D904 & 0x1001) == 0 || (word_69D904 & 0x1001) == (word_69D908 & 0x1001))
       && ((word_69D904 & 0x1001) == 0 || !word_69D90C)) {
        goto LABEL_66;
    }
    if(*(int*) (this + 16) < 8)
        v3 = *(_DWORD*) (this + 16);
    else
        v3 = 7;
    if(*(int*) (this + 32) < 94) {
        *(_BYTE*) (v3 + this + 20883) = *((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32));
        goto LABEL_62;
    }
    if(*(_DWORD*) (this + 32) == 94) {
        *(_BYTE*) (v3 + this + 20883) = 32;
        LABEL_62:
        if(*(int*) (this + 16) < 8 && ++ * (_DWORD*) (this + 16) == 8)
            *(_DWORD*) (this + 32) = 95;
        sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
        LABEL_66:
        if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)
           || (word_69D904 & 0xA) != 0 && word_69D90C) {
            if(*(int*) (this + 16) < 8)
                v2 = *(_DWORD*) (this + 16);
            else
                v2 = 7;
            if(*(int*) (this + 16) > 0) {
                --* (_DWORD*) (this + 16);
                *(_BYTE*) (v2 + this + 20883) = 32;
            }
            sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
        }
        if((word_69D904 & 8) == 0 || (word_69D904 & 8) == (word_69D908 & 8))
            return 0;
    }
    sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
    LABEL_79:
    *(_DWORD*) (this + 8) = 15;
    *(_DWORD*) (this + 4) = 0;
    v6 = this + 64;
    for(j = 0; j < 38; ++j) {
        *(_WORD*) (v6 + 138) = 2;
        v6 += 272;
    }
    strcpy((char*) (this + 52), (const char*) (this + 20883));
    return 0;
}
// 4784D4: using guessed type void *off_4784D4;
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D4C2: using guessed type char byte_69D4C2;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0042C2D4) --------------------------------------------------------
int __thiscall sub_42C2D4(int this) {
    unsigned int v1; // eax
    unsigned int v3; // eax
    int v4; // [esp+8h] [ebp-B4h]
    int v5; // [esp+Ch] [ebp-B0h]
    int v6; // [esp+10h] [ebp-ACh]
    char FileName [68]; // [esp+1Ch] [ebp-A0h] BYREF
    int v9; // [esp+60h] [ebp-5Ch]
    char Buffer [68]; // [esp+64h] [ebp-58h] BYREF
    unsigned int v11; // [esp+A8h] [ebp-14h]
    void* Block; // [esp+ACh] [ebp-10h]
    int i; // [esp+B0h] [ebp-Ch]
    int v14; // [esp+B4h] [ebp-8h]
    int v15; // [esp+B8h] [ebp-4h]
    unsigned int retaddr; // [esp+C0h] [ebp+4h]

    v11 = retaddr ^ dword_47A630;
    v6 = *(_DWORD*) (this + 8);
    switch(v6) {
        case 10:
            if(*(_DWORD*) (this + 4) == 60) {
                if(byte_69D4B8) {
                    v14 = 12;
                }
                else if(*(float*) &dword_6C6EC4 >= 0.99000001) {
                    v14 = 9;
                }
                else {
                    v14 = 13;
                }
                v15 = this + 336;
                i = 0;
                while(i < 38) {
                    *(_WORD*) (v15 + 138) = v14;
                    ++i;
                    v15 += 272;
                }
                if(v14 != 9)
                    *(_DWORD*) (this + 8) = 11;
                *(_DWORD*) (this + 16) = 0;
            }
            v15 = this + 4416;
            if(*(_DWORD*) (this + 16)) {
                *(_DWORD*) (v15 + 124) = (unsigned int) &unk_606060 | *(_DWORD*) (v15 + 124) & 0xFF000000;
                v1 = *(_DWORD*) (v15 + 396) & 0xFF000000 | 0xFF6060;
            }
            else {
                *(_DWORD*) (v15 + 124) = *(_DWORD*) (v15 + 124) & 0xFF000000 | 0xFF6060;
                v1 = (unsigned int) &unk_606060 | *(_DWORD*) (v15 + 396) & 0xFF000000;
            }
            *(_DWORD*) (v15 + 396) = v1;
            if(*(int*) (this + 4) < 80)
                return 0;
            sub_42D18F(this, 2);
            if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)
               || (word_69D904 & 8) != 0 && (word_69D904 & 8) != (word_69D908 & 8)) {
                goto LABEL_36;
            }
            if((word_69D904 & 0x1001) == 0 || (word_69D904 & 0x1001) == (word_69D908 & 0x1001))
                return 0;
            if(*(_DWORD*) (this + 16)) {
                LABEL_36:
                *(_DWORD*) (this + 4) = 0;
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                *(_DWORD*) (this + 8) = 2;
                v15 = this + 64;
                i = 0;
                while(i < 38) {
                    *(_WORD*) (v15 + 138) = 2;
                    ++i;
                    v15 += 272;
                }
                return 0;
            }
            goto LABEL_32;
        case 11:
            if(*(int*) (this + 4) < 20)
                return 0;
            if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)
               || (word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                *(_DWORD*) (this + 4) = 0;
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                *(_DWORD*) (this + 8) = 2;
                v15 = this + 64;
                i = 0;
                while(i < 38) {
                    *(_WORD*) (v15 + 138) = 2;
                    ++i;
                    v15 += 272;
                }
            }
            return 0;
        case 12:
            LABEL_50:
            if(!*(_DWORD*) (this + 4)) {
                _mkdir("replay");
                for(i = 0; i < 15; ++i) {
                    sprintf(Buffer, "./replay/th6_%.2d.rpy", i + 1);
                    Block = sub_41E290(Buffer, 1);
                    if(Block) {
                        if(!sub_42A140((int) Block, dword_69D914))
                            qmemcpy((void*) (this + 80 * i + 20912), Block, 0x50u);
                        free(Block);
                    }
                }
            }
            if(*(int*) (this + 4) < 20)
                return 0;
            sub_42D0A4(this, 15);
            *(_DWORD*) (this + 28) = *(_DWORD*) (this + 16);
            if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                *(_DWORD*) (this + 28) = *(_DWORD*) (this + 16);
                *(_DWORD*) (this + 4) = 0;
                _strdate((char*) (this + 22128));
                *(_DWORD*) (this + 22148) = dword_69BCA4;
                if(*(_DWORD*) (this + 80 * *(_DWORD*) (this + 16) + 20912) == 1347565140
                   && *(_WORD*) (this + 80 * *(_DWORD*) (this + 16) + 20916) == 258) {
                    v15 = this + 64;
                    i = 0;
                    while(i < 38) {
                        *(_WORD*) (v15 + 138) = 11;
                        ++i;
                        v15 += 272;
                    }
                    v15 = this + 272 * (*(_DWORD*) (this + 28) + 22) + 64;
                    *(_WORD*) (v15 + 138) = 14;
                    *(_DWORD*) (this + 8) = 14;
                }
                else {
                    v15 = this + 64;
                    i = 0;
                    while(i < 38) {
                        *(_WORD*) (v15 + 138) = 15;
                        ++i;
                        v15 += 272;
                    }
                    v15 = this + 272 * (*(_DWORD*) (this + 28) + 22) + 64;
                    *(_WORD*) (v15 + 138) = 14;
                    *(_DWORD*) (this + 8) = 13;
                }
                *(_DWORD*) (this + 16) = 0;
                *(_DWORD*) (this + 32) = 0;
            }
            if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                *(_DWORD*) (this + 8) = 10;
                v15 = this + 64;
                i = 0;
                while(i < 38) {
                    *(_WORD*) (v15 + 138) = 2;
                    ++i;
                    v15 += 272;
                }
                *(_DWORD*) (this + 4) = 0;
            }
            return 0;
        case 13:
            if(*(int*) (this + 4) < 30)
                return 0;
            if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
               || (word_69D904 & 0x10) != 0 && word_69D90C) {
                do {
                    *(_DWORD*) (this + 32) -= 16;
                    if(*(int*) (this + 32) < 0)
                        *(_DWORD*) (this + 32) += 96;
                }
                while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
            }
            if((word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)
               || (word_69D904 & 0x20) != 0 && word_69D90C) {
                do {
                    *(_DWORD*) (this + 32) += 16;
                    if(*(int*) (this + 32) >= 96)
                        *(_DWORD*) (this + 32) -= 96;
                }
                while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
            }
            if((word_69D904 & 0x40) != 0 && (word_69D904 & 0x40) != (word_69D908 & 0x40)
               || (word_69D904 & 0x40) != 0 && word_69D90C) {
                do {
                    if(-- * (_DWORD*) (this + 32) % 16 == 15)
                        *(_DWORD*) (this + 32) += 16;
                    if(*(int*) (this + 32) < 0)
                        *(_DWORD*) (this + 32) = 15;
                }
                while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
            }
            if((word_69D904 & 0x80) != 0 && (word_69D904 & 0x80) != (word_69D908 & 0x80)
               || (word_69D904 & 0x80) != 0 && word_69D90C) {
                do {
                    if(!(++ * (_DWORD*) (this + 32) % 16))
                        *(_DWORD*) (this + 32) -= 16;
                }
                while(*((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32)) == 32);
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
            }
            if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)
               || (word_69D904 & 0x1001) != 0 && word_69D90C) {
                if(*(int*) (this + 16) < 8)
                    v5 = *(_DWORD*) (this + 16);
                else
                    v5 = 7;
                v9 = v5;
                if(*(int*) (this + 32) >= 94) {
                    if(*(_DWORD*) (this + 32) == 94) {
                        *(_BYTE*) (v9 + this + 52) = 32;
                    }
                    else {
                        sprintf(FileName, "./replay/th6_%.2d.rpy", *(_DWORD*) (this + 28) + 1);
                        sub_42AB30(FileName, (char*) (this + 52));
                        *(_DWORD*) (this + 4) = 0;
                        *(_DWORD*) (this + 8) = 2;
                        v15 = this + 64;
                        i = 0;
                        while(i < 38) {
                            *(_WORD*) (v15 + 138) = 2;
                            ++i;
                            v15 += 272;
                        }
                    }
                }
                else {
                    *(_BYTE*) (v9 + this + 52) = *((_BYTE*) off_4784D4 + *(_DWORD*) (this + 32));
                }
                if(*(int*) (this + 16) < 8 && ++ * (_DWORD*) (this + 16) == 8)
                    *(_DWORD*) (this + 32) = 95;
                sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
            }
            if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)
               || (word_69D904 & 0xA) != 0 && word_69D90C) {
                if(*(int*) (this + 16) < 8)
                    v4 = *(_DWORD*) (this + 16);
                else
                    v4 = 7;
                if(*(int*) (this + 16) > 0) {
                    --* (_DWORD*) (this + 16);
                    *(_BYTE*) (v4 + this + 52) = 32;
                }
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
            }
            if((word_69D904 & 8) == 0 || (word_69D904 & 8) == (word_69D908 & 8))
                return 0;
            LABEL_32:
            sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
            *(_DWORD*) (this + 8) = 12;
            v15 = this + 64;
            i = 0;
            while(i < 38) {
                *(_WORD*) (v15 + 138) = 10;
                ++i;
                v15 += 272;
            }
            *(_DWORD*) (this + 4) = 0;
            goto LABEL_50;
        case 14:
            v15 = this + 4416;
            if(*(_DWORD*) (this + 16)) {
                *(_DWORD*) (v15 + 124) = (unsigned int) &unk_606060 | *(_DWORD*) (v15 + 124) & 0xFF000000;
                v3 = *(_DWORD*) (v15 + 396) & 0xFF000000 | 0xFF6060;
            }
            else {
                *(_DWORD*) (v15 + 124) = *(_DWORD*) (v15 + 124) & 0xFF000000 | 0xFF6060;
                v3 = (unsigned int) &unk_606060 | *(_DWORD*) (v15 + 396) & 0xFF000000;
            }
            *(_DWORD*) (v15 + 396) = v3;
            if(*(int*) (this + 4) < 20)
                return 0;
            sub_42D18F(this, 2);
            if(((word_69D904 & 0xA) == 0 || (word_69D904 & 0xA) == (word_69D908 & 0xA))
               && ((word_69D904 & 8) == 0 || (word_69D904 & 8) == (word_69D908 & 8))) {
                if((word_69D904 & 0x1001) == 0 || (word_69D904 & 0x1001) == (word_69D908 & 0x1001))
                    return 0;
                *(_DWORD*) (this + 4) = 0;
                if(!*(_DWORD*) (this + 16)) {
                    v15 = this + 64;
                    i = 0;
                    while(i < 38) {
                        *(_WORD*) (v15 + 138) = 15;
                        ++i;
                        v15 += 272;
                    }
                    *(_WORD*) (this + 272 * (*(_DWORD*) (this + 28) + 22) + 202) = 14;
                    *(_DWORD*) (this + 8) = 13;
                    return 0;
                }
            }
            goto LABEL_32;
    }
    return 0;
}
// 4784D4: using guessed type void *off_4784D4;
// 47A630: using guessed type int dword_47A630;
// 69BCA4: using guessed type int dword_69BCA4;
// 69D4B8: using guessed type char byte_69D4B8;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 69D914: using guessed type int dword_69D914;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0042D0A4) --------------------------------------------------------
int __cdecl sub_42D0A4(int a1, int a2) {
    int result; // eax

    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
       || (word_69D904 & 0x10) != 0 && word_69D90C) {
        if((int)-- * (_DWORD*) (a1 + 16) < 0)
            *(_DWORD*) (a1 + 16) += a2;
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    if((word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)
       || (result = word_69D904 & 0x20, (word_69D904 & 0x20) != 0) && (result = (unsigned __int16) word_69D90C, word_69D90C)) {
        if(++ * (_DWORD*) (a1 + 16) >= a2)
            *(_DWORD*) (a1 + 16) -= a2;
        return (int) sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
    }
    return result;
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0042D18F) --------------------------------------------------------
int __cdecl sub_42D18F(int a1, int a2) {
    if((word_69D904 & 0x40) != 0 && (word_69D904 & 0x40) != (word_69D908 & 0x40)
       || (word_69D904 & 0x40) != 0 && word_69D90C) {
        if((int)-- * (_DWORD*) (a1 + 16) < 0)
            *(_DWORD*) (a1 + 16) += a2;
        LABEL_7:
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
        return 1;
    }
    if((word_69D904 & 0x80) != 0 && (word_69D904 & 0x80) != (word_69D908 & 0x80)
       || (word_69D904 & 0x80) != 0 && word_69D90C) {
        if(++ * (_DWORD*) (a1 + 16) >= a2)
            *(_DWORD*) (a1 + 16) -= a2;
        goto LABEL_7;
    }
    return 0;
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0042D292) --------------------------------------------------------
int __thiscall sub_42D292(int this) {
    int v2; // [esp+0h] [ebp-Ch]

    v2 = *(_DWORD*) (this + 8);
    if(v2 == 15) {
        if(*(int*) (this + 4) <= 30)
            *(_WORD*) (this + 10266) = 16;
        if(*(int*) (this + 4) >= 90 && (word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
            *(_WORD*) (this + 10266) = 2;
            *(_DWORD*) (this + 4) = 0;
            *(_DWORD*) (this + 8) = 16;
        }
    }
    else if(v2 == 16 && *(int*) (this + 4) >= 30) {
        *(_DWORD*) (this + 4) = 59;
        *(_DWORD*) (this + 8) = 10;
    }
    return 0;
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;

//----- (0042D35A) --------------------------------------------------------
int __thiscall sub_42D35A(float* this) {
    double v1; // st7
    int v2; // edx
    float v4; // [esp+3Ch] [ebp-34h]
    float v5; // [esp+40h] [ebp-30h]
    float v6; // [esp+44h] [ebp-2Ch]
    int v7; // [esp+48h] [ebp-28h]
    float v8; // [esp+54h] [ebp-1Ch]
    float v9; // [esp+54h] [ebp-1Ch]
    int v10; // [esp+60h] [ebp-10h] BYREF
    float v11; // [esp+64h] [ebp-Ch]
    int v12; // [esp+68h] [ebp-8h]
    float* v13; // [esp+6Ch] [ebp-4h]

    v7 = *((_DWORD*) this + 2);
    if(v7 >= 15 && v7 <= 16) {
        v13 = this + 2532;
        dword_481B24 = *((_DWORD*) this + 2563);
        if(dword_69BCB0 >= 4) {
            v4 = (float) dword_69D70C;
            v1 = v4 / 39600.0;
        }
        else {
            v6 = (float) dword_69D70C;
            v1 = v6 / 89500.0;
        }
        v10 = *((int*) v13 + 36);
        v11 = v13 [37];
        v12 = *((_DWORD*) v13 + 38);
        *(float*) &v10 = *(float*) &v10 + 224.0;
        v11 = v11 + 32.0;
        sub_401650(dword_47B900, &v10, (char*) off_46BCC0, *(_DWORD*) dword_69BCA0);
        v11 = v11 + 22.0;
        sub_401530(dword_47B900, v2, &v10, off_478504 [dword_69BCB0]);
        v11 = v11 + 22.0;
        if(dword_69BCB0 && byte_69D4C2) {
            sub_401650(dword_47B900, &v10, "      100%%");
        }
        else {
            v5 = v1;
            sub_401650(dword_47B900, &v10, "    %3.2f%%", v5 * 100.0);
        }
        v11 = v11 + 22.0;
        sub_401650(dword_47B900, &v10, (char*) off_46BCC0, (unsigned __int8) byte_69D4B8);
        v11 = v11 + 22.0;
        sub_401650(dword_47B900, &v10, (char*) off_46BCC0, *(_DWORD*) dword_69BCC0);
        v11 = v11 + 22.0;
        sub_401650(dword_47B900, &v10, (char*) off_46BCC0, *(_DWORD*) dword_69BCC4);
        v11 = v11 + 22.0;
        sub_401650(dword_47B900, &v10, (char*) off_46BCC0, *(_DWORD*) dword_69BCC8);
        v8 = flt_6C6ECC / flt_6C6ED0 - 0.5 + flt_6C6ECC / flt_6C6ED0 - 0.5;
        if(v8 >= 0.0) {
            if(v8 >= 1.0)
                v8 = 1.0;
        }
        else {
            v8 = 0.0;
        }
        v9 = (1.0 - v8) * 100.0;
        v11 = v11 + 22.0;
        sub_401650(dword_47B900, &v10, "    %3.2f%%", v9);
        dword_481B24 = -1;
    }
    return 0;
}
// 42D4A9: variable 'v2' is possibly undefined
// 478504: using guessed type char *off_478504[9];
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCB8: using guessed type int dword_69BCB8;
// 69D4B6: using guessed type __int16 word_69D4B6;
// 69D4B8: using guessed type char byte_69D4B8;
// 69D4C2: using guessed type char byte_69D4C2;
// 69D70C: using guessed type int dword_69D70C;
// 6C6ECC: using guessed type float flt_6C6ECC;
// 6C6ED0: using guessed type float flt_6C6ED0;

//----- (0042D773) --------------------------------------------------------
int __cdecl sub_42D773(int a1) {
    _DWORD* v1; // eax
    _DWORD* v3; // [esp+0h] [ebp-60h]

    v1 = operator new(0x56B0u);
    if(v1)
        v3 = sub_42D8A1(v1);
    else
        v3 = 0;
    sub_42F6C4();
    v3 [5226] = sub_41CD40((int) sub_42D98E);
    *(_DWORD*) (v3 [5226] + 8) = sub_42F060;
    *(_DWORD*) (v3 [5226] + 12) = sub_42F5BC;
    *(_DWORD*) (v3 [5226] + 28) = v3;
    if(a1) {
        if(byte_69D4C3)
            v3 [2] = 17;
        else
            v3 [2] = 9;
    }
    if(sub_41C860(byte_69D918, v3 [5226], 13))
        return -1;
    v3 [5227] = sub_41CD40((int) sub_42E446);
    *(_DWORD*) (v3 [5227] + 28) = v3;
    sub_41C940((__int16*) byte_69D918, v3 [5227], 12);
    return 0;
}
// 69D4C3: using guessed type char byte_69D4C3;
// 69D70C: using guessed type int dword_69D70C;

//----- (0042D8A1) --------------------------------------------------------
_DWORD* __thiscall sub_42D8A1(_DWORD* this) {
    _DWORD* k; // [esp+4h] [ebp-54h]
    int v4; // [esp+Ch] [ebp-4Ch]
    int j; // [esp+20h] [ebp-38h]
    int v6; // [esp+28h] [ebp-30h]
    int i; // [esp+3Ch] [ebp-1Ch]
    int v8; // [esp+44h] [ebp-14h]

    v8 = 38;
    for(i = (int) (this + 16); --v8 >= 0; i += 272)
        sub_403720(i);
    v6 = 16;
    for(j = (int) (this + 2600); --v6 >= 0; j += 272)
        sub_403720(j);
    sub_403720((int) (this + 3688));
    v4 = 20;
    for(k = this + 3756; --v4 >= 0; k += 3) {
        *k = 0;
        k [1] = 0;
        k [2] = 0;
    }
    memset(this, 0, 0x56B0u);
    this [4] = 1;
    return this;
}

//----- (0042D98E) --------------------------------------------------------
int __cdecl sub_42D98E(_DWORD* a1) {
    int v2; // eax
    int v3; // [esp+8h] [ebp-48h]
    int v4; // [esp+Ch] [ebp-44h]
    int i1; // [esp+40h] [ebp-10h]
    int nn; // [esp+44h] [ebp-Ch]
    _DWORD* v7; // [esp+48h] [ebp-8h]
    float* v8; // [esp+48h] [ebp-8h]
    float* v9; // [esp+48h] [ebp-8h]
    _DWORD* v10; // [esp+48h] [ebp-8h]
    _DWORD* v11; // [esp+48h] [ebp-8h]
    _DWORD* v12; // [esp+48h] [ebp-8h]
    _DWORD* v13; // [esp+48h] [ebp-8h]
    _DWORD* v14; // [esp+48h] [ebp-8h]
    int v15; // [esp+48h] [ebp-8h]
    int m; // [esp+4Ch] [ebp-4h]
    int n; // [esp+4Ch] [ebp-4h]
    int ii; // [esp+4Ch] [ebp-4h]
    int jj; // [esp+4Ch] [ebp-4h]
    int kk; // [esp+4Ch] [ebp-4h]
    int mm; // [esp+4Ch] [ebp-4h]
    int i2; // [esp+4Ch] [ebp-4h]
    int i3; // [esp+4Ch] [ebp-4h]
    int i; // [esp+4Ch] [ebp-4h]
    int j; // [esp+4Ch] [ebp-4h]
    int k; // [esp+4Ch] [ebp-4h]
    int i4; // [esp+4Ch] [ebp-4h]

    v4 = a1 [2];
    if(v4 > 8) {
        if(v4 == 9) {
            sub_42BC85((int) a1);
        }
        else if(v4 <= 14) {
            sub_42C2D4((int) a1);
        }
        else if(v4 <= 16) {
            sub_42D292((int) a1);
        }
        else if(v4 == 17) {
            dword_6C6EA4 = 1;
            return 0;
        }
        goto LABEL_145;
    }
    switch(v4) {
        case 8:
            if(a1 [10] != a1 [4] && a1 [1] == 20) {
                a1 [10] = a1 [4];
                for(i = 10 * a1 [10]; i < 10 * a1 [10] + 10 && i < 64; ++i) {
                    if(word_69BD0C [32 * i])
                        sub_434B60(
                            (_DWORD*) dword_6D4588,
                            (int) &a1 [68 * (i % 10) + 2600],
                            0xFFFFFFu,
                            0,
                            (char*) (dword_4760DC + 80 * i));
                    else
                        sub_434B60((_DWORD*) dword_6D4588, (int) &a1 [68 * (i % 10) + 2600], 0xFFFFFFu, 0, "? ? ? ? ?");
                }
            }
            if((int) a1 [1] >= 30) {
                if(sub_42D18F((int) a1, 7)) {
                    a1 [1] = 0;
                    v13 = a1 + 16;
                    for(j = 0; j < 38; ++j) {
                        *((_WORD*) v13 + 69) = a1 [11] + 3;
                        v13 += 68;
                    }
                }
                if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                    sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                    a1 [2] = 0;
                    a1 [1] = 1;
                    v14 = a1 + 16;
                    for(k = 0; k < 38; ++k) {
                        *((_WORD*) v14 + 69) = 1;
                        v14 += 68;
                    }
                    a1 [6] = a1 [4];
                    a1 [4] = a1 [11];
                }
            }
            break;
        case 0:
            if(!a1 [1]) {
                v7 = a1 + 16;
                for(m = 0; m < 38; ++m) {
                    *((_WORD*) v7 + 69) = 1;
                    v2 = v7 [32];
                    LOBYTE(v2) = v2 | 8;
                    v7 [32] = v2;
                    if((dword_6C6E60 & 1) != 0)
                        v7 [31] = v7 [31];
                    else
                        v7 [31] &= 0xFF000000;
                    v7 += 68;
                }
                v8 = (float*) (a1 + 84);
                for(n = 0; n <= 6; ++n) {
                    if(n == a1 [4]) {
                        if((dword_6C6E60 & 1) != 0)
                            v8 [31] = NAN;
                        else
                            v8 [31] = -2.7689643e38;
                        v8 [57] = -4.0;
                        v8 [58] = -4.0;
                        v8 [59] = 0.0;
                    }
                    else {
                        if((dword_6C6E60 & 1) != 0)
                            v8 [31] = -0.000000001862645;
                        else
                            v8 [31] = -4.6566129e-10;
                        v8 [57] = 0.0;
                        v8 [58] = 0.0;
                        v8 [59] = 0.0;
                    }
                    v8 += 68;
                }
            }
            if((int) a1 [1] < 20)
                break;
            ++a1 [2];
            a1 [1] = 0;
            goto LABEL_35;
        case 1:
            LABEL_35:
            sub_42D0A4((int) a1, 7);
            v9 = (float*) (a1 + 84);
            for(ii = 0; ii <= 6; ++ii) {
                if(ii == a1 [4]) {
                    if((dword_6C6E60 & 1) != 0)
                        v9 [31] = NAN;
                    else
                        v9 [31] = -2.7689643e38;
                    v9 [57] = -4.0;
                    v9 [58] = -4.0;
                    v9 [59] = 0.0;
                }
                else {
                    if((dword_6C6E60 & 1) != 0)
                        v9 [31] = -0.000000001862645;
                    else
                        v9 [31] = -4.6566129e-10;
                    v9 [57] = 0.0;
                    v9 [58] = 0.0;
                    v9 [59] = 0.0;
                }
                v9 += 68;
            }
            if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                v10 = a1 + 16;
                v3 = a1 [4];
                if(v3 >= 0) {
                    if(v3 <= 4) {
                        for(jj = 0; jj < 38; ++jj) {
                            *((_WORD*) v10 + 69) = a1 [4] + 3;
                            v10 += 68;
                        }
                        a1 [11] = a1 [4];
                        a1 [2] = a1 [4] + 3;
                        a1 [3] = a1 [2];
                        a1 [1] = 0;
                        a1 [4] = a1 [5];
                        a1 [9] = -1;
                        a1 [10] = -1;
                    }
                    else if(v3 == 5) {
                        for(kk = 0; kk < 38; ++kk) {
                            *((_WORD*) v10 + 69) = a1 [4] + 3;
                            v10 += 68;
                        }
                        a1 [11] = a1 [4];
                        a1 [2] = 8;
                        a1 [3] = a1 [2];
                        a1 [1] = 0;
                        a1 [9] = -1;
                        a1 [4] = a1 [6];
                        a1 [10] = -1;
                    }
                    else if(v3 == 6) {
                        for(mm = 0; mm < 38; ++mm) {
                            *((_WORD*) v10 + 69) = 2;
                            v10 += 68;
                        }
                        a1 [2] = 2;
                        sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                    }
                }
            }
            if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                a1 [4] = 6;
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
            }
            break;
        case 2:
            if((int) a1 [1] >= 60) {
                dword_6C6EA4 = 1;
                return 0;
            }
            break;
        default:
            if(v4 > 2) {
                if(v4 > 6) {
                    if((word_69D904 & 4) != 0 || (word_69D904 & 0x100) != 0) {
                        if((int) a1 [12] >= 5) {
                            if((int) a1 [12] >= 7) {
                                if((int) a1 [12] >= 10) {
                                    for(nn = 0; nn < 4; ++nn) {
                                        for(i1 = 0; i1 < 5; ++i1) {
                                            byte_69CCDC [24 * nn + i1] = 99;
                                            byte_69CCE1 [24 * nn + i1] = 99;
                                        }
                                    }
                                    a1 [12] = 0;
                                    sub_4311E0(dword_6D3F50, (int*) 0x1C, 0);
                                }
                                else if((word_69D904 & 0x400) == 0 || (word_69D904 & 0x400) == (word_69D908 & 0x400)) {
                                    if((word_69D904 & 0x160B) != 0 && (word_69D904 & 0x160B) != (word_69D908 & 0x160B))
                                        a1 [12] = 0;
                                }
                                else {
                                    ++a1 [12];
                                }
                            }
                            else if((word_69D904 & 0x200) == 0 || (word_69D904 & 0x200) == (word_69D908 & 0x200)) {
                                if((word_69D904 & 0x160B) != 0 && (word_69D904 & 0x160B) != (word_69D908 & 0x160B))
                                    a1 [12] = 0;
                            }
                            else {
                                ++a1 [12];
                            }
                        }
                        else if((word_69D904 & 0x800) == 0 || (word_69D904 & 0x800) == (word_69D908 & 0x800)) {
                            if((word_69D904 & 0x160B) != 0 && (word_69D904 & 0x160B) != (word_69D908 & 0x160B))
                                a1 [12] = 0;
                        }
                        else {
                            ++a1 [12];
                        }
                    }
                    else {
                        a1 [12] = 0;
                    }
                }
                if(a1 [9] != a1 [4] && a1 [1] == 20) {
                    a1 [9] = a1 [4];
                    sub_434E20((_DWORD*) dword_6D4588, (int) (a1 + 2600), 0xFFFFFFu, 0, (&off_4784D8) [2 * a1 [9]]);
                    sub_434E20((_DWORD*) dword_6D4588, (int) (a1 + 2668), 0xFFFFFFu, 0, (&off_4784DC) [2 * a1 [9]]);
                }
                if((int) a1 [1] >= 30) {
                    if(sub_42D18F((int) a1, 2)) {
                        a1 [1] = 0;
                        v11 = a1 + 16;
                        for(i2 = 0; i2 < 38; ++i2) {
                            *((_WORD*) v11 + 69) = a1 [11] + 3;
                            v11 += 68;
                        }
                    }
                    if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                        sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                        a1 [2] = 0;
                        a1 [1] = 1;
                        v12 = a1 + 16;
                        for(i3 = 0; i3 < 38; ++i3) {
                            *((_WORD*) v12 + 69) = 1;
                            v12 += 68;
                        }
                        a1 [5] = a1 [4];
                        a1 [4] = a1 [11];
                    }
                }
            }
            break;
    }
    LABEL_145:
    v15 = (int) (a1 + 16);
    for(i4 = 0; i4 < 38; ++i4) {
        sub_433960((int*) dword_6D4588, v15);
        v15 += 272;
    }
    ++a1 [1];
    return 1;
}
// 42D9E5: conditional instruction was optimized away because %var_44.4==7
// 42D9FE: conditional instruction was optimized away because %var_44.4>=A
// 4760DC: using guessed type int dword_4760DC;
// 69BD0C: using guessed type __int16 word_69BD0C[];
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0042E446) --------------------------------------------------------
int __cdecl sub_42E446(int a1) {
    int v1; // edx
    float* v2; // edi
    float* v3; // edi
    double v4; // st7
    int v6; // [esp+8h] [ebp-CCh]
    float v7; // [esp+10h] [ebp-C4h]
    float v8; // [esp+20h] [ebp-B4h]
    float v9; // [esp+28h] [ebp-ACh]
    int v10; // [esp+4Ch] [ebp-88h]
    int v11; // [esp+54h] [ebp-80h]
    int v12; // [esp+68h] [ebp-6Ch]
    int v13; // [esp+6Ch] [ebp-68h]
    char v14 [16]; // [esp+7Ch] [ebp-58h] BYREF
    float v15; // [esp+8Ch] [ebp-48h]
    float v16; // [esp+90h] [ebp-44h]
    int v17; // [esp+94h] [ebp-40h]
    int v18; // [esp+98h] [ebp-3Ch] BYREF
    float v19; // [esp+9Ch] [ebp-38h]
    float v20; // [esp+A0h] [ebp-34h]
    int v21; // [esp+A4h] [ebp-30h]
    int j; // [esp+A8h] [ebp-2Ch]
    int v23; // [esp+ACh] [ebp-28h]
    unsigned int v24; // [esp+B0h] [ebp-24h]
    char v25 [12]; // [esp+B4h] [ebp-20h] BYREF
    unsigned int v26; // [esp+C0h] [ebp-14h]
    int i; // [esp+C4h] [ebp-10h]
    float v28 [3]; // [esp+C8h] [ebp-Ch] BYREF
    unsigned int retaddr; // [esp+D8h] [ebp+4h]

    v26 = retaddr ^ dword_47A630;
    v24 = a1 + 64;
    dword_6C6DE0 = 0;
    dword_6C6DE4 = 0;
    dword_6C6DE8 = 640;
    dword_6C6DEC = 480;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    sub_435300((_DWORD*) dword_6D4588, 0, 0, 0, 0, 0);
    i = 0;
    while(i < 38) {
        v18 = *(int*) (v24 + 144);
        v19 = *(float*) (v24 + 148);
        v20 = *(float*) (v24 + 152);
        v13 = v24 + 228;
        v12 = v24 + 144;
        *(float*) (v24 + 144) = *(float*) (v24 + 144) + *(float*) (v24 + 228);
        *(float*) (v12 + 4) = *(float*) (v12 + 4) + *(float*) (v13 + 4);
        *(float*) (v12 + 8) = *(float*) (v12 + 8) + *(float*) (v13 + 8);
        sub_432AD0((void*) dword_6D4588, v24);
        v2 = (float*) (v24 + 144);
        *(float*) (v24 + 144) = *(float*) &v18;
        *++v2 = v19;
        v2 [1] = v20;
        ++i;
        v24 += 272;
    }
    v24 = a1 + 3872;
    if(*(float*) (a1 + 4016) < 640.0) {
        if(*(_DWORD*) (a1 + 12) == 8) {
            v18 = *(int*) (v24 + 144);
            v19 = *(float*) (v24 + 148);
            v20 = *(float*) (v24 + 152);
            v19 = v19 + 16.0;
            for(i = 0; i < 10; ++i) {
                v17 = i + 10 * *(_DWORD*) (a1 + 40);
                if(v17 >= 64)
                    break;
                v3 = (float*) (a1 + 272 * i + 10544);
                *v3++ = *(float*) &v18;
                *v3 = v19;
                v3 [1] = v20;
                if(word_69BD0C [32 * v17]) {
                    if(word_69BD0E [32 * v17])
                        dword_481B24 = -986881 - 526336 * i;
                    else
                        dword_481B24 = -4153184;
                }
                else {
                    dword_481B24 = -2134851329;
                }
                sub_401650(dword_47B900, &v18, "No.%.2d", v17 + 1);
                *(float*) (a1 + 272 * i + 10544) = *(float*) (a1 + 272 * i + 10544) + 96.0;
                sub_432AD0((void*) dword_6D4588, a1 + 272 * i + 10400);
                *(float*) &v18 = *(float*) &v18 + 368.0;
                sub_401650(
                    dword_47B900,
                    &v18,
                    "%3d/%3d",
                    (unsigned __int16) word_69BD0E [32 * v17],
                    (unsigned __int16) word_69BD0C [32 * v17]);
                *(float*) &v18 = *(float*) &v18 - 368.0;
                v19 = v19 + 30.0;
            }
        }
        else {
            v18 = *(int*) (v24 + 144);
            v19 = *(float*) (v24 + 148);
            v20 = *(float*) (v24 + 152);
            *(float*) (a1 + 10544) = *(float*) &v18;
            *(float*) (a1 + 10548) = v19;
            *(float*) (a1 + 10552) = v20;
            sub_432AD0((void*) dword_6D4588, a1 + 10400);
            *(float*) &v18 = *(float*) &v18 + 320.0;
            *(float*) (a1 + 10816) = *(float*) &v18;
            *(float*) (a1 + 10820) = v19;
            *(float*) (a1 + 10824) = v20;
            sub_432AD0((void*) dword_6D4588, a1 + 10672);
            *(float*) &v18 = *(float*) &v18 - 320.0;
            v19 = v19 + 18.0;
            v19 = v19 + 18.0;
            v23 = *(_DWORD*) (a1 + 48 * *(_DWORD*) (a1 + 44) + 15024 + 24 * *(_DWORD*) (a1 + 36) + 4);
            v21 = *(_DWORD*) (a1 + 48 * *(_DWORD*) (a1 + 44) + 15024 + 12 * (2 * *(_DWORD*) (a1 + 36) + 1) + 4);
            for(i = 0; i < 10; ++i) {
                if(*(_DWORD*) (a1 + 8) == 9) {
                    if(byte_69D4BE) {
                        dword_481B24 = -2130722624;
                    }
                    else if(*(_BYTE*) (*(_DWORD*) (v23 + 8) + 9)) {
                        dword_481B24 = -986881;
                        strcpy(v25, "        ");
                        if(*(int*) (a1 + 16) < 8)
                            v11 = *(_DWORD*) (a1 + 16);
                        else
                            v11 = 7;
                        v25 [v11] = 95;
                        sub_401650(dword_47B900, &v18, "   %8s", v25);
                    }
                    else {
                        dword_481B24 = -2130706496;
                    }
                }
                else {
                    dword_481B24 = -16192;
                }
                sub_401650(dword_47B900, &v18, (char*) off_46BDD0, i + 1);
                *(float*) &v18 = *(float*) &v18 + 36.0;
                if(*(unsigned __int8*) (*(_DWORD*) (v23 + 8) + 18) > 6u) {
                    if(*(_BYTE*) (*(_DWORD*) (v23 + 8) + 18) == 7)
                        sub_401650(
                            dword_47B900,
                            &v18,
                            "%8s %9d(1)",
                            (const char*) (*(_DWORD*) (v23 + 8) + 19),
                            *(_DWORD*) (*(_DWORD*) (v23 + 8) + 12));
                    else
                        sub_401650(
                            dword_47B900,
                            &v18,
                            "%8s %9d(C)",
                            (const char*) (*(_DWORD*) (v23 + 8) + 19),
                            *(_DWORD*) (*(_DWORD*) (v23 + 8) + 12));
                }
                else {
                    sub_401650(
                        dword_47B900,
                        &v18,
                        "%8s %9d(%d)",
                        (const char*) (*(_DWORD*) (v23 + 8) + 19),
                        *(_DWORD*) (*(_DWORD*) (v23 + 8) + 12),
                        *(unsigned __int8*) (*(_DWORD*) (v23 + 8) + 18));
                }
                *(float*) &v18 = *(float*) &v18 + 300.0;
                if(*(_DWORD*) (a1 + 8) == 9) {
                    if(byte_69D4BE == 1) {
                        if(*(_BYTE*) (*(_DWORD*) (v21 + 8) + 9)) {
                            dword_481B24 = -3856;
                            strcpy(v25, "        ");
                            if(*(int*) (a1 + 16) < 8)
                                v10 = *(_DWORD*) (a1 + 16);
                            else
                                v10 = 7;
                            v25 [v10] = 95;
                            sub_401650(dword_47B900, &v18, "%8s", v25);
                        }
                        else {
                            dword_481B24 = -1061109505;
                        }
                    }
                    else {
                        dword_481B24 = -2134851329;
                    }
                }
                else {
                    dword_481B24 = -4144897;
                }
                if(*(unsigned __int8*) (*(_DWORD*) (v21 + 8) + 18) > 6u) {
                    if(*(_BYTE*) (*(_DWORD*) (v21 + 8) + 18) == 7)
                        sub_401650(
                            dword_47B900,
                            &v18,
                            "%8s %9d(1)",
                            (const char*) (*(_DWORD*) (v21 + 8) + 19),
                            *(_DWORD*) (*(_DWORD*) (v21 + 8) + 12));
                    else
                        sub_401650(
                            dword_47B900,
                            &v18,
                            "%8s %9d(C)",
                            (const char*) (*(_DWORD*) (v21 + 8) + 19),
                            *(_DWORD*) (*(_DWORD*) (v21 + 8) + 12));
                }
                else {
                    sub_401650(
                        dword_47B900,
                        &v18,
                        "%8s %9d(%d)",
                        (const char*) (*(_DWORD*) (v21 + 8) + 19),
                        *(_DWORD*) (*(_DWORD*) (v21 + 8) + 12),
                        *(unsigned __int8*) (*(_DWORD*) (v21 + 8) + 18));
                }
                *(float*) &v18 = *(float*) &v18 - 336.0;
                v19 = v19 + 18.0;
                v23 = *(_DWORD*) (v23 + 4);
                v21 = *(_DWORD*) (v21 + 4);
            }
        }
    }
    if(*(_DWORD*) (a1 + 8) == 9 || *(_DWORD*) (a1 + 8) == 13) {
        *(float*) &v18 = 160.0;
        v19 = 356.0;
        v20 = 0.0;
        for(i = 0; i < 6; ++i) {
            for(j = 0; j < 16; ++j) {
                v16 = 0.0;
                v15 = 0.0;
                if(*(_DWORD*) (a1 + 32) == j + 16 * i) {
                    dword_481B24 = -64;
                    v1 = *(_DWORD*) (a1 + 4) % 32;
                    if(*(_DWORD*) (a1 + 4) % 64 >= 32) {
                        v8 = (float) (*(_DWORD*) (a1 + 4) % 32);
                        v4 = 2.0 - 0.80000001 * v8 / 32.0;
                    }
                    else {
                        v9 = (float) (*(_DWORD*) (a1 + 4) % 32);
                        v4 = 0.80000001 * v9 / 32.0 + 1.2;
                    }
                    v16 = v4;
                    flt_481B28 = v16;
                    flt_481B2C = v16;
                    v16 = -(v16 - 1.0) * 8.0;
                    v15 = v16;
                }
                else {
                    dword_481B24 = 1623244992;
                    flt_481B28 = 1.0;
                    flt_481B2C = 1.0;
                }
                v28 [2] = v20;
                v28 [0] = *(float*) &v18 + v16;
                v28 [1] = v19 + v15;
                v14 [0] = *((_BYTE*) off_4784D4 + 16 * i + j);
                v14 [1] = 0;
                if(i == 5) {
                    if(j == 14) {
                        v14 [0] = 0x80;
                    }
                    else if(j == 15) {
                        v14 [0] = -127;
                    }
                }
                sub_401530(dword_47B900, v1, v28, v14);
                *(float*) &v18 = *(float*) &v18 + 20.0;
            }
            v7 = (float) (20 * j);
            *(float*) &v18 = *(float*) &v18 - v7;
            v19 = v19 + 18.0;
        }
    }
    flt_481B28 = 1.0;
    flt_481B2C = 1.0;
    if(*(int*) (a1 + 8) >= 10 && *(int*) (a1 + 8) <= 14) {
        v24 = a1 + 4144;
        i = 0;
        while(i < 6) {
            sub_432AD0((void*) dword_6D4588, v24);
            ++i;
            v24 += 272;
        }
        v24 = a1 + 5776;
        v18 = *(int*) (a1 + 5920);
        v19 = *(float*) (a1 + 5924);
        v20 = *(float*) (a1 + 5928);
        v24 = a1 + 6048;
        sub_401650(dword_47B900, &v18, "No.   Name     Date     Player Score");
        for(i = 0; i < 15; ++i) {
            v18 = *(int*) (v24 + 144);
            v19 = *(float*) (v24 + 148);
            v20 = *(float*) (v24 + 152);
            v24 += 272;
            if(i == *(_DWORD*) (a1 + 28))
                dword_481B24 = -32640;
            else
                dword_481B24 = -8355712;
            if(*(_DWORD*) (a1 + 8) == 13) {
                sub_401650(
                    dword_47B900,
                    &v18,
                    "No.%.2d %8s %8s %7s %9d",
                    i + 1,
                    (const char*) (a1 + 52),
                    (const char*) (a1 + 22128),
                    (&off_478518 [2 * (unsigned __int8) byte_69D4BD]) [(unsigned __int8) byte_69D4BE],
                    *(_DWORD*) (a1 + 22148));
                dword_481B24 = -986881;
                strcpy(v25, "        ");
                if(*(int*) (a1 + 16) < 8)
                    v6 = *(_DWORD*) (a1 + 16);
                else
                    v6 = 7;
                v25 [v6] = 95;
                sub_401650(dword_47B900, &v18, "      %8s", v25);
            }
            else if(*(_DWORD*) (a1 + 80 * i + 20912) == 1347565140 && *(_WORD*) (a1 + 80 * i + 20916) == 258) {
                sub_401650(
                    dword_47B900,
                    &v18,
                    "No.%.2d %8s %8s %7s %9d",
                    i + 1,
                    (const char*) (a1 + 80 * i + 20937),
                    (const char*) (a1 + 80 * i + 20928),
                    off_478518 [*(unsigned __int8*) (a1 + 80 * i + 20918)],
                    *(_DWORD*) (a1 + 80 * i + 20948));
            }
            else {
                sub_401650(dword_47B900, &v18, "No.%.2d -------- --/--/-- -------         0", i + 1);
            }
        }
    }
    dword_481B24 = -1;
    sub_42D35A((float*) a1);
    return 1;
}
// 42ED52: variable 'v1' is possibly undefined
// 4784D4: using guessed type void *off_4784D4;
// 478518: using guessed type char *off_478518[4];
// 47A630: using guessed type int dword_47A630;
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 481B28: using guessed type float flt_481B28;
// 481B2C: using guessed type float flt_481B2C;
// 69BD0C: using guessed type __int16 word_69BD0C[];
// 69BD0E: using guessed type __int16 word_69BD0E[2017];
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 42E446: using guessed type float var_38;

//----- (0042F060) --------------------------------------------------------
int __cdecl sub_42F060(float* a1) {
    int v2; // eax
    int* v3; // [esp+8h] [ebp-40h]
    int* v4; // [esp+Ch] [ebp-3Ch]
    int n; // [esp+38h] [ebp-10h]
    int m; // [esp+3Ch] [ebp-Ch]
    int jj; // [esp+3Ch] [ebp-Ch]
    float* v8; // [esp+40h] [ebp-8h]
    int v9; // [esp+40h] [ebp-8h]
    int i; // [esp+44h] [ebp-4h]
    int j; // [esp+44h] [ebp-4h]
    int k; // [esp+44h] [ebp-4h]
    int ii; // [esp+44h] [ebp-4h]

    if(*((_DWORD*) a1 + 2) != 17) {
        if(sub_435010((_DWORD**) dword_6D4588, 0, "data/result/result.jpg"))
            return -1;
        if(sub_431DC0((_DWORD*) dword_6D4588, 37, "data/result00.anm", 256))
            return -1;
        if(sub_431DC0((_DWORD*) dword_6D4588, 38, "data/result01.anm", 264))
            return -1;
        if(sub_431DC0((_DWORD*) dword_6D4588, 39, "data/result02.anm", 271))
            return -1;
        if(sub_431DC0((_DWORD*) dword_6D4588, 40, "data/result03.anm", 293))
            return -1;
        v8 = a1 + 16;
        for(i = 0; i < 38; ++i) {
            v8 [36] = 0.0;
            v8 [37] = 0.0;
            v8 [38] = 0.0;
            v8 [57] = 0.0;
            v8 [58] = 0.0;
            v8 [59] = 0.0;
            v4 = (int*) dword_6D4588;
            *((_WORD*) v8 + 90) = i + 256;
            sub_432430(v4, v8, v4 [i + 29517]);
            v8 += 68;
        }
        v9 = (int) (a1 + 2600);
        for(j = 0; j < 16; ++j) {
            v3 = (int*) dword_6D4588;
            sub_403580((_DWORD*) v9);
            sub_4323A0(v3, v9, j + 1800);
            *(float*) (v9 + 144) = 0.0;
            *(float*) (v9 + 148) = 0.0;
            *(float*) (v9 + 152) = 0.0;
            v2 = *(_DWORD*) (v9 + 128);
            BYTE1(v2) |= 3u;
            *(_DWORD*) (v9 + 128) = v2;
            *(_BYTE*) (v9 + 268) = 15;
            *(_BYTE*) (v9 + 269) = 15;
            v9 += 272;
        }
    }
    for(k = 0; k < 5; ++k) {
        for(m = 0; m < 4; ++m) {
            for(n = 0; n < 10; ++n) {
                LODWORD(a1 [280 * k + 3819 + 70 * m + 7 * n]) = 1000000 - 100000 * n;
                a1 [280 * k + 3816 + 70 * m + 7 * n] = 9.3330421e11;
                BYTE1(a1 [280 * k + 3820 + 70 * m + 7 * n]) = k;
                LOBYTE(a1 [280 * k + 3818 + 70 * m + 7 * n]) = 16;
                HIWORD(a1 [280 * k + 3817 + 70 * m + 7 * n]) = 28;
                LOWORD(a1 [280 * k + 3817 + 70 * m + 7 * n]) = 28;
                BYTE2(a1 [280 * k + 3820 + 70 * m + 7 * n]) = 1;
                BYTE1(a1 [280 * k + 3818 + 70 * m + 7 * n]) = 0;
                sub_42BC2D(a1, (int) &a1 [280 * k + 3816 + 70 * m + 7 * n], k, m);
                strcpy((char*) &a1 [280 * k + 3820 + 70 * m + 7 * n] + 3, "Nanashi ");
            }
        }
    }
    a1 [5] = 0.0;
    *(_DWORD*) a1 = sub_42B0D9("score.dat");
    for(ii = 0; ii < 5; ++ii) {
        for(jj = 0; jj < 4; ++jj)
            sub_42B280(*(_DWORD**) a1, (int) &a1 [12 * ii + 3756 + 3 * jj], jj, ii);
    }
    if(*((_DWORD*) a1 + 2) != 9 && *((_DWORD*) a1 + 2) != 17) {
        sub_42B466(*(_DWORD*) a1, (int) &unk_69BCD0);
        sub_42B502(*(_DWORD*) a1, (int) &unk_69CCD0);
        sub_42B65E(*(_DWORD*) a1, dword_69CD30);
    }
    if(*((_DWORD*) a1 + 2) == 17
       && dword_69CD30 [240 * (unsigned __int8) byte_69D4BD
       - 17
       + 120 * (unsigned __int8) byte_69D4BE
       + 20 * *(_DWORD*) dword_69D6D4
       + 5 * dword_69BCB0] < (unsigned int) dword_69BCA4) {
        dword_69CD30 [240 * (unsigned __int8) byte_69D4BD
            - 17
            + 120 * (unsigned __int8) byte_69D4BE
            + 20 * *(_DWORD*) dword_69D6D4
            + 5 * dword_69BCB0] = dword_69BCA4;
    }
    *((_WORD*) a1 + 7464) = -1;
    return 0;
}
// 69BCA4: using guessed type int dword_69BCA4;
// 69BCB0: using guessed type int dword_69BCB0;
// 69CD30: using guessed type _DWORD dword_69CD30[480];
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;

//----- (0042F5BC) --------------------------------------------------------
int __cdecl sub_42F5BC(int a1) {
    int j; // [esp+10h] [ebp-8h]
    int i; // [esp+14h] [ebp-4h]

    if(*(_DWORD*) a1) {
        sub_42B809(a1);
        sub_42B7DC(*(void**) a1);
    }
    *(_DWORD*) a1 = 0;
    for(i = 0; i < 5; ++i) {
        for(j = 0; j < 4; ++j)
            sub_42BC5B((_DWORD*) a1, i, j);
    }
    sub_432030(dword_6D4588, 37);
    sub_432030(dword_6D4588, 38);
    sub_432030(dword_6D4588, 39);
    sub_432030(dword_6D4588, 40);
    sub_435270((_DWORD**) dword_6D4588, 0);
    sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 20908));
    *(_DWORD*) (a1 + 20908) = 0;
    if(a1) {
        free(*(void**) a1);
        j__free((void*) a1);
    }
    return 0;
}

//----- (0042F6C4) --------------------------------------------------------
void sub_42F6C4() {
    ;
}

//----- (0042F6D0) --------------------------------------------------------
int __cdecl sub_42F6D0(int a1) {
    int result; // eax

    (*(void(__stdcall**)(int, _DWORD, _DWORD, int, int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 144))(
        dword_6C6D20,
        0,
        0,
        3,
        a1,
        1065353216,
        0);
    if((*(int(__stdcall**)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 60))(
        dword_6C6D20,
        0,
        0,
        0,
        0) < 0)
        (*(void(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8);
    (*(void(__stdcall**)(int, _DWORD, _DWORD, int, int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 144))(
        dword_6C6D20,
        0,
        0,
        3,
        a1,
        1065353216,
        0);
    result = (*(int(__stdcall**)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 60))(
        dword_6C6D20,
        0,
        0,
        0,
        0);
    if(result < 0)
        return (*(int(__stdcall**)(int, void*))(*(_DWORD*) dword_6C6D20 + 56))(dword_6C6D20, &unk_6C6DF8);
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;

//----- (0042F790) --------------------------------------------------------
int __cdecl sub_42F790(int a1) {
    dword_6C6DE0 = 0;
    dword_6C6DE4 = 0;
    dword_6C6DE8 = 640;
    dword_6C6DEC = 480;
    dword_6C6DF0 = 0;
    dword_6C6DF4 = 1065353216;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    return sub_42F6D0(a1);
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;
// 6C6DF0: using guessed type int dword_6C6DF0;
// 6C6DF4: using guessed type int dword_6C6DF4;

//----- (0042F800) --------------------------------------------------------
int __cdecl sub_42F800(int a1) {
    float v2; // [esp+0h] [ebp-10h]
    float v3; // [esp+4h] [ebp-Ch]

    if(*(_DWORD*) (a1 + 20)) {
        v3 = (float) *(int*) (a1 + 44);
        v2 = (float) *(int*) (a1 + 20);
        *(_DWORD*) (a1 + 16) = (unsigned __int64) (255.0 - (v3 + *(float*) (a1 + 40)) * 255.0 / v2);
        if(*(int*) (a1 + 16) < 0)
            *(_DWORD*) (a1 + 16) = 0;
    }
    if(*(_DWORD*) (a1 + 44) >= *(_DWORD*) (a1 + 20))
        return 0;
    *(_DWORD*) (a1 + 36) = *(_DWORD*) (a1 + 44);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 44), (float*) (a1 + 40));
    return 1;
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0042F8B0) --------------------------------------------------------
int __cdecl sub_42F8B0(int* a1, int a2) {
    int* i; // [esp+38h] [ebp-8Ch]
    int v4; // [esp+40h] [ebp-84h]
    int v5; // [esp+48h] [ebp-7Ch]
    int v6; // [esp+54h] [ebp-70h]
    int v7; // [esp+60h] [ebp-64h]
    int v8; // [esp+6Ch] [ebp-58h]
    int v9 [20]; // [esp+74h] [ebp-50h] BYREF

    v4 = 4;
    for(i = v9; --v4 >= 0; i += 5)
        ;
    v8 = a1 [1];
    v9 [0] = *a1;
    v9 [1] = v8;
    v9 [2] = 0;
    v7 = a1 [1];
    v9 [5] = a1 [2];
    v9 [6] = v7;
    v9 [7] = 0;
    v6 = a1 [3];
    v9 [10] = *a1;
    v9 [11] = v6;
    v9 [12] = 0;
    v5 = a1 [3];
    v9 [15] = a1 [2];
    v9 [16] = v5;
    v9 [17] = 0;
    v9 [18] = 1065353216;
    v9 [13] = 1065353216;
    v9 [8] = 1065353216;
    v9 [3] = 1065353216;
    v9 [19] = a2;
    v9 [14] = a2;
    v9 [9] = a2;
    v9 [4] = a2;
    if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 2);
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 2);
    }
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 0);
    (*(void(__stdcall**)(int, _DWORD, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 0);
    if((((unsigned int) dword_6C6E60 >> 6) & 1) == 0) {
        (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 8);
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 14, 0);
    }
    (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 20, 6);
    (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 68);
    (*(void(__stdcall**)(int, int, int, int*, int))(*(_DWORD*) dword_6C6D20 + 288))(dword_6C6D20, 5, 2, v9, 20);
    *(_BYTE*) (dword_6D4588 + 135358) = -1;
    *(_DWORD*) (dword_6D4588 + 135360) = 0;
    *(_DWORD*) (dword_6D4588 + 135352) = 0;
    *(_BYTE*) (dword_6D4588 + 135357) = -1;
    *(_BYTE*) (dword_6D4588 + 135356) = -1;
    *(_BYTE*) (dword_6D4588 + 135359) = -1;
    if((((unsigned int) dword_6C6E60 >> 8) & 1) == 0) {
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 4, 4);
        (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 4);
    }
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 5, 2);
    (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 2, 2);
    return (*(int(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 23, 4);
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (0042FC80) --------------------------------------------------------
int __cdecl sub_42FC80(int a1) {
    float v2; // [esp+0h] [ebp-10h]
    float v3; // [esp+4h] [ebp-Ch]

    if(*(_DWORD*) (a1 + 20)) {
        v3 = (float) *(int*) (a1 + 44);
        v2 = (float) *(int*) (a1 + 20);
        *(_DWORD*) (a1 + 16) = (unsigned __int64) ((v3 + *(float*) (a1 + 40)) * 255.0 / v2);
        if(*(int*) (a1 + 16) < 0)
            *(_DWORD*) (a1 + 16) = 0;
    }
    if(*(_DWORD*) (a1 + 44) >= *(_DWORD*) (a1 + 20))
        return 0;
    *(_DWORD*) (a1 + 36) = *(_DWORD*) (a1 + 44);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 44), (float*) (a1 + 40));
    return 1;
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (0042FD30) --------------------------------------------------------
_DWORD* __cdecl sub_42FD30(int a1, int a2, int a3, int a4, int a5) {
    _DWORD* v6; // [esp+8h] [ebp-28h]
    _DWORD* Block; // [esp+10h] [ebp-20h]
    _DWORD* v8; // [esp+1Ch] [ebp-14h]
    _DWORD* v9; // [esp+20h] [ebp-10h]

    v9 = 0;
    v8 = 0;
    Block = operator new(0x30u);
    if(Block) {
        sub_424127(Block + 9);
        v6 = Block;
    }
    else {
        v6 = 0;
    }
    if(!v6)
        return 0;
    memset(v6, 0, 0x30u);
    if(a1) {
        if(a1 == 1) {
            v9 = sub_41CD40((int) sub_42FFC0);
        }
        else if(a1 == 2) {
            v9 = sub_41CD40((int) sub_42FC80);
            v8 = sub_41CD40((int) sub_42FF70);
        }
    }
    else {
        v9 = sub_41CD40((int) sub_42F800);
        v8 = sub_41CD40((int) sub_42FEE0);
    }
    v9 [2] = sub_4301F0;
    v9 [3] = sub_430220;
    v9 [7] = v6;
    *v6 = a1;
    v6 [5] = a2;
    v6 [6] = a3;
    v6 [7] = a4;
    v6 [8] = a5;
    if(sub_41C860(byte_69D918, (int) v9, 14))
        return 0;
    if(v8) {
        v8 [7] = v6;
        sub_41C940((__int16*) byte_69D918, (int) v8, 16);
    }
    v6 [1] = v9;
    v6 [2] = v8;
    return v6;
}

//----- (0042FEE0) --------------------------------------------------------
int __cdecl sub_42FEE0(int a1) {
    int v2 [4]; // [esp+0h] [ebp-10h] BYREF

    v2 [0] = 0;
    v2 [1] = 0;
    v2 [2] = 1142947840;
    v2 [3] = 1139802112;
    dword_6C6DE0 = 0;
    dword_6C6DE4 = 0;
    dword_6C6DE8 = 640;
    dword_6C6DEC = 480;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) dword_6C6D20 + 160))(dword_6C6D20, &dword_6C6DE0);
    sub_42F8B0(v2, *(_DWORD*) (a1 + 24) | (*(_DWORD*) (a1 + 16) << 24));
    return 1;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6DE0: using guessed type int dword_6C6DE0;
// 6C6DE4: using guessed type int dword_6C6DE4;
// 6C6DE8: using guessed type int dword_6C6DE8;
// 6C6DEC: using guessed type int dword_6C6DEC;

//----- (0042FF70) --------------------------------------------------------
int __cdecl sub_42FF70(int a1) {
    int v2 [4]; // [esp+0h] [ebp-10h] BYREF

    v2 [0] = 1107296256;
    v2 [1] = 1098907648;
    v2 [2] = 1137704960;
    v2 [3] = 1139277824;
    sub_42F8B0(v2, *(_DWORD*) (a1 + 24) | (*(_DWORD*) (a1 + 16) << 24));
    return 1;
}

//----- (0042FFC0) --------------------------------------------------------
int __cdecl sub_42FFC0(int a1) {
    unsigned int v2; // [esp+0h] [ebp-30h]
    unsigned int v3; // [esp+8h] [ebp-28h]
    float v4; // [esp+10h] [ebp-20h]
    float v5; // [esp+14h] [ebp-1Ch]
    float v6; // [esp+18h] [ebp-18h]
    float v7; // [esp+1Ch] [ebp-14h]
    float v8; // [esp+2Ch] [ebp-4h]

    if(byte_69BCCC) {
        flt_69D6DC = 32.0;
        flt_69D6E0 = 16.0;
        flt_69D6E4 = 384.0;
        flt_69D6E8 = 448.0;
        return 1;
    }
    else {
        *(_DWORD*) (a1 + 36) = *(_DWORD*) (a1 + 44);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a1 + 44), (float*) (a1 + 40));
        if(*(_DWORD*) (a1 + 44) < *(_DWORD*) (a1 + 20)) {
            v7 = (float) (*(_DWORD*) (a1 + 28) - *(_DWORD*) (a1 + 24));
            v6 = (float) *(int*) (a1 + 44);
            v5 = (float) *(int*) (a1 + 20);
            v4 = (float) *(int*) (a1 + 24);
            v8 = (v6 + *(float*) (a1 + 40)) * v7 / v5 + v4;
            v3 = sub_41E7F0(&word_69D8F8) % 3u;
            if(v3) {
                if(v3 == 1) {
                    flt_69D6DC = v8 + 32.0;
                    flt_69D6E4 = 384.0 - v8;
                }
                else if(v3 == 2) {
                    flt_69D6DC = 32.0;
                    flt_69D6E4 = 384.0 - v8;
                }
            }
            else {
                flt_69D6DC = 32.0;
                flt_69D6E4 = 384.0;
            }
            v2 = sub_41E7F0(&word_69D8F8) % 3u;
            if(v2) {
                if(v2 == 1) {
                    flt_69D6E0 = v8 + 16.0;
                    flt_69D6E8 = 448.0 - v8;
                }
                else if(v2 == 2) {
                    flt_69D6E0 = 16.0;
                    flt_69D6E8 = 448.0 - v8;
                }
            }
            else {
                flt_69D6E0 = 16.0;
                flt_69D6E8 = 448.0;
            }
            return 1;
        }
        else {
            flt_69D6DC = 32.0;
            flt_69D6E0 = 16.0;
            flt_69D6E4 = 384.0;
            flt_69D6E8 = 448.0;
            return 0;
        }
    }
}
// 69BCCC: using guessed type char byte_69BCCC;
// 69D6DC: using guessed type float flt_69D6DC;
// 69D6E0: using guessed type float flt_69D6E0;
// 69D6E4: using guessed type float flt_69D6E4;
// 69D6E8: using guessed type float flt_69D6E8;
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6D18: using guessed type int dword_6C6D18;

//----- (004301F0) --------------------------------------------------------
int __cdecl sub_4301F0(_DWORD* a1) {
    a1 [11] = 0;
    a1 [10] = 0;
    a1 [9] = -999;
    return 0;
}

//----- (00430220) --------------------------------------------------------
int __cdecl sub_430220(_DWORD* a1) {
    *(_DWORD*) (a1 [1] + 12) = 0;
    sub_41CDE0(byte_69D918, a1 [2]);
    a1 [2] = 0;
    j__free(a1);
    return 0;
}

//----- (00430270) --------------------------------------------------------
int __thiscall sub_430270(_DWORD* this, HWND hWnd) {
    int v3; // [esp+8h] [ebp-74h]
    _DWORD* Block; // [esp+18h] [ebp-64h]
    void* v6; // [esp+1Ch] [ebp-60h]
    int v7 [4]; // [esp+24h] [ebp-58h] BYREF
    __int16 v8; // [esp+34h] [ebp-48h]
    void* v9; // [esp+38h] [ebp-44h] BYREF
    int v10; // [esp+3Ch] [ebp-40h] BYREF
    int v11; // [esp+40h] [ebp-3Ch] BYREF
    int v12; // [esp+44h] [ebp-38h] BYREF
    int v13 [10]; // [esp+48h] [ebp-34h] BYREF
    int v14; // [esp+78h] [ebp-4h]
    unsigned int retaddr; // [esp+80h] [ebp+4h]

    v13 [9] = retaddr ^ dword_47A630;
    v6 = operator new(4u);
    v14 = 0;
    if(v6)
        v3 = unknown_libname_4(v6);
    else
        v3 = 0;
    v14 = -1;
    this [388] = v3;
    if(sub_43A800((LPDIRECTSOUND8*) this [388], hWnd, 2u, 2, 44100, 0x10u) >= 0) {
        *this = *(_DWORD*) this [388];
        this [390] = 0;
        memset(v13, 0, 0x24u);
        v13 [0] = 36;
        v13 [1] = 32776;
        v13 [2] = 0x8000;
        v8 = 0;
        v7 [0] = 131073;
        v7 [1] = 44100;
        v7 [2] = 176400;
        v7 [3] = 1048580;
        v13 [4] = (int) v7;
        if((*(int(__stdcall**)(_DWORD, int*, _DWORD*, _DWORD))(*(_DWORD*) *this + 12))(*this, v13, this + 386, 0) >= 0) {
            if((*(int(__stdcall**)(_DWORD, _DWORD, int, void**, int*, int*, int*, _DWORD))(*(_DWORD*) this [386] + 44))(
                this [386],
                0,
                0x8000,
                &v9,
                &v10,
                &v12,
                &v11,
                0) >= 0) {
                memset(v9, 0, 0x8000u);
                (*(void(__stdcall**)(_DWORD, void*, int, int, int))(*(_DWORD*) this [386] + 76))(this [386], v9, v10, v12, v11);
                (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, int))(*(_DWORD*) this [386] + 48))(this [386], 0, 0, 1);
                SetTimer(hWnd, 0, 0xFAu, 0);
                this [387] = hWnd;
                sub_41E4D0((int) byte_69D998, aDirectsound_0);
                return 0;
            }
            else {
                return -1;
            }
        }
        else {
            return -1;
        }
    }
    else {
        sub_41E4D0((int) byte_69D998, aDirectsound);
        if(this [388]) {
            Block = (_DWORD*) this [388];
            if(Block) {
                sub_43A7D0(Block);
                j__free(Block);
            }
            this [388] = 0;
        }
        return -1;
    }
}
// 43A7B0: using guessed type int __thiscall unknown_libname_4(_DWORD);
// 47A630: using guessed type int dword_47A630;
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (00430510) --------------------------------------------------------
int __thiscall sub_430510(int this) {
    _DWORD* Block; // [esp+10h] [ebp-10h]
    int i; // [esp+1Ch] [ebp-4h]

    if(!*(_DWORD*) (this + 1552))
        return 0;
    for(i = 0; i < 128; ++i) {
        if(*(_DWORD*) (this + 4 * i + 520)) {
            (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 4 * i + 520) + 8))(*(_DWORD*) (this + 4 * i + 520));
            *(_DWORD*) (this + 4 * i + 520) = 0;
        }
        if(*(_DWORD*) (this + 4 * i + 8)) {
            (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 4 * i + 8) + 8))(*(_DWORD*) (this + 4 * i + 8));
            *(_DWORD*) (this + 4 * i + 8) = 0;
        }
    }
    KillTimer(*(HWND*) (this + 1548), 1u);
    sub_430F80(this);
    *(_DWORD*) this = 0;
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 1544) + 72))(*(_DWORD*) (this + 1544));
    if(*(_DWORD*) (this + 1544)) {
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 1544) + 8))(*(_DWORD*) (this + 1544));
        *(_DWORD*) (this + 1544) = 0;
    }
    if(*(_DWORD*) (this + 1580)) {
        (***(void(__thiscall****)(_DWORD, int))(this + 1580))(*(_DWORD*) (this + 1580), 1);
        *(_DWORD*) (this + 1580) = 0;
    }
    if(*(_DWORD*) (this + 1552)) {
        Block = *(_DWORD**) (this + 1552);
        if(Block) {
            sub_43A7D0(Block);
            j__free(Block);
        }
        *(_DWORD*) (this + 1552) = 0;
    }
    return 0;
}

//----- (004306E0) --------------------------------------------------------
int __thiscall sub_4306E0(_DWORD* this, int a2, char* Str) {
    int v5; // [esp+Ch] [ebp-60h]
    int v6 [4]; // [esp+10h] [ebp-5Ch] BYREF
    __int16 v7; // [esp+20h] [ebp-4Ch]
    void* Block; // [esp+24h] [ebp-48h]
    int* v9; // [esp+28h] [ebp-44h] BYREF
    unsigned int v10; // [esp+2Ch] [ebp-40h] BYREF
    unsigned int v11; // [esp+30h] [ebp-3Ch] BYREF
    char* v12; // [esp+34h] [ebp-38h] BYREF
    int v13; // [esp+38h] [ebp-34h] BYREF
    int* v14; // [esp+3Ch] [ebp-30h]
    int v15 [10]; // [esp+40h] [ebp-2Ch] BYREF
    char* Str1; // [esp+68h] [ebp-4h]
    unsigned int retaddr; // [esp+70h] [ebp+4h]

    v15 [9] = retaddr ^ dword_47A630;
    if(!this [388])
        return 0;
    if(this [a2 + 2]) {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) this [a2 + 2] + 8))(this [a2 + 2]);
        this [a2 + 2] = 0;
    }
    Block = sub_41E290(Str, 0);
    Str1 = (char*) Block;
    if(!Block)
        return -1;
    if(!strncmp(Str1, "RIFF", 4u)) {
        Str1 += 4;
        v5 = *(_DWORD*) Str1;
        Str1 += 4;
        if(!strncmp(Str1, "WAVE", 4u)) {
            Str1 += 4;
            v14 = (int*) sub_4309F0(Str1, "fmt ", &v13, v5 - 12);
            if(v14
               && (v6 [0] = *v14,
               v6 [1] = v14 [1],
               v6 [2] = v14 [2],
               v6 [3] = v14 [3],
               v7 = *((_WORD*) v14 + 8),
               (v14 = (int*) sub_4309F0(Str1, "data", &v13, v5 - 12)) != 0)) {
                memset(v15, 0, 0x24u);
                v15 [0] = 36;
                v15 [1] = 32904;
                v15 [2] = v13;
                v15 [4] = (int) v6;
                if((*(int(__stdcall**)(_DWORD, int*, _DWORD*, _DWORD))(*(_DWORD*) *this + 12))(
                    *this,
                    v15,
                    &this [a2 + 2],
                    0) < 0
                    || (*(int(__stdcall**)(_DWORD, _DWORD, int, int**, unsigned int*, char**, unsigned int*, _DWORD))(*(_DWORD*) this [a2 + 2] + 44))(
                    this [a2 + 2],
                    0,
                    v13,
                    &v9,
                    &v10,
                    &v12,
                    &v11,
                    0) < 0) {
                    free(Block);
                    return -1;
                }
                else {
                    qmemcpy(v9, v14, v10);
                    if(v11)
                        qmemcpy(v12, (char*) v14 + v10, v11);
                    (*(void(__stdcall**)(_DWORD, int*, unsigned int, char*, unsigned int))(*(_DWORD*) this [a2 + 2] + 76))(
                        this [a2 + 2],
                        v9,
                        v10,
                        v12,
                        v11);
                    free(Block);
                    return 0;
                }
            }
            else {
                sub_41E4D0((int) byte_69D998, aWav_0, Str);
                free(Block);
                return -1;
            }
        }
        else {
            sub_41E4D0((int) byte_69D998, aWav_0, Str);
            free(Block);
            return -1;
        }
    }
    else {
        sub_41E4D0((int) byte_69D998, aWav, Str);
        free(Block);
        return -1;
    }
}
// 47A630: using guessed type int dword_47A630;
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (004309F0) --------------------------------------------------------
char* __cdecl sub_4309F0(char* Str1, char* Str2, _DWORD* a3, int a4) {
    while(a4) {
        *a3 = *((_DWORD*) Str1 + 1);
        if(!strncmp(Str1, Str2, 4u))
            return Str1 + 8;
        a4 -= *a3 + 8;
        Str1 += *a3 + 8;
    }
    return 0;
}

//----- (00430A50) --------------------------------------------------------
int __userpurge sub_430A50(int a1, int a2, LPSTR pszFileName) {
    DWORD v5; // [esp+24h] [ebp-CCh]
    DWORD j; // [esp+28h] [ebp-C8h]
    DWORD Time; // [esp+30h] [ebp-C0h]
    DWORD i; // [esp+34h] [ebp-BCh]
    unsigned int v9; // [esp+38h] [ebp-B8h]
    int v10 [39]; // [esp+44h] [ebp-ACh] BYREF
    unsigned int v11; // [esp+E0h] [ebp-10h]
    int v12; // [esp+ECh] [ebp-4h]

    sub_43B9B0(v10);
    v12 = 0;
    if(*(_DWORD*) (a1 + 1552) && byte_6C6E48 && *(_DWORD*) a1) {
        sub_430F80(a1);
        sub_41E940();
        if(sub_43BA60((int) v10, pszFileName, 0, 1) >= 0) {
            if(unknown_libname_5(v10)) {
                Time = timeGetTime();
                for(i = Time; i < Time + 100 && i >= Time; i = timeGetTime())
                    ;
                sub_43C2C0((int) v10);
                v9 = *(unsigned __int16*) (v10 [0] + 12);
                v11 = (v9 * 2 * *(_DWORD*) (v10 [0] + 4)) >> 2;
                v11 -= v11 % v9;
                *(_DWORD*) (a1 + 1584) = CreateEventA(0, 0, 0, 0);
                *(_DWORD*) (a1 + 1560) = CreateThread(
                    0,
                    0,
                    (LPTHREAD_START_ROUTINE) StartAddress,
                    (LPVOID) lpParameter,
                    0,
                    (LPDWORD) (a1 + 1556));
                if(sub_43A9C0(
                    *(_DWORD**) (a1 + 1552),
                    a2,
                    (_DWORD*) (a1 + 1580),
                    pszFileName,
                    65792,
                    0,
                    0,
                    0,
                    0,
                    4u,
                    v11,
                    *(_DWORD*) (a1 + 1584)) >= 0) {
                    sub_41E940();
                    v5 = timeGetTime();
                    for(j = v5; j < v5 + 100 && j >= v5; j = timeGetTime())
                        ;
                    v12 = -1;
                    sub_43BA10((int) v10);
                    return 0;
                }
                else {
                    sub_41E940();
                    v12 = -1;
                    sub_43BA10((int) v10);
                    return -1;
                }
            }
            else {
                sub_43C2C0((int) v10);
                v12 = -1;
                sub_43BA10((int) v10);
                return -1;
            }
        }
        else {
            sub_41E940();
            sub_43C2C0((int) v10);
            v12 = -1;
            sub_43BA10((int) v10);
            return -1;
        }
    }
    else {
        v12 = -1;
        sub_43BA10((int) v10);
        return -1;
    }
}
// 43BE50: using guessed type int __thiscall unknown_libname_5(_DWORD);
// 6C6E48: using guessed type char byte_6C6E48;

//----- (00430E10) --------------------------------------------------------
int __thiscall sub_430E10(_DWORD* this, char* Str) {
    int v4; // [esp+8h] [ebp-Ch]
    int v5; // [esp+Ch] [ebp-8h]
    _DWORD* Block; // [esp+10h] [ebp-4h]

    if(!this [388])
        return -1;
    if(!byte_6C6E48)
        return -1;
    if(!this [395])
        return -1;
    Block = sub_41E290(Str, 0);
    if(!Block)
        return -1;
    v5 = *(_DWORD*) (this [395] + 12);
    v4 = 4 * Block [1];
    *(_DWORD*) (v5 + 144) = 4 * *Block;
    *(_DWORD*) (v5 + 148) = v4;
    free(Block);
    return 0;
}
// 6C6E48: using guessed type char byte_6C6E48;

//----- (00430EC0) --------------------------------------------------------
int __userpurge sub_430EC0(int a1, int a2, int a3) {
    int v4; // eax

    sub_41E940();
    if(!*(_DWORD*) (a1 + 1580))
        return -1;
    if(sub_43B8E0(*(_DWORD*) (a1 + 1580), a2) < 0)
        return -1;
    v4 = sub_43B200(*(_DWORD**) (a1 + 1580), 0);
    if(sub_43AEA0(*(_DWORD*) (a1 + 1580), a2, v4, a3) < 0)
        return -1;
    if(sub_43B240(*(_DWORD**) (a1 + 1580), a2, 0, 1) < 0)
        return -1;
    sub_41E940();
    *(_DWORD*) (a1 + 1588) = a3;
    return 0;
}

//----- (00430F80) --------------------------------------------------------
void __thiscall sub_430F80(int this) {
    if(*(_DWORD*) (this + 1580)) {
        sub_43B300(*(_DWORD**) (this + 1580));
        if(*(_DWORD*) (this + 1560)) {
            PostThreadMessageA(*(_DWORD*) (this + 1556), 0x12u, 0, 0);
            sub_41E940();
            WaitForSingleObject(*(HANDLE*) (this + 1560), 0xFFFFFFFF);
            sub_41E940();
            CloseHandle(*(HANDLE*) (this + 1560));
            CloseHandle(*(HANDLE*) (this + 1584));
            *(_DWORD*) (this + 1560) = 0;
        }
        if(*(_DWORD*) (this + 1580)) {
            (***(void(__thiscall****)(_DWORD, int))(this + 1580))(*(_DWORD*) (this + 1580), 1);
            *(_DWORD*) (this + 1580) = 0;
        }
        sub_41E940();
    }
}

//----- (00431080) --------------------------------------------------------
int __thiscall sub_431080(_DWORD* this) {
    int i; // [esp+4h] [ebp-4h]
    int j; // [esp+4h] [ebp-4h]
    unsigned int k; // [esp+4h] [ebp-4h]

    if(!this [388])
        return -1;
    if(!*this)
        return 0;
    for(i = 0; i < 3; ++i)
        this [i + 392] = -1;
    for(j = 0; j < 26; ++j) {
        if(sub_4306E0(this, j, *(char**) &off_478628 [4 * j])) {
            sub_41E4D0((int) byte_69D998, aErrorSound, *(_DWORD*) &off_478628 [4 * j]);
            return -1;
        }
    }
    for(k = 0; k < 0x20; ++k) {
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD*))(*(_DWORD*) *this + 20))(
            *this,
            this [dword_478528 [2 * k] + 2],
            &this [k + 130]);
        (*(void(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*) this [k + 130] + 52))(this [k + 130], 0);
        (*(void(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*) this [k + 130] + 60))(this [k + 130], word_47852C [4 * k]);
    }
    return 0;
}
// 478528: using guessed type int dword_478528[];
// 47852C: using guessed type __int16 word_47852C[];
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (004311E0) --------------------------------------------------------
int* __thiscall sub_4311E0(int* this, int* a2, int a3) {
    int* result; // eax
    int v4; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    result = a2;
    v4 = word_47852E [4 * (_DWORD) a2];
    for(i = 0; i < 3; ++i) {
        result = (int*) i;
        if(this [i + 392] < 0)
            break;
        result = this;
        if((int*) this [i + 392] == a2)
            return result;
    }
    if(i < 3) {
        this [i + 392] = (int) a2;
        result = this;
        this [(_DWORD) a2 + 258] = v4;
    }
    return result;
}
// 47852E: using guessed type __int16 word_47852E[125];

//----- (00431270) --------------------------------------------------------
int __thiscall sub_431270(_DWORD* this) {
    int result; // eax
    int v3; // [esp+4h] [ebp-8h]
    int i; // [esp+8h] [ebp-4h]

    result = (int) this;
    if(this [388] && byte_6C6E48) {
        for(i = 0; i < 3; ++i) {
            result = i;
            if((int) this [i + 392] < 0)
                break;
            v3 = this [i + 392];
            result = (int) this;
            this [i + 392] = -1;
            if(this [v3 + 130]) {
                (*(void(__stdcall**)(_DWORD))(*(_DWORD*) this [v3 + 130] + 72))(this [v3 + 130]);
                (*(void(__thiscall**)(_DWORD, _DWORD, _DWORD))(*(_DWORD*) this [v3 + 130] + 52))(
                    this [v3 + 130],
                    this [v3 + 130],
                    0);
                result = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD*) this [v3 + 130] + 48))(
                    this [v3 + 130],
                    0,
                    0,
                    0);
            }
        }
    }
    return result;
}
// 6C6E48: using guessed type char byte_6C6E48;

//----- (00431370) --------------------------------------------------------
DWORD __userpurge StartAddress(int a1, LPVOID lpThreadParameter) {
    BOOL v3; // [esp+4h] [ebp-30h]
    DWORD v4; // [esp+Ch] [ebp-28h]
    struct tagMSG Msg; // [esp+18h] [ebp-1Ch] BYREF

    v3 = 0;
    while(!v3) {
        v4 = MsgWaitForMultipleObjects(1u, &pHandles, 0, 0xFFFFFFFF, 0xBFu);
        v3 = dword_6D457C == 0;
        if(v4) {
            if(v4 == 1) {
                while(PeekMessageA(&Msg, 0, 0, 0, 1u)) {
                    if(Msg.message == 18)
                        v3 = 1;
                }
            }
        }
        else if(dword_6D457C) {
            sub_43B560(dword_6D457C, a1, 1);
        }
    }
    return 0;
}
// 6D457C: using guessed type int dword_6D457C;

//----- (00431420) --------------------------------------------------------
void* __thiscall sub_431420(void* this) {
    int i; // [esp+8h] [ebp-4h]

    memset(this, 0, 0x638u);
    for(i = 0; i < 128; ++i)
        *((_DWORD*) this + i + 258) = -1;
    return this;
}

//----- (00431470) --------------------------------------------------------
int __thiscall sub_431470(int this) {
    int i; // [esp+8h] [ebp-20h]
    int v4; // [esp+10h] [ebp-18h]
    int j; // [esp+24h] [ebp-4h]

    sub_403720(this + 114688);
    v4 = 4;
    for(i = this + 135368; --v4 >= 0; i += 20)
        ;
    *(_DWORD*) (this + 117040) = 0;
    memset((void*) this, 0, 0x2112Cu);
    for(j = 0; j < 2048; ++j)
        *(_DWORD*) (this + 56 * j) = -1;
    dword_6D4654 = 1065353216;
    dword_6D463C = 1065353216;
    dword_6D4624 = 1065353216;
    dword_6D460C = 1065353216;
    dword_6D4610 = 0;
    dword_6D4614 = 0;
    dword_6D4628 = 1065353216;
    dword_6D462C = 0;
    dword_6D4640 = 0;
    dword_6D4644 = 1065353216;
    dword_6D4658 = 1065353216;
    dword_6D465C = 1065353216;
    dword_6D45F0 = 1065353216;
    dword_6D45D4 = 1065353216;
    dword_6D45B8 = 1065353216;
    dword_6D459C = 1065353216;
    dword_6D45A4 = 0;
    dword_6D45A8 = 0;
    dword_6D45C0 = 1065353216;
    dword_6D45C4 = 0;
    dword_6D45DC = 0;
    dword_6D45E0 = 1065353216;
    dword_6D45F8 = 1065353216;
    dword_6D45FC = 1065353216;
    *(_DWORD*) (this + 135364) = 0;
    *(_DWORD*) (this + 135352) = 0;
    *(_BYTE*) (this + 135356) = 0;
    *(_BYTE*) (this + 135357) = 0;
    *(_DWORD*) (this + 135348) = 1;
    *(_BYTE*) (this + 135358) = 0;
    *(_BYTE*) (this + 135359) = 0;
    *(_DWORD*) (this + 135448) = -1;
    return this;
}
// 6D459C: using guessed type int dword_6D459C;
// 6D45A4: using guessed type int dword_6D45A4;
// 6D45A8: using guessed type int dword_6D45A8;
// 6D45B8: using guessed type int dword_6D45B8;
// 6D45C0: using guessed type int dword_6D45C0;
// 6D45C4: using guessed type int dword_6D45C4;
// 6D45D4: using guessed type int dword_6D45D4;
// 6D45DC: using guessed type int dword_6D45DC;
// 6D45E0: using guessed type int dword_6D45E0;
// 6D45F0: using guessed type int dword_6D45F0;
// 6D45F8: using guessed type int dword_6D45F8;
// 6D45FC: using guessed type int dword_6D45FC;
// 6D460C: using guessed type int dword_6D460C;
// 6D4610: using guessed type int dword_6D4610;
// 6D4614: using guessed type int dword_6D4614;
// 6D4624: using guessed type int dword_6D4624;
// 6D4628: using guessed type int dword_6D4628;
// 6D462C: using guessed type int dword_6D462C;
// 6D463C: using guessed type int dword_6D463C;
// 6D4640: using guessed type int dword_6D4640;
// 6D4644: using guessed type int dword_6D4644;
// 6D4654: using guessed type int dword_6D4654;
// 6D4658: using guessed type int dword_6D4658;
// 6D465C: using guessed type int dword_6D465C;

//----- (00431660) --------------------------------------------------------
int __thiscall sub_431660(int this) {
    int result; // eax
    void* v3; // [esp+Ch] [ebp-4h] BYREF

    *(_DWORD*) (this + 135408) = -1023410176;
    *(_DWORD*) (this + 135368) = -1023410176;
    *(_DWORD*) (this + 135428) = 1124073472;
    *(_DWORD*) (this + 135388) = 1124073472;
    *(_DWORD*) (this + 135392) = -1023410176;
    *(_DWORD*) (this + 135372) = -1023410176;
    *(_DWORD*) (this + 135432) = 1124073472;
    *(_DWORD*) (this + 135412) = 1124073472;
    *(_DWORD*) (this + 135436) = 0;
    *(_DWORD*) (this + 135416) = 0;
    *(_DWORD*) (this + 135396) = 0;
    *(_DWORD*) (this + 135376) = 0;
    *(_DWORD*) (this + 135420) = 0;
    *(_DWORD*) (this + 135380) = 0;
    *(_DWORD*) (this + 135440) = 1065353216;
    *(_DWORD*) (this + 135400) = 1065353216;
    *(_DWORD*) (this + 135404) = 0;
    *(_DWORD*) (this + 135384) = 0;
    *(_DWORD*) (this + 135444) = 1065353216;
    *(_DWORD*) (this + 135424) = 1065353216;
    dword_6D4660 = *(_DWORD*) (this + 135368);
    dword_6D4664 = *(_DWORD*) (this + 135372);
    dword_6D4668 = *(_DWORD*) (this + 135376);
    dword_6D4678 = *(_DWORD*) (this + 135388);
    dword_6D467C = *(_DWORD*) (this + 135392);
    dword_6D4680 = *(_DWORD*) (this + 135396);
    dword_6D4690 = *(_DWORD*) (this + 135408);
    dword_6D4694 = *(_DWORD*) (this + 135412);
    dword_6D4698 = *(_DWORD*) (this + 135416);
    dword_6D46A8 = *(_DWORD*) (this + 135428);
    dword_6D46AC = *(_DWORD*) (this + 135432);
    dword_6D46B0 = *(_DWORD*) (this + 135436);
    dword_6D4670 = *(_DWORD*) (this + 135380);
    dword_6D4674 = *(_DWORD*) (this + 135384);
    dword_6D4688 = *(_DWORD*) (this + 135400);
    dword_6D468C = *(_DWORD*) (this + 135404);
    dword_6D46A0 = *(_DWORD*) (this + 135420);
    dword_6D46A4 = *(_DWORD*) (this + 135424);
    dword_6D46B8 = *(_DWORD*) (this + 135440);
    result = *(_DWORD*) (this + 135444);
    dword_6D46BC = result;
    if((((unsigned int) dword_6C6E60 >> 1) & 1) == 0) {
        (*(void(__stdcall**)(int, int, _DWORD, int, int, int))(*(_DWORD*) dword_6C6D20 + 92))(
            dword_6C6D20,
            80,
            0,
            258,
            1,
            this + 135364);
        (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, void**, _DWORD))(**(_DWORD**) (this + 135364) + 44))(
            *(_DWORD*) (this + 135364),
            0,
            0,
            &v3,
            0);
        qmemcpy(v3, (const void*) (this + 135368), 0x50u);
        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 135364) + 48))(*(_DWORD*) (this + 135364));
        return (*(int(__stdcall**)(int, _DWORD, _DWORD, int))(*(_DWORD*) dword_6C6D20 + 332))(
            dword_6C6D20,
            0,
            *(_DWORD*) (dword_6D4588 + 135364),
            20);
    }
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;
// 6D4660: using guessed type int dword_6D4660;
// 6D4664: using guessed type int dword_6D4664;
// 6D4668: using guessed type int dword_6D4668;
// 6D4670: using guessed type int dword_6D4670;
// 6D4674: using guessed type int dword_6D4674;
// 6D4678: using guessed type int dword_6D4678;
// 6D467C: using guessed type int dword_6D467C;
// 6D4680: using guessed type int dword_6D4680;
// 6D4688: using guessed type int dword_6D4688;
// 6D468C: using guessed type int dword_6D468C;
// 6D4690: using guessed type int dword_6D4690;
// 6D4694: using guessed type int dword_6D4694;
// 6D4698: using guessed type int dword_6D4698;
// 6D46A0: using guessed type int dword_6D46A0;
// 6D46A4: using guessed type int dword_6D46A4;
// 6D46A8: using guessed type int dword_6D46A8;
// 6D46AC: using guessed type int dword_6D46AC;
// 6D46B0: using guessed type int dword_6D46B0;
// 6D46B8: using guessed type int dword_6D46B8;
// 6D46BC: using guessed type int dword_6D46BC;

//----- (00431920) --------------------------------------------------------
int __thiscall sub_431920(_DWORD** this, int a2, char* Str, int a4, int a5) {
    sub_4321E0(this, a2);
    this [a2 + 29004] = sub_41E290(Str, 0);
    if(!this [a2 + 29004])
        return -1;
    if((((unsigned int) dword_6C6E60 >> 2) & 1) != 0) {
        if(dword_46C220 [a4] != 21 && dword_46C220 [a4]) {
            if(dword_46C220 [a4] == 20)
                a4 = 3;
        }
        else {
            a4 = 5;
        }
    }
    if(sub_4401C6(
        dword_6C6D20,
        (unsigned __int8*) this [a2 + 29004],
        dword_69D914,
        0,
        0,
        0,
        0,
        dword_46C220 [a4],
        1u,
        (float*) 3,
        (float*) 0xFFFFFFFF,
        a5,
        0,
        0,
        (int*) &this [a2 + 28740])) {
        return -1;
    }
    else {
        return 0;
    }
}
// 46C220: using guessed type int dword_46C220[6];
// 69D914: using guessed type int dword_69D914;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00431A10) --------------------------------------------------------
int __thiscall sub_431A10(_DWORD** this, int a2, char* Str, int a4, int a5) {
    unsigned int ii; // [esp+8h] [ebp-68h]
    unsigned int n; // [esp+Ch] [ebp-64h]
    _WORD* v9; // [esp+10h] [ebp-60h]
    _WORD* v10; // [esp+14h] [ebp-5Ch]
    unsigned int m; // [esp+18h] [ebp-58h]
    unsigned int k; // [esp+1Ch] [ebp-54h]
    _WORD* v13; // [esp+20h] [ebp-50h]
    _WORD* v14; // [esp+24h] [ebp-4Ch]
    unsigned int j; // [esp+28h] [ebp-48h]
    unsigned int i; // [esp+2Ch] [ebp-44h]
    _BYTE* v17; // [esp+30h] [ebp-40h]
    int v18; // [esp+34h] [ebp-3Ch]
    int v19; // [esp+38h] [ebp-38h] BYREF
    int v20; // [esp+3Ch] [ebp-34h] BYREF
    int v21; // [esp+40h] [ebp-30h]
    int v22; // [esp+44h] [ebp-2Ch] BYREF
    int v23; // [esp+48h] [ebp-28h]
    void* Block; // [esp+4Ch] [ebp-24h]
    int v25 [6]; // [esp+50h] [ebp-20h] BYREF
    unsigned int v26; // [esp+68h] [ebp-8h]
    unsigned int v27; // [esp+6Ch] [ebp-4h]

    v19 = 0;
    Block = sub_41E290(Str, 0);
    if(!Block)
        return -1;
    (*(void(__thiscall**)(_DWORD*, _DWORD*, _DWORD, int*))(*this [a2 + 28740] + 56))(
        this [a2 + 28740],
        this [a2 + 28740],
        0,
        v25);
    if(v25 [0] != 21 && v25 [0] != 26 && v25 [0] != 25) {
        sub_41E620((int) byte_69D998, aError_10);
        goto LABEL_37;
    }
    if(sub_4401C6(
        dword_6C6D20,
        (unsigned __int8*) Block,
        dword_69D914,
        0,
        0,
        0,
        0,
        v25 [0],
        2u,
        (float*) 3,
        (float*) 0xFFFFFFFF,
        a5,
        0,
        0,
        &v19)
        || (*(int(__thiscall**)(_DWORD*, _DWORD*, _DWORD, int*, _DWORD, _DWORD))(*this [a2 + 28740] + 64))(
        this [a2 + 28740],
        this [a2 + 28740],
        0,
        &v22,
        0,
        0)
        || (*(int(__stdcall**)(int, _DWORD, int*, _DWORD, int))(*(_DWORD*) v19 + 64))(v19, 0, &v20, 0, 0x8000)) {
        LABEL_37:
        if(v19) {
            (*(void(__stdcall**)(int))(*(_DWORD*) v19 + 8))(v19);
            v19 = 0;
        }
        free(Block);
        return -1;
    }
    switch(v25 [0]) {
        case 21:
            for(i = 0; i < v27; ++i) {
                v18 = v22 * i + v23;
                v17 = (_BYTE*) (v20 * i + v21);
                for(j = 0; j < v26; ++j) {
                    *(_BYTE*) (v18 + 3) = *v17;
                    v17 += 4;
                    v18 += 4;
                }
            }
            break;
        case 25:
            for(k = 0; k < v27; ++k) {
                v14 = (_WORD*) (v22 * k + v23);
                v13 = (_WORD*) (v20 * k + v21);
                for(m = 0; m < v26; ++m) {
                    *v14 = ((((*v13++ & 0x1F) >> 4) & 1) << 15) | *v14 & 0x7FFF;
                    ++v14;
                }
            }
            break;
        case 26:
            for(n = 0; n < v27; ++n) {
                v10 = (_WORD*) (v22 * n + v23);
                v9 = (_WORD*) (v20 * n + v21);
                for(ii = 0; ii < v26; ++ii) {
                    *v10 = ((*v9++ & 0xF) << 12) | *v10 & 0xFFF;
                    ++v10;
                }
            }
            break;
    }
    (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) v19 + 68))(v19, 0);
    (*(void(__stdcall**)(_DWORD*, _DWORD))(*this [a2 + 28740] + 68))(this [a2 + 28740], 0);
    if(v19) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v19 + 8))(v19);
        v19 = 0;
    }
    free(Block);
    return 0;
}
// 69D914: using guessed type int dword_69D914;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D20: using guessed type int dword_6C6D20;
// 431A10: using guessed type unsigned int var_20[6];

//----- (00431D70) --------------------------------------------------------
int __thiscall sub_431D70(void* this, int a2, int a3, int a4, int a5) {
    sub_43FE5C(dword_6C6D20, a3, a4, 1, 0, dword_46C220 [a5], 1u, (int) this + 4 * a2 + 114960);
    return 0;
}
// 46C220: using guessed type int dword_46C220[6];
// 6C6D20: using guessed type int dword_6C6D20;

//----- (00431DC0) --------------------------------------------------------
int __thiscall sub_431DC0(_DWORD* this, int a2, char* Str, int a4) {
    int v6 [14]; // [esp+4h] [ebp-4Ch] BYREF
    _DWORD* v7; // [esp+3Ch] [ebp-14h]
    int v8; // [esp+40h] [ebp-10h]
    int v9; // [esp+44h] [ebp-Ch]
    char* v10; // [esp+48h] [ebp-8h]
    _DWORD* v11; // [esp+4Ch] [ebp-4h]

    sub_432030((int) this, a2);
    this [a2 + 33357] = sub_41E290(Str, 0);
    v11 = (_DWORD*) this [a2 + 33357];
    if(!v11) {
        sub_41E620((int) byte_69D998, (char*) &byte_46C2A8, Str);
        return -1;
    }
    v11 [2] = a2;
    v10 = (char*) v11 + v11 [7];
    if(*v10 == 64) {
        sub_431D70(this, v11 [2], v11 [3], v11 [4], v11 [5]);
    }
    else if(sub_431920((_DWORD**) this, v11 [2], v10, v11 [5], v11 [6])) {
        LABEL_6:
        sub_41E620((int) byte_69D998, (char*) &byte_46C260, v10);
        return -1;
    }
    if(v11 [9]) {
        v10 = (char*) v11 + v11 [9];
        if(sub_431A10((_DWORD**) this, v11 [2], v10, v11 [5], v11 [6]))
            goto LABEL_6;
    }
    v11 [8] = a4;
    v7 = v11 + 16;
    v8 = 0;
    while(v8 < *(_DWORD*) this [a2 + 33357]) {
        v9 = (int) v11 + *v7;
        v6 [0] = *(_DWORD*) (this [a2 + 33357] + 8);
        v6 [1] = *(_DWORD*) (v9 + 4);
        v6 [2] = *(_DWORD*) (v9 + 8);
        *(float*) &v6 [3] = *(float*) (v9 + 4) + *(float*) (v9 + 12);
        *(float*) &v6 [4] = *(float*) (v9 + 8) + *(float*) (v9 + 16);
        *(float*) &v6 [6] = (float) (int) v11 [3];
        *(float*) &v6 [5] = (float) (int) v11 [4];
        sub_432260(this, a4 + *(_DWORD*) v9, v6);
        ++v8;
        ++v7;
    }
    v8 = 0;
    while(v8 < v11 [1]) {
        this [a4 + 29261 + *v7] = (char*) v11 + v7 [1];
        this [a4 + 31309 + *v7] = a4;
        ++v8;
        v7 += 2;
    }
    this [a2 + 33485] = a4;
    return 0;
}
// 69D998: using guessed type _BYTE byte_69D998[2048];

//----- (00432030) --------------------------------------------------------
int __thiscall sub_432030(int this, int a2) {
    int result; // eax
    _DWORD* v4; // [esp+Ch] [ebp-14h]
    int i; // [esp+10h] [ebp-10h]
    int j; // [esp+10h] [ebp-10h]
    int v7; // [esp+14h] [ebp-Ch]
    _DWORD* v8; // [esp+18h] [ebp-8h]

    result = a2;
    if(*(_DWORD*) (this + 4 * a2 + 133428)) {
        v7 = *(_DWORD*) (this + 4 * a2 + 133940);
        v4 = (_DWORD*) (*(_DWORD*) (this + 4 * a2 + 133428) + 64);
        for(i = 0; i < **(_DWORD**) (this + 4 * a2 + 133428); ++i) {
            v8 = (_DWORD*) (*v4 + *(_DWORD*) (this + 4 * a2 + 133428));
            memset((void*) (56 * (v7 + *v8) + this), 0, 0x38u);
            *(_DWORD*) (this + 56 * (v7 + *v8)) = -1;
            ++v4;
        }
        for(j = 0; j < *(_DWORD*) (*(_DWORD*) (this + 4 * a2 + 133428) + 4); ++j) {
            *(_DWORD*) (this + 4 * (v7 + *v4) + 117044) = 0;
            *(_DWORD*) (this + 4 * (v7 + *v4) + 125236) = 0;
            v4 += 2;
        }
        *(_DWORD*) (this + 4 * a2 + 133940) = 0;
        sub_4321E0((_DWORD**) this, *(_DWORD*) (*(_DWORD*) (this + 4 * a2 + 133428) + 8));
        free(*(void**) (this + 4 * a2 + 133428));
        *(_DWORD*) (this + 4 * a2 + 133428) = 0;
        *(_BYTE*) (this + 135356) = -1;
        *(_BYTE*) (this + 135357) = -1;
        result = this;
        *(_BYTE*) (this + 135358) = -1;
        *(_DWORD*) (this + 135352) = 0;
    }
    return result;
}

//----- (004321E0) --------------------------------------------------------
int __thiscall sub_4321E0(_DWORD** this, int a2) {
    int result; // eax

    if(this [a2 + 28740]) {
        (*(void(__thiscall**)(_DWORD*, _DWORD*))(*this [a2 + 28740] + 8))(this [a2 + 28740], this [a2 + 28740]);
        this [a2 + 28740] = 0;
    }
    free(this [a2 + 29004]);
    this [a2 + 29004] = 0;
    return result;
}

//----- (00432260) --------------------------------------------------------
_DWORD* __thiscall sub_432260(_DWORD* this, int a2, const void* a3) {
    _DWORD* result; // eax

    qmemcpy(&this [14 * a2], a3, 0x38u);
    this [14 * a2 + 13] = this [29260]++;
    *(float*) &this [14 * a2 + 7] = *(float*) &this [14 * a2 + 1] / *(float*) &this [14 * a2 + 6];
    *(float*) &this [14 * a2 + 9] = *(float*) &this [14 * a2 + 3] / *(float*) &this [14 * a2 + 6];
    *(float*) &this [14 * a2 + 8] = *(float*) &this [14 * a2 + 2] / *(float*) &this [14 * a2 + 5];
    *(float*) &this [14 * a2 + 10] = *(float*) &this [14 * a2 + 4] / *(float*) &this [14 * a2 + 5];
    *(float*) &this [14 * a2 + 12] = *(float*) &this [14 * a2 + 3] - *(float*) &this [14 * a2 + 1];
    result = this;
    *(float*) &this [14 * a2 + 11] = *(float*) &this [14 * a2 + 4] - *(float*) &this [14 * a2 + 2];
    return result;
}

//----- (004323A0) --------------------------------------------------------
int __thiscall sub_4323A0(int* this, int a2, int a3) {
    if(this [14 * a3] < 0)
        return -1;
    *(_WORD*) (a2 + 176) = a3;
    *(_DWORD*) (a2 + 192) = &this [14 * a3];
    sub_403670((_DWORD*) (a2 + 60));
    *(float*) (a2 + 60) = *(float*) (*(_DWORD*) (a2 + 192) + 48) / *(float*) (*(_DWORD*) (a2 + 192) + 24);
    *(float*) (a2 + 80) = *(float*) (*(_DWORD*) (a2 + 192) + 44) / *(float*) (*(_DWORD*) (a2 + 192) + 20);
    return 0;
}

//----- (00432430) --------------------------------------------------------
int __thiscall sub_432430(int* this, _DWORD* a2, int a3) {
    int v3; // ecx
    int result; // eax

    v3 = a2 [32];
    LOBYTE(v3) = v3 & 0x3F;
    a2 [32] = v3;
    sub_403580(a2);
    a2 [46] = a3;
    a2 [47] = a2 [46];
    a2 [14] = 0;
    a2 [13] = 0;
    a2 [12] = -999;
    result = (int) a2;
    a2 [32] &= ~1u;
    if(a3)
        return sub_433960(this, (int) a2);
    return result;
}

//----- (004324D0) --------------------------------------------------------
unsigned int __thiscall sub_4324D0(int this, unsigned int a2) {
    unsigned int result; // eax

    if(*(_BYTE*) (this + 135356) != ((*(_DWORD*) (a2 + 128) >> 2) & 1)) {
        *(_BYTE*) (this + 135356) = (*(_DWORD*) (a2 + 128) & 4) != 0;
        if(*(_BYTE*) (this + 135356))
            (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 20, 2);
        else
            (*(void(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 20, 6);
    }
    if((dword_6C6E60 & 1) == 0
       && (((unsigned int) dword_6C6E60 >> 8) & 1) == 0
       && *(_BYTE*) (this + 135357) != ((*(_DWORD*) (a2 + 128) >> 3) & 1)) {
        *(_BYTE*) (this + 135357) = (*(_DWORD*) (a2 + 128) & 8) != 0;
        if(*(_BYTE*) (this + 135357))
            (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 7);
        else
            (*(void(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) dword_6C6D20 + 252))(dword_6C6D20, 0, 1, 4);
    }
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0) {
        dword_6D45A0 = *(_DWORD*) (a2 + 124);
        dword_6D45BC = *(_DWORD*) (a2 + 124);
        dword_6D45D8 = *(_DWORD*) (a2 + 124);
        dword_6D45F4 = *(_DWORD*) (a2 + 124);
        dword_6D466C = *(_DWORD*) (a2 + 124);
        dword_6D4684 = *(_DWORD*) (a2 + 124);
        dword_6D469C = *(_DWORD*) (a2 + 124);
        dword_6D46B4 = *(_DWORD*) (a2 + 124);
    }
    else if(*(_DWORD*) (this + 135348) != *(_DWORD*) (a2 + 124)) {
        *(_DWORD*) (this + 135348) = *(_DWORD*) (a2 + 124);
        (*(void(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(
            dword_6C6D20,
            60,
            *(_DWORD*) (this + 135348));
    }
    result = ((unsigned int) dword_6C6E60 >> 6) & 1;
    if(!result) {
        result = a2;
        if(*(_BYTE*) (this + 135359) != ((*(_DWORD*) (a2 + 128) >> 12) & 1)) {
            *(_BYTE*) (this + 135359) = (*(_DWORD*) (a2 + 128) & 0x1000) != 0;
            if(*(_BYTE*) (this + 135359))
                return (*(int(__stdcall**)(int, int, _DWORD))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 14, 0);
            else
                return (*(int(__stdcall**)(int, int, int))(*(_DWORD*) dword_6C6D20 + 200))(dword_6C6D20, 14, 1);
        }
    }
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;
// 6D45A0: using guessed type int dword_6D45A0;
// 6D45BC: using guessed type int dword_6D45BC;
// 6D45D8: using guessed type int dword_6D45D8;
// 6D45F4: using guessed type int dword_6D45F4;
// 6D466C: using guessed type int dword_6D466C;
// 6D4684: using guessed type int dword_6D4684;
// 6D469C: using guessed type int dword_6D469C;
// 6D46B4: using guessed type int dword_6D46B4;

//----- (00432730) --------------------------------------------------------
int __thiscall sub_432730(int this, unsigned int a2, int a3) {
    if(a3) {
        _ST7 = flt_6D4600;
        __asm { frndint }
        _ST6 = flt_6D4618;
        __asm { frndint }
        _ST5 = flt_6D4604;
        __asm { frndint }
        _ST4 = flt_6D4634;
        __asm { frndint }
        flt_6D4634 = _ST4 - 0.5;
        flt_6D464C = flt_6D4634;
        flt_6D4604 = _ST5 - 0.5;
        flt_6D461C = flt_6D4604;
        flt_6D4618 = _ST6 - 0.5;
        flt_6D4648 = flt_6D4618;
        flt_6D4600 = _ST7 - 0.5;
        flt_6D4630 = flt_6D4600;
    }
    dword_6D4650 = *(_DWORD*) (a2 + 152);
    dword_6D4638 = dword_6D4650;
    dword_6D4620 = dword_6D4650;
    dword_6D4608 = dword_6D4650;
    if(*(_DWORD*) (this + 135360) != *(_DWORD*) (a2 + 192)) {
        *(_DWORD*) (this + 135360) = *(_DWORD*) (a2 + 192);
        *(float*) &dword_6D4640 = *(float*) (*(_DWORD*) (a2 + 192) + 28) + *(float*) (a2 + 40);
        dword_6D4610 = dword_6D4640;
        *(float*) &dword_6D4658 = *(float*) (*(_DWORD*) (a2 + 192) + 36) + *(float*) (a2 + 40);
        dword_6D4628 = dword_6D4658;
        *(float*) &dword_6D462C = *(float*) (*(_DWORD*) (a2 + 192) + 32) + *(float*) (a2 + 44);
        dword_6D4614 = dword_6D462C;
        *(float*) &dword_6D465C = *(float*) (*(_DWORD*) (a2 + 192) + 40) + *(float*) (a2 + 44);
        dword_6D4644 = dword_6D465C;
        if(*(_DWORD*) (this + 135352) != *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960)) {
            *(_DWORD*) (this + 135352) = *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960);
            (*(void(__stdcall**)(int, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 244))(
                dword_6C6D20,
                0,
                *(_DWORD*) (this + 135352));
        }
    }
    if(*(_BYTE*) (this + 135358) != 2) {
        if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0)
            (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 324);
        else
            (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 260);
        *(_BYTE*) (this + 135358) = 2;
    }
    sub_4324D0(this, a2);
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0) {
        dword_6D4590 = LODWORD(flt_6D4600);
        dword_6D4594 = LODWORD(flt_6D4604);
        dword_6D4598 = dword_6D4608;
        dword_6D45AC = LODWORD(flt_6D4618);
        dword_6D45B0 = LODWORD(flt_6D461C);
        dword_6D45B4 = dword_6D4620;
        dword_6D45C8 = LODWORD(flt_6D4630);
        dword_6D45CC = LODWORD(flt_6D4634);
        dword_6D45D0 = dword_6D4638;
        dword_6D45E4 = LODWORD(flt_6D4648);
        dword_6D45E8 = LODWORD(flt_6D464C);
        dword_6D45EC = dword_6D4650;
        *(float*) &dword_6D45DC = *(float*) (*(_DWORD*) (a2 + 192) + 28) + *(float*) (a2 + 40);
        dword_6D45A4 = dword_6D45DC;
        *(float*) &dword_6D45F8 = *(float*) (*(_DWORD*) (a2 + 192) + 36) + *(float*) (a2 + 40);
        dword_6D45C0 = dword_6D45F8;
        *(float*) &dword_6D45C4 = *(float*) (*(_DWORD*) (a2 + 192) + 32) + *(float*) (a2 + 44);
        dword_6D45A8 = dword_6D45C4;
        *(float*) &dword_6D45FC = *(float*) (*(_DWORD*) (a2 + 192) + 40) + *(float*) (a2 + 44);
        dword_6D45E0 = dword_6D45FC;
        (*(void(__stdcall**)(int, int, int, int*, int))(*(_DWORD*) dword_6C6D20 + 288))(
            dword_6C6D20,
            5,
            2,
            &dword_6D4590,
            28);
    }
    else {
        (*(void(__stdcall**)(int, int, int, float*, int))(*(_DWORD*) dword_6C6D20 + 288))(
            dword_6C6D20,
            5,
            2,
            &flt_6D4600,
            24);
    }
    return 0;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;
// 6D4590: using guessed type int dword_6D4590;
// 6D4594: using guessed type int dword_6D4594;
// 6D4598: using guessed type int dword_6D4598;
// 6D45A4: using guessed type int dword_6D45A4;
// 6D45A8: using guessed type int dword_6D45A8;
// 6D45AC: using guessed type int dword_6D45AC;
// 6D45B0: using guessed type int dword_6D45B0;
// 6D45B4: using guessed type int dword_6D45B4;
// 6D45C0: using guessed type int dword_6D45C0;
// 6D45C4: using guessed type int dword_6D45C4;
// 6D45C8: using guessed type int dword_6D45C8;
// 6D45CC: using guessed type int dword_6D45CC;
// 6D45D0: using guessed type int dword_6D45D0;
// 6D45DC: using guessed type int dword_6D45DC;
// 6D45E0: using guessed type int dword_6D45E0;
// 6D45E4: using guessed type int dword_6D45E4;
// 6D45E8: using guessed type int dword_6D45E8;
// 6D45EC: using guessed type int dword_6D45EC;
// 6D45F8: using guessed type int dword_6D45F8;
// 6D45FC: using guessed type int dword_6D45FC;
// 6D4600: using guessed type float flt_6D4600;
// 6D4604: using guessed type float flt_6D4604;
// 6D4608: using guessed type int dword_6D4608;
// 6D4610: using guessed type int dword_6D4610;
// 6D4614: using guessed type int dword_6D4614;
// 6D4618: using guessed type float flt_6D4618;
// 6D461C: using guessed type float flt_6D461C;
// 6D4620: using guessed type int dword_6D4620;
// 6D4628: using guessed type int dword_6D4628;
// 6D462C: using guessed type int dword_6D462C;
// 6D4630: using guessed type float flt_6D4630;
// 6D4634: using guessed type float flt_6D4634;
// 6D4638: using guessed type int dword_6D4638;
// 6D4640: using guessed type int dword_6D4640;
// 6D4644: using guessed type int dword_6D4644;
// 6D4648: using guessed type float flt_6D4648;
// 6D464C: using guessed type float flt_6D464C;
// 6D4650: using guessed type int dword_6D4650;
// 6D4658: using guessed type int dword_6D4658;
// 6D465C: using guessed type int dword_6D465C;

//----- (00432AD0) --------------------------------------------------------
int __thiscall sub_432AD0(void* this, unsigned int a2) {
    float v3; // [esp+4h] [ebp-8h]
    float v4; // [esp+8h] [ebp-4h]

    if((*(_DWORD*) (a2 + 128) & 1) == 0)
        return -1;
    if(((*(_DWORD*) (a2 + 128) >> 1) & 1) == 0)
        return -1;
    if(!*(_DWORD*) (a2 + 124))
        return -1;
    v4 = *(float*) (*(_DWORD*) (a2 + 192) + 48) * *(float*) (a2 + 28) / 2.0;
    v3 = *(float*) (*(_DWORD*) (a2 + 192) + 44) * *(float*) (a2 + 24) / 2.0;
    if((*(_DWORD*) (a2 + 128) & 0x100) != 0) {
        flt_6D4630 = *(float*) (a2 + 144);
        flt_6D4600 = flt_6D4630;
        flt_6D4648 = v4 + *(float*) (a2 + 144) + v4;
    }
    else {
        flt_6D4630 = *(float*) (a2 + 144) - v4;
        flt_6D4600 = flt_6D4630;
        flt_6D4648 = v4 + *(float*) (a2 + 144);
    }
    flt_6D4618 = flt_6D4648;
    if((*(_DWORD*) (a2 + 128) & 0x200) != 0) {
        flt_6D461C = *(float*) (a2 + 148);
        flt_6D4604 = flt_6D461C;
        flt_6D464C = v3 + *(float*) (a2 + 148) + v3;
    }
    else {
        flt_6D461C = *(float*) (a2 + 148) - v3;
        flt_6D4604 = flt_6D461C;
        flt_6D464C = v3 + *(float*) (a2 + 148);
    }
    flt_6D4634 = flt_6D464C;
    return sub_432730((int) this, a2, 1);
}
// 6D4600: using guessed type float flt_6D4600;
// 6D4604: using guessed type float flt_6D4604;
// 6D4618: using guessed type float flt_6D4618;
// 6D461C: using guessed type float flt_6D461C;
// 6D4630: using guessed type float flt_6D4630;
// 6D4634: using guessed type float flt_6D4634;
// 6D4648: using guessed type float flt_6D4648;
// 6D464C: using guessed type float flt_6D464C;

//----- (00432C80) --------------------------------------------------------
float* __stdcall sub_432C80(float* a1, float a2, float a3, float a4, float a5, float a6, float a7) {
    float* result; // eax

    result = a1;
    *a1 = a2 * a5 + a3 * a4 + a6;
    a1 [1] = -a2 * a4 + a3 * a5 + a7;
    return result;
}

//----- (00432CC0) --------------------------------------------------------
int __thiscall sub_432CC0(void* this, unsigned int a2) {
    float v11; // [esp+0h] [ebp-48h]
    float v12; // [esp+0h] [ebp-48h]
    float v13; // [esp+0h] [ebp-48h]
    float v14; // [esp+0h] [ebp-48h]
    float v15; // [esp+4h] [ebp-44h]
    float v16; // [esp+4h] [ebp-44h]
    float v17; // [esp+4h] [ebp-44h]
    float v18; // [esp+4h] [ebp-44h]
    float v20; // [esp+1Ch] [ebp-2Ch]
    float v21; // [esp+1Ch] [ebp-2Ch]
    float v22; // [esp+20h] [ebp-28h]
    float v23; // [esp+20h] [ebp-28h]
    float v24; // [esp+24h] [ebp-24h]
    float v25; // [esp+28h] [ebp-20h]
    float v26; // [esp+2Ch] [ebp-1Ch]
    float v27; // [esp+30h] [ebp-18h]
    float v28; // [esp+34h] [ebp-14h]

    if(*(float*) (a2 + 8) == 0.0)
        return sub_432AD0(this, a2);
    if((*(_DWORD*) (a2 + 128) & 1) == 0)
        return -1;
    if(((*(_DWORD*) (a2 + 128) >> 1) & 1) == 0)
        return -1;
    if(!*(_DWORD*) (a2 + 124))
        return -1;
    v27 = *(float*) (a2 + 8);
    v26 = cos(v27);
    v28 = sin(v27);
    _ST7 = *(float*) (a2 + 144);
    __asm { frndint }
    v25 = _ST7;
    _ST7 = *(float*) (a2 + 148);
    __asm { frndint }
    v24 = _ST7;
    v22 = *(float*) (*(_DWORD*) (a2 + 192) + 48) * *(float*) (a2 + 28) / 2.0;
    _ST7 = v22;
    __asm { frndint }
    v23 = _ST7;
    v20 = *(float*) (*(_DWORD*) (a2 + 192) + 44) * *(float*) (a2 + 24) / 2.0;
    _ST7 = v20;
    __asm { frndint }
    v21 = _ST7;
    v15 = -v21 - 0.5;
    v11 = -v23 - 0.5;
    sub_432C80(&flt_6D4600, v11, v15, v28, v26, v25, v24);
    v16 = -v21 - 0.5;
    v12 = v23 - 0.5;
    sub_432C80(&flt_6D4618, v12, v16, v28, v26, v25, v24);
    v17 = v21 - 0.5;
    v13 = -v23 - 0.5;
    sub_432C80(&flt_6D4630, v13, v17, v28, v26, v25, v24);
    v18 = v21 - 0.5;
    v14 = v23 - 0.5;
    sub_432C80(&flt_6D4648, v14, v18, v28, v26, v25, v24);
    dword_6D4650 = *(_DWORD*) (a2 + 152);
    dword_6D4638 = dword_6D4650;
    dword_6D4620 = dword_6D4650;
    dword_6D4608 = dword_6D4650;
    if((*(_DWORD*) (a2 + 128) & 0x100) != 0) {
        flt_6D4600 = flt_6D4600 + v23;
        flt_6D4618 = flt_6D4618 + v23;
        flt_6D4630 = flt_6D4630 + v23;
        flt_6D4648 = flt_6D4648 + v23;
    }
    if((*(_DWORD*) (a2 + 128) & 0x200) != 0) {
        flt_6D4604 = flt_6D4604 + v21;
        flt_6D461C = flt_6D461C + v21;
        flt_6D4634 = flt_6D4634 + v21;
        flt_6D464C = flt_6D464C + v21;
    }
    return sub_432730((int) this, a2, 0);
}
// 6D4600: using guessed type float flt_6D4600;
// 6D4604: using guessed type float flt_6D4604;
// 6D4608: using guessed type int dword_6D4608;
// 6D4618: using guessed type float flt_6D4618;
// 6D461C: using guessed type float flt_6D461C;
// 6D4620: using guessed type int dword_6D4620;
// 6D4630: using guessed type float flt_6D4630;
// 6D4634: using guessed type float flt_6D4634;
// 6D4638: using guessed type int dword_6D4638;
// 6D4648: using guessed type float flt_6D4648;
// 6D464C: using guessed type float flt_6D464C;
// 6D4650: using guessed type int dword_6D4650;

//----- (00432FA0) --------------------------------------------------------
int __thiscall sub_432FA0(void* this, unsigned int a2) {
    float v3; // [esp+4h] [ebp-8h]
    float v4; // [esp+8h] [ebp-4h]

    if((*(_DWORD*) (a2 + 128) & 1) == 0)
        return -1;
    if(((*(_DWORD*) (a2 + 128) >> 1) & 1) == 0)
        return -1;
    if(!*(_DWORD*) (a2 + 124))
        return -1;
    v4 = *(float*) (*(_DWORD*) (a2 + 192) + 48) * *(float*) (a2 + 28) / 2.0;
    v3 = *(float*) (*(_DWORD*) (a2 + 192) + 44) * *(float*) (a2 + 24) / 2.0;
    if((*(_DWORD*) (a2 + 128) & 0x100) != 0) {
        flt_6D4630 = *(float*) (a2 + 144);
        flt_6D4600 = flt_6D4630;
        flt_6D4648 = v4 + *(float*) (a2 + 144) + v4;
    }
    else {
        flt_6D4630 = *(float*) (a2 + 144) - v4;
        flt_6D4600 = flt_6D4630;
        flt_6D4648 = v4 + *(float*) (a2 + 144);
    }
    flt_6D4618 = flt_6D4648;
    if((*(_DWORD*) (a2 + 128) & 0x200) != 0) {
        flt_6D461C = *(float*) (a2 + 148);
        flt_6D4604 = flt_6D461C;
        flt_6D464C = v3 + *(float*) (a2 + 148) + v3;
    }
    else {
        flt_6D461C = *(float*) (a2 + 148) - v3;
        flt_6D4604 = flt_6D461C;
        flt_6D464C = v3 + *(float*) (a2 + 148);
    }
    flt_6D4634 = flt_6D464C;
    return sub_432730((int) this, a2, 0);
}
// 6D4600: using guessed type float flt_6D4600;
// 6D4604: using guessed type float flt_6D4604;
// 6D4618: using guessed type float flt_6D4618;
// 6D461C: using guessed type float flt_6D461C;
// 6D4630: using guessed type float flt_6D4630;
// 6D4634: using guessed type float flt_6D4634;
// 6D4648: using guessed type float flt_6D4648;
// 6D464C: using guessed type float flt_6D464C;

//----- (00433150) --------------------------------------------------------
int __thiscall sub_433150(int this, unsigned int a2) {
    float v3; // [esp+10h] [ebp-D8h]
    float v4; // [esp+14h] [ebp-D4h]
    float v6; // [esp+20h] [ebp-C8h]
    float v7; // [esp+24h] [ebp-C4h]
    float v8 [16]; // [esp+28h] [ebp-C0h] BYREF
    int v9 [16]; // [esp+68h] [ebp-80h] BYREF
    float v10 [16]; // [esp+A8h] [ebp-40h] BYREF

    if((*(_DWORD*) (a2 + 128) & 1) == 0)
        return -1;
    if(((*(_DWORD*) (a2 + 128) >> 1) & 1) == 0)
        return -1;
    if(!*(_DWORD*) (a2 + 124))
        return -1;
    qmemcpy(v8, (const void*) (a2 + 60), sizeof(v8));
    v8 [0] = v8 [0] * *(float*) (a2 + 28);
    v8 [5] = -*(float*) (a2 + 24) * v8 [5];
    if(*(float*) a2 != 0.0) {
        sub_43ED9B((float*) v9, *(float*) a2);
        sub_43EC4B((char*) v8, (char*) v8, (char*) v9);
    }
    if(*(float*) (a2 + 4) != 0.0) {
        sub_43EE15((float*) v9, *(float*) (a2 + 4));
        sub_43EC4B((char*) v8, (char*) v8, (char*) v9);
    }
    if(*(float*) (a2 + 8) != 0.0) {
        sub_43EE90((float*) v9, *(float*) (a2 + 8));
        sub_43EC4B((char*) v8, (char*) v8, (char*) v9);
    }
    if((*(_DWORD*) (a2 + 128) & 0x100) != 0) {
        v7 = *(float*) (*(_DWORD*) (a2 + 192) + 48) * *(float*) (a2 + 28) / 2.0;
        v4 = fabs(v7);
        v8 [12] = v4 + *(float*) (a2 + 144);
    }
    else {
        v8 [12] = *(float*) (a2 + 144);
    }
    if((*(_DWORD*) (a2 + 128) & 0x200) != 0) {
        v6 = *(float*) (*(_DWORD*) (a2 + 192) + 44) * *(float*) (a2 + 24) / 2.0;
        v3 = fabs(v6);
        v8 [13] = -*(float*) (a2 + 148) - v3;
    }
    else {
        v8 [13] = -*(float*) (a2 + 148);
    }
    v8 [14] = *(float*) (a2 + 152);
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 256, v8);
    if(*(_DWORD*) (this + 135360) != *(_DWORD*) (a2 + 192)) {
        *(_DWORD*) (this + 135360) = *(_DWORD*) (a2 + 192);
        qmemcpy(v10, (const void*) (a2 + 60), sizeof(v10));
        v10 [8] = *(float*) (*(_DWORD*) (a2 + 192) + 28) + *(float*) (a2 + 40);
        v10 [9] = *(float*) (*(_DWORD*) (a2 + 192) + 32) + *(float*) (a2 + 44);
        (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 16, v10);
        if(*(_DWORD*) (this + 135352) != *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960)) {
            *(_DWORD*) (this + 135352) = *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960);
            (*(void(__stdcall**)(int, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 244))(
                dword_6C6D20,
                0,
                *(_DWORD*) (this + 135352));
        }
    }
    if(*(_BYTE*) (this + 135358) != 3) {
        if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0) {
            (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 322);
        }
        else {
            (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 258);
            (*(void(__stdcall**)(int, _DWORD, _DWORD, int))(*(_DWORD*) dword_6C6D20 + 332))(
                dword_6C6D20,
                0,
                *(_DWORD*) (this + 135364),
                20);
        }
        *(_BYTE*) (this + 135358) = 3;
    }
    sub_4324D0(this, a2);
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0)
        (*(void(__stdcall**)(int, int, int, int*, int))(*(_DWORD*) dword_6C6D20 + 288))(
            dword_6C6D20,
            5,
            2,
            &dword_6D4660,
            24);
    else
        (*(void(__stdcall**)(int, int, _DWORD, int))(*(_DWORD*) dword_6C6D20 + 280))(dword_6C6D20, 5, 0, 2);
    return 0;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;
// 6D4660: using guessed type int dword_6D4660;

//----- (00433590) --------------------------------------------------------
int __thiscall sub_433590(int this, unsigned int a2) {
    float v8; // [esp+10h] [ebp-CCh]
    float v9; // [esp+18h] [ebp-C4h]
    float v10 [32]; // [esp+1Ch] [ebp-C0h] BYREF
    float v11 [16]; // [esp+9Ch] [ebp-40h] BYREF

    if((*(_DWORD*) (a2 + 128) & 1) == 0)
        return -1;
    if(((*(_DWORD*) (a2 + 128) >> 1) & 1) == 0)
        return -1;
    if(*(float*) a2 != 0.0 || *(float*) (a2 + 4) != 0.0 || *(float*) (a2 + 8) != 0.0)
        return sub_433150(this, a2);
    if(!*(_DWORD*) (a2 + 124))
        return -1;
    qmemcpy(v10, (const void*) (a2 + 60), 0x40u);
    _ST7 = *(float*) (a2 + 144);
    __asm { frndint }
    v9 = _ST7;
    v10 [12] = v9 - 0.5;
    _ST7 = *(float*) (a2 + 148);
    __asm { frndint }
    v8 = _ST7;
    v10 [13] = 0.5 - v8;
    if((*(_DWORD*) (a2 + 128) & 0x100) != 0)
        v10 [12] = *(float*) (*(_DWORD*) (a2 + 192) + 48) * *(float*) (a2 + 28) / 2.0 + v10 [12];
    if((*(_DWORD*) (a2 + 128) & 0x200) != 0)
        v10 [13] = v10 [13] - *(float*) (*(_DWORD*) (a2 + 192) + 44) * *(float*) (a2 + 24) / 2.0;
    v10 [14] = *(float*) (a2 + 152);
    v10 [0] = v10 [0] * *(float*) (a2 + 28);
    v10 [5] = -*(float*) (a2 + 24) * v10 [5];
    (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 256, v10);
    if(*(_DWORD*) (this + 135360) != *(_DWORD*) (a2 + 192)) {
        *(_DWORD*) (this + 135360) = *(_DWORD*) (a2 + 192);
        qmemcpy(v11, (const void*) (a2 + 60), sizeof(v11));
        v11 [8] = *(float*) (*(_DWORD*) (a2 + 192) + 28) + *(float*) (a2 + 40);
        v11 [9] = *(float*) (*(_DWORD*) (a2 + 192) + 32) + *(float*) (a2 + 44);
        (*(void(__stdcall**)(int, int, float*))(*(_DWORD*) dword_6C6D20 + 148))(dword_6C6D20, 16, v11);
        if(*(_DWORD*) (this + 135352) != *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960)) {
            *(_DWORD*) (this + 135352) = *(_DWORD*) (this + 4 * **(_DWORD**) (a2 + 192) + 114960);
            (*(void(__stdcall**)(int, _DWORD, _DWORD))(*(_DWORD*) dword_6C6D20 + 244))(
                dword_6C6D20,
                0,
                *(_DWORD*) (this + 135352));
        }
        if(*(_BYTE*) (this + 135358) != 3) {
            if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0) {
                (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 322);
            }
            else {
                (*(void(__stdcall**)(int, int))(*(_DWORD*) dword_6C6D20 + 304))(dword_6C6D20, 258);
                (*(void(__stdcall**)(int, _DWORD, _DWORD, int))(*(_DWORD*) dword_6C6D20 + 332))(
                    dword_6C6D20,
                    0,
                    *(_DWORD*) (this + 135364),
                    20);
            }
            *(_BYTE*) (this + 135358) = 3;
        }
    }
    sub_4324D0(this, a2);
    if((((unsigned int) dword_6C6E60 >> 1) & 1) != 0)
        (*(void(__stdcall**)(int, int, int, int*, int))(*(_DWORD*) dword_6C6D20 + 288))(
            dword_6C6D20,
            5,
            2,
            &dword_6D4660,
            24);
    else
        (*(void(__stdcall**)(int, int, _DWORD, int))(*(_DWORD*) dword_6C6D20 + 280))(dword_6C6D20, 5, 0, 2);
    return 0;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E60: using guessed type int dword_6C6E60;
// 6D4660: using guessed type int dword_6D4660;

//----- (00433960) --------------------------------------------------------
int __thiscall sub_433960(int* this, int a2) {
    int v3; // ecx
    int v4; // ecx
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    int v11; // edx
    int v12; // eax
    int v13; // eax
    __int16 v14; // fps
    double v15; // st7
    bool v16; // c0
    char v17; // c2
    bool v18; // c3
    __int16 v19; // fps
    double v20; // st7
    bool v21; // c0
    char v22; // c2
    bool v23; // c3
    int v24; // edx
    __int16 v25; // fps
    bool v26; // c0
    char v27; // c2
    bool v28; // c3
    __int16 v29; // fps
    bool v30; // c0
    char v31; // c2
    bool v32; // c3
    float v33; // [esp+0h] [ebp-130h]
    float v34; // [esp+0h] [ebp-130h]
    float v35; // [esp+0h] [ebp-130h]
    int v36; // [esp+4h] [ebp-12Ch]
    float v37; // [esp+8h] [ebp-128h]
    float v38; // [esp+Ch] [ebp-124h]
    char v39; // [esp+14h] [ebp-11Ch]
    float v40; // [esp+20h] [ebp-110h]
    float v41; // [esp+28h] [ebp-108h]
    float v42; // [esp+30h] [ebp-100h]
    float v43; // [esp+34h] [ebp-FCh]
    float v44; // [esp+3Ch] [ebp-F4h]
    float v45; // [esp+44h] [ebp-ECh]
    float v46; // [esp+48h] [ebp-E8h]
    float v47; // [esp+50h] [ebp-E0h]
    int v48; // [esp+54h] [ebp-DCh]
    unsigned __int16 v50; // [esp+CAh] [ebp-66h]
    int v51; // [esp+D8h] [ebp-58h]
    int v52; // [esp+DCh] [ebp-54h]
    int v53; // [esp+E4h] [ebp-4Ch]
    int v54; // [esp+E8h] [ebp-48h]
    int v55; // [esp+F0h] [ebp-40h]
    int v56; // [esp+F4h] [ebp-3Ch]
    float v57; // [esp+F8h] [ebp-38h]
    float v58; // [esp+F8h] [ebp-38h]
    float v59; // [esp+F8h] [ebp-38h]
    float v60; // [esp+F8h] [ebp-38h]
    float v61; // [esp+F8h] [ebp-38h]
    int j; // [esp+FCh] [ebp-34h]
    int v63; // [esp+100h] [ebp-30h]
    float v64; // [esp+104h] [ebp-2Ch]
    int v65; // [esp+108h] [ebp-28h]
    int v66; // [esp+10Ch] [ebp-24h]
    __int16* v67; // [esp+110h] [ebp-20h]
    __int16* v68; // [esp+114h] [ebp-1Ch]
    _DWORD* v69; // [esp+118h] [ebp-18h]
    _DWORD* v70; // [esp+11Ch] [ebp-14h]
    _DWORD* v71; // [esp+120h] [ebp-10h]
    _DWORD* v72; // [esp+124h] [ebp-Ch]
    _DWORD* v73; // [esp+128h] [ebp-8h]
    __int16* i; // [esp+12Ch] [ebp-4h]

    if(!*(_DWORD*) (a2 + 188))
        return 1;
    if(!*(_WORD*) (a2 + 138))
        goto LABEL_4;
    LABEL_40:
    v67 = 0;
    for(i = *(__int16**) (a2 + 184);
        (*((_BYTE*) i + 2) != 22 || *(__int16*) (a2 + 138) != *((_DWORD*) i + 1))
        && *((_BYTE*) i + 2)
        && *((_BYTE*) i + 2) != 15;
        i = (__int16*) ((char*) i + *((unsigned __int8*) i + 3) + 4)) {
        if(*((_BYTE*) i + 2) == 22 && *((_DWORD*) i + 1) == -1)
            v67 = i;
    }
    *(_WORD*) (a2 + 138) = 0;
    v11 = *(_DWORD*) (a2 + 128);
    BYTE1(v11) &= ~0x20u;
    *(_DWORD*) (a2 + 128) = v11;
    if(*((_BYTE*) i + 2) == 22) {
        LABEL_53:
        i = (__int16*) ((char*) i + *((unsigned __int8*) i + 3) + 4);
        *(_DWORD*) (a2 + 188) = i;
        *(_DWORD*) (a2 + 56) = **(__int16**) (a2 + 188);
        *(_DWORD*) (a2 + 52) = 0;
        *(_DWORD*) (a2 + 48) = -999;
        *(_DWORD*) (a2 + 128) |= 1u;
        LABEL_4:
        while(2) {
            i = *(__int16**) (a2 + 188);
            if(*i <= *(_DWORD*) (a2 + 56)) {
                switch(*((_BYTE*) i + 2)) {
                    case 0:
                        *(_DWORD*) (a2 + 128) &= ~1u;
                        goto LABEL_7;
                    case 1:
                        *(_DWORD*) (a2 + 128) |= 1u;
                        sub_4323A0(this, a2, this [*(__int16*) (a2 + 180) + 31309] + *((_DWORD*) i + 1));
                        *(_DWORD*) (a2 + 252) = *(_DWORD*) (a2 + 56);
                        goto LABEL_68;
                    case 2:
                        *(_DWORD*) (a2 + 28) = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 24) = *((_DWORD*) i + 2);
                        goto LABEL_68;
                    case 3:
                        *(_BYTE*) (a2 + 127) = *((_DWORD*) i + 1);
                        goto LABEL_68;
                    case 4:
                        *(_DWORD*) (a2 + 124) = *((_DWORD*) i + 1) & 0xFFFFFF | *(_DWORD*) (a2 + 124) & 0xFF000000;
                        goto LABEL_68;
                    case 5:
                        *(_DWORD*) (a2 + 188) = *((_DWORD*) i + 1) + *(_DWORD*) (a2 + 184);
                        *(_DWORD*) (a2 + 56) = **(__int16**) (a2 + 188);
                        continue;
                    case 7:
                        v3 = *(_DWORD*) (a2 + 128);
                        LOBYTE(v3) = v3 & 0x3F;
                        *(_DWORD*) (a2 + 128) = ((((*(_DWORD*) (a2 + 128) >> 6) & 3 ^ 1) & 3) << 6) | v3;
                        *(float*) (a2 + 28) = *(float*) (a2 + 28) * -1.0;
                        goto LABEL_68;
                    case 8:
                        v4 = *(_DWORD*) (a2 + 128);
                        LOBYTE(v4) = v4 & 0x3F;
                        *(_DWORD*) (a2 + 128) = ((((*(_DWORD*) (a2 + 128) >> 6) & 3 ^ 2) & 3) << 6) | v4;
                        *(float*) (a2 + 24) = *(float*) (a2 + 24) * -1.0;
                        goto LABEL_68;
                    case 9:
                        v72 = i + 2;
                        *(_DWORD*) a2 = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 4) = *++v72;
                        *(_DWORD*) (a2 + 8) = *++v72;
                        goto LABEL_68;
                    case 0xA:
                        v71 = i + 2;
                        *(_DWORD*) (a2 + 12) = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 16) = *++v71;
                        *(_DWORD*) (a2 + 20) = *++v71;
                        goto LABEL_68;
                    case 0xB:
                        v70 = i + 2;
                        *(_DWORD*) (a2 + 36) = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 32) = *++v70;
                        *(_WORD*) (a2 + 134) = 0;
                        goto LABEL_68;
                    case 0xC:
                        v68 = i + 2;
                        *(_DWORD*) (a2 + 196) = *(_DWORD*) (a2 + 124);
                        *(_DWORD*) (a2 + 200) = ((unsigned __int8) *(_DWORD*) v68 << 24) | *(_DWORD*) (a2 + 124) & 0xFFFFFF;
                        *(_WORD*) (a2 + 132) = v68 [2];
                        *(_DWORD*) (a2 + 264) = 0;
                        *(_DWORD*) (a2 + 260) = 0;
                        *(_DWORD*) (a2 + 256) = -999;
                        goto LABEL_68;
                    case 0xD:
                        v5 = *(_DWORD*) (a2 + 128);
                        LOBYTE(v5) = v5 | 4;
                        *(_DWORD*) (a2 + 128) = v5;
                        goto LABEL_68;
                    case 0xE:
                        v6 = *(_DWORD*) (a2 + 128);
                        LOBYTE(v6) = v6 & 0xFB;
                        *(_DWORD*) (a2 + 128) = v6;
                        goto LABEL_68;
                    case 0xF:
                        LABEL_7:
                        *(_DWORD*) (a2 + 188) = 0;
                        return 1;
                    case 0x10:
                        *(_DWORD*) (a2 + 128) |= 1u;
                        v73 = i + 2;
                        v50 = i [4];
                        if(v50)
                            v48 = (unsigned __int16) sub_41E780(&word_69D8F8) % (int) v50;
                        else
                            LOWORD(v48) = 0;
                        sub_4323A0(this, a2, this [*(__int16*) (a2 + 180) + 31309] + (unsigned __int16) v48 + *v73);
                        *(_DWORD*) (a2 + 252) = *(_DWORD*) (a2 + 56);
                        goto LABEL_68;
                    case 0x11:
                        if(((*(_DWORD*) (a2 + 128) >> 5) & 1) != 0) {
                            v53 = *((_DWORD*) i + 2);
                            v54 = *((_DWORD*) i + 3);
                            *(_DWORD*) (a2 + 228) = *((_DWORD*) i + 1);
                            *(_DWORD*) (a2 + 232) = v53;
                            *(_DWORD*) (a2 + 236) = v54;
                        }
                        else {
                            v55 = *((_DWORD*) i + 2);
                            v56 = *((_DWORD*) i + 3);
                            *(_DWORD*) (a2 + 144) = *((_DWORD*) i + 1);
                            *(_DWORD*) (a2 + 148) = v55;
                            *(_DWORD*) (a2 + 152) = v56;
                        }
                        goto LABEL_68;
                    case 0x12:
                        v9 = *(_DWORD*) (a2 + 128);
                        BYTE1(v9) &= 0xF3u;
                        *(_DWORD*) (a2 + 128) = v9;
                        goto LABEL_33;
                    case 0x13:
                        v8 = *(_DWORD*) (a2 + 128);
                        BYTE1(v8) = BYTE1(v8) & 0xF3 | 4;
                        *(_DWORD*) (a2 + 128) = v8;
                        goto LABEL_33;
                    case 0x14:
                        v7 = *(_DWORD*) (a2 + 128);
                        BYTE1(v7) = BYTE1(v7) & 0xF3 | 8;
                        *(_DWORD*) (a2 + 128) = v7;
                        LABEL_33:
                        if(((*(_DWORD*) (a2 + 128) >> 5) & 1) != 0) {
                            *(_DWORD*) (a2 + 204) = *(_DWORD*) (a2 + 228);
                            *(_DWORD*) (a2 + 208) = *(_DWORD*) (a2 + 232);
                            *(_DWORD*) (a2 + 212) = *(_DWORD*) (a2 + 236);
                        }
                        else {
                            *(_DWORD*) (a2 + 204) = *(_DWORD*) (a2 + 144);
                            *(_DWORD*) (a2 + 208) = *(_DWORD*) (a2 + 148);
                            *(_DWORD*) (a2 + 212) = *(_DWORD*) (a2 + 152);
                        }
                        v51 = *((_DWORD*) i + 2);
                        v52 = *((_DWORD*) i + 3);
                        *(_DWORD*) (a2 + 216) = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 220) = v51;
                        *(_DWORD*) (a2 + 224) = v52;
                        *(_WORD*) (a2 + 140) = i [8];
                        *(_DWORD*) (a2 + 248) = 0;
                        *(_DWORD*) (a2 + 244) = 0;
                        *(_DWORD*) (a2 + 240) = -999;
                        goto LABEL_68;
                    case 0x15:
                        goto LABEL_38;
                    case 0x17:
                        v13 = *(_DWORD*) (a2 + 128);
                        BYTE1(v13) |= 3u;
                        *(_DWORD*) (a2 + 128) = v13;
                        goto LABEL_68;
                    case 0x18:
                        *(_DWORD*) (a2 + 128) &= ~1u;
                        LABEL_38:
                        if(*(_WORD*) (a2 + 138))
                            goto LABEL_40;
                        v10 = *(_DWORD*) (a2 + 128);
                        BYTE1(v10) |= 0x20u;
                        *(_DWORD*) (a2 + 128) = v10;
                        sub_4241E5(a2 + 48, 1);
                        goto LABEL_69;
                    case 0x19:
                        *(_DWORD*) (a2 + 128) = (32 * (*((_DWORD*) i + 1) & 1)) | *(_DWORD*) (a2 + 128) & 0xFFFFFFDF;
                        goto LABEL_68;
                    case 0x1A:
                        *(_WORD*) (a2 + 136) = i [2];
                        goto LABEL_68;
                    case 0x1B:
                        *(float*) (a2 + 40) = *(float*) (a2 + 40) + *((float*) i + 1);
                        v15 = *(float*) (a2 + 40);
                        v16 = v15 < 1.0;
                        v17 = 0;
                        v18 = v15 == 1.0;
                        if((v14 & 0x100) != 0) {
                            if(*(float*) (a2 + 40) < 0.0)
                                *(float*) (a2 + 40) = *(float*) (a2 + 40) + 1.0;
                        }
                        else {
                            *(float*) (a2 + 40) = *(float*) (a2 + 40) - 1.0;
                        }
                        goto LABEL_68;
                    case 0x1C:
                        *(float*) (a2 + 44) = *(float*) (a2 + 44) + *((float*) i + 1);
                        v20 = *(float*) (a2 + 44);
                        v21 = v20 < 1.0;
                        v22 = 0;
                        v23 = v20 == 1.0;
                        if((v19 & 0x100) != 0) {
                            if(*(float*) (a2 + 44) < 0.0)
                                *(float*) (a2 + 44) = *(float*) (a2 + 44) + 1.0;
                        }
                        else {
                            *(float*) (a2 + 44) = *(float*) (a2 + 44) - 1.0;
                        }
                        goto LABEL_68;
                    case 0x1D:
                        v12 = *(_DWORD*) (a2 + 128);
                        LOBYTE(v12) = v12 & 0xFE;
                        *(_DWORD*) (a2 + 128) = *((_DWORD*) i + 1) & 1 | v12;
                        goto LABEL_68;
                    case 0x1E:
                        v69 = i + 2;
                        *(_DWORD*) (a2 + 36) = *((_DWORD*) i + 1);
                        *(_DWORD*) (a2 + 32) = *++v69;
                        *(_WORD*) (a2 + 134) = *(_WORD*)++v69;
                        *(_DWORD*) (a2 + 172) = 0;
                        *(_DWORD*) (a2 + 168) = 0;
                        *(_DWORD*) (a2 + 164) = -999;
                        *(_DWORD*) (a2 + 160) = *(_DWORD*) (a2 + 28);
                        *(_DWORD*) (a2 + 156) = *(_DWORD*) (a2 + 24);
                        goto LABEL_68;
                    case 0x1F:
                        v24 = *(_DWORD*) (a2 + 128);
                        BYTE1(v24) &= ~0x10u;
                        *(_DWORD*) (a2 + 128) = ((*((_DWORD*) i + 1) & 1) << 12) | v24;
                        goto LABEL_68;
                    default:
                        LABEL_68:
                        *(_DWORD*) (a2 + 188) = (char*) i + *((unsigned __int8*) i + 3) + 4;
                        continue;
                }
            }
            goto LABEL_69;
        }
    }
    if(v67) {
        i = v67;
        goto LABEL_53;
    }
    sub_4241E5(a2 + 48, 1);
    LABEL_69:
    if(*(float*) (a2 + 12) != 0.0) {
        v33 = flt_6C6EC0 * *(float*) (a2 + 12);
        *(float*) a2 = sub_41E850(*(float*) a2, v33);
    }
    if(*(float*) (a2 + 16) != 0.0) {
        v34 = flt_6C6EC0 * *(float*) (a2 + 16);
        *(float*) (a2 + 4) = sub_41E850(*(float*) (a2 + 4), v34);
    }
    if(*(float*) (a2 + 20) != 0.0) {
        v35 = flt_6C6EC0 * *(float*) (a2 + 20);
        *(float*) (a2 + 8) = sub_41E850(*(float*) (a2 + 8), v35);
    }
    if(*(__int16*) (a2 + 134) <= 0) {
        *(float*) (a2 + 24) = flt_6C6EC0 * *(float*) (a2 + 32) + *(float*) (a2 + 24);
        *(float*) (a2 + 28) = flt_6C6EC0 * *(float*) (a2 + 36) + *(float*) (a2 + 28);
    }
    else {
        *(_DWORD*) (a2 + 164) = *(_DWORD*) (a2 + 172);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a2 + 172), (float*) (a2 + 168));
        if(*(_DWORD*) (a2 + 172) < *(__int16*) (a2 + 134)) {
            v47 = (float) *(int*) (a2 + 172);
            v46 = (float) *(__int16*) (a2 + 134);
            *(float*) (a2 + 28) = (*(float*) (a2 + 36) - *(float*) (a2 + 160)) * (v47 + *(float*) (a2 + 168)) / v46
                + *(float*) (a2 + 160);
            v45 = (float) *(int*) (a2 + 172);
            v44 = (float) *(__int16*) (a2 + 134);
            *(float*) (a2 + 24) = (*(float*) (a2 + 32) - *(float*) (a2 + 156)) * (v45 + *(float*) (a2 + 168)) / v44
                + *(float*) (a2 + 156);
        }
        else {
            *(_DWORD*) (a2 + 24) = *(_DWORD*) (a2 + 32);
            *(_DWORD*) (a2 + 28) = *(_DWORD*) (a2 + 36);
            *(_WORD*) (a2 + 134) = 0;
            *(_DWORD*) (a2 + 32) = 0;
            *(_DWORD*) (a2 + 36) = 0;
        }
        if((*(_DWORD*) (a2 + 128) & 0x40) != 0)
            *(float*) (a2 + 28) = *(float*) (a2 + 28) * -1.0;
        if(((*(_DWORD*) (a2 + 128) >> 6) & 2) != 0)
            *(float*) (a2 + 24) = *(float*) (a2 + 24) * -1.0;
    }
    if(*(__int16*) (a2 + 132) > 0) {
        *(_DWORD*) (a2 + 256) = *(_DWORD*) (a2 + 264);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a2 + 264), (float*) (a2 + 260));
        v65 = *(_DWORD*) (a2 + 196);
        v66 = *(_DWORD*) (a2 + 200);
        v43 = (float) *(__int16*) (a2 + 132);
        v42 = (float) *(int*) (a2 + 264);
        v64 = (v42 + *(float*) (a2 + 260)) / v43;
        v26 = v64 < 1.0;
        v27 = 0;
        v28 = v64 == 1.0;
        if((v25 & 0x100) == 0)
            v64 = 1.0;
        for(j = 0; j < 4; ++j) {
            v41 = (float) *((unsigned __int8*) &v66 + j);
            v40 = (float) *((unsigned __int8*) &v65 + j);
            v63 = (unsigned __int64) ((v41 - v40) * v64 + v40);
            if(v63 < 0)
                v63 = 0;
            if(v63 < 256)
                v39 = v63;
            else
                v39 = -1;
            *((_BYTE*) &v65 + j) = v39;
        }
        *(_DWORD*) (a2 + 124) = v65;
        if(*(_DWORD*) (a2 + 264) >= *(__int16*) (a2 + 132))
            *(_WORD*) (a2 + 132) = 0;
    }
    if(*(_WORD*) (a2 + 140)) {
        v38 = (float) *(__int16*) (a2 + 140);
        v37 = (float) *(int*) (a2 + 248);
        v57 = (v37 + *(float*) (a2 + 244)) / v38;
        v30 = v57 < 1.0;
        v31 = 0;
        v32 = v57 == 1.0;
        if((v29 & 0x100) == 0)
            v57 = 1.0;
        v36 = (*(_DWORD*) (a2 + 128) >> 10) & 3;
        if(v36 == 1) {
            v58 = 1.0 - v57;
            v59 = v58 * v58;
            v57 = 1.0 - v59;
        }
        else if(v36 == 2) {
            v60 = 1.0 - v57;
            v61 = v60 * v60 * v60 * v60;
            v57 = 1.0 - v61;
        }
        if(((*(_DWORD*) (a2 + 128) >> 5) & 1) != 0) {
            *(float*) (a2 + 228) = v57 * *(float*) (a2 + 216) + (1.0 - v57) * *(float*) (a2 + 204);
            *(float*) (a2 + 232) = v57 * *(float*) (a2 + 220) + (1.0 - v57) * *(float*) (a2 + 208);
            *(float*) (a2 + 236) = v57 * *(float*) (a2 + 224) + (1.0 - v57) * *(float*) (a2 + 212);
        }
        else {
            *(float*) (a2 + 144) = v57 * *(float*) (a2 + 216) + (1.0 - v57) * *(float*) (a2 + 204);
            *(float*) (a2 + 148) = v57 * *(float*) (a2 + 220) + (1.0 - v57) * *(float*) (a2 + 208);
            *(float*) (a2 + 152) = v57 * *(float*) (a2 + 224) + (1.0 - v57) * *(float*) (a2 + 212);
        }
        if(*(_DWORD*) (a2 + 248) >= *(__int16*) (a2 + 140))
            *(_WORD*) (a2 + 140) = 0;
        *(_DWORD*) (a2 + 240) = *(_DWORD*) (a2 + 248);
        sub_424285((float*) &dword_6C6D18, (_DWORD*) (a2 + 248), (float*) (a2 + 244));
    }
    *(_DWORD*) (a2 + 48) = *(_DWORD*) (a2 + 56);
    sub_424285((float*) &dword_6C6D18, (_DWORD*) (a2 + 56), (float*) (a2 + 52));
    return 0;
}
// 69D8F8: using guessed type __int16 word_69D8F8;
// 6C6D18: using guessed type int dword_6C6D18;
// 6C6EC0: using guessed type float flt_6C6EC0;

//----- (00434AF0) --------------------------------------------------------
char __thiscall sub_434AF0(
    _DWORD* this,
    int a2,
    int a3,
    int a4,
    int a5,
    int a6,
    int a7,
    int a8,
    COLORREF a9,
    COLORREF color,
    LPCSTR lpString) {
    return sub_41F050(a3, a4, a5, a6, 15, 15, a9, color, lpString, this [a2 + 28740]);
}

//----- (00434B60) --------------------------------------------------------
int sub_434B60(_DWORD* a1, int a2, COLORREF a3, COLORREF color, char* Format, ...) {
    int result; // eax
    int v6; // [esp+0h] [ebp-6Ch]
    char Buffer [96]; // [esp+4h] [ebp-68h] BYREF
    unsigned int v8; // [esp+64h] [ebp-8h]
    va_list ArgList; // [esp+68h] [ebp-4h]
    unsigned int retaddr; // [esp+70h] [ebp+4h]
    va_list va; // [esp+88h] [ebp+1Ch] BYREF

    va_start(va, Format);
    v8 = retaddr ^ dword_47A630;
    v6 = *(unsigned __int8*) (a2 + 268);
    va_copy(ArgList, va);
    vsprintf(Buffer, Format, va);
    ArgList = 0;
    sub_434AF0(
        a1,
        **(_DWORD**) (a2 + 192),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 4),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 8),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 24),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 20),
        v6,
        *(unsigned __int8*) (a2 + 269),
        a3,
        color,
        Buffer);
    result = *(_DWORD*) (a2 + 128);
    LOBYTE(result) = result | 1;
    *(_DWORD*) (a2 + 128) = result;
    return result;
}
// 47A630: using guessed type int dword_47A630;

//----- (00434E20) --------------------------------------------------------
int sub_434E20(_DWORD* a1, int a2, COLORREF a3, COLORREF color, char* Format, ...) {
    int result; // eax
    float v6; // [esp+0h] [ebp-7Ch]
    float v7; // [esp+8h] [ebp-74h]
    int v8; // [esp+24h] [ebp-58h]
    char Buffer [68]; // [esp+2Ch] [ebp-50h] BYREF
    unsigned int v10; // [esp+70h] [ebp-Ch]
    int v11; // [esp+74h] [ebp-8h]
    va_list ArgList; // [esp+78h] [ebp-4h]
    unsigned int retaddr; // [esp+80h] [ebp+4h]
    va_list va; // [esp+98h] [ebp+1Ch] BYREF

    va_start(va, Format);
    v10 = retaddr ^ dword_47A630;
    if(*(_BYTE*) (a2 + 268))
        v8 = *(unsigned __int8*) (a2 + 268);
    else
        v8 = 15;
    va_copy(ArgList, va);
    vsprintf(Buffer, Format, va);
    ArgList = 0;
    sub_434AF0(
        a1,
        **(_DWORD**) (a2 + 192),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 4),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 8),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 24),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 20),
        v8,
        *(unsigned __int8*) (a2 + 269),
        a3,
        color,
        " ");
    v7 = (float) strlen(Buffer);
    v6 = (float) (v8 + 1);
    v11 = (unsigned __int64) (*(float*) (*(_DWORD*) (a2 + 192) + 24) / 2.0
                              + *(float*) (*(_DWORD*) (a2 + 192) + 4)
                              - v7 * v6 / 4.0);
    sub_434AF0(
        a1,
        **(_DWORD**) (a2 + 192),
        v11,
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 8),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 24),
        (unsigned __int64) *(float*) (*(_DWORD*) (a2 + 192) + 20),
        v8,
        *(unsigned __int8*) (a2 + 269),
        a3,
        color,
        Buffer);
    result = a2;
    *(_DWORD*) (a2 + 128) |= 1u;
    return result;
}
// 47A630: using guessed type int dword_47A630;

//----- (00435010) --------------------------------------------------------
int __thiscall sub_435010(_DWORD** this, int a2, char* Str) {
    void* Block; // [esp+4h] [ebp-8h]
    int v6; // [esp+8h] [ebp-4h] BYREF

    if(this [a2 + 33613])
        sub_435270(this, a2);
    Block = sub_41E290(Str, 0);
    if(Block) {
        if((*(int(__stdcall**)(int, int, int, int, int*))(*(_DWORD*) dword_6C6D20 + 108))(
            dword_6C6D20,
            640,
            1024,
            dword_6C6E00,
            &v6)) {
            return -1;
        }
        else if(sub_43FEC2(v6, 0, 0, (unsigned __int8*) Block, dword_69D914, 0, (float*) 1, 0, &this [5 * a2 + 33677])
                || (*(int(__stdcall**)(int, _DWORD*, _DWORD*, int, _DWORD, int, _DWORD**))(*(_DWORD*) dword_6C6D20 + 100))(
                dword_6C6D20,
                this [5 * a2 + 33677],
                this [5 * a2 + 33678],
                dword_6C6E00,
                0,
                1,
                &this [a2 + 33613])
                && (*(int(__stdcall**)(int, _DWORD*, _DWORD*, int, _DWORD**))(*(_DWORD*) dword_6C6D20 + 108))(
                dword_6C6D20,
                this [5 * a2 + 33677],
                this [5 * a2 + 33678],
                dword_6C6E00,
                &this [a2 + 33613])
                || (*(int(__stdcall**)(int, _DWORD*, _DWORD*, int, _DWORD**))(*(_DWORD*) dword_6C6D20 + 108))(
                dword_6C6D20,
                this [5 * a2 + 33677],
                this [5 * a2 + 33678],
                dword_6C6E00,
                &this [a2 + 33645])
                || sub_43FF78((int) this [a2 + 33613], 0, 0, v6, 0, 0, (float*) 1, 0)
                || sub_43FF78((int) this [a2 + 33645], 0, 0, v6, 0, 0, (float*) 1, 0)) {
            if(v6) {
                (*(void(__stdcall**)(int))(*(_DWORD*) v6 + 8))(v6);
                v6 = 0;
            }
            free(Block);
            return -1;
        }
        else {
            if(v6) {
                (*(void(__stdcall**)(int))(*(_DWORD*) v6 + 8))(v6);
                v6 = 0;
            }
            free(Block);
            return 0;
        }
    }
    else {
        sub_41E620((int) byte_69D998, aS_0, Str);
        return -1;
    }
}
// 69D914: using guessed type int dword_69D914;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E00: using guessed type int dword_6C6E00;

//----- (00435270) --------------------------------------------------------
int __thiscall sub_435270(_DWORD** this, int a2) {
    int result; // eax

    if(this [a2 + 33613]) {
        (*(void(__thiscall**)(_DWORD*, _DWORD*))(*this [a2 + 33613] + 8))(this [a2 + 33613], this [a2 + 33613]);
        this [a2 + 33613] = 0;
    }
    result = a2;
    if(this [a2 + 33645]) {
        result = (*(int(__thiscall**)(_DWORD*, _DWORD*))(*this [a2 + 33645] + 8))(this [a2 + 33645], this [a2 + 33645]);
        this [a2 + 33645] = 0;
    }
    return result;
}

//----- (00435300) --------------------------------------------------------
int __thiscall sub_435300(_DWORD* this, int a2, int a3, int a4, int a5, int a6) {
    int result; // eax
    int v8; // [esp+4h] [ebp-1Ch] BYREF
    int v9 [4]; // [esp+8h] [ebp-18h] BYREF
    int v10 [2]; // [esp+18h] [ebp-8h] BYREF

    result = a2;
    if(this [a2 + 33645]) {
        result = (*(int(__stdcall**)(int, _DWORD, _DWORD, int*))(*(_DWORD*) dword_6C6D20 + 64))(dword_6C6D20, 0, 0, &v8);
        if(!result) {
            if(!this [a2 + 33613]
               && ((*(int(__stdcall**)(int, _DWORD, _DWORD, int, _DWORD, int, _DWORD*))(*(_DWORD*) dword_6C6D20 + 100))(
               dword_6C6D20,
               this [5 * a2 + 33677],
               this [5 * a2 + 33678],
               dword_6C6E00,
               0,
               1,
               &this [a2 + 33613])
               && (*(int(__stdcall**)(int, _DWORD, _DWORD, int, _DWORD*))(*(_DWORD*) dword_6C6D20 + 108))(
               dword_6C6D20,
               this [5 * a2 + 33677],
               this [5 * a2 + 33678],
               dword_6C6E00,
               &this [a2 + 33613])
               || sub_43FF78(this [a2 + 33613], 0, 0, this [a2 + 33645], 0, 0, (float*) 1, 0))) {
                return (*(int(__stdcall**)(int))(*(_DWORD*) v8 + 8))(v8);
            }
            else {
                v9 [0] = a3;
                v9 [1] = a4;
                v9 [2] = this [5 * a2 + 33677];
                v9 [3] = this [5 * a2 + 33678];
                v10 [0] = a5;
                v10 [1] = a6;
                (*(void(__stdcall**)(int, _DWORD, int*, int, int, int*))(*(_DWORD*) dword_6C6D20 + 112))(
                    dword_6C6D20,
                    this [a2 + 33613],
                    v9,
                    1,
                    v8,
                    v10);
                return (*(int(__stdcall**)(int))(*(_DWORD*) v8 + 8))(v8);
            }
        }
    }
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E00: using guessed type int dword_6C6E00;

//----- (004354C0) --------------------------------------------------------
int __thiscall sub_4354C0(_DWORD* this, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {
    int result; // eax
    int v10; // [esp+4h] [ebp-1Ch] BYREF
    int v11 [4]; // [esp+8h] [ebp-18h] BYREF
    int v12 [2]; // [esp+18h] [ebp-8h] BYREF

    result = a2;
    if(this [a2 + 33645]) {
        result = (*(int(__stdcall**)(int, _DWORD, _DWORD, int*))(*(_DWORD*) dword_6C6D20 + 64))(dword_6C6D20, 0, 0, &v10);
        if(!result) {
            if(!this [a2 + 33613]
               && ((*(int(__stdcall**)(int, _DWORD, _DWORD, int, _DWORD, int, _DWORD*))(*(_DWORD*) dword_6C6D20 + 100))(
               dword_6C6D20,
               this [5 * a2 + 33677],
               this [5 * a2 + 33678],
               dword_6C6E00,
               0,
               1,
               &this [a2 + 33613])
               && (*(int(__stdcall**)(int, _DWORD, _DWORD, int, _DWORD*))(*(_DWORD*) dword_6C6D20 + 108))(
               dword_6C6D20,
               this [5 * a2 + 33677],
               this [5 * a2 + 33678],
               dword_6C6E00,
               &this [a2 + 33613])
               || sub_43FF78(this [a2 + 33613], 0, 0, this [a2 + 33645], 0, 0, (float*) 1, 0))) {
                return (*(int(__stdcall**)(int))(*(_DWORD*) v10 + 8))(v10);
            }
            else {
                v11 [0] = a5;
                v11 [1] = a6;
                v11 [2] = a7 + a5;
                v11 [3] = a8 + a6;
                v12 [0] = a3;
                v12 [1] = a4;
                (*(void(__stdcall**)(int, _DWORD, int*, int, int, int*))(*(_DWORD*) dword_6C6D20 + 112))(
                    dword_6C6D20,
                    this [a2 + 33613],
                    v11,
                    1,
                    v10,
                    v12);
                return (*(int(__stdcall**)(int))(*(_DWORD*) v10 + 8))(v10);
            }
        }
    }
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6E00: using guessed type int dword_6C6E00;

//----- (00435670) --------------------------------------------------------
int __thiscall sub_435670(_DWORD** this, int a2, int a3, int a4, int a5, int a6) {
    int result; // eax
    int v8; // [esp+4h] [ebp-18h] BYREF
    int v9; // [esp+8h] [ebp-14h] BYREF
    int v10 [4]; // [esp+Ch] [ebp-10h] BYREF

    result = a2;
    if(this [a2 + 28740]) {
        result = (*(int(__stdcall**)(int, _DWORD, _DWORD, int*))(*(_DWORD*) dword_6C6D20 + 64))(dword_6C6D20, 0, 0, &v8);
        if(!result) {
            if(!(*(int(__stdcall**)(_DWORD*, _DWORD, int*))(*this [a2 + 28740] + 60))(this [a2 + 28740], 0, &v9)) {
                v10 [0] = a3;
                v10 [1] = a4;
                v10 [2] = a5 + a3;
                v10 [3] = a6 + a4;
                sub_43FF78(v9, 0, 0, v8, 0, v10, (float*) 0xFFFFFFFF, 0);
                (*(void(__stdcall**)(int))(*(_DWORD*) v9 + 8))(v9);
            }
            return (*(int(__stdcall**)(int))(*(_DWORD*) v8 + 8))(v8);
        }
    }
    return result;
}
// 6C6D20: using guessed type int dword_6C6D20;

//----- (0043575D) --------------------------------------------------------
void* __thiscall sub_43575D(void* this) {
    int i; // [esp+4h] [ebp-1Ch]
    int v4; // [esp+Ch] [ebp-14h]

    v4 = 122;
    for(i = (int) this; --v4 >= 0; i += 272)
        sub_403720(i);
    return this;
}

//----- (0043579F) --------------------------------------------------------
int __usercall sub_43579F(int a1, int a2) {
    int v3; // eax
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    int v11; // [esp+10h] [ebp-B4h]
    int v12; // [esp+14h] [ebp-B0h]
    float v13; // [esp+18h] [ebp-ACh]
    int v14; // [esp+1Ch] [ebp-A8h]
    float v15; // [esp+28h] [ebp-9Ch]
    float v16; // [esp+2Ch] [ebp-98h]
    BOOL v17; // [esp+34h] [ebp-90h]
    int v18; // [esp+38h] [ebp-8Ch]
    int v19; // [esp+78h] [ebp-4Ch]
    int v20; // [esp+7Ch] [ebp-48h]
    float v21; // [esp+80h] [ebp-44h]
    float v22; // [esp+80h] [ebp-44h]
    float v23; // [esp+84h] [ebp-40h]
    char* v24; // [esp+9Ch] [ebp-28h]
    __int16 m; // [esp+A0h] [ebp-24h]
    __int16 n; // [esp+A0h] [ebp-24h]
    __int16 v27; // [esp+A8h] [ebp-1Ch]
    float v28; // [esp+B0h] [ebp-14h]
    int v29; // [esp+B4h] [ebp-10h]
    DWORD Time; // [esp+B8h] [ebp-Ch]
    int v31; // [esp+BCh] [ebp-8h]
    int v32; // [esp+BCh] [ebp-8h]
    int v33; // [esp+BCh] [ebp-8h]
    int v34; // [esp+BCh] [ebp-8h]
    int v35; // [esp+BCh] [ebp-8h]
    int v36; // [esp+BCh] [ebp-8h]
    int v37; // [esp+BCh] [ebp-8h]
    int v38; // [esp+BCh] [ebp-8h]
    int v39; // [esp+BCh] [ebp-8h]
    int v40; // [esp+BCh] [ebp-8h]
    int v41; // [esp+BCh] [ebp-8h]
    int v42; // [esp+BCh] [ebp-8h]
    int v43; // [esp+BCh] [ebp-8h]
    int v44; // [esp+BCh] [ebp-8h]
    int v45; // [esp+BCh] [ebp-8h]
    int v46; // [esp+BCh] [ebp-8h]
    int v47; // [esp+BCh] [ebp-8h]
    int i; // [esp+C0h] [ebp-4h]
    int j; // [esp+C0h] [ebp-4h]
    int k; // [esp+C0h] [ebp-4h]
    int jj; // [esp+C0h] [ebp-4h]
    int ii; // [esp+C0h] [ebp-4h]
    int nn; // [esp+C0h] [ebp-4h]
    int kk; // [esp+C0h] [ebp-4h]
    int mm; // [esp+C0h] [ebp-4h]
    int i3; // [esp+C0h] [ebp-4h]
    int i1; // [esp+C0h] [ebp-4h]
    int i2; // [esp+C0h] [ebp-4h]
    int i4; // [esp+C0h] [ebp-4h]
    int i5; // [esp+C0h] [ebp-4h]
    int i10; // [esp+C0h] [ebp-4h]
    int i9; // [esp+C0h] [ebp-4h]
    int i6; // [esp+C0h] [ebp-4h]
    int i7; // [esp+C0h] [ebp-4h]
    int i8; // [esp+C0h] [ebp-4h]
    int i11; // [esp+C0h] [ebp-4h]
    int i12; // [esp+C0h] [ebp-4h]
    int i16; // [esp+C0h] [ebp-4h]
    int i17; // [esp+C0h] [ebp-4h]
    int i18; // [esp+C0h] [ebp-4h]
    int i23; // [esp+C0h] [ebp-4h]
    int i13; // [esp+C0h] [ebp-4h]
    int i14; // [esp+C0h] [ebp-4h]
    int i15; // [esp+C0h] [ebp-4h]
    int i19; // [esp+C0h] [ebp-4h]
    int i20; // [esp+C0h] [ebp-4h]
    int i21; // [esp+C0h] [ebp-4h]
    int i22; // [esp+C0h] [ebp-4h]

    if(*(int*) (a2 + 69344) < 16) {
        timeBeginPeriod(1u);
        if(!*(_DWORD*) (a2 + 69424))
            *(_DWORD*) (a2 + 69424) = timeGetTime();
        Time = timeGetTime();
        timeEndPeriod(1u);
        ++* (_DWORD*) (a2 + 69420);
        v29 = Time - *(_DWORD*) (a2 + 69424);
        if(v29 < 700) {
            if(v29 >= 500) {
                v16 = (float) *(int*) (a2 + 69420);
                v15 = (float) v29;
                v28 = v16 * 1000.0 / v15;
                if(v28 >= 57.0)
                    *(float*) (a2 + 4 * (*(_DWORD*) (a2 + 69344))++ + 69348) = v28;
                *(_DWORD*) (a2 + 69424) = Time;
                *(_DWORD*) (a2 + 69420) = 0;
            }
        }
        else {
            *(_DWORD*) (a2 + 69424) = Time;
            *(_DWORD*) (a2 + 69420) = 0;
        }
    }
    switch(*(_DWORD*) (a2 + 33264)) {
        case 0:
            if(sub_4378A2(a2, a1) != -1)
                goto LABEL_13;
            return 0;
        case 1:
            LABEL_13:
            ++ * (_DWORD*) (a2 + 33272);
            if(word_69D904)
                *(_DWORD*) (a2 + 33272) = 0;
            if(*(int*) (a2 + 33272) >= 720)
                goto LABEL_21;
            if(sub_4379E4((_DWORD*) a2))
                goto LABEL_340;
            *(_DWORD*) (a2 + 33272) = 0;
            goto LABEL_18;
        case 2:
            LABEL_18:
            sub_437B41(a2);
            if(word_69D904)
                *(_DWORD*) (a2 + 33272) = 0;
            if((int)++ * (_DWORD*) (a2 + 33272) < 720)
                goto LABEL_340;
            LABEL_21:
            dword_69BCBC = 1;
            byte_69D4C4 = 1;
            dword_69D4C8 = 0;
            *(float*) &dword_6C6EC4 = 1.0;
            strcpy(Destination, "data/demo/demo00.rpy");
            *(_DWORD*) dword_69D6D4 = 3;
            dword_69BCB0 = 3;
            dword_6C6EA4 = 2;
            return 0;
        case 3:
            if(!sub_439137(a2, a1))
                goto LABEL_340;
            return 0;
        case 4:
            if(*(int*) (a2 + 33268) < 60)
                goto LABEL_340;
            dword_6C6EA4 = 4;
            return 0;
        case 5:
            sub_43753C(a2, 11);
            v31 = a2 + 9248;
            for(i = 0; i < 11; ++i) {
                sub_4377A3(v31, i, *(_DWORD*) (a2 + 33184), *(_DWORD*) (a2 + 33284), *(_DWORD*) (a2 + 33288), 115);
                v31 += 272;
            }
            for(j = 0; j < 9; ++j) {
                v3 = *(_DWORD*) (v31 + 128);
                if(*(__int16*) (a2 + 2 * j + 33308) >= 0) {
                    LOBYTE(v3) = v3 | 2;
                    *(_DWORD*) (v31 + 128) = v3;
                    sub_4377A3(v31, j, *(_DWORD*) (a2 + 33184), *(_DWORD*) (a2 + 33284), *(_DWORD*) (a2 + 33288), 115);
                }
                else {
                    LOBYTE(v3) = v3 & 0xFD;
                    *(_DWORD*) (v31 + 128) = v3;
                }
                v31 += 272;
            }
            for(k = 0; k < 18; ++k) {
                if(*(__int16*) (a2 + 2 * (k / 2) + 33308) >= 0) {
                    v5 = *(_DWORD*) (v31 + 128);
                    LOBYTE(v5) = v5 | 2;
                    *(_DWORD*) (v31 + 128) = v5;
                    v27 = *(_WORD*) (a2 + 2 * (k / 2) + 33308);
                    if(k % 2)
                        sub_4323A0((int*) dword_6D4588, v31, v27 % 10 + 256);
                    else
                        sub_4323A0((int*) dword_6D4588, v31, v27 / 10 + 256);
                    *(_WORD*) (v31 + 178) = *(_WORD*) (v31 + 176);
                    sub_4377A3(v31, k / 2, *(_DWORD*) (a2 + 33184), *(_DWORD*) (a2 + 33284), *(_DWORD*) (a2 + 33288), 122);
                }
                else {
                    v4 = *(_DWORD*) (v31 + 128);
                    LOBYTE(v4) = v4 & 0xFD;
                    *(_DWORD*) (v31 + 128) = v4;
                }
                v31 += 272;
            }
            if(*(int*) (a2 + 33268) >= 32) {
                v24 = sub_41D680();
                for(m = 0; m < 32 && (v24 [m] & 0x80) == 0; ++m)
                    ;
                if(m < 32 && word_478690 != m) {
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    switch(*(_DWORD*) (a2 + 33184)) {
                        case 0:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33308), 1);
                            *(_WORD*) (a2 + 33308) = m;
                            break;
                        case 1:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33310), 0);
                            *(_WORD*) (a2 + 33310) = m;
                            break;
                        case 2:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33312), 1);
                            *(_WORD*) (a2 + 33312) = m;
                            break;
                        case 3:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33314), 0);
                            *(_WORD*) (a2 + 33314) = m;
                            break;
                        case 4:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33316), 0);
                            *(_WORD*) (a2 + 33316) = m;
                            break;
                        case 5:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33318), 0);
                            *(_WORD*) (a2 + 33318) = m;
                            break;
                        case 6:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33320), 0);
                            *(_WORD*) (a2 + 33320) = m;
                            break;
                        case 7:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33322), 0);
                            *(_WORD*) (a2 + 33322) = m;
                            break;
                        case 8:
                            sub_437672((_WORD*) a2, m, *(_WORD*) (a2 + 33324), 0);
                            *(_WORD*) (a2 + 33324) = m;
                            break;
                        default:
                            break;
                    }
                }
                word_478690 = m;
                if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                    v14 = *(_DWORD*) (a2 + 33184);
                    if(v14 == 9) {
                        *(_DWORD*) (a2 + 33308) = 0x10000;
                        *(_DWORD*) (a2 + 33312) = -65536;
                        *(_DWORD*) (a2 + 33316) = -1;
                        *(_DWORD*) (a2 + 33320) = -1;
                        *(_WORD*) (a2 + 33324) = -1;
                    }
                    else if(v14 == 10) {
                        *(_DWORD*) (a2 + 33264) = 3;
                        *(_DWORD*) (a2 + 33268) = 0;
                        for(n = 0; n < 122; ++n)
                            *(_WORD*) (a2 + 272 * n + 138) = 3;
                        *(_DWORD*) (a2 + 33184) = 7;
                        sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                        *(_DWORD*) &word_4765A0 = *(_DWORD*) (a2 + 33308);
                        *((_DWORD*) &word_4765A0 + 1) = *(_DWORD*) (a2 + 33312);
                        *((_DWORD*) &word_4765A0 + 2) = *(_DWORD*) (a2 + 33316);
                        *((_DWORD*) &word_4765A0 + 3) = *(_DWORD*) (a2 + 33320);
                        *(&word_4765A0 + 8) = *(_WORD*) (a2 + 33324);
                        *(_DWORD*) &word_6C6E2C = *(_DWORD*) (a2 + 33308);
                        *((_DWORD*) &word_6C6E2C + 1) = *(_DWORD*) (a2 + 33312);
                        *((_DWORD*) &word_6C6E2C + 2) = *(_DWORD*) (a2 + 33316);
                        *((_DWORD*) &word_6C6E2C + 3) = *(_DWORD*) (a2 + 33320);
                        *(&word_6C6E2C + 8) = *(_WORD*) (a2 + 33324);
                    }
                }
            }
            goto LABEL_340;
        case 6:
            if(*(_DWORD*) (a2 + 33268) != 60)
                goto LABEL_340;
            if(sub_439F88(a2)) {
                sub_41E4D0((int) byte_69D998, (char*) &byte_46C368);
                dword_6C6EA4 = 4;
                return 0;
            }
            *(_DWORD*) (a2 + 33264) = 7;
            *(_DWORD*) (a2 + 33276) = 0;
            *(_DWORD*) (a2 + 33300) = *(_DWORD*) (a2 + 33296);
            *(_DWORD*) (a2 + 33296) = 0;
            if(dword_69BCB0 >= 4) {
                for(ii = 0; ii < 122; ++ii)
                    *(_WORD*) (a2 + 272 * ii + 138) = 18;
                *(_DWORD*) (a2 + 33184) = 0;
            }
            else {
                for(jj = 0; jj < 122; ++jj)
                    *(_WORD*) (a2 + 272 * jj + 138) = 6;
                *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_6C6E49;
            }
            LABEL_88:
            if(*(_DWORD*) (a2 + 33268) == 36) {
                *(_DWORD*) (a2 + 33264) = 0;
                *(_DWORD*) (a2 + 33268) = 0;
            }
            goto LABEL_340;
        case 7:
            v32 = a2 + 22032;
            if(dword_69BCB0 >= 4) {
                for(kk = 0; kk < 4; ++kk) {
                    v7 = *(_DWORD*) (v32 + 128);
                    LOBYTE(v7) = v7 & 0xFD;
                    *(_DWORD*) (v32 + 128) = v7;
                    v32 += 272;
                }
                for(mm = 4; mm < 5; ++mm) {
                    if((dword_6C6E60 & 1) != 0)
                        *(_DWORD*) (v32 + 124) = -1;
                    else
                        *(_DWORD*) (v32 + 124) = -16777216;
                    *(float*) (v32 + 228) = -6.0;
                    *(float*) (v32 + 232) = -6.0;
                    *(float*) (v32 + 236) = 0.0;
                    v32 += 272;
                }
            }
            else {
                sub_43753C(a2, 4);
                for(nn = 0; nn < 4; ++nn) {
                    if(nn == *(_DWORD*) (a2 + 33184)) {
                        if((dword_6C6E60 & 1) != 0)
                            *(_DWORD*) (v32 + 124) = -1;
                        else
                            *(_DWORD*) (v32 + 124) = -16777216;
                        *(float*) (v32 + 228) = -6.0;
                        *(float*) (v32 + 232) = -6.0;
                        *(float*) (v32 + 236) = 0.0;
                    }
                    else {
                        if((dword_6C6E60 & 1) != 0)
                            *(_DWORD*) (v32 + 124) = 1627389951;
                        else
                            *(_DWORD*) (v32 + 124) = 1610612736;
                        *(float*) (v32 + 228) = 0.0;
                        *(float*) (v32 + 232) = 0.0;
                        *(float*) (v32 + 236) = 0.0;
                        *(_WORD*) (v32 + 132) = 0;
                    }
                    v32 += 272;
                }
                v6 = *(_DWORD*) (v32 + 128);
                LOBYTE(v6) = v6 & 0xFD;
                *(_DWORD*) (v32 + 128) = v6;
            }
            if((word_69D904 & 0xA) == 0 || (word_69D904 & 0xA) == (word_69D908 & 0xA)) {
                if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                    *(_DWORD*) (a2 + 33264) = 9;
                    *(_DWORD*) (a2 + 33268) = 0;
                    for(i1 = 0; i1 < 122; ++i1)
                        *(_WORD*) (a2 + 272 * i1 + 138) = 7;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    if(dword_69BCB0 >= 4) {
                        *(_WORD*) (a2 + 23258) = 8;
                        dword_69BCB0 = 4;
                        if(sub_43A736(dword_69BCA0, (unsigned __int8) byte_69D4BD, 0)
                           || sub_43A736(dword_69BCA0, (unsigned __int8) byte_69D4BD, 1)) {
                            *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BD;
                        }
                        else {
                            *(_DWORD*) (a2 + 33184) = 1 - (unsigned __int8) byte_69D4BD;
                        }
                    }
                    else {
                        *(_WORD*) (272 * (*(_DWORD*) (a2 + 33184) + 81) + a2 + 138) = 8;
                        dword_69BCB0 = *(_DWORD*) (a2 + 33184);
                        *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BD;
                    }
                    byte_6C6E49 = dword_69BCB0;
                    v33 = a2 + 23392;
                    for(i2 = 0; i2 < 2; ++i2) {
                        if(i2 != *(_DWORD*) (a2 + 33184)) {
                            *(_WORD*) (v33 + 138) = 0;
                            *(_WORD*) (v33 + 410) = 0;
                        }
                        v33 += 544;
                    }
                }
            }
            else {
                *(_DWORD*) (a2 + 33264) = 8;
                *(_DWORD*) (a2 + 33268) = 0;
                for(i3 = 0; i3 < 122; ++i3)
                    *(_WORD*) (a2 + 272 * i3 + 138) = 4;
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                if(dword_69BCB0 >= 4) {
                    *(_DWORD*) (a2 + 33184) = 1;
                }
                else {
                    byte_6C6E49 = *(_BYTE*) (a2 + 33184);
                    if(byte_69D4C3)
                        *(_DWORD*) (a2 + 33184) = 2;
                    else
                        *(_DWORD*) (a2 + 33184) = 0;
                }
            }
            goto LABEL_340;
        case 8:
            goto LABEL_88;
        case 9:
            if(*(int*) (a2 + 33268) < 30)
                goto LABEL_340;
            if(((word_69D904 & 0x40) == 0 || (word_69D904 & 0x40) == (word_69D908 & 0x40))
               && ((word_69D904 & 0x40) == 0 || !word_69D90C)) {
                goto LABEL_161;
            }
            if((int)++ * (_DWORD*) (a2 + 33184) >= 2)
                *(_DWORD*) (a2 + 33184) -= 2;
            if(dword_69BCB0 != 4
               || sub_43A736(dword_69BCA0, *(_DWORD*) (a2 + 33184), 0)
               || sub_43A736(dword_69BCA0, *(_DWORD*) (a2 + 33184), 1)) {
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                v34 = a2 + 23392;
                for(i4 = 0; i4 < 2; ++i4) {
                    if(i4 == *(_DWORD*) (a2 + 33184)) {
                        *(_WORD*) (v34 + 138) = 9;
                        v35 = v34 + 272;
                        *(_WORD*) (v35 + 138) = 9;
                    }
                    else {
                        *(_WORD*) (v34 + 138) = 12;
                        v35 = v34 + 272;
                        *(_WORD*) (v35 + 138) = 12;
                    }
                    v34 = v35 + 272;
                }
                LABEL_161:
                if((word_69D904 & 0x80) != 0 && (word_69D904 & 0x80) != (word_69D908 & 0x80)
                   || (word_69D904 & 0x80) != 0 && word_69D90C) {
                    if((int)-- * (_DWORD*) (a2 + 33184) < 0)
                        *(_DWORD*) (a2 + 33184) += 2;
                    if(dword_69BCB0 != 4
                       || sub_43A736(dword_69BCA0, *(_DWORD*) (a2 + 33184), 0)
                       || sub_43A736(dword_69BCA0, *(_DWORD*) (a2 + 33184), 1)) {
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        v36 = a2 + 23392;
                        for(i5 = 0; i5 < 2; ++i5) {
                            if(i5 == *(_DWORD*) (a2 + 33184)) {
                                *(_WORD*) (v36 + 138) = 10;
                                v37 = v36 + 272;
                                *(_WORD*) (v37 + 138) = 10;
                            }
                            else {
                                *(_WORD*) (v36 + 138) = 11;
                                v37 = v36 + 272;
                                *(_WORD*) (v37 + 138) = 11;
                            }
                            v36 = v37 + 272;
                        }
                    }
                    else if((int)++ * (_DWORD*) (a2 + 33184) >= 2) {
                        *(_DWORD*) (a2 + 33184) -= 2;
                    }
                }
            }
            else if((int)-- * (_DWORD*) (a2 + 33184) < 0) {
                *(_DWORD*) (a2 + 33184) += 2;
            }
            if((word_69D904 & 0xA) == 0 || (word_69D904 & 0xA) == (word_69D908 & 0xA)) {
                if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                    *(_DWORD*) (a2 + 33264) = 11;
                    *(_DWORD*) (a2 + 33268) = 0;
                    for(i6 = 0; i6 < 122; ++i6)
                        *(_WORD*) (a2 + 272 * i6 + 138) = 13;
                    *(_WORD*) (272 * (dword_69BCB0 + 81) + a2 + 138) = 0;
                    v38 = a2 + 23392;
                    for(i7 = 0; i7 < 2; ++i7) {
                        if(i7 != *(_DWORD*) (a2 + 33184)) {
                            *(_WORD*) (v38 + 138) = 0;
                            *(_WORD*) (v38 + 410) = 0;
                        }
                        v38 += 544;
                    }
                    v39 = a2 + 25024;
                    for(i8 = 0; i8 < 2; ++i8) {
                        if(i8 != *(_DWORD*) (a2 + 33184)) {
                            *(_WORD*) (v39 + 138) = 0;
                            *(_WORD*) (v39 + 410) = 0;
                        }
                        v39 += 544;
                    }
                    byte_69D4BD = *(_BYTE*) (a2 + 33184);
                    if(dword_69BCB0 >= 4) {
                        if(sub_43A736(dword_69BCA0, (unsigned __int8) byte_69D4BD, (unsigned __int8) byte_69D4BE))
                            *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BE;
                        else
                            *(_DWORD*) (a2 + 33184) = 1 - (unsigned __int8) byte_69D4BE;
                    }
                    else {
                        *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BE;
                    }
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                }
            }
            else {
                *(_DWORD*) (a2 + 33264) = 7;
                *(_DWORD*) (a2 + 33268) = 0;
                if(dword_69BCB0 >= 4) {
                    for(i9 = 0; i9 < 122; ++i9)
                        *(_WORD*) (a2 + 272 * i9 + 138) = 18;
                    *(_DWORD*) (a2 + 33184) = 0;
                }
                else {
                    for(i10 = 0; i10 < 122; ++i10)
                        *(_WORD*) (a2 + 272 * i10 + 138) = 6;
                    *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_6C6E49;
                }
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
            }
            goto LABEL_340;
        case 0xA:
            if(*(int*) (a2 + 33268) < 60)
                goto LABEL_340;
            dword_6C6EA4 = 6;
            return 0;
        case 0xB:
            sub_43753C(a2, 2);
            if(dword_69BCB0 == 4 && !sub_43A736(dword_69BCA0, (unsigned __int8) byte_69D4BD, *(_DWORD*) (a2 + 33184)))
                *(_DWORD*) (a2 + 33184) = 1 - *(_DWORD*) (a2 + 33184);
            v40 = a2 + 25024;
            for(i11 = 0; i11 < 2; ++i11) {
                v8 = *(_DWORD*) (v40 + 400);
                LOBYTE(v8) = v8 | 8;
                *(_DWORD*) (v40 + 400) = v8;
                v40 += 544;
            }
            v41 = 272 * (2 * (unsigned __int8) byte_69D4BD + 92) + a2;
            for(i12 = 0; i12 < 2; ++i12) {
                v9 = *(_DWORD*) (v41 + 128);
                LOBYTE(v9) = v9 | 8;
                *(_DWORD*) (v41 + 128) = v9;
                v10 = *(_DWORD*) (v41 + 128);
                LOBYTE(v10) = v10 | 1;
                *(_DWORD*) (v41 + 128) = v10;
                if(i12 == *(_DWORD*) (a2 + 33184)) {
                    if((dword_6C6E60 & 1) != 0)
                        *(_DWORD*) (v41 + 124) = -1;
                    else
                        *(_DWORD*) (v41 + 124) = -14671840;
                    *(float*) (v41 + 228) = -6.0;
                    *(float*) (v41 + 232) = -6.0;
                    *(float*) (v41 + 236) = 0.0;
                }
                else {
                    if((dword_6C6E60 & 1) != 0)
                        *(_DWORD*) (v41 + 124) = -1596927792;
                    else
                        *(_DWORD*) (v41 + 124) = -1610612736;
                    *(float*) (v41 + 228) = 0.0;
                    *(float*) (v41 + 232) = 0.0;
                    *(float*) (v41 + 236) = 0.0;
                }
                v41 += 272;
            }
            if(*(int*) (a2 + 33268) < 30)
                goto LABEL_340;
            if((word_69D904 & 0xA) == 0 || (word_69D904 & 0xA) == (word_69D908 & 0xA)) {
                if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                    byte_69D4BE = *(_BYTE*) (a2 + 33184);
                    if(!byte_69D4C3) {
                        if(dword_69BCB0 >= 4)
                            *(_DWORD*) dword_69D6D4 = 6;
                        else
                            *(_DWORD*) dword_69D6D4 = 0;
                        goto LABEL_254;
                    }
                    *(_DWORD*) (a2 + 33264) = 17;
                    *(_DWORD*) (a2 + 33268) = 0;
                    for(i13 = 0; i13 < 122; ++i13)
                        *(_WORD*) (a2 + 272 * i13 + 138) = 19;
                    *(_WORD*) (272 * (dword_69BCB0 + 81) + a2 + 138) = 0;
                    v44 = a2 + 23392;
                    for(i14 = 0; i14 < 2; ++i14) {
                        if(i14 != (unsigned __int8) byte_69D4BD) {
                            *(_WORD*) (v44 + 138) = 0;
                            *(_WORD*) (v44 + 410) = 0;
                        }
                        v44 += 544;
                    }
                    v45 = a2 + 25024;
                    for(i15 = 0; i15 < 2; ++i15) {
                        if(i15 != (unsigned __int8) byte_69D4BD) {
                            *(_WORD*) (v45 + 138) = 0;
                            *(_WORD*) (v45 + 410) = 0;
                        }
                        v45 += 544;
                    }
                    *(_DWORD*) (a2 + 33184) = dword_69D6D8;
                    if((unsigned __int8) byte_69CCE1 [48 * (unsigned __int8) byte_69D4BD
                       + 24 * (unsigned __int8) byte_69D4BE
                       + dword_69BCB0] <= 6u)
                        v12 = (unsigned __int8) byte_69CCE1 [48 * (unsigned __int8) byte_69D4BD
                        + 24 * (unsigned __int8) byte_69D4BE
                        + dword_69BCB0];
                    else
                        v12 = 6;
                    v20 = v12;
                    if(!dword_69BCB0 && v12 == 6)
                        v20 = 5;
                    if(*(_DWORD*) (a2 + 33184) >= v20)
                        *(_DWORD*) (a2 + 33184) = 0;
                }
            }
            else {
                *(_DWORD*) (a2 + 33264) = 9;
                *(_DWORD*) (a2 + 33268) = 0;
                for(i16 = 0; i16 < 122; ++i16)
                    *(_WORD*) (a2 + 272 * i16 + 138) = 7;
                v42 = a2 + 25024;
                for(i17 = 0; i17 < 2; ++i17) {
                    if(i17 != (unsigned __int8) byte_69D4BD) {
                        *(_WORD*) (v42 + 138) = 0;
                        *(_WORD*) (v42 + 410) = 0;
                    }
                    v42 += 544;
                }
                *(_WORD*) (272 * (dword_69BCB0 + 81) + a2 + 138) = 0;
                sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                byte_69D4BE = *(_BYTE*) (a2 + 33184);
                *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BD;
                v43 = a2 + 23392;
                for(i18 = 0; i18 < 2; ++i18) {
                    if(i18 != *(_DWORD*) (a2 + 33184)) {
                        *(_WORD*) (v43 + 138) = 0;
                        *(_WORD*) (v43 + 410) = 0;
                    }
                    v43 += 544;
                }
            }
            goto LABEL_340;
        case 0xC:
        case 0xD:
        case 0xE:
        case 0xF:
            if(!sub_4381EC((_DWORD*) a2))
                goto LABEL_340;
            return 0;
        case 0x10:
            if(*(int*) (a2 + 33268) < 60)
                goto LABEL_340;
            dword_6C6EA4 = 9;
            return 0;
        case 0x11:
            if((unsigned __int8) byte_69CCE1 [48 * (unsigned __int8) byte_69D4BD
               + 24 * (unsigned __int8) byte_69D4BE
               + dword_69BCB0] <= 6u)
                v11 = (unsigned __int8) byte_69CCE1 [48 * (unsigned __int8) byte_69D4BD
                + 24 * (unsigned __int8) byte_69D4BE
                + dword_69BCB0];
            else
                v11 = 6;
            v19 = v11;
            if(!dword_69BCB0 && v11 == 6)
                v19 = 5;
            sub_43753C(a2, v19);
            if(*(int*) (a2 + 33268) < 30)
                goto LABEL_340;
            if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                *(_DWORD*) (a2 + 33264) = 11;
                *(_DWORD*) (a2 + 33268) = 0;
                for(i19 = 0; i19 < 122; ++i19)
                    *(_WORD*) (a2 + 272 * i19 + 138) = 13;
                *(_WORD*) (272 * (dword_69BCB0 + 81) + a2 + 138) = 0;
                v46 = a2 + 23392;
                for(i20 = 0; i20 < 2; ++i20) {
                    if(i20 != (unsigned __int8) byte_69D4BD) {
                        *(_WORD*) (v46 + 138) = 0;
                        *(_WORD*) (v46 + 410) = 0;
                    }
                    v46 += 544;
                }
                v47 = a2 + 25024;
                for(i21 = 0; i21 < 2; ++i21) {
                    if(i21 != (unsigned __int8) byte_69D4BD) {
                        *(_WORD*) (v47 + 138) = 0;
                        *(_WORD*) (v47 + 410) = 0;
                    }
                    v47 += 544;
                }
                *(_DWORD*) (a2 + 33184) = (unsigned __int8) byte_69D4BE;
                sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                goto LABEL_340;
            }
            if((word_69D904 & 0x1001) == 0 || (word_69D904 & 0x1001) == (word_69D908 & 0x1001)) {
                LABEL_340:
                ++* (_DWORD*) (a2 + 33268);
                for(i22 = 0; i22 < 122; ++i22) {
                    v18 = 272 * i22 + a2;
                    if(*(_DWORD*) (v18 + 192))
                        v17 = **(int**) (v18 + 192) >= 0 && *(_DWORD*) (dword_6D4588 + 4 * **(_DWORD**) (v18 + 192) + 114960) != 0;
                    else
                        v17 = 0;
                    if(v17)
                        sub_433960((int*) dword_6D4588, 272 * i22 + a2);
                }
                return 1;
            }
            *(_DWORD*) dword_69D6D4 = *(_DWORD*) (a2 + 33184);
            dword_69D6D8 = *(_DWORD*) (a2 + 33184);
            LABEL_254:
            byte_69D4BA = byte_6C6E44;
            byte_69D4BB = byte_6C6E45;
            if(dword_69BCB0 == 4 || byte_69D4C3) {
                byte_69D4BA = 2;
                byte_69D4BB = 3;
            }
            dword_6C6EA4 = 2;
            sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
            dword_69BCBC = 0;
            v21 = 0.0;
            if(*(int*) (a2 + 69344) < 2) {
                v22 = 60.0;
            }
            else {
                for(i23 = 0; i23 < *(_DWORD*) (a2 + 69344); ++i23)
                    v21 = v21 + *(float*) (a2 + 4 * i23 + 69348);
                v13 = (float) i23;
                v22 = v21 / v13;
            }
            if(v22 < 155.0) {
                if(v22 < 135.0) {
                    if(v22 < 110.0) {
                        if(v22 < 95.0) {
                            if(v22 < 87.5) {
                                if(v22 < 82.5) {
                                    if(v22 < 77.5) {
                                        if(v22 < 73.5) {
                                            if(v22 < 68.0)
                                                v23 = 1.0;
                                            else
                                                v23 = 0.85714287;
                                        }
                                        else {
                                            v23 = 0.80000001;
                                        }
                                    }
                                    else {
                                        v23 = 0.75;
                                    }
                                }
                                else {
                                    v23 = 0.70588237;
                                }
                            }
                            else {
                                v23 = 0.66666669;
                            }
                        }
                        else {
                            v23 = 0.60000002;
                        }
                    }
                    else {
                        v23 = 0.5;
                    }
                }
                else {
                    v23 = 0.40000001;
                }
            }
            else {
                v23 = 0.375;
            }
            sub_42F6C4();
            *(float*) &dword_6C6EC4 = v23;
            sub_424D38();
            return 0;
        default:
            goto LABEL_340;
    }
}
// 4765A0: using guessed type __int16 word_4765A0;
// 478690: using guessed type __int16 word_478690;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D4C3: using guessed type char byte_69D4C3;
// 69D4C4: using guessed type char byte_69D4C4;
// 69D4C8: using guessed type int dword_69D4C8;
// 69D6D8: using guessed type int dword_69D6D8;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6E2C: using guessed type __int16 word_6C6E2C;
// 6C6E44: using guessed type char byte_6C6E44;
// 6C6E45: using guessed type char byte_6C6E45;
// 6C6E49: using guessed type char byte_6C6E49;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (0043753C) --------------------------------------------------------
int __cdecl sub_43753C(int a1, int a2) {
    if((word_69D904 & 0x10) != 0 && (word_69D904 & 0x10) != (word_69D908 & 0x10)
       || (word_69D904 & 0x10) != 0 && word_69D90C) {
        --* (_DWORD*) (a1 + 33184);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
        if(*(int*) (a1 + 33184) < 0)
            *(_DWORD*) (a1 + 33184) = a2 - 1;
        if(*(_DWORD*) (a1 + 33184) >= a2)
            *(_DWORD*) (a1 + 33184) = 0;
        return -1;
    }
    else if((word_69D904 & 0x20) != 0 && (word_69D904 & 0x20) != (word_69D908 & 0x20)
            || (word_69D904 & 0x20) != 0 && word_69D90C) {
        ++* (_DWORD*) (a1 + 33184);
        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
        if(*(int*) (a1 + 33184) < 0)
            *(_DWORD*) (a1 + 33184) = a2 - 1;
        if(*(_DWORD*) (a1 + 33184) >= a2)
            *(_DWORD*) (a1 + 33184) = 0;
        return 1;
    }
    else {
        return 0;
    }
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00437672) --------------------------------------------------------
_WORD* __cdecl sub_437672(_WORD* a1, __int16 a2, __int16 a3, int a4) {
    _WORD* result; // eax

    if(!a4 && (__int16) a1 [16654] == a2)
        a1 [16654] = a3;
    if((__int16) a1 [16655] == a2)
        a1 [16655] = a3;
    if(!a4 && (__int16) a1 [16656] == a2)
        a1 [16656] = a3;
    if((__int16) a1 [16658] == a2)
        a1 [16658] = a3;
    if((__int16) a1 [16659] == a2)
        a1 [16659] = a3;
    if((__int16) a1 [16660] == a2)
        a1 [16660] = a3;
    if((__int16) a1 [16661] == a2)
        a1 [16661] = a3;
    if((__int16) a1 [16657] == a2)
        a1 [16657] = a3;
    result = (_WORD*) (__int16) a1 [16662];
    if(result == (_WORD*) a2) {
        result = a1;
        a1 [16662] = a3;
    }
    return result;
}

//----- (004377A3) --------------------------------------------------------
unsigned int __cdecl sub_4377A3(int a1, int a2, int a3, int a4, int a5, int a6) {
    unsigned int result; // eax

    if(a2 == a3) {
        if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1) {
            sub_4323A0((int*) dword_6D4588, a1, a6 + *(__int16*) (a1 + 178));
            result = a4 & 0xFF000000 | 0xFFFFFF;
            *(_DWORD*) (a1 + 124) = result;
        }
        else {
            result = a1;
            *(_DWORD*) (a1 + 124) = a4;
        }
        *(float*) (a1 + 228) = -4.0;
        *(float*) (a1 + 232) = -4.0;
        *(float*) (a1 + 236) = 0.0;
    }
    else {
        if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1) {
            sub_4323A0((int*) dword_6D4588, a1, *(__int16*) (a1 + 178));
            result = a5 & 0xFF000000 | 0xFFFFFF;
            *(_DWORD*) (a1 + 124) = result;
        }
        else {
            result = a1;
            *(_DWORD*) (a1 + 124) = a5;
        }
        *(float*) (a1 + 228) = 0.0;
        *(float*) (a1 + 232) = 0.0;
        *(float*) (a1 + 236) = 0.0;
    }
    return result;
}
// 6C6E60: using guessed type int dword_6C6E60;

//----- (004378A2) --------------------------------------------------------
int __usercall sub_4378A2(int a1, int a2) {
    int v3; // eax
    int i; // [esp+18h] [ebp-8h]

    if(sub_439DA0(a1)) {
        dword_6C6EA4 = 4;
        return -1;
    }
    else {
        if(dword_6C7118) {
            while(timeGetTime() - dword_6C7118 < 0xBB8)
                ;
            dword_6C7118 = 0;
            sub_424B5D(a2, "bgm/th06_01.mid");
        }
        for(i = 0; i < 122; ++i) {
            *(_WORD*) (a1 + 272 * i + 138) = 1;
            v3 = *(_DWORD*) (a1 + 272 * i + 128);
            LOBYTE(v3) = v3 | 8;
            *(_DWORD*) (a1 + 272 * i + 128) = v3;
            if((dword_6C6E60 & 1) != 0)
                *(_DWORD*) (a1 + 272 * i + 124) = -1;
            else
                *(_DWORD*) (a1 + 272 * i + 124) = -16777216;
            *(float*) (a1 + 272 * i + 228) = 0.0;
            *(float*) (a1 + 272 * i + 232) = 0.0;
            *(float*) (a1 + 272 * i + 236) = 0.0;
        }
        *(_DWORD*) (a1 + 33264) = 1;
        return 0;
    }
}
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C7118: using guessed type int dword_6C7118;

//----- (004379E4) --------------------------------------------------------
int __thiscall sub_4379E4(_DWORD* this) {
    float* v2; // edi
    int i; // [esp+18h] [ebp-4h]

    if((int) this [8317] < 30)
        return 1;
    if(((word_69D904 & 0x160B) == 0 || (word_69D904 & 0x160B) == (word_69D908 & 0x160B))
       && ((word_69D904 & 0x160B) == 0 || !word_69D90C)) {
        return 1;
    }
    this [8317] = 0;
    this [8316] = 2;
    for(i = 0; i < 122; ++i)
        HIWORD(this [68 * i + 34]) = 2;
    if((dword_6C6E60 & 1) != 0)
        this [68 * this [8296] + 31] = -7968;
    else
        this [68 * this [8296] + 31] = -65536;
    v2 = (float*) &this [68 * this [8296] + 57];
    *v2++ = -6.0;
    *v2 = -6.0;
    v2 [1] = 0.0;
    this [8319] = 0;
    this [8320] = 0x40000000;
    this [8323] = 0;
    this [8324] = 60;
    return 0;
}
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00437B41) --------------------------------------------------------
int __thiscall sub_437B41(int this) {
    int v3; // [esp+8h] [ebp-8h]
    int v4; // [esp+Ch] [ebp-4h]
    int i; // [esp+Ch] [ebp-4h]
    int j; // [esp+Ch] [ebp-4h]
    int k; // [esp+Ch] [ebp-4h]
    int m; // [esp+Ch] [ebp-4h]
    int n; // [esp+Ch] [ebp-4h]
    int ii; // [esp+Ch] [ebp-4h]
    int jj; // [esp+Ch] [ebp-4h]
    int kk; // [esp+Ch] [ebp-4h]
    int mm; // [esp+Ch] [ebp-4h]
    int nn; // [esp+Ch] [ebp-4h]

    v4 = sub_43753C(this, 8);
    if(*(_DWORD*) (this + 33184) == 1
       && !sub_43A736(dword_69BCA0, 0, 0)
       && !sub_43A736(dword_69BCA0, 0, 1)
       && !sub_43A736(dword_69BCA0, 1, 0)
       && !sub_43A736(dword_69BCA0, 1, 1)) {
        *(_DWORD*) (this + 33184) += v4;
    }
    v3 = this;
    for(i = 0; i < 8; ++i) {
        sub_4377A3(v3, i, *(_DWORD*) (this + 33184), -65536, -2144337920, 122);
        v3 += 272;
    }
    if(*(int*) (this + 33268) >= 20) {
        if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
            switch(*(_DWORD*) (this + 33184)) {
                case 0:
                    for(j = 0; j < 122; ++j)
                        *(_WORD*) (this + 272 * j + 138) = 4;
                    *(_DWORD*) (this + 33264) = 6;
                    byte_69D4C3 = 0;
                    if(dword_69BCB0 >= 4)
                        dword_69BCB0 = 1;
                    if((unsigned __int8) byte_6C6E49 >= 4u)
                        byte_6C6E49 = 1;
                    goto LABEL_21;
                case 1:
                    if(!sub_43A736(dword_69BCA0, 0, 0)
                       && !sub_43A736(dword_69BCA0, 0, 1)
                       && !sub_43A736(dword_69BCA0, 1, 0)
                       && !sub_43A736(dword_69BCA0, 1, 1)) {
                        goto LABEL_58;
                    }
                    for(k = 0; k < 122; ++k)
                        *(_WORD*) (this + 272 * k + 138) = 4;
                    *(_DWORD*) (this + 33264) = 6;
                    byte_69D4C3 = 0;
                    dword_69BCB0 = 4;
                    *(_DWORD*) (this + 33268) = 0;
                    *(_DWORD*) (this + 33276) = 0x40000000;
                    *(_DWORD*) (this + 33280) = -16777216;
                    *(_DWORD*) (this + 33292) = 0;
                    *(_DWORD*) (this + 33296) = 60;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 2:
                    byte_69D4C3 = 1;
                    for(m = 0; m < 122; ++m)
                        *(_WORD*) (this + 272 * m + 138) = 4;
                    *(_DWORD*) (this + 33264) = 6;
                    if(dword_69BCB0 >= 4)
                        dword_69BCB0 = 1;
                    if((unsigned __int8) byte_6C6E49 >= 4u)
                        byte_6C6E49 = 1;
                    LABEL_21:
                    *(_DWORD*) (this + 33268) = 0;
                    *(_DWORD*) (this + 33276) = 0x40000000;
                    *(_DWORD*) (this + 33280) = -16777216;
                    *(_DWORD*) (this + 33292) = 0;
                    *(_DWORD*) (this + 33296) = 60;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 3:
                    for(n = 0; n < 122; ++n)
                        *(_WORD*) (this + 272 * n + 138) = 4;
                    *(_DWORD*) (this + 33264) = 12;
                    byte_69D4C3 = 0;
                    *(_DWORD*) (this + 33268) = 0;
                    *(_DWORD*) (this + 33276) = 0x40000000;
                    *(_DWORD*) (this + 33280) = -16777216;
                    *(_DWORD*) (this + 33292) = 0;
                    *(_DWORD*) (this + 33296) = 60;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 4:
                    for(ii = 0; ii < 122; ++ii)
                        *(_WORD*) (this + 272 * ii + 138) = 4;
                    *(_DWORD*) (this + 33264) = 10;
                    *(_DWORD*) (this + 33268) = 0;
                    *(_DWORD*) (this + 33276) = 0x40000000;
                    *(_DWORD*) (this + 33280) = -16777216;
                    *(_DWORD*) (this + 33292) = 0;
                    *(_DWORD*) (this + 33296) = 60;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 5:
                    *(_DWORD*) (this + 33264) = 16;
                    *(_DWORD*) (this + 33268) = 0;
                    for(jj = 0; jj < 122; ++jj)
                        *(_WORD*) (this + 272 * jj + 138) = 4;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 6:
                    *(_DWORD*) (this + 33264) = 3;
                    *(_DWORD*) (this + 33268) = 0;
                    for(kk = 0; kk < 122; ++kk)
                        *(_WORD*) (this + 272 * kk + 138) = 3;
                    *(_DWORD*) (this + 33184) = 0;
                    *(_BYTE*) (this + 33328) = byte_6C6E46;
                    *(_BYTE*) (this + 33329) = byte_6C6E4A;
                    *(_BYTE*) (this + 33330) = byte_6C6E4B;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    break;
                case 7:
                    *(_DWORD*) (this + 33264) = 4;
                    *(_DWORD*) (this + 33268) = 0;
                    for(mm = 0; mm < 122; ++mm)
                        *(_WORD*) (this + 272 * mm + 138) = 4;
                    LABEL_58:
                    sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                    break;
                default:
                    break;
            }
        }
        if((word_69D904 & 0x200) != 0 && (word_69D904 & 0x200) != (word_69D908 & 0x200)) {
            *(_DWORD*) (this + 33264) = 4;
            *(_DWORD*) (this + 33268) = 0;
            for(nn = 0; nn < 122; ++nn)
                *(_WORD*) (this + 272 * nn + 138) = 4;
            sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
        }
        if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
            *(_DWORD*) (this + 33184) = 7;
            sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
        }
    }
    return 0;
}
// 69BCB0: using guessed type int dword_69BCB0;
// 69D4C3: using guessed type char byte_69D4C3;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 6C6E46: using guessed type char byte_6C6E46;
// 6C6E49: using guessed type char byte_6C6E49;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (004381EC) --------------------------------------------------------
int __thiscall sub_4381EC(_DWORD* this) {
    int v2; // [esp+8h] [ebp-1A8h]
    struct _WIN32_FIND_DATAA FindFileData; // [esp+18h] [ebp-198h] BYREF
    char Buffer [64]; // [esp+158h] [ebp-58h] BYREF
    unsigned int v6; // [esp+198h] [ebp-18h]
    void* Block; // [esp+19Ch] [ebp-14h]
    int v8; // [esp+1A0h] [ebp-10h]
    HANDLE hFindFile; // [esp+1A4h] [ebp-Ch]
    int i; // [esp+1A8h] [ebp-8h]
    _DWORD* v11; // [esp+1ACh] [ebp-4h]
    unsigned int retaddr; // [esp+1B4h] [ebp+4h]

    v6 = retaddr ^ dword_47A630;
    v2 = this [8316];
    switch(v2) {
        case 12:
            if(this [8317] == 60) {
                if(sub_43A1EC((int) this)) {
                    sub_41E4D0((int) byte_69D998, (char*) &byte_46C368);
                    dword_6C6EA4 = 4;
                    return 0;
                }
                v8 = 0;
                for(i = 0; i < 15; ++i) {
                    sprintf(Buffer, "./replay/th6_%.2d.rpy", i + 1);
                    Block = sub_41E290(Buffer, 1);
                    if(Block) {
                        if(!sub_42A140((int) Block, dword_69D914)) {
                            qmemcpy(&this [20 * v8 + 16135], Block, 0x50u);
                            strcpy((char*) &this [128 * v8 + 8335], Buffer);
                            sprintf((char* const) &this [2 * v8++ + 16015], "No.%.2d", i + 1);
                        }
                        free(Block);
                    }
                }
                _mkdir("./replay");
                sub_45D5F9("./replay");
                hFindFile = FindFirstFileA("th6_ud????.rpy", &FindFileData);
                if(hFindFile != (HANDLE) -1) {
                    for(i = 0; i < 45; ++i) {
                        Block = sub_41E290(FindFileData.cFileName, 1);
                        if(Block) {
                            if(!sub_42A140((int) Block, dword_69D914)) {
                                qmemcpy(&this [20 * v8 + 16135], Block, 0x50u);
                                sprintf((char* const) &this [128 * v8 + 8335], "./replay/%s", FindFileData.cFileName);
                                sprintf((char* const) &this [2 * v8++ + 16015], "User ");
                            }
                            free(Block);
                            if(!FindNextFileA(hFindFile, &FindFileData))
                                break;
                        }
                    }
                }
                FindClose(hFindFile);
                sub_45D5F9("../");
                this [8315] = v8;
                this [8319] = 0;
                this [8325] = this [8324];
                this [8324] = 0;
                this [8316] = 13;
                v11 = this;
                i = 0;
                while(i < 122) {
                    *((_WORD*) v11 + 69) = 15;
                    ++i;
                    v11 += 68;
                }
                this [8296] = 0;
            }
            return 0;
        case 13:
            if((int) this [8317] >= 40) {
                if(this [8315]) {
                    sub_43753C((int) this, this [8315]);
                    this [8314] = this [8296];
                    if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
                        this [8316] = 15;
                        v11 = this + 6596;
                        i = 0;
                        while(i < 25) {
                            *((_WORD*) v11 + 69) = 17;
                            ++i;
                            v11 += 68;
                        }
                        v11 = &this [68 * this [8314] + 6732];
                        *((_WORD*) v11 + 69) = 16;
                        this [8317] = 0;
                        this [8296] = 0;
                        sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                        this [17335] = sub_41E290((char*) &this [128 * this [8314] + 8335], 1);
                        sub_42A140(this [17335], dword_69D914);
                        for(i = 0; i < 7; ++i) {
                            if(*(_DWORD*) (this [17335] + 4 * i + 52))
                                *(_DWORD*) (this [17335] + 4 * i + 52) += this [17335];
                        }
                        while(!this [20 * this [8314] + 16148 + this [8296]]) {
                            if((int)++this [8296] >= 7)
                                return 0;
                        }
                    }
                }
                if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
                    this [8316] = 14;
                    this [8317] = 0;
                    for(i = 0; i < 122; ++i)
                        HIWORD(this [68 * i + 34]) = 4;
                    sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                    this [8296] = 0;
                }
            }
            return 0;
        case 14:
            if(this [8317] == 36) {
                this [8316] = 0;
                this [8317] = 0;
            }
            return 0;
    }
    if(v2 != 15 || (int) this [8317] < 40)
        return 0;
    i = sub_43753C((int) this, 7);
    if(i >= 0) {
        if(i > 0) {
            while(!this [20 * this [8314] + 16148 + this [8296]]) {
                if((int)++this [8296] >= 7)
                    this [8296] = 0;
            }
        }
    }
    else {
        while(!this [20 * this [8314] + 16148 + this [8296]]) {
            if((int)--this [8296] < 0)
                this [8296] = 6;
        }
    }
    if((word_69D904 & 0x1001) == 0
       || (word_69D904 & 0x1001) == (word_69D908 & 0x1001)
       || this [17335] + 80 * this [8296] == -52) {
        if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
            free((void*) this [17335]);
            this [17335] = 0;
            this [8316] = 13;
            this [8317] = 0;
            for(i = 0; i < 122; ++i)
                HIWORD(this [68 * i + 34]) = 4;
            sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
            this [8316] = 13;
            v11 = this;
            i = 0;
            while(i < 122) {
                *((_WORD*) v11 + 69) = 15;
                ++i;
                v11 += 68;
            }
            this [8296] = this [8314];
        }
        return 0;
    }
    dword_69BCBC = 1;
    *(float*) &dword_6C6EC4 = 1.0;
    strcpy(Destination, (const char*) &this [128 * this [8314] + 8335]);
    dword_69BCB0 = *(unsigned __int8*) (this [17335] + 7);
    byte_69D4BD = *(unsigned __int8*) (this [17335] + 6) / 2;
    byte_69D4BE = *(unsigned __int8*) (this [17335] + 6) % 2;
    for(i = 0; !*(_DWORD*) (this [17335] + 4 * i + 52); ++i)
        ;
    byte_69D4BA = *(_BYTE*) (*(_DWORD*) (this [17335] + 4 * i + 52) + 9);
    byte_69D4BB = *(_BYTE*) (*(_DWORD*) (this [17335] + 4 * i + 52) + 10);
    free((void*) this [17335]);
    this [17335] = 0;
    *(_DWORD*) dword_69D6D4 = this [8296];
    dword_6C6EA4 = 2;
    return 1;
}
// 47A630: using guessed type int dword_47A630;
// 69BCB0: using guessed type int dword_69BCB0;
// 69BCBC: using guessed type int dword_69BCBC;
// 69D4BA: using guessed type char byte_69D4BA;
// 69D4BB: using guessed type char byte_69D4BB;
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D914: using guessed type int dword_69D914;
// 69D998: using guessed type _BYTE byte_69D998[2048];
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6C6EC4: using guessed type int dword_6C6EC4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00438BC1) --------------------------------------------------------
int __thiscall sub_438BC1(_DWORD* this) {
    int v3; // [esp+14h] [ebp-Ch]
    int v4; // [esp+18h] [ebp-8h]
    int i; // [esp+18h] [ebp-8h]
    _DWORD* v6; // [esp+1Ch] [ebp-4h]
    _DWORD* v7; // [esp+1Ch] [ebp-4h]

    v6 = this + 6664;
    sub_401650(dword_47B900, this + 6700, "No.   Name      Date     Player   Rank");
    v4 = this [8314] - this [8314] % 15;
    v3 = v4;
    while(v4 < v3 + 15 && v4 < this [8315]) {
        v6 += 68;
        if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1) {
            dword_481B34 = this [8314] == v4;
            if(v4 == this [8314])
                dword_481B24 = -1;
            else
                dword_481B24 = -8355712;
        }
        else if(v4 == this [8314]) {
            dword_481B24 = -32640;
        }
        else {
            dword_481B24 = -8355712;
        }
        sub_401650(
            dword_47B900,
            v6 + 36,
            "%s %8s  %8s %7s  %7s",
            (const char*) &this [2 * v4 + 16015],
            (const char*) &this [20 * v4 + 16141] + 1,
            (const char*) &this [20 * v4 + 16139],
            off_4786B0 [BYTE2(this [20 * v4 + 16136])],
            off_4786C0 [HIBYTE(this [20 * v4 + 16136])]);
        ++v4;
    }
    if(this [8316] == 15 && this [17335]) {
        dword_481B24 = -1;
        dword_481B34 = 0;
        sub_401650(dword_47B900, this + 6632, "       %2.3f%%", *(float*) (this [17335] + 44));
        v7 = this + 7752;
        sub_401650(dword_47B900, this + 7788, "Stage  LastScore");
        for(i = 0; i < 7; ++i) {
            v7 += 68;
            if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1) {
                dword_481B34 = this [8296] == i;
                if(i == this [8296])
                    dword_481B24 = -1;
                else
                    dword_481B24 = -8355712;
            }
            else if(i == this [8296]) {
                dword_481B24 = -32640;
            }
            else {
                dword_481B24 = -8355712;
            }
            if(*(_DWORD*) (this [17335] + 4 * i + 52))
                sub_401650(
                    dword_47B900,
                    v7 + 36,
                    "%s %9d",
                    *(const char**) &off_478694 [4 * i],
                    **(_DWORD**) (this [17335] + 4 * i + 52));
            else
                sub_401650(dword_47B900, v7 + 36, "%s ---------", *(const char**) &off_478694 [4 * i]);
        }
    }
    dword_481B24 = -1;
    dword_481B34 = 0;
    return 0;
}
// 4786B0: using guessed type char *off_4786B0[9];
// 4786C0: using guessed type char *off_4786C0[5];
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 481B34: using guessed type int dword_481B34;
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00438EF8) --------------------------------------------------------
int __thiscall sub_438EF8(_DWORD* this, int a2, int a3, int a4, int a5) {
    int result; // eax

    if(a4 == a5) {
        if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1) {
            if(*(__int16*) (a2 + 178) >= 290)
                sub_4323A0((int*) dword_6D4588, a2, *(__int16*) (a2 + 178) + 115);
            else
                sub_4323A0((int*) dword_6D4588, a2, *(__int16*) (a2 + 178) + 122);
        }
        else {
            *(_DWORD*) (a2 + 124) = -2147483393;
        }
        *(float*) (a2 + 228) = -2.0;
        *(float*) (a2 + 232) = -2.0;
        *(float*) (a2 + 236) = 0.0;
    }
    else {
        if(dword_6C6E60 & 1 | ((unsigned int) dword_6C6E60 >> 8) & 1)
            sub_4323A0((int*) dword_6D4588, a2, *(__int16*) (a2 + 178));
        else
            *(_DWORD*) (a2 + 124) = -2145378224;
        *(float*) (a2 + 28) = 1.0;
        *(float*) (a2 + 24) = 1.0;
        *(float*) (a2 + 228) = 0.0;
        *(float*) (a2 + 232) = 0.0;
        *(float*) (a2 + 236) = 0.0;
    }
    if(a3 == this [8296]) {
        *(_DWORD*) (a2 + 124) = *(_DWORD*) (a2 + 124) & 0xFFFFFF | 0xFF000000;
        *(float*) (a2 + 228) = (float) -4.0 + *(float*) (a2 + 228);
        *(float*) (a2 + 232) = (float) -4.0 + *(float*) (a2 + 232);
    }
    else {
        *(_DWORD*) (a2 + 124) = *(_DWORD*) (a2 + 124) & 0xFFFFFF | 0x80000000;
        *(float*) (a2 + 228) = (float) 0.0 + *(float*) (a2 + 228);
        *(float*) (a2 + 232) = (float) 0.0 + *(float*) (a2 + 232);
    }
    result = a2 + 228;
    *(float*) (a2 + 236) = (float) 0.0 + *(float*) (a2 + 236);
    return result;
}
// 6C6E60: using guessed type int dword_6C6E60;

//----- (00439137) --------------------------------------------------------
int __usercall sub_439137(int a1, int a2) {
    int v3; // [esp+8h] [ebp-18h]
    int v4; // [esp+Ch] [ebp-14h]
    int v5; // [esp+10h] [ebp-10h]
    int v7; // [esp+18h] [ebp-8h]
    int v8; // [esp+18h] [ebp-8h]
    int v9; // [esp+18h] [ebp-8h]
    int i; // [esp+1Ch] [ebp-4h]
    int j; // [esp+1Ch] [ebp-4h]
    int k; // [esp+1Ch] [ebp-4h]
    int m; // [esp+1Ch] [ebp-4h]
    int n; // [esp+1Ch] [ebp-4h]
    int ii; // [esp+1Ch] [ebp-4h]
    int jj; // [esp+1Ch] [ebp-4h]
    int kk; // [esp+1Ch] [ebp-4h]
    int mm; // [esp+1Ch] [ebp-4h]

    sub_43753C(a1, 9);
    v7 = a1 + 2176;
    for(i = 0; i < 9; ++i) {
        if(i < 5 || i > 7) {
            sub_438EF8((_DWORD*) a1, v7, i, i, *(_DWORD*) (a1 + 33184));
            v7 += 272;
        }
        else {
            sub_438EF8((_DWORD*) a1, 272 * (i + 67) + a1, i, i, *(_DWORD*) (a1 + 33184));
        }
    }
    for(j = 0; j < 5; ++j) {
        sub_438EF8((_DWORD*) a1, v7, 0, j, (unsigned __int8) byte_6C6E44);
        v7 += 272;
    }
    for(k = 0; k < 4; ++k) {
        sub_438EF8((_DWORD*) a1, v7, 1, k, (unsigned __int8) byte_6C6E45);
        v7 += 272;
    }
    for(m = 0; m < 2; ++m) {
        sub_438EF8((_DWORD*) a1, v7, 2, m, (unsigned __int8) byte_6C6E46);
        v7 += 272;
    }
    for(n = 0; n < 2; ++n) {
        sub_438EF8((_DWORD*) a1, v7, 4, n, (unsigned __int8) byte_6C6E48);
        v7 += 272;
    }
    v8 = a1 + 20944;
    for(ii = 0; ii < 3; ++ii) {
        sub_438EF8((_DWORD*) a1, v8, 3, ii, (unsigned __int8) byte_6C6E47);
        v8 += 272;
    }
    v9 = a1 + 20400;
    for(jj = 0; jj < 2; ++jj) {
        sub_438EF8((_DWORD*) a1, v9, 5, jj, *(unsigned __int8*) (a1 + 33329));
        v9 += 272;
    }
    if(*(int*) (a1 + 33268) >= 32) {
        if((word_69D904 & 0x40) != 0 && (word_69D904 & 0x40) != (word_69D908 & 0x40)
           || (word_69D904 & 0x40) != 0 && word_69D90C) {
            v5 = *(_DWORD*) (a1 + 33184);
            if(v5) {
                switch(v5) {
                    case 1:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if(!byte_6C6E45)
                            byte_6C6E45 = 4;
                        --byte_6C6E45;
                        break;
                    case 2:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if(!byte_6C6E46)
                            byte_6C6E46 = 2;
                        --byte_6C6E46;
                        break;
                    case 3:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        sub_424D38();
                        if(!byte_6C6E47)
                            byte_6C6E47 = 3;
                        --byte_6C6E47;
                        sub_424B2F((int) "bgm/th06_01.mid");
                        sub_424B5D(a2, "bgm/th06_01.mid");
                        break;
                    case 4:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if(!byte_6C6E48)
                            byte_6C6E48 = 2;
                        --byte_6C6E48;
                        break;
                    case 5:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if(!*(_BYTE*) (a1 + 33329))
                            *(_BYTE*) (a1 + 33329) = 2;
                        --* (_BYTE*) (a1 + 33329);
                        break;
                }
            }
            else {
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                if(!byte_6C6E44)
                    byte_6C6E44 = 5;
                --byte_6C6E44;
            }
        }
        if((word_69D904 & 0xA) != 0 && (word_69D904 & 0xA) != (word_69D908 & 0xA)) {
            *(_DWORD*) (a1 + 33184) = 8;
            sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
        }
        if((word_69D904 & 0x80) != 0 && (word_69D904 & 0x80) != (word_69D908 & 0x80)
           || (word_69D904 & 0x80) != 0 && word_69D90C) {
            v4 = *(_DWORD*) (a1 + 33184);
            if(v4) {
                switch(v4) {
                    case 1:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if((unsigned __int8)++byte_6C6E45 >= 4u)
                            byte_6C6E45 = 0;
                        break;
                    case 2:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if((unsigned __int8)++byte_6C6E46 >= 2u)
                            byte_6C6E46 = 0;
                        break;
                    case 3:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        sub_424D38();
                        if((unsigned __int8)++byte_6C6E47 >= 3u)
                            byte_6C6E47 = 0;
                        sub_424B2F((int) "bgm/th06_01.mid");
                        sub_424B5D(a2, "bgm/th06_01.mid");
                        break;
                    case 4:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if((unsigned __int8)++byte_6C6E48 >= 2u)
                            byte_6C6E48 = 0;
                        break;
                    case 5:
                        sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                        if((unsigned __int8)++ * (_BYTE*) (a1 + 33329) >= 2u)
                            *(_BYTE*) (a1 + 33329) = 0;
                        break;
                }
            }
            else {
                sub_4311E0(dword_6D3F50, (int*) 0xC, 0);
                if((unsigned __int8)++byte_6C6E44 >= 5u)
                    byte_6C6E44 = 0;
            }
        }
        if((word_69D904 & 0x1001) != 0 && (word_69D904 & 0x1001) != (word_69D908 & 0x1001)) {
            v3 = *(_DWORD*) (a1 + 33184);
            switch(v3) {
                case 6:
                    sub_424D38();
                    byte_6C6E44 = 2;
                    byte_6C6E45 = 3;
                    byte_6C6E47 = 1;
                    byte_6C6E48 = 1;
                    byte_6C6E49 = 1;
                    byte_6C6E4A = 0;
                    byte_6C6E4B = 0;
                    sub_424B2F((int) "bgm/th06_01.mid");
                    sub_424B5D(a2, "bgm/th06_01.mid");
                    break;
                case 7:
                    *(_DWORD*) (a1 + 33264) = 5;
                    *(_DWORD*) (a1 + 33268) = 0;
                    for(kk = 0; kk < 122; ++kk)
                        *(_WORD*) (a1 + 272 * kk + 138) = 5;
                    *(_DWORD*) (a1 + 33184) = 0;
                    sub_4311E0(dword_6D3F50, (int*) 0xA, 0);
                    *(_DWORD*) (a1 + 33308) = *(_DWORD*) &word_4765A0;
                    *(_DWORD*) (a1 + 33312) = *((_DWORD*) &word_4765A0 + 1);
                    *(_DWORD*) (a1 + 33316) = *((_DWORD*) &word_4765A0 + 2);
                    *(_DWORD*) (a1 + 33320) = *((_DWORD*) &word_4765A0 + 3);
                    *(_WORD*) (a1 + 33324) = *(&word_4765A0 + 8);
                    word_4765A8 = -1;
                    word_4765AA = -1;
                    break;
                case 8:
                    *(_DWORD*) (a1 + 33264) = 2;
                    *(_DWORD*) (a1 + 33268) = 0;
                    for(mm = 0; mm < 122; ++mm)
                        *(_WORD*) (a1 + 272 * mm + 138) = 2;
                    *(_DWORD*) (a1 + 33184) = 6;
                    sub_4311E0(dword_6D3F50, (int*) 0xB, 0);
                    if(*(unsigned __int8*) (a1 + 33328) != (unsigned __int8) byte_6C6E46
                       || *(unsigned __int8*) (a1 + 33329) != (unsigned __int8) byte_6C6E4A
                       || *(unsigned __int8*) (a1 + 33330) != (unsigned __int8) byte_6C6E4B) {
                        byte_6C6E4B = *(_BYTE*) (a1 + 33330);
                        byte_6C6E4A = *(_BYTE*) (a1 + 33329);
                        dword_6C6EA4 = 5;
                        return 1;
                    }
                    break;
            }
        }
    }
    return 0;
}
// 4765A0: using guessed type __int16 word_4765A0;
// 4765A8: using guessed type __int16 word_4765A8;
// 4765AA: using guessed type __int16 word_4765AA;
// 69D904: using guessed type __int16 word_69D904;
// 69D908: using guessed type __int16 word_69D908;
// 69D90C: using guessed type __int16 word_69D90C;
// 6C6E44: using guessed type char byte_6C6E44;
// 6C6E45: using guessed type char byte_6C6E45;
// 6C6E46: using guessed type char byte_6C6E46;
// 6C6E47: using guessed type char byte_6C6E47;
// 6C6E48: using guessed type char byte_6C6E48;
// 6C6E49: using guessed type char byte_6C6E49;
// 6C6E4A: using guessed type char byte_6C6E4A;
// 6C6E4B: using guessed type char byte_6C6E4B;
// 6C6EA4: using guessed type int dword_6C6EA4;
// 6D3F50: using guessed type int dword_6D3F50[395];

//----- (00439965) --------------------------------------------------------
int __thiscall sub_439965(_DWORD* this) {
    int v2; // [esp+0h] [ebp-28h]
    int v3; // [esp+4h] [ebp-24h]
    int v5; // [esp+Ch] [ebp-1Ch] BYREF
    float v6; // [esp+10h] [ebp-18h]
    float v7; // [esp+14h] [ebp-14h]
    int v8; // [esp+18h] [ebp-10h]
    int v9; // [esp+1Ch] [ebp-Ch]
    unsigned int v10; // [esp+20h] [ebp-8h]
    int i; // [esp+24h] [ebp-4h]

    if(this [8316] == 17) {
        *(float*) &v5 = 320.0;
        v6 = 200.0;
        v7 = 0.0;
        if((int) this [8317] >= 30)
            v3 = 255;
        else
            v3 = 255 * this [8317] / 30;
        v10 = v3;
        v9 = (unsigned __int8) byte_69D4BE + 2 * (unsigned __int8) byte_69D4BD;
        if((unsigned __int8) byte_69CCE1 [24 * v9 + dword_69BCB0] <= 6u)
            v2 = (unsigned __int8) byte_69CCE1 [24 * v9 + dword_69BCB0];
        else
            v2 = 6;
        v8 = v2;
        if(!dword_69BCB0 && v8 == 6)
            v8 = 5;
        for(i = 0; i < v8; ++i) {
            if(i == this [8296])
                dword_481B24 = (v10 << 24) | 0xC0F0F0;
            else
                dword_481B24 = (v10 >> 1 << 24) | 0x80C0C0;
            sub_401650(dword_47B900, &v5, "STAGE %d  %.9d", i + 1, dword_69CD30 [120 * v9 + 3 + 20 * i + 5 * dword_69BCB0]);
            v6 = v6 + 24.0;
        }
        dword_481B24 = -1;
    }
    return 0;
}
// 47B900: using guessed type _DWORD dword_47B900[6281];
// 481B24: using guessed type int dword_481B24;
// 69BCB0: using guessed type int dword_69BCB0;
// 69CD30: using guessed type _DWORD dword_69CD30[480];
// 69D4BD: using guessed type char byte_69D4BD;
// 69D4BE: using guessed type char byte_69D4BE;

//----- (00439AD6) --------------------------------------------------------
int __cdecl sub_439AD6(_DWORD* a1) {
    int v2; // [esp+8h] [ebp-3Ch]
    BOOL v3; // [esp+14h] [ebp-30h]
    float v4; // [esp+1Ch] [ebp-28h]
    int v5; // [esp+20h] [ebp-24h]
    int v6; // [esp+24h] [ebp-20h]
    unsigned int v7; // [esp+28h] [ebp-1Ch]
    int i; // [esp+2Ch] [ebp-18h]
    int v9 [4]; // [esp+30h] [ebp-14h] BYREF
    unsigned int v10; // [esp+40h] [ebp-4h]

    v7 = (unsigned int) a1;
    *(float*) v9 = 0.0;
    *(float*) &v9 [1] = 0.0;
    *(float*) &v9 [2] = 640.0;
    *(float*) &v9 [3] = 480.0;
    if(!a1 [8316])
        return 1;
    *(_DWORD*) (dword_6D4588 + 135352) = 0;
    sub_435300((_DWORD*) dword_6D4588, 0, 0, 0, 0, 0);
    if(a1 [8324]) {
        if(a1 [8323] < a1 [8324])
            ++a1 [8323];
        v10 = ((a1 [8320] & 0xFF000000) >> 24) - ((a1 [8319] & 0xFF000000) >> 24);
        sub_42F8B0(v9, a1 [8320] & 0xFFFFFF | ((((a1 [8319] & 0xFF000000) >> 24) + a1 [8323] * v10 / a1 [8324]) << 24));
    }
    else if(a1 [8323]) {
        --a1 [8323];
        v10 = ((a1 [8320] & 0xFF000000) >> 24) - ((a1 [8319] & 0xFF000000) >> 24);
        sub_42F8B0(v9, a1 [8320] & 0xFFFFFF | ((((a1 [8319] & 0xFF000000) >> 24) + a1 [8323] * v10 / a1 [8325]) << 24));
    }
    for(i = 0; i < 98; ++i) {
        if(*(_DWORD*) (v7 + 192))
            v3 = **(int**) (v7 + 192) >= 0 && *(_DWORD*) (dword_6D4588 + 4 * **(_DWORD**) (v7 + 192) + 114960) != 0;
        else
            v3 = 0;
        if(v3) {
            v4 = *(float*) (v7 + 144);
            v5 = *(_DWORD*) (v7 + 148);
            v6 = *(_DWORD*) (v7 + 152);
            *(float*) (v7 + 144) = v4 + *(float*) (v7 + 228);
            *(float*) (v7 + 148) = *(float*) (v7 + 148) + *(float*) (v7 + 232);
            *(float*) (v7 + 152) = *(float*) (v7 + 152) + *(float*) (v7 + 236);
            sub_432CC0((void*) dword_6D4588, v7);
            *(float*) (v7 + 144) = v4;
            *(_DWORD*) (v7 + 148) = v5;
            *(_DWORD*) (v7 + 152) = v6;
        }
        v7 += 272;
    }
    v2 = a1 [8316];
    if(v2 >= 13 && v2 <= 15)
        sub_438BC1(a1);
    sub_439965(a1);
    return 1;
}

//----- (00439DA0) --------------------------------------------------------
int __cdecl sub_439DA0(int a1) {
    int v2; // eax
    int v3; // eax
    int i; // [esp+1Ch] [ebp-4h]
    int j; // [esp+1Ch] [ebp-4h]

    sub_424375((int**) &dword_6C6D18, 3, "th06e_TL.dat");
    for(i = 27; i <= 36; ++i)
        sub_432030(dword_6D4588, i);
    if(sub_431DC0((_DWORD*) dword_6D4588, 21, "data/title01.anm", 256))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 24, "data/title02.anm", 283))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 25, "data/title03.anm", 287))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 26, "data/title04.anm", 290))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 22, "data/title01s.anm", 378))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 23, "data/title04s.anm", 405))
        return -1;
    for(j = 0; j < 80; ++j) {
        sub_4051B0((int*) dword_6D4588, 272 * j + a1, j + 256);
        v2 = *(_DWORD*) (a1 + 272 * j + 128);
        LOBYTE(v2) = v2 & 0xFE;
        *(_DWORD*) (a1 + 272 * j + 128) = v2;
        *(_WORD*) (a1 + 272 * j + 178) = *(_WORD*) (a1 + 272 * j + 176);
        v3 = *(_DWORD*) (a1 + 272 * j + 128);
        BYTE1(v3) |= 0x10u;
        *(_DWORD*) (a1 + 272 * j + 128) = v3;
    }
    if(sub_435010((_DWORD**) dword_6D4588, 0, "data/title/title00.jpg"))
        return -1;
    else
        return 0;
}
// 6C6D18: using guessed type int dword_6C6D18;

//----- (00439F88) --------------------------------------------------------
int __cdecl sub_439F88(int a1) {
    int v2; // eax
    int v3; // eax
    int v4; // eax
    int v5; // [esp+2Ch] [ebp-8h]
    int i; // [esp+30h] [ebp-4h]
    int j; // [esp+30h] [ebp-4h]

    for(i = 21; i <= 26; ++i)
        sub_432030(dword_6D4588, i);
    if(sub_435010((_DWORD**) dword_6D4588, 0, "data/title/select00.jpg"))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 27, "data/select01.anm", 336))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 28, "data/select02.anm", 339))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 29, "data/select03.anm", 346))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 30, "data/select04.anm", 348))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 31, "data/select05.anm", 341))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 32, "data/slpl00a.anm", 342))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 33, "data/slpl00b.anm", 343))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 34, "data/slpl01a.anm", 344))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 35, "data/slpl01b.anm", 345))
        return -1;
    v5 = a1 + 21760;
    for(j = 336; j <= 351; ++j) {
        sub_4051B0((int*) dword_6D4588, v5, j);
        v2 = *(_DWORD*) (v5 + 128);
        LOBYTE(v2) = v2 & 0xFE;
        *(_DWORD*) (v5 + 128) = v2;
        v3 = *(_DWORD*) (v5 + 128);
        LOBYTE(v3) = v3 | 8;
        *(_DWORD*) (v5 + 128) = v3;
        if((dword_6C6E60 & 1) != 0)
            *(_DWORD*) (v5 + 124) = -1;
        else
            *(_DWORD*) (v5 + 124) = -16777216;
        *(float*) (v5 + 228) = 0.0;
        *(float*) (v5 + 232) = 0.0;
        *(float*) (v5 + 236) = 0.0;
        *(_WORD*) (v5 + 178) = *(_WORD*) (v5 + 176);
        v4 = *(_DWORD*) (v5 + 128);
        BYTE1(v4) |= 0x10u;
        *(_DWORD*) (v5 + 128) = v4;
        v5 += 272;
    }
    return 0;
}
// 6C6E60: using guessed type int dword_6C6E60;

//----- (0043A1EC) --------------------------------------------------------
int __cdecl sub_43A1EC(int a1) {
    int v2; // eax
    int v3; // eax
    int v4; // eax
    int v5; // [esp+2Ch] [ebp-8h]
    int i; // [esp+30h] [ebp-4h]
    int j; // [esp+30h] [ebp-4h]

    for(i = 21; i <= 26; ++i)
        sub_432030(dword_6D4588, i);
    if(sub_435010((_DWORD**) dword_6D4588, 0, "data/title/select00.jpg"))
        return -1;
    if(sub_431DC0((_DWORD*) dword_6D4588, 36, "data/replay00.anm", 352))
        return -1;
    v5 = a1 + 26112;
    for(j = 352; j <= 377; ++j) {
        sub_4051B0((int*) dword_6D4588, v5, j);
        v2 = *(_DWORD*) (v5 + 128);
        LOBYTE(v2) = v2 & 0xFE;
        *(_DWORD*) (v5 + 128) = v2;
        v3 = *(_DWORD*) (v5 + 128);
        LOBYTE(v3) = v3 | 8;
        *(_DWORD*) (v5 + 128) = v3;
        if((dword_6C6E60 & 1) != 0)
            *(_DWORD*) (v5 + 124) = -1;
        else
            *(_DWORD*) (v5 + 124) = -16777216;
        *(float*) (v5 + 228) = 0.0;
        *(float*) (v5 + 232) = 0.0;
        *(float*) (v5 + 236) = 0.0;
        *(_WORD*) (v5 + 178) = *(_WORD*) (v5 + 176);
        v4 = *(_DWORD*) (v5 + 128);
        BYTE1(v4) |= 0x10u;
        *(_DWORD*) (v5 + 128) = v4;
        v5 += 272;
    }
    return 0;
}
// 6C6E60: using guessed type int dword_6C6E60;

//----- (0043A338) --------------------------------------------------------
int __cdecl sub_43A338(int a1) {
    memset(&unk_6D46C0, 0, 0x10F34u);
    byte_69D4BF = 0;
    (*(void(__stdcall**)(int))(*(_DWORD*) dword_6C6D20 + 16))(dword_6C6D20);
    sub_42F6C4();
    *((_DWORD*) &unk_6D46C0 + 8316) = a1 != 0 ? 0xC : 0;
    *(float*) &dword_6C6EC4 = 0.0;
    *((_DWORD*) &unk_6D46C0 + 8333) = sub_41CD40((int) sub_43579F);
    *(_DWORD*) (*((_DWORD*) &unk_6D46C0 + 8333) + 28) = &unk_6D46C0;
    *(_DWORD*) (*((_DWORD*) &unk_6D46C0 + 8333) + 8) = sub_43A464;
    *(_DWORD*) (*((_DWORD*) &unk_6D46C0 + 8333) + 12) = sub_43A659;
    *((_DWORD*) &unk_6D46C0 + 8317) = 0;
    if(sub_41C860(byte_69D918, *((_DWORD*) &unk_6D46C0 + 8333), 2))
        return -1;
    *((_DWORD*) &unk_6D46C0 + 8334) = sub_41CD40((int) sub_439AD6);
    *(_DWORD*) (*((_DWORD*) &unk_6D46C0 + 8334) + 28) = &unk_6D46C0;
    sub_41C940((__int16*) byte_69D918, *((_DWORD*) &unk_6D46C0 + 8334), 0);
    *((_DWORD*) &unk_6D46C0 + 17356) = 0;
    *((_DWORD*) &unk_6D46C0 + 8317) = 60;
    *((_DWORD*) &unk_6D46C0 + 17355) = 0;
    return 0;
}
// 69D4BF: using guessed type char byte_69D4BF;
// 6C6D20: using guessed type int dword_6C6D20;
// 6C6EC4: using guessed type int dword_6C6EC4;

//----- (0043A464) --------------------------------------------------------
int __usercall sub_43A464(int a1, _DWORD* a2) {
    int v3; // [esp+4h] [ebp-Ch]
    int i; // [esp+8h] [ebp-8h]
    _DWORD* v5; // [esp+Ch] [ebp-4h]

    if(!byte_69D4C4)
        sub_424B2F((int) "bgm/th06_01.mid");
    v3 = dword_6D4588;
    for(i = 0; i < 122; ++i)
        *(_DWORD*) (v3 + 4 * i + 118068) = 0;
    a2 [8313] = 0;
    if(dword_6C6EA8 < 2)
        goto LABEL_15;
    if(dword_6C6EA8 <= 3)
        goto LABEL_12;
    switch(dword_6C6EA8) {
        case 6:
            a2 [8296] = 4;
            break;
        case 7:
            LABEL_12:
            a2 [8296] = dword_69BCB0 == 4;
            break;
        case 9:
            a2 [8296] = 5;
            break;
        default:
            LABEL_15:
            a2 [8296] = 0;
            break;
    }
    if(byte_69D4C3)
        a2 [8296] = 2;
    byte_69D4C3 = 0;
    if((dword_6C6E60 & 1) != 0) {
        a2 [8322] = -2130706433;
        a2 [8321] = -1;
    }
    else {
        a2 [8322] = -2147467264;
        a2 [8321] = -16744448;
    }
    a2 [8319] = 0;
    a2 [8320] = 0x40000000;
    a2 [8323] = 0;
    a2 [8324] = 0;
    a2 [17354] = 16;
    a2 [17335] = 0;
    v5 = sub_42B0D9("score.dat");
    sub_42B502((int) v5, (int) &unk_69CCD0);
    sub_42B65E((int) v5, dword_69CD30);
    sub_42B7DC(v5);
    if(!byte_69D4C4) {
        if(dword_6C7118) {
            sub_42FD30(0, 200, 0xFFFFFF, 0, 0);
        }
        else {
            sub_424B5D(a1, "bgm/th06_01.mid");
            sub_42FD30(0, 120, 0xFFFFFF, 0, 0);
        }
    }
    byte_69D4C4 = 0;
    dword_69D4C8 = 0;
    return 0;
}
// 69BCB0: using guessed type int dword_69BCB0;
// 69CD30: using guessed type _DWORD dword_69CD30[480];
// 69D4C3: using guessed type char byte_69D4C3;
// 69D4C4: using guessed type char byte_69D4C4;
// 69D4C8: using guessed type int dword_69D4C8;
// 6C6E60: using guessed type int dword_6C6E60;
// 6C6EA8: using guessed type int dword_6C6EA8;
// 6C7118: using guessed type int dword_6C7118;

//----- (0043A659) --------------------------------------------------------
int __cdecl sub_43A659(int a1) {
    int v2; // [esp+4h] [ebp-Ch]
    int j; // [esp+8h] [ebp-8h]
    int i; // [esp+Ch] [ebp-4h]

    (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) dword_6C6D20 + 20))(dword_6C6D20, 0);
    sub_43A70A();
    for(i = 27; i <= 36; ++i)
        sub_432030(dword_6D4588, i);
    sub_435270((_DWORD**) dword_6D4588, 0);
    v2 = dword_6D4588;
    for(j = 0; j < 122; ++j)
        *(_DWORD*) (v2 + 4 * j + 118068) = 0;
    sub_41CDE0(byte_69D918, *(_DWORD*) (a1 + 33336));
    *(_DWORD*) (a1 + 33336) = 0;
    free(*(void**) (a1 + 69340));
    return 0;
}
// 6C6D20: using guessed type int dword_6C6D20;

//----- (0043A70A) --------------------------------------------------------
int sub_43A70A() {
    int result; // eax
    int i; // [esp+0h] [ebp-4h]

    for(i = 21; i <= 27; ++i) {
        sub_432030(dword_6D4588, i);
        result = i + 1;
    }
    return result;
}

//----- (0043A736) --------------------------------------------------------
BOOL __thiscall sub_43A736(_BYTE* this, int a2, int a3) {
    return this [48 * a2 + 4157 + 24 * a3] == 99
        || this [48 * a2 + 4158 + 24 * a3] == 99
        || this [48 * a2 + 4159 + 24 * a3] == 99;
}

//----- (0043A7D0) --------------------------------------------------------
_DWORD* __thiscall sub_43A7D0(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    if(*this) {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) *this + 8))(*this);
        result = this;
        *this = 0;
    }
    return result;
}

//----- (0043A800) --------------------------------------------------------
int __thiscall sub_43A800(LPDIRECTSOUND8* this, HWND a2, DWORD a3, __int16 a4, int a5, unsigned __int16 a6) {
    HRESULT v8; // [esp+4h] [ebp-8h]
    int v9; // [esp+4h] [ebp-8h]

    if(*this) {
        (*this)->lpVtbl->Release(*this);
        *this = 0;
    }
    v8 = DirectSoundCreate8(0, this, 0);
    if(v8 < 0)
        return v8;
    v9 = (*this)->lpVtbl->SetCooperativeLevel(*this, a2, a3);
    if(v9 < 0)
        return v9;
    sub_43A890(this, a4, a5, a6);
    return 0;
}

//----- (0043A890) --------------------------------------------------------
int __thiscall sub_43A890(_DWORD* this, __int16 a2, int a3, unsigned __int16 a4) {
    int v5; // [esp+8h] [ebp-44h]
    int v6; // [esp+8h] [ebp-44h]
    int v7 [10]; // [esp+Ch] [ebp-40h] BYREF
    _WORD v8 [2]; // [esp+34h] [ebp-18h] BYREF
    int v9; // [esp+38h] [ebp-14h]
    int v10; // [esp+3Ch] [ebp-10h]
    unsigned __int16 v11; // [esp+40h] [ebp-Ch]
    unsigned __int16 v12; // [esp+42h] [ebp-Ah]
    __int16 v13; // [esp+44h] [ebp-8h]
    int v14; // [esp+48h] [ebp-4h] BYREF
    unsigned int retaddr; // [esp+50h] [ebp+4h]

    v7 [9] = retaddr ^ dword_47A630;
    v14 = 0;
    if(!*this)
        return -2147221008;
    memset(v7, 0, 0x24u);
    v7 [0] = 36;
    v7 [1] = 1;
    v7 [2] = 0;
    v7 [4] = 0;
    v5 = (*(int(__stdcall**)(_DWORD, int*, int*, _DWORD))(*(_DWORD*) *this + 12))(*this, v7, &v14, 0);
    if(v5 < 0)
        return v5;
    v13 = 0;
    v8 [0] = 1;
    v8 [1] = a2;
    v9 = a3;
    v12 = a4;
    v11 = a2 * (a4 / 8);
    v10 = v11 * a3;
    v6 = (*(int(__stdcall**)(int, _WORD*))(*(_DWORD*) v14 + 56))(v14, v8);
    if(v6 < 0)
        return v6;
    if(v14) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v14 + 8))(v14);
        v14 = 0;
    }
    return 0;
}
// 47A630: using guessed type int dword_47A630;

//----- (0043A9C0) --------------------------------------------------------
int __userpurge sub_43A9C0(
    _DWORD* a1,
    int a2,
    _DWORD* a3,
    LPSTR pszFileName,
    int a5,
    int a6,
    int a7,
    int a8,
    int a9,
    unsigned int a10,
    int a11,
    int a12) {
    int v13; // edx
    _DWORD* v14; // [esp+4h] [ebp-78h]
    int* v15; // [esp+8h] [ebp-74h]
    _DWORD* v17; // [esp+10h] [ebp-6Ch]
    _DWORD* v18; // [esp+24h] [ebp-58h]
    unsigned int i; // [esp+2Ch] [ebp-50h]
    int v20; // [esp+30h] [ebp-4Ch] BYREF
    int v21; // [esp+34h] [ebp-48h]
    int v22 [10]; // [esp+38h] [ebp-44h] BYREF
    int(__stdcall * **v23)(_DWORD, void*, int*); // [esp+60h] [ebp-1Ch] BYREF
    int* v24; // [esp+64h] [ebp-18h]
    _DWORD* v25; // [esp+68h] [ebp-14h]
    int v26; // [esp+6Ch] [ebp-10h]
    int v27; // [esp+78h] [ebp-4h]
    unsigned int retaddr; // [esp+80h] [ebp+4h]

    v22 [9] = retaddr ^ dword_47A630;
    if(!*a1)
        return -2147221008;
    v23 = 0;
    v24 = 0;
    v25 = 0;
    v20 = 0;
    v18 = operator new(0x98u);
    v27 = 0;
    if(v18)
        v15 = sub_43B9B0(v18);
    else
        v15 = 0;
    v27 = -1;
    v24 = v15;
    sub_43BA60((int) v15, pszFileName, 0, 1);
    v26 = a10 * a11;
    memset(v22, 0, 0x24u);
    v22 [0] = 36;
    v13 = a5;
    BYTE1(v13) = BYTE1(a5) | 0x81;
    v13 |= 0x10000u;
    LOBYTE(v13) = v13 | 0x80;
    v22 [1] = v13 | 8;
    v22 [2] = a10 * a11;
    v22 [5] = a6;
    v22 [6] = a7;
    v22 [7] = a8;
    v22 [8] = a9;
    v22 [4] = *v15;
    v21 = (*(int(__stdcall**)(_DWORD, int*, int(__stdcall****)(_DWORD, void*, int*), _DWORD))(*(_DWORD*) *a1 + 12))(
        *a1,
        v22,
        &v23,
        0);
    if(v21 < 0)
        return -2147467259;
    v21 = (**v23)(v23, &unk_46FE10, &v20);
    if(v21 < 0)
        return -2147467259;
    v25 = operator new(8 * a10);
    if(!v25)
        return -2147024882;
    for(i = 0; i < a10; ++i) {
        v25 [2 * i] = i * a11 + a11 - 1;
        v25 [2 * i + 1] = a12;
    }
    v21 = (*(int(__stdcall**)(int, unsigned int, _DWORD*))(*(_DWORD*) v20 + 12))(v20, a10, v25);
    if(v21 >= 0) {
        if(v20) {
            (*(void(__stdcall**)(int))(*(_DWORD*) v20 + 8))(v20);
            v20 = 0;
        }
        if(v25) {
            j__free(v25);
            v25 = 0;
        }
        v17 = operator new(0x34u);
        v27 = 1;
        if(v17)
            v14 = sub_43B420(v17, a2, (char) v23, v26, (int) v24, a11);
        else
            v14 = 0;
        *a3 = v14;
        return 0;
    }
    else {
        if(v20) {
            (*(void(__stdcall**)(int))(*(_DWORD*) v20 + 8))(v20);
            v20 = 0;
        }
        if(v25) {
            j__free(v25);
            v25 = 0;
        }
        return -2147467259;
    }
}
// 47A630: using guessed type int dword_47A630;

//----- (0043AC90) --------------------------------------------------------
int __userpurge sub_43AC90(int a1, int a2, int a3, int a4, unsigned int a5, int a6) {
    unsigned int i; // [esp+Ch] [ebp-4h]
    unsigned int j; // [esp+Ch] [ebp-4h]

    *(_DWORD*) a1 = &off_46C680;
    *(_DWORD*) (a1 + 4) = operator new(4 * a5);
    for(i = 0; i < a5; ++i)
        *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * i) = *(_DWORD*) (a3 + 4 * i);
    *(_DWORD*) (a1 + 8) = a4;
    *(_DWORD*) (a1 + 16) = a5;
    *(_DWORD*) (a1 + 12) = a6;
    sub_43AEA0(a1, a2, **(_DWORD**) (a1 + 4), 0);
    for(j = 0; j < a5; ++j)
        (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (*(_DWORD*) (a1 + 4) + 4 * j) + 52))(
            *(_DWORD*) (*(_DWORD*) (a1 + 4) + 4 * j),
            0);
    return a1;
}
// 46C680: using guessed type int (__stdcall *off_46C680)(int);

//----- (0043AD70) --------------------------------------------------------
void* __thiscall sub_43AD70(void* this, char a2) {
    sub_43ADA0(this);
    if((a2 & 1) != 0)
        j__free(this);
    return this;
}

//----- (0043ADA0) --------------------------------------------------------
void __thiscall sub_43ADA0(void* this) {
    void* v2; // [esp+Ch] [ebp-Ch]
    unsigned int i; // [esp+14h] [ebp-4h]

    *(_DWORD*) this = &off_46C680;
    for(i = 0; i < *((_DWORD*) this + 4); ++i) {
        if(*(_DWORD*) (*((_DWORD*) this + 1) + 4 * i)) {
            (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (*((_DWORD*) this + 1) + 4 * i) + 8))(*(_DWORD*) (*((_DWORD*) this + 1) + 4 * i));
            *(_DWORD*) (*((_DWORD*) this + 1) + 4 * i) = 0;
        }
    }
    if(*((_DWORD*) this + 1)) {
        j__free(*((void**) this + 1));
        *((_DWORD*) this + 1) = 0;
    }
    if(*((_DWORD*) this + 3)) {
        v2 = (void*) *((_DWORD*) this + 3);
        if(v2) {
            sub_43BA10((int) v2);
            j__free(v2);
        }
        *((_DWORD*) this + 3) = 0;
    }
}
// 46C680: using guessed type int (__stdcall *off_46C680)(int);

//----- (0043AEA0) --------------------------------------------------------
int __userpurge sub_43AEA0(int a1, int a2, int a3, int a4) {
    char* v5; // edi
    char v6; // dl
    int v7; // eax
    unsigned int v8; // ecx
    char* v9; // edi
    char v10; // dl
    int v11; // eax
    unsigned int v12; // ecx
    unsigned int i; // [esp+Ch] [ebp-14h]
    char* v15; // [esp+10h] [ebp-10h] BYREF
    int v16; // [esp+14h] [ebp-Ch]
    unsigned int v17; // [esp+18h] [ebp-8h] BYREF
    unsigned int v18; // [esp+1Ch] [ebp-4h] BYREF

    v15 = 0;
    v18 = 0;
    v17 = 0;
    if(!a3)
        return -2147221008;
    v16 = sub_43B090(a3, 0);
    if(v16 < 0)
        return v16;
    v16 = (*(int(__stdcall**)(int, _DWORD, _DWORD, char**, unsigned int*, _DWORD, _DWORD, _DWORD))(*(_DWORD*) a3 + 44))(
        a3,
        0,
        *(_DWORD*) (a1 + 8),
        &v15,
        &v18,
        0,
        0,
        0);
    if(v16 < 0)
        return v16;
    sub_43BE70(*(_DWORD*) (a1 + 12), 0);
    v16 = sub_43C080(*(_DWORD*) (a1 + 12), v15, v18, &v17);
    if(v16 < 0)
        return v16;
    if(v17) {
        if(v17 < v18) {
            if(a4) {
                for(i = v17; i < v18; i += v17) {
                    v16 = sub_43BE70(*(_DWORD*) (a1 + 12), 0);
                    if(v16 < 0)
                        return v16;
                    v16 = sub_43C080(*(_DWORD*) (a1 + 12), &v15 [i], v18 - i, &v17);
                    if(v16 < 0)
                        return v16;
                }
            }
            else {
                v9 = &v15 [v17];
                v10 = v18 - v17;
                LOBYTE(a2) = *(_WORD*) (**(_DWORD**) (a1 + 12) + 14) != 8 ? 0 : 0x80;
                BYTE1(a2) = a2;
                v11 = a2 << 16;
                LOWORD(v11) = a2;
                v12 = (v18 - v17) >> 2;
                memset32(&v15 [v17], v11, v12);
                memset(&v9 [4 * v12], a2, v10 & 3);
            }
        }
    }
    else {
        v5 = v15;
        v6 = v18;
        LOBYTE(a2) = *(_WORD*) (**(_DWORD**) (a1 + 12) + 14) != 8 ? 0 : 0x80;
        BYTE1(a2) = a2;
        v7 = a2 << 16;
        LOWORD(v7) = a2;
        v8 = v18 >> 2;
        memset32(v15, v7, v18 >> 2);
        memset(&v5 [4 * v8], a2, v6 & 3);
    }
    (*(void(__stdcall**)(int, char*, unsigned int, _DWORD, _DWORD))(*(_DWORD*) a3 + 76))(a3, v15, v18, 0, 0);
    return 0;
}

//----- (0043B090) --------------------------------------------------------
int __stdcall sub_43B090(int a1, _DWORD* a2) {
    int v3; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h] BYREF

    if(!a1)
        return -2147221008;
    if(a2)
        *a2 = 0;
    v3 = (*(int(__stdcall**)(int, int*))(*(_DWORD*) a1 + 36))(a1, &v4);
    if(v3 < 0)
        return v3;
    if((v4 & 2) == 0)
        return 1;
    do {
        if((*(int(__stdcall**)(int))(*(_DWORD*) a1 + 80))(a1) == -2005401450)
            Sleep(0xAu);
    }
    while((*(int(__stdcall**)(int))(*(_DWORD*) a1 + 80))(a1));
    if(a2)
        *a2 = 1;
    return 0;
}

//----- (0043B140) --------------------------------------------------------
int __thiscall sub_43B140(_DWORD* this) {
    int v3; // [esp+4h] [ebp-Ch] BYREF
    unsigned int i; // [esp+8h] [ebp-8h]
    int v5; // [esp+Ch] [ebp-4h]

    v5 = 0;
    if(!this [1])
        return 0;
    for(i = 0; i < this [4]; ++i) {
        if(*(_DWORD*) (this [1] + 4 * i)) {
            v3 = 0;
            (*(void(__stdcall**)(_DWORD, int*))(**(_DWORD**) (this [1] + 4 * i) + 36))(*(_DWORD*) (this [1] + 4 * i), &v3);
            if((v3 & 1) == 0)
                break;
        }
    }
    if(i == this [4])
        return *(_DWORD*) (this [1] + 4 * ((unsigned int) rand() % this [4]));
    else
        return *(_DWORD*) (this [1] + 4 * i);
}

//----- (0043B200) --------------------------------------------------------
int __thiscall sub_43B200(_DWORD* this, unsigned int a2) {
    if(!this [1])
        return 0;
    if(a2 < this [4])
        return *(_DWORD*) (this [1] + 4 * a2);
    return 0;
}

//----- (0043B240) --------------------------------------------------------
int __userpurge sub_43B240(_DWORD* a1, int a2, int a3, int a4) {
    int v6; // [esp+4h] [ebp-Ch]
    int v7; // [esp+4h] [ebp-Ch]
    int v8; // [esp+8h] [ebp-8h] BYREF
    int v9; // [esp+Ch] [ebp-4h]

    if(!a1 [1])
        return -2147221008;
    v9 = sub_43B140(a1);
    if(!v9)
        return -2147467259;
    v6 = sub_43B090(v9, &v8);
    if(v6 < 0)
        return v6;
    if(v8) {
        v7 = sub_43AEA0((int) a1, a2, v9, 0);
        if(v7 < 0)
            return v7;
        sub_43B3B0(a1);
    }
    a1 [7] = 0;
    a1 [5] = 0;
    a1 [6] = 0;
    return (*(int(__stdcall**)(int, _DWORD, int, int))(*(_DWORD*) v9 + 48))(v9, 0, a3, a4);
}

//----- (0043B300) --------------------------------------------------------
int __thiscall sub_43B300(_DWORD* this) {
    unsigned int i; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h]

    if(!this [1])
        return -2147221008;
    v4 = 0;
    sub_41E940();
    for(i = 0; i < this [4]; ++i) {
        sub_41E940();
        v4 |= (*(int(__stdcall**)(_DWORD))(**(_DWORD**) (this [1] + 4 * i) + 72))(*(_DWORD*) (this [1] + 4 * i));
    }
    sub_41E940();
    this [7] = 0;
    return v4;
}

//----- (0043B3B0) --------------------------------------------------------
int __thiscall sub_43B3B0(_DWORD* this) {
    unsigned int i; // [esp+4h] [ebp-8h]
    int v4; // [esp+8h] [ebp-4h]

    if(!this [1])
        return -2147221008;
    v4 = 0;
    for(i = 0; i < this [4]; ++i)
        v4 |= (*(int(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (this [1] + 4 * i) + 52))(*(_DWORD*) (this [1] + 4 * i), 0);
    return v4;
}

//----- (0043B420) --------------------------------------------------------
_DWORD* __userpurge sub_43B420(_DWORD* a1, int a2, char a3, int a4, int a5, int a6) {
    sub_43AC90((int) a1, a2, (int) &a3, a4, 1u, a5);
    *a1 = &off_46C69C;
    a1 [8] = 0;
    a1 [9] = 0;
    a1 [10] = a6;
    a1 [11] = 0;
    a1 [12] = 0;
    return a1;
}
// 46C69C: using guessed type int (__stdcall *off_46C69C)(int);

//----- (0043B480) --------------------------------------------------------
_DWORD* __thiscall sub_43B480(_DWORD* this, char a2) {
    sub_43B4B0(this);
    if((a2 & 1) != 0)
        j__free(this);
    return this;
}

//----- (0043B4B0) --------------------------------------------------------
void __thiscall sub_43B4B0(_DWORD* this) {
    *this = &off_46C69C;
    sub_43ADA0(this);
}
// 46C69C: using guessed type int (__stdcall *off_46C69C)(int);

//----- (0043B4D0) --------------------------------------------------------
int __thiscall sub_43B4D0(int this) {
    if(*(_DWORD*) (this + 28)) {
        if((int)-- * (_DWORD*) (this + 20) <= 0) {
            *(_DWORD*) (this + 28) = 0;
            (*(void(__stdcall**)(_DWORD))(***(_DWORD***) (this + 4) + 72))(**(_DWORD**) (this + 4));
            return 1;
        }
        (*(void(__stdcall**)(_DWORD, int))(***(_DWORD***) (this + 4) + 60))(
            **(_DWORD**) (this + 4),
            5000 * *(_DWORD*) (this + 20) / *(_DWORD*) (this + 24) - 5000);
    }
    return 0;
}

//----- (0043B560) --------------------------------------------------------
int __userpurge sub_43B560(int a1, int a2, int a3) {
    char* v4; // edi
    char v5; // dl
    int v6; // eax
    unsigned int v7; // ecx
    char* v8; // edi
    char v9; // dl
    int v10; // eax
    unsigned int v11; // ecx
    unsigned int i; // [esp+10h] [ebp-28h]
    unsigned int v14; // [esp+14h] [ebp-24h] BYREF
    unsigned int v15; // [esp+18h] [ebp-20h] BYREF
    int v16; // [esp+1Ch] [ebp-1Ch]
    unsigned int v17; // [esp+20h] [ebp-18h]
    int v18; // [esp+24h] [ebp-14h] BYREF
    int v19; // [esp+28h] [ebp-10h] BYREF
    unsigned int v20; // [esp+2Ch] [ebp-Ch] BYREF
    char* v21; // [esp+30h] [ebp-8h] BYREF
    char v22 [4]; // [esp+34h] [ebp-4h] BYREF

    if(!*(_DWORD*) (a1 + 4) || !*(_DWORD*) (a1 + 12))
        return -2147221008;
    v16 = sub_43B090(**(_DWORD**) (a1 + 4), &v18);
    if(v16 < 0)
        goto LABEL_5;
    if(!v18) {
        v21 = 0;
        v19 = 0;
        v16 = (*(int(__thiscall**)(_DWORD, _DWORD, _DWORD, _DWORD, char**, unsigned int*, int*, char*, _DWORD))(***(_DWORD***) (a1 + 4) + 44))(
            **(_DWORD**) (a1 + 4),
            **(_DWORD**) (a1 + 4),
            *(_DWORD*) (a1 + 44),
            *(_DWORD*) (a1 + 40),
            &v21,
            &v15,
            &v19,
            v22,
            0);
        if(v16 < 0) {
            LABEL_24:
            sub_41E940();
            return v16;
        }
        if(v19)
            return -2147418113;
        if(*(_DWORD*) (a1 + 48)) {
            v4 = v21;
            v5 = v15;
            LOBYTE(a2) = *(_WORD*) (**(_DWORD**) (a1 + 12) + 14) != 8 ? 0 : 0x80;
            BYTE1(a2) = a2;
            v6 = a2 << 16;
            LOWORD(v6) = a2;
            v7 = v15 >> 2;
            memset32(v21, v6, v15 >> 2);
            memset(&v4 [4 * v7], a2, v5 & 3);
            v20 = v15;
        }
        else {
            v16 = sub_43C080(*(_DWORD*) (a1 + 12), v21, v15, &v20);
            if(v16 < 0)
                goto LABEL_24;
        }
        if(v20 < v15) {
            if(a3) {
                for(i = v20; i < v15; i += v20) {
                    v16 = sub_43BE70(*(_DWORD*) (a1 + 12), 1);
                    if(v16 < 0)
                        goto LABEL_24;
                    v16 = sub_43C080(*(_DWORD*) (a1 + 12), &v21 [i], v15 - i, &v20);
                    if(v16 < 0)
                        goto LABEL_24;
                }
            }
            else {
                v8 = &v21 [v20];
                v9 = v15 - v20;
                LOBYTE(a2) = *(_WORD*) (**(_DWORD**) (a1 + 12) + 14) != 8 ? 0 : 0x80;
                BYTE1(a2) = a2;
                v10 = a2 << 16;
                LOWORD(v10) = a2;
                v11 = (v15 - v20) >> 2;
                memset32(&v21 [v20], v10, v11);
                memset(&v8 [4 * v11], a2, v9 & 3);
                *(_DWORD*) (a1 + 48) = 1;
            }
        }
        (*(void(__thiscall**)(_DWORD, _DWORD, char*, unsigned int, _DWORD, _DWORD))(***(_DWORD***) (a1 + 4) + 76))(
            **(_DWORD**) (a1 + 4),
            **(_DWORD**) (a1 + 4),
            v21,
            v15,
            0,
            0);
        v16 = (*(int(__thiscall**)(_DWORD, _DWORD, unsigned int*, _DWORD))(***(_DWORD***) (a1 + 4) + 16))(
            **(_DWORD**) (a1 + 4),
            **(_DWORD**) (a1 + 4),
            &v14,
            0);
        if(v16 >= 0) {
            if(v14 >= *(_DWORD*) (a1 + 32))
                v17 = v14 - *(_DWORD*) (a1 + 32);
            else
                v17 = v14 + *(_DWORD*) (a1 + 8) - *(_DWORD*) (a1 + 32);
            *(_DWORD*) (a1 + 36) += v17;
            *(_DWORD*) (a1 + 32) = v14;
            if(*(_DWORD*) (a1 + 48)) {
                if(*(_DWORD*) (a1 + 36) >= (unsigned int) unknown_libname_5(*(_DWORD*) (a1 + 12)))
                    (*(void(__thiscall**)(_DWORD, _DWORD))(***(_DWORD***) (a1 + 4) + 72))(
                        **(_DWORD**) (a1 + 4),
                        **(_DWORD**) (a1 + 4));
            }
            *(_DWORD*) (a1 + 44) += v15;
            *(_DWORD*) (a1 + 44) %= *(_DWORD*) (a1 + 8);
            return 0;
        }
        else {
            sub_41E940();
            return v16;
        }
    }
    v16 = sub_43AEA0(a1, a2, **(_DWORD**) (a1 + 4), 0);
    if(v16 < 0) {
        LABEL_5:
        sub_41E940();
        return v16;
    }
    return 0;
}
// 43BE50: using guessed type int __thiscall unknown_libname_5(_DWORD);
// 43B560: using guessed type char var_4[4];

//----- (0043B8E0) --------------------------------------------------------
int __usercall sub_43B8E0(int a1, int a2) {
    int v4; // [esp+4h] [ebp-8h]
    int v5; // [esp+4h] [ebp-8h]
    int v6; // [esp+8h] [ebp-4h] BYREF

    if(!**(_DWORD**) (a1 + 4) || !*(_DWORD*) (a1 + 12))
        return -2147221008;
    *(_DWORD*) (a1 + 32) = 0;
    *(_DWORD*) (a1 + 36) = 0;
    *(_DWORD*) (a1 + 44) = 0;
    *(_DWORD*) (a1 + 48) = 0;
    v4 = sub_43B090(**(_DWORD**) (a1 + 4), &v6);
    if(v4 < 0)
        return v4;
    if(v6) {
        v5 = sub_43AEA0(a1, a2, **(_DWORD**) (a1 + 4), 0);
        if(v5 < 0)
            return v5;
    }
    sub_43BE70(*(_DWORD*) (a1 + 12), 0);
    return (*(int(__stdcall**)(_DWORD, _DWORD))(***(_DWORD***) (a1 + 4) + 52))(**(_DWORD**) (a1 + 4), 0);
}

//----- (0043B9B0) --------------------------------------------------------
_DWORD* __thiscall sub_43B9B0(_DWORD* this) {
    *this = 0;
    this [1] = 0;
    this [12] = 0;
    this [32] = 0;
    this [37] = 0;
    this [36] = 0;
    return this;
}

//----- (0043BA10) --------------------------------------------------------
void __thiscall sub_43BA10(int this) {
    sub_43C2C0(this);
    if(!*(_DWORD*) (this + 128)) {
        if(*(_DWORD*) this) {
            j__free(*(void**) this);
            *(_DWORD*) this = 0;
        }
    }
}

//----- (0043BA60) --------------------------------------------------------
int __thiscall sub_43BA60(int this, LPSTR pszFileName, int a3, int a4) {
    struct _MMIOINFO pmmioinfo; // [esp+10h] [ebp-50h] BYREF
    int v7; // [esp+5Ch] [ebp-4h]

    *(_DWORD*) (this + 124) = a4;
    *(_DWORD*) (this + 128) = 0;
    if(*(_DWORD*) (this + 124) == 1) {
        if(!pszFileName)
            return -2147024809;
        if(*(_DWORD*) this) {
            j__free(*(void**) this);
            *(_DWORD*) this = 0;
        }
        memset(&pmmioinfo, 0, sizeof(pmmioinfo));
        *(_DWORD*) (this + 4) = mmioOpenA(pszFileName, &pmmioinfo, 0x10000u);
        if(!*(_DWORD*) (this + 4)) {
            switch(pmmioinfo.wErrorRet) {
                case 0x10Bu:
                case 0x10Cu:
                case 0x10Du:
                case 0x10Fu:
                case 0x110u:
                    sub_41E940();
                    break;
                default:
                    break;
            }
            LABEL_12:
            sub_41E940();
            return -2147467259;
        }
        v7 = sub_43BC00(this);
        if(v7 < 0) {
            mmioClose(*(HMMIO*) (this + 4), 0);
            sub_41E940();
            return -2147467259;
        }
        v7 = sub_43BE70(this, 0);
        if(v7 < 0)
            goto LABEL_12;
        *(_DWORD*) (this + 48) = *(_DWORD*) (this + 12);
    }
    return v7;
}

//----- (0043BC00) --------------------------------------------------------
int __thiscall sub_43BC00(int this) {
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    LONG v4; // eax
    char v6 [4]; // [esp+14h] [ebp-28h] BYREF
    struct _MMCKINFO pmmcki; // [esp+18h] [ebp-24h] BYREF
    char pch [4]; // [esp+2Ch] [ebp-10h] BYREF
    int v9; // [esp+30h] [ebp-Ch]
    int v10; // [esp+34h] [ebp-8h]
    int v11; // [esp+38h] [ebp-4h]

    *(_DWORD*) this = 0;
    if(mmioDescend(*(HMMIO*) (this + 4), (LPMMCKINFO) (this + 28), 0, 0))
        return -2147467259;
    if(*(_DWORD*) (this + 28) != 1179011410 || *(_DWORD*) (this + 36) != 1163280727)
        return -2147467259;
    pmmcki.ckid = 544501094;
    if(mmioDescend(*(HMMIO*) (this + 4), &pmmcki, (const MMCKINFO*) (this + 28), 0x10u))
        return -2147467259;
    if(pmmcki.cksize < 0x10)
        return -2147467259;
    if(mmioRead(*(HMMIO*) (this + 4), pch, 16) != 16)
        return -2147467259;
    if(*(unsigned __int16*) pch == 1) {
        *(_DWORD*) this = operator new(0x12u);
        if(!*(_DWORD*) this)
            return -2147467259;
        v2 = *(_DWORD**) this;
        *v2 = *(_DWORD*) pch;
        v2 [1] = v9;
        v2 [2] = v10;
        v2 [3] = v11;
        *(_WORD*) (*(_DWORD*) this + 16) = 0;
        LABEL_24:
        if(!mmioAscend(*(HMMIO*) (this + 4), &pmmcki, 0))
            return 0;
        if(*(_DWORD*) this) {
            j__free(*(void**) this);
            *(_DWORD*) this = 0;
        }
        return -2147467259;
    }
    *(_WORD*) v6 = 0;
    if(mmioRead(*(HMMIO*) (this + 4), v6, 2) != 2)
        return -2147467259;
    *(_DWORD*) this = operator new(*(unsigned __int16*) v6 + 18);
    if(!*(_DWORD*) this)
        return -2147467259;
    v3 = *(_DWORD**) this;
    *v3 = *(_DWORD*) pch;
    v3 [1] = v9;
    v3 [2] = v10;
    v3 [3] = v11;
    *(_WORD*) (*(_DWORD*) this + 16) = *(_WORD*) v6;
    v4 = mmioRead(*(HMMIO*) (this + 4), (HPSTR) (*(_DWORD*) this + 18), *(unsigned __int16*) v6);
    if(v4 == *(unsigned __int16*) v6)
        goto LABEL_24;
    if(*(_DWORD*) this) {
        j__free(*(void**) this);
        *(_DWORD*) this = 0;
    }
    return -2147467259;
}

//----- (0043BE70) --------------------------------------------------------
int __thiscall sub_43BE70(int this, char a2) {
    int i; // [esp+4h] [ebp-54h]
    struct _MMIOINFO pmmioinfo; // [esp+8h] [ebp-50h] BYREF
    MMRESULT v6; // [esp+54h] [ebp-4h]

    if(*(_DWORD*) (this + 128)) {
        *(_DWORD*) (this + 136) = *(_DWORD*) (this + 132);
    }
    else {
        if(!*(_DWORD*) (this + 4)) {
            sub_41E940();
            return -2147221008;
        }
        if(*(_DWORD*) (this + 124) == 1) {
            if(mmioSeek(*(HMMIO*) (this + 4), *(_DWORD*) (this + 40) + 4, 0) == -1
               || (*(_DWORD*) (this + 8) = 1635017060,
               (v6 = mmioDescend(*(HMMIO*) (this + 4), (LPMMCKINFO) (this + 8), (const MMCKINFO*) (this + 28), 0x10u)) != 0)) {
                sub_41E940();
                return -2147467259;
            }
            if(*(int*) (this + 148) > 0)
                *(_DWORD*) (this + 12) = *(_DWORD*) (this + 148);
            if(a2 && *(int*) (this + 144) > 0) {
                if(mmioGetInfo(*(HMMIO*) (this + 4), &pmmioinfo, 0))
                    goto LABEL_22;
                for(i = 0; i < *(_DWORD*) (this + 144); ++i) {
                    if(pmmioinfo.pchNext == pmmioinfo.pchEndRead
                       && (mmioAdvance(*(HMMIO*) (this + 4), &pmmioinfo, 0) || pmmioinfo.pchNext == pmmioinfo.pchEndRead)) {
                        goto LABEL_22;
                    }
                    ++pmmioinfo.pchNext;
                }
                *(_DWORD*) (this + 12) -= *(_DWORD*) (this + 144);
                if(mmioSetInfo(*(HMMIO*) (this + 4), &pmmioinfo, 0)) {
                    LABEL_22:
                    sub_41E940();
                    return -2147467259;
                }
            }
        }
    }
    return 0;
}

//----- (0043C080) --------------------------------------------------------
int __thiscall sub_43C080(int this, void* a2, unsigned int a3, unsigned int* a4) {
    unsigned int i; // [esp+Ch] [ebp-54h]
    struct _MMIOINFO pmmioinfo; // [esp+10h] [ebp-50h] BYREF
    unsigned int v8; // [esp+5Ch] [ebp-4h]

    if(*(_DWORD*) (this + 128)) {
        if(*(_DWORD*) (this + 136)) {
            if(a4)
                *a4 = 0;
            if(a3 + *(_DWORD*) (this + 136) > *(_DWORD*) (this + 140) + *(_DWORD*) (this + 132))
                a3 = *(_DWORD*) (this + 140) - (*(_DWORD*) (this + 136) - *(_DWORD*) (this + 132));
            qmemcpy(a2, *(const void**) (this + 136), a3);
            if(a4)
                *a4 = a3;
            return 0;
        }
        else {
            return -2147221008;
        }
    }
    else if(*(_DWORD*) (this + 4)) {
        if(a2 && a4) {
            *a4 = 0;
            if(mmioGetInfo(*(HMMIO*) (this + 4), &pmmioinfo, 0))
                goto LABEL_27;
            v8 = a3;
            if(a3 > *(_DWORD*) (this + 12))
                v8 = *(_DWORD*) (this + 12);
            *(_DWORD*) (this + 12) -= v8;
            for(i = 0; i < v8; ++i) {
                if(pmmioinfo.pchNext == pmmioinfo.pchEndRead
                   && (mmioAdvance(*(HMMIO*) (this + 4), &pmmioinfo, 0) || pmmioinfo.pchNext == pmmioinfo.pchEndRead)) {
                    goto LABEL_27;
                }
                *((_BYTE*) a2 + i) = *pmmioinfo.pchNext++;
            }
            if(mmioSetInfo(*(HMMIO*) (this + 4), &pmmioinfo, 0)) {
                LABEL_27:
                sub_41E940();
                return -2147467259;
            }
            else {
                *a4 = v8;
                return 0;
            }
        }
        else {
            return -2147024809;
        }
    }
    else {
        return -2147221008;
    }
}
// 43C2A5: conditional instruction was optimized away because %arg_8.4!=0

//----- (0043C2C0) --------------------------------------------------------
int __thiscall sub_43C2C0(int this) {
    if(*(_DWORD*) (this + 124) == 1) {
        mmioClose(*(HMMIO*) (this + 4), 0);
        *(_DWORD*) (this + 4) = 0;
    }
    return 0;
}

//----- (0043C2F0) --------------------------------------------------------
int __thiscall sub_43C2F0(int this) {
    int result; // eax

    result = 0;
    *(_BYTE*) (this + 16) = 0x80;
    *(_DWORD*) (this + 4) = 0;
    *(_DWORD*) (this + 8) = 0;
    *(_DWORD*) (this + 12) = 0;
    *(_DWORD*) (this + 20) = 0;
    return result;
}

//----- (0043C310) --------------------------------------------------------
int __thiscall sub_43C310(int(__thiscall*** this)(_DWORD)) {
    int v2; // ebx
    int v3; // edi
    unsigned int v4; // edi

    v2 = 0;
    v3 = 0;
    if((**this)(this))
        v3 = 2;
    if((**this)(this))
        v3 |= 1u;
    switch(v3) {
        case 0:
            v4 = 128;
            goto LABEL_10;
        case 1:
            v4 = 0x8000;
            goto LABEL_10;
        case 2:
            v4 = 0x800000;
            goto LABEL_10;
        case 3:
            v4 = 0x80000000;
            do {
                LABEL_10:
                if((**this)(this))
                    v2 |= v4;
                v4 >>= 1;
            }
            while(v4);
            break;
        default:
            return v2;
    }
    return v2;
}

//----- (0043C380) --------------------------------------------------------
int __thiscall sub_43C380(void* this) {
    int v2; // ebx
    int v3; // edi
    int v4; // ebx

    v2 = (*(int(__thiscall**)(void*, int))(*(_DWORD*) this + 4))(this, 8);
    v3 = v2 + ((*(int(__thiscall**)(void*, int))(*(_DWORD*) this + 4))(this, 8) << 8);
    v4 = v3 + ((*(int(__thiscall**)(void*, int))(*(_DWORD*) this + 4))(this, 8) << 16);
    return v4 + ((*(int(__thiscall**)(void*, int))(*(_DWORD*) this + 4))(this, 8) << 24);
}

//----- (0043C3C0) --------------------------------------------------------
int __thiscall sub_43C3C0(void* this, int a2, unsigned int a3) {
    int v5; // edi
    char v6; // al

    if(!a2)
        return 0;
    v5 = 0;
    if(!a3)
        return 0;
    while(1) {
        v6 = (*(int(__thiscall**)(void*, int))(*(_DWORD*) this + 4))(this, 8);
        *(_BYTE*) (v5 + a2) = v6;
        if(!v6)
            break;
        if(++v5 >= a3)
            return 0;
    }
    return 1;
}

//----- (0043C440) --------------------------------------------------------
_DWORD* __thiscall sub_43C440(_DWORD* this) {
    *this = off_46CB7C;
    sub_43C2F0((int) this);
    sub_43CE40(this + 6);
    this [6] = &off_46CBBC;
    *this = &off_46CB9C;
    return this;
}
// 46CB7C: using guessed type void (__noreturn *off_46CB7C[7])();
// 46CB9C: using guessed type int (*off_46CB9C)();
// 46CBBC: using guessed type int (__stdcall *off_46CBBC)(LPCSTR lpFileName, int);

//----- (0043C4A0) --------------------------------------------------------
int __thiscall sub_43C4A0(int this, LPCSTR lpFileName) {
    _DWORD* v3; // edi
    int result; // eax

    v3 = (_DWORD*) (this + 24);
    (*(void(__thiscall**)(int))(*(_DWORD*) (this + 24) + 4))(this + 24);
    sub_43C2F0(this);
    result = sub_43CE60(v3, lpFileName, byte_46CBE4);
    if(result) {
        *(_DWORD*) (this + 8) = GetFileSize(*(HANDLE*) (this + 28), 0);
        return 1;
    }
    return result;
}
// 46CBE4: using guessed type _BYTE byte_46CBE4[4];

//----- (0043C4F0) --------------------------------------------------------
int __thiscall sub_43C4F0(void* this) {
    sub_43CF20((int) this);
    return sub_43C2F0((int) this - 24);
}

//----- (0043C510) --------------------------------------------------------
BOOL __thiscall sub_43C510(int this) {
    int v2; // eax
    int v4; // ecx
    int v5; // eax
    char v6; // cl

    if(!*(_DWORD*) (this + 28))
        return 0;
    if(*(_BYTE*) (this + 16) == 0x80) {
        v2 = sub_43CFB0((void*) (this + 24));
        *(_DWORD*) (this + 12) = v2;
        if(v2 == -1)
            return 0;
        v4 = *(_DWORD*) (this + 20);
        ++* (_DWORD*) (this + 4);
        *(_DWORD*) (this + 20) = v2 + v4;
    }
    v5 = *(unsigned __int8*) (this + 16) & *(_DWORD*) (this + 12);
    v6 = *(_BYTE*) (this + 16) >> 1;
    *(_BYTE*) (this + 16) = v6;
    if(!v6)
        *(_BYTE*) (this + 16) = 0x80;
    return v5 != 0;
}

//----- (0043C570) --------------------------------------------------------
int __thiscall sub_43C570(int this, char a2) {
    unsigned int v3; // edi
    int v4; // ebp
    int v6; // eax
    int v7; // ecx
    unsigned __int8 v8; // al
    char v9; // al

    v3 = 1 << (a2 - 1);
    v4 = 0;
    if(!*(_DWORD*) (this + 28))
        return 0;
    if(!v3)
        return v4;
    while(*(_BYTE*) (this + 16) != 0x80) {
        LABEL_7:
        v8 = *(_BYTE*) (this + 16);
        if((*(_BYTE*) (this + 12) & v8) != 0)
            v4 |= v3;
        v3 >>= 1;
        v9 = v8 >> 1;
        *(_BYTE*) (this + 16) = v9;
        if(!v9)
            *(_BYTE*) (this + 16) = 0x80;
        if(!v3)
            return v4;
    }
    v6 = sub_43CFB0((void*) (this + 24));
    *(_DWORD*) (this + 12) = v6;
    if(v6 != -1) {
        v7 = *(_DWORD*) (this + 20);
        ++* (_DWORD*) (this + 4);
        *(_DWORD*) (this + 20) = v6 + v7;
        goto LABEL_7;
    }
    return 0;
}

//----- (0043C5F0) --------------------------------------------------------
int __thiscall sub_43C5F0(_DWORD* this) {
    unsigned int v1; // eax

    v1 = this [1];
    if(v1 < this [2])
        this [1] = v1 + 1;
    return sub_43CFB0(this + 6);
}

//----- (0043C610) --------------------------------------------------------
int __thiscall sub_43C610(_DWORD* this, unsigned int lDistanceToMove) {
    if(lDistanceToMove >= this [2]
       || !(*(int(__thiscall**)(_DWORD*))(*this + 16))(this)
       || !sub_43D030(this + 6, lDistanceToMove, 0)) {
        return 0;
    }
    this [1] = lDistanceToMove;
    this [5] = 0;
    return 1;
}

//----- (0043C650) --------------------------------------------------------
int __thiscall sub_43C650(_DWORD* this) {
    if(!this [7])
        return 0;
    while(*((_BYTE*) this + 16) != 0x80)
        (*(void(__thiscall**)(_DWORD*)) * this)(this);
    return 1;
}

//----- (0043C680) --------------------------------------------------------
BOOL __thiscall sub_43C680(void* this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead) {
    DWORD NumberOfBytesRead; // [esp+4h] [ebp-4h] BYREF

    (*(void(__thiscall**)(void*))(*(_DWORD*) this + 16))(this);
    return sub_43CF50((int) this + 24, lpBuffer, nNumberOfBytesToRead, &NumberOfBytesRead);
}

//----- (0043C6B0) --------------------------------------------------------
BOOL __thiscall sub_43C6B0(_DWORD* this, LPFILETIME lpLastWriteTime) {
    void* v2; // eax

    v2 = (void*) this [7];
    return v2 != (void*) -1 && GetFileTime(v2, 0, 0, lpLastWriteTime);
}

//----- (0043C6D0) --------------------------------------------------------
int __thiscall sub_43C6D0(_DWORD* this) {
    return sub_43C5F0(this - 6);
}

//----- (0043C6E0) --------------------------------------------------------
void* __thiscall sub_43C6E0(_DWORD* this) {
    _DWORD* v2; // esi
    void* result; // eax

    v2 = this + 6;
    *this = &off_46CB9C;
    this [6] = &off_46CBBC;
    sub_43CF20((int) (this + 6));
    sub_43C2F0((int) (v2 - 6));
    result = sub_43D130(v2);
    *this = off_46CB7C;
    return result;
}
// 46CB7C: using guessed type void (__noreturn *off_46CB7C[7])();
// 46CB9C: using guessed type int (*off_46CB9C)();
// 46CBBC: using guessed type int (__stdcall *off_46CBBC)(LPCSTR lpFileName, int);

//----- (0043C750) --------------------------------------------------------
_DWORD* __thiscall sub_43C750(_DWORD* Block, char a2) {
    sub_43C6E0(Block);
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}

//----- (0043C770) --------------------------------------------------------
_DWORD* __thiscall sub_43C770(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    this [3] = 0;
    this [2] = 0;
    this [4] = 0;
    *this = 0;
    this [1] = 0;
    return result;
}

//----- (0043C790) --------------------------------------------------------
int __thiscall sub_43C790(_DWORD* this) {
    int v2; // eax
    int(__thiscall * **v3)(_DWORD); // ecx
    int v4; // eax
    int(__thiscall * **v5)(_DWORD); // ecx
    int v6; // eax
    void* v7; // ecx
    void* v9; // eax
    int v10; // ebx
    int i; // edi

    v2 = sub_43C380((void*) *this);
    v3 = (int(__thiscall***)(_DWORD)) * this;
    if(v2 != 860308048) {
        LABEL_4:
        if(v3) {
            ((void(__thiscall*)(int(__thiscall***)(_DWORD), int))(*v3) [7])(v3, 1);
            *this = 0;
            return 0;
        }
        return 0;
    }
    v4 = sub_43C310(v3);
    v5 = (int(__thiscall***)(_DWORD)) * this;
    this [2] = v4;
    v6 = sub_43C310(v5);
    v7 = (void*) *this;
    this [3] = v6;
    if(!(*(int(__thiscall**)(void*, int))(*(_DWORD*) v7 + 12))(v7, v6)) {
        v3 = (int(__thiscall***)(_DWORD)) * this;
        goto LABEL_4;
    }
    v9 = operator new(276 * this [2]);
    this [4] = v9;
    if(!v9) {
        if(*this) {
            (*(void(__thiscall**)(_DWORD, int))(*(_DWORD*) *this + 28))(*this, 1);
            *this = 0;
        }
        return 0;
    }
    v10 = 0;
    if(!this [2])
        return 1;
    for(i = 0; ; i += 276) {
        *(_DWORD*) (i + this [4] + 4) = sub_43C310((int(__thiscall***)(_DWORD)) * this);
        *(_DWORD*) (i + this [4]) = sub_43C310((int(__thiscall***)(_DWORD)) * this);
        *(_DWORD*) (i + this [4] + 16) = sub_43C310((int(__thiscall***)(_DWORD)) * this);
        *(_DWORD*) (i + this [4] + 12) = sub_43C310((int(__thiscall***)(_DWORD)) * this);
        *(_DWORD*) (i + this [4] + 8) = sub_43C310((int(__thiscall***)(_DWORD)) * this);
        if(!sub_43C3C0((void*) *this, i + this [4] + 20, 0x100u))
            break;
        if((unsigned int)++v10 >= this [2])
            return 1;
    }
    if(*this) {
        (*(void(__thiscall**)(_DWORD, int))(*(_DWORD*) *this + 28))(*this, 1);
        *this = 0;
    }
    if(this [4]) {
        j__free((void*) this [4]);
        this [4] = 0;
    }
    return 0;
}

//----- (0043C8D0) --------------------------------------------------------
int __thiscall sub_43C8D0(int* this) {
    int v2; // ecx

    v2 = *this;
    this [3] = 0;
    this [2] = 0;
    if(v2) {
        (*(void(__thiscall**)(int, int))(*(_DWORD*) v2 + 28))(v2, 1);
        *this = 0;
    }
    if(this [4]) {
        j__free((void*) this [4]);
        this [4] = 0;
    }
    free((void*) this [1]);
    return 1;
}

//----- (0043C920) --------------------------------------------------------
int __thiscall sub_43C920(_DWORD* this, const char* a2) {
    unsigned int v2; // eax
    int v3; // ebp
    const char* i; // edi

    v2 = this [2];
    v3 = 0;
    if(!v2)
        return -1;
    for(i = (const char*) (this [4] + 20); strcmp(a2, i); i += 276) {
        if(++v3 >= v2)
            return -1;
    }
    return v3;
}

//----- (0043C990) --------------------------------------------------------
int __thiscall sub_43C990(_DWORD* this, unsigned int a2) {
    if(a2 < this [2])
        return *(_DWORD*) (this [4] + 276 * a2 + 8);
    else
        return 0;
}

//----- (0043C9C0) --------------------------------------------------------
void* __thiscall sub_43C9C0(_DWORD* this, size_t* a2, _DWORD* a3, unsigned int a4) {
    int v5; // ecx
    void* result; // eax
    int v7; // ebx
    size_t v8; // esi
    void* v9; // eax
    void* v10; // ebp

    v5 = *this;
    if(!v5)
        return 0;
    if(a4 >= this [2])
        return 0;
    if(!a2)
        return 0;
    if(!a3)
        return 0;
    v7 = 276 * a4;
    if(!(*(int(__thiscall**)(int, _DWORD))(*(_DWORD*) v5 + 12))(v5, *(_DWORD*) (this [4] + 276 * a4 + 12)))
        return 0;
    v8 = a4 == this [2] - 1
        ? this [3] - *(_DWORD*) (this [4] + v7 + 12)
        : *(_DWORD*) (this [4] + v7 + 288) - *(_DWORD*) (this [4] + v7 + 12);
    v9 = malloc(v8);
    v10 = v9;
    if(!v9)
        return 0;
    if(!(*(int(__thiscall**)(_DWORD, void*, size_t))(*(_DWORD*) *this + 20))(*this, v9, v8)) {
        free(v10);
        return 0;
    }
    *a3 = *(_DWORD*) (this [4] + v7 + 16);
    result = v10;
    *a2 = v8;
    return result;
}

//----- (0043CA90) --------------------------------------------------------
int __thiscall sub_43CA90(int* this, LPCSTR lpFileName) {
    _DWORD* v3; // eax
    _DWORD* v4; // eax

    if(!sub_43C8D0(this))
        return 0;
    v3 = operator new(0x24u);
    v4 = v3 ? sub_43C440(v3) : 0;
    *this = (int) v4;
    if(!v4)
        return 0;
    if(!sub_43C4A0((int) v4, lpFileName)) {
        if(*this) {
            (*(void(__thiscall**)(int, int))(*(_DWORD*) *this + 28))(*this, 1);
            *this = 0;
        }
        return 0;
    }
    return sub_43C790(this);
}

//----- (0043CB40) --------------------------------------------------------
void* __thiscall sub_43CB40(_DWORD* this, unsigned int a2, int a3) {
    unsigned int v4; // eax
    void* v5; // edi
    unsigned __int8* v6; // esi
    unsigned __int8 v8; // dl
    unsigned __int8* v9; // ebx
    int v10; // ecx
    int v11; // eax
    int v12; // edi
    signed int v13; // eax
    char* v14; // esi
    signed int v15; // eax
    unsigned int v16; // esi
    unsigned int v17; // edi
    signed int v18; // eax
    int i; // edx
    char v20; // al
    char* v21; // edi
    char v22; // [esp+10h] [ebp-2030h]
    int v23; // [esp+14h] [ebp-202Ch]
    __int64 v24; // [esp+18h] [ebp-2028h]
    int v25; // [esp+18h] [ebp-2028h]
    __int16 v26; // [esp+1Ch] [ebp-2024h]
    int v27; // [esp+20h] [ebp-2020h] BYREF
    void* Block; // [esp+24h] [ebp-201Ch]
    signed int v29; // [esp+28h] [ebp-2018h] BYREF
    char* v30; // [esp+2Ch] [ebp-2014h]
    void* v31; // [esp+30h] [ebp-2010h]
    _DWORD* v32; // [esp+34h] [ebp-200Ch]
    char v33 [8196]; // [esp+38h] [ebp-2008h] BYREF
    unsigned int v34; // [esp+203Ch] [ebp-4h]
    unsigned int retaddr; // [esp+2044h] [ebp+4h]

    v34 = retaddr ^ dword_47A630;
    v4 = this [2];
    v32 = this;
    if(a2 >= v4)
        return 0;
    if(!*this)
        return 0;
    v29 = *(_DWORD*) (this [4] + 276 * a2 + 8);
    v5 = malloc(v29);
    v31 = v5;
    if(!v5)
        return 0;
    v30 = (char*) v5;
    v6 = (unsigned __int8*) sub_43C9C0(this, (size_t*) &v29, &v27, a2);
    Block = v6;
    if(!v6) {
        free(v5);
        return 0;
    }
    v8 = 0x80;
    v9 = v6;
    v22 = 0x80;
    v23 = 0;
    v27 = 1;
    memset(v33, 0, 0x2000u);
    LABEL_10:
    v10 = *v9;
    if(v9 - v6 < v29)
        ++v9;
    else
        v10 = 0;
    v23 += v10;
    while(1) {
        v11 = (unsigned __int8) (v10 & v22);
        v8 >>= 1;
        v22 = v8;
        if(!v8) {
            v22 = 0x80;
            v8 = 0x80;
        }
        v12 = 0;
        if(!v11)
            break;
        v24 = 0x8000000000i64;
        v13 = v9 - (_BYTE*) Block;
        do {
            if(v8 == 0x80) {
                v10 = *v9;
                if(v13 < v29) {
                    ++v9;
                    ++v13;
                }
                else {
                    v10 = 0;
                }
                v23 += v10;
            }
            if((v8 & (unsigned __int8) v10) != 0) {
                v8 = v22;
                LOBYTE(v24) = BYTE4(v24) | v24;
            }
            v8 >>= 1;
            HIDWORD(v24) >>= 1;
            v22 = v8;
            if(!v8) {
                v22 = 0x80;
                v8 = 0x80;
            }
        }
        while(HIDWORD(v24));
        v14 = v30;
        *v30 = v24;
        v30 = v14 + 1;
        LOWORD(v14) = v27;
        v33 [v27] = v24;
        v27 = ((_WORD) v14 + 1) & 0x1FFF;
        LABEL_8:
        if(v8 == 0x80) {
            v6 = (unsigned __int8*) Block;
            goto LABEL_10;
        }
    }
    v15 = v9 - (_BYTE*) Block;
    v16 = 4096;
    do {
        if(v8 == 0x80) {
            v10 = *v9;
            if(v15 < v29) {
                ++v9;
                ++v15;
            }
            else {
                v10 = 0;
            }
            v23 += v10;
            v8 = v22;
        }
        if((v8 & (unsigned __int8) v10) != 0)
            v12 |= v16;
        v16 >>= 1;
        v8 >>= 1;
        v22 = v8;
        if(!v8) {
            v22 = 0x80;
            v8 = 0x80;
        }
    }
    while(v16);
    v26 = v12;
    if(v12) {
        v25 = 0;
        v17 = 8;
        v18 = v9 - (_BYTE*) Block;
        do {
            if(v8 == 0x80) {
                v10 = *v9;
                if(v18 < v29) {
                    ++v9;
                    ++v18;
                }
                else {
                    v10 = 0;
                }
                v23 += v10;
            }
            if((v8 & (unsigned __int8) v10) != 0)
                v25 |= v17;
            v17 >>= 1;
            v8 >>= 1;
            v22 = v8;
            if(!v8) {
                v22 = 0x80;
                v8 = 0x80;
            }
        }
        while(v17);
        for(i = 0; i <= v25 + 2; v27 = ((_WORD) v21 + 1) & 0x1FFF) {
            v20 = v33 [(v26 + (_WORD) i) & 0x1FFF];
            v21 = v30;
            *v30 = v20;
            v30 = v21 + 1;
            LOWORD(v21) = v27;
            v33 [v27] = v20;
            ++i;
        }
        v8 = v22;
        goto LABEL_8;
    }
    if(v8 != 0x80) {
        do
            v8 >>= 1;
        while(v8 && v8 != 0x80);
    }
    free(Block);
    if(*(_DWORD*) (v32 [4] + 276 * a2 + 16) != v23) {
        free(v31);
        return 0;
    }
    return v31;
}
// 47A630: using guessed type int dword_47A630;
// 43CB40: using guessed type char var_2008[8196];

//----- (0043CE40) --------------------------------------------------------
_DWORD* __thiscall sub_43CE40(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    *this = &off_46CBE8;
    this [1] = -1;
    this [2] = 0;
    return result;
}
// 46CBE8: using guessed type int (__stdcall *off_46CBE8)(LPCSTR lpFileName, int);

//----- (0043CE60) --------------------------------------------------------
int __thiscall sub_43CE60(_DWORD* this, LPCSTR lpFileName, _BYTE* a3) {
    int v4; // ebx
    _BYTE* v5; // edi
    char v6; // al
    DWORD v8; // eax
    HANDLE FileA; // eax

    v4 = 0;
    (*(void(__thiscall**)(_DWORD*))(*this + 4))(this);
    v5 = a3;
    v6 = *a3;
    if(*a3) {
        while(1) {
            if(v6 == 114) {
                this [2] = 0x80000000;
                v8 = 3;
                goto LABEL_11;
            }
            if(v6 == 119) {
                DeleteFileA(lpFileName);
                this [2] = 0x40000000;
                v8 = 4;
                goto LABEL_11;
            }
            if(v6 == 97)
                break;
            v6 = *++v5;
            if(!v6)
                return 0;
        }
        v4 = 1;
        this [2] = 0x40000000;
        v8 = 4;
    }
    else {
        v8 = (DWORD) a3;
    }
    LABEL_11:
    if(!*v5)
        return 0;
    FileA = CreateFileA(lpFileName, this [2], 1u, 0, v8, 0x8000080u, 0);
    this [1] = FileA;
    if(FileA == (HANDLE) -1)
        return 0;
    if(v4)
        SetFilePointer(FileA, 0, 0, 2u);
    return 1;
}

//----- (0043CF20) --------------------------------------------------------
int __thiscall sub_43CF20(int this) {
    int result; // eax

    result = *(_DWORD*) (this + 4);
    if(result != -1) {
        result = CloseHandle(*(HANDLE*) (this + 4));
        *(_DWORD*) (this + 4) = -1;
        *(_DWORD*) (this + 8) = 0;
    }
    return result;
}

//----- (0043CF50) --------------------------------------------------------
BOOL __thiscall sub_43CF50(int this, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead) {
    return *(_DWORD*) (this + 8) == 0x80000000
        && ReadFile(*(HANDLE*) (this + 4), lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, 0);
}

//----- (0043CF80) --------------------------------------------------------
BOOL __thiscall sub_43CF80(int this, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten) {
    return *(_DWORD*) (this + 8) == 0x40000000
        && WriteFile(*(HANDLE*) (this + 4), lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, 0);
}

//----- (0043CFB0) --------------------------------------------------------
int __thiscall sub_43CFB0(void* this) {
    int v2; // [esp+Ch] [ebp-8h] BYREF
    char v3 [4]; // [esp+10h] [ebp-4h] BYREF

    if((*(int(__thiscall**)(void*, char*, int, int*))(*(_DWORD*) this + 8))(this, v3, 1, &v2) && v2)
        return (unsigned __int8) v3 [0];
    else
        return -1;
}
// 43CFB0: using guessed type char var_4[4];

//----- (0043CFF0) --------------------------------------------------------
int __thiscall sub_43CFF0(void* this, int a2) {
    int v2; // ebx
    int v4; // [esp+Ch] [ebp-4h] BYREF

    v2 = a2;
    if((*(int(__thiscall**)(void*, int*, int, int*))(*(_DWORD*) this + 12))(this, &a2, 1, &v4) && v4)
        return v2;
    else
        return -1;
}

//----- (0043D030) --------------------------------------------------------
int __thiscall sub_43D030(_DWORD* this, LONG lDistanceToMove, DWORD dwMoveMethod) {
    void* v3; // eax

    v3 = (void*) this [1];
    if(v3 == (void*) -1)
        return 0;
    SetFilePointer(v3, lDistanceToMove, 0, dwMoveMethod);
    return 1;
}

//----- (0043D060) --------------------------------------------------------
DWORD __thiscall sub_43D060(_DWORD* this) {
    void* v1; // eax

    v1 = (void*) this [1];
    if(v1 == (void*) -1)
        return 0;
    else
        return SetFilePointer(v1, 0, 0, 1u);
}

//----- (0043D080) --------------------------------------------------------
DWORD __thiscall sub_43D080(_DWORD* this) {
    void* v1; // eax

    v1 = (void*) this [1];
    if(v1 == (void*) -1)
        return 0;
    else
        return GetFileSize(v1, 0);
}

//----- (0043D0A0) --------------------------------------------------------
HLOCAL __thiscall sub_43D0A0(_DWORD* this, SIZE_T a2) {
    SIZE_T v4; // ebp
    HLOCAL v5; // edi
    int v6; // ebx
    char v7 [4]; // [esp+8h] [ebp-4h] BYREF

    if(this [2] != 0x80000000)
        return 0;
    v4 = (*(int(__thiscall**)(_DWORD*))(*this + 32))(this);
    if(v4 > a2)
        return 0;
    v5 = LocalAlloc(0x40u, v4);
    if(!v5)
        return 0;
    v6 = (*(int(__thiscall**)(_DWORD*))(*this + 28))(this);
    if(!(*(int(__thiscall**)(_DWORD*, int, _DWORD))(*this + 24))(this, v6, 0))
        return 0;
    if(!(*(int(__thiscall**)(_DWORD*, HLOCAL, SIZE_T, char*))(*this + 8))(this, v5, v4, v7)) {
        LocalFree(v5);
        return 0;
    }
    (*(void(__thiscall**)(_DWORD*, int, _DWORD))(*this + 24))(this, v6, 0);
    return v5;
}
// 43D0A0: using guessed type char var_4[4];

//----- (0043D130) --------------------------------------------------------
void* __thiscall sub_43D130(_DWORD* this) {
    void* result; // eax

    result = (void*) this [1];
    *this = &off_46CBE8;
    if(result != (void*) -1) {
        result = (void*) CloseHandle(result);
        this [1] = -1;
        this [2] = 0;
    }
    return result;
}
// 46CBE8: using guessed type int (__stdcall *off_46CBE8)(LPCSTR lpFileName, int);

//----- (0043EBB2) --------------------------------------------------------
float* __stdcall sub_43EBB2(float* a1, float* a2, float* a3) {
    double v3; // st5
    double v4; // st6
    double v5; // st7

    v3 = *a2 * a3 [1] + a2 [1] * a3 [5] + a2 [2] * a3 [9] + a2 [3] * a3 [13];
    v4 = *a2 * a3 [2] + a2 [1] * a3 [6] + a2 [2] * a3 [10] + a2 [3] * a3 [14];
    v5 = *a2 * a3 [3] + a2 [1] * a3 [7] + a2 [2] * a3 [11] + a2 [3] * a3 [15];
    *a1 = *a2 * *a3 + a2 [1] * a3 [4] + a2 [2] * a3 [8] + a2 [3] * a3 [12];
    a1 [1] = v3;
    a1 [2] = v4;
    a1 [3] = v5;
    return a1;
}

//----- (0043EC4B) --------------------------------------------------------
char* __stdcall sub_43EC4B(char* a1, char* a2, char* a3) {
    char* result; // eax
    char* v4; // ebx
    char* v10; // ebx
    int v13; // edi
    char v16 [64]; // [esp+Ch] [ebp-40h] BYREF

    result = a1;
    if(a3 == a1) {
        if(a2 != a1) {
            v4 = a1;
            _ECX = a2;
            _EDX = a3;
            _EDI = -4;
            do {
                _ESI = -16;
                __asm
                {
                    fld     dword ptr [edx + edi * 4 + 10h]
                    fld     dword ptr [edx + edi * 4 + 20h]
                    fld     dword ptr [edx + edi * 4 + 30h]
                    fld     dword ptr [edx + edi * 4 + 40h]
                }
                do {
                    __asm
                    {
                        fld     st(3)
                        fmul    dword ptr [ecx + esi * 4 + 40h]
                        fld     st(3)
                        fmul    dword ptr [ecx + esi * 4 + 44h]
                        fld     st(3)
                        fmul    dword ptr [ecx + esi * 4 + 48h]
                        fld     st(3)
                        fmul    dword ptr [ecx + esi * 4 + 4Ch]
                        fxch    st(3)
                        faddp   st(1), st
                        fxch    st(2)
                        faddp   st(1), st
                        faddp   st(1), st
                        fstp    dword ptr [ebx + esi * 4 + 40h]
                    }
                    *(float*) &v4 [4 * _ESI + 64] = _ET1;
                    _ESI += 4;
                }
                while(_ESI);
                __asm
                {
                    ffree   st(3)
                    ffree   st(2)
                    ffree   st(1)
                    ffree   st
                }
                v4 += 4;
                ++_EDI;
            }
            while(_EDI);
            return result;
        }
        qmemcpy(v16, a3, sizeof(v16));
        a3 = v16;
    }
    v10 = a1;
    _ECX = a2;
    _EDX = a3;
    v13 = -4;
    do {
        _ESI = -4;
        __asm
        {
            fld     dword ptr [ecx]
            fld     dword ptr [ecx + 4]
            fld     dword ptr [ecx + 8]
            fld     dword ptr [ecx + 0Ch]
        }
        do {
            __asm
            {
                fld     st(3)
                fmul    dword ptr [edx + esi * 4 + 10h]
                fld     st(3)
                fmul    dword ptr [edx + esi * 4 + 20h]
                fld     st(3)
                fmul    dword ptr [edx + esi * 4 + 30h]
                fld     st(3)
                fmul    dword ptr [edx + esi * 4 + 40h]
                fxch    st(3)
                faddp   st(1), st
                fxch    st(2)
                faddp   st(1), st
                faddp   st(1), st
                fstp    dword ptr [ebx + esi * 4 + 10h]
            }
            *(float*) &v10 [4 * _ESI++ + 16] = _ET1;
        }
        while(_ESI);
        __asm
        {
            ffree   st(3)
            ffree   st(2)
            ffree   st(1)
            ffree   st
        }
        _ECX += 16;
        v10 += 16;
        ++v13;
    }
    while(v13);
    return result;
}
// 43EC76: inconsistent fpu stack

//----- (0043ED2E) --------------------------------------------------------
int __stdcall sub_43ED2E(int a1, int a2) {
    double v2; // st7
    int result; // eax
    double v4; // st7
    double v5; // st7
    double v6; // st7
    double v7; // st7
    double v8; // st7

    v2 = *(float*) (a2 + 4);
    result = a1;
    *(float*) (a1 + 4) = *(float*) (a2 + 16);
    *(float*) (a1 + 16) = v2;
    v4 = *(float*) (a2 + 8);
    *(_DWORD*) (a1 + 8) = *(_DWORD*) (a2 + 32);
    *(float*) (a1 + 32) = v4;
    v5 = *(float*) (a2 + 12);
    *(_DWORD*) (a1 + 12) = *(_DWORD*) (a2 + 48);
    *(float*) (a1 + 48) = v5;
    v6 = *(float*) (a2 + 24);
    *(_DWORD*) (a1 + 24) = *(_DWORD*) (a2 + 36);
    *(float*) (a1 + 36) = v6;
    v7 = *(float*) (a2 + 28);
    *(_DWORD*) (a1 + 28) = *(_DWORD*) (a2 + 52);
    *(float*) (a1 + 52) = v7;
    v8 = *(float*) (a2 + 44);
    *(_DWORD*) (a1 + 44) = *(_DWORD*) (a2 + 56);
    *(float*) (a1 + 56) = v8;
    if(a1 != a2) {
        *(_DWORD*) a1 = *(_DWORD*) a2;
        *(_DWORD*) (a1 + 20) = *(_DWORD*) (a2 + 20);
        *(_DWORD*) (a1 + 40) = *(_DWORD*) (a2 + 40);
        *(_DWORD*) (a1 + 60) = *(_DWORD*) (a2 + 60);
    }
    return result;
}

//----- (0043ED9B) --------------------------------------------------------
float* __stdcall sub_43ED9B(float* a1, float a2) {
    float* result; // eax
    float v3; // [esp+8h] [ebp-8h]
    float v4; // [esp+Ch] [ebp-4h]

    v3 = cos(a2);
    v4 = sin(a2);
    result = a1;
    *a1 = 1.0;
    a1 [1] = 0.0;
    a1 [6] = v4;
    a1 [2] = 0.0;
    a1 [3] = 0.0;
    a1 [4] = 0.0;
    a1 [5] = v3;
    a1 [7] = 0.0;
    a1 [8] = 0.0;
    a1 [9] = -v4;
    a1 [10] = v3;
    a1 [11] = 0.0;
    a1 [12] = 0.0;
    a1 [13] = 0.0;
    a1 [14] = 0.0;
    a1 [15] = 1.0;
    return result;
}

//----- (0043EE15) --------------------------------------------------------
float* __stdcall sub_43EE15(float* a1, float a2) {
    float* result; // eax
    float v3; // [esp+8h] [ebp-8h]
    float v4; // [esp+Ch] [ebp-4h]

    v4 = cos(a2);
    v3 = sin(a2);
    result = a1;
    *a1 = v4;
    a1 [1] = 0.0;
    a1 [2] = -v3;
    a1 [3] = 0.0;
    a1 [4] = 0.0;
    a1 [5] = 1.0;
    a1 [6] = 0.0;
    a1 [7] = 0.0;
    a1 [8] = v3;
    a1 [9] = 0.0;
    a1 [10] = v4;
    a1 [11] = 0.0;
    a1 [12] = 0.0;
    a1 [13] = 0.0;
    a1 [14] = 0.0;
    a1 [15] = 1.0;
    return result;
}

//----- (0043EE90) --------------------------------------------------------
float* __stdcall sub_43EE90(float* a1, float a2) {
    float* result; // eax
    float v3; // [esp+8h] [ebp-8h]
    float v4; // [esp+Ch] [ebp-4h]

    v3 = cos(a2);
    v4 = sin(a2);
    result = a1;
    *a1 = v3;
    a1 [1] = v4;
    a1 [2] = 0.0;
    a1 [3] = 0.0;
    a1 [4] = -v4;
    a1 [5] = v3;
    a1 [6] = 0.0;
    a1 [7] = 0.0;
    a1 [8] = 0.0;
    a1 [9] = 0.0;
    a1 [10] = 1.0;
    a1 [11] = 0.0;
    a1 [12] = 0.0;
    a1 [13] = 0.0;
    a1 [14] = 0.0;
    a1 [15] = 1.0;
    return result;
}

//----- (0043EF0C) --------------------------------------------------------
float* __stdcall sub_43EF0C(float* a1, float* a2) {
    double v3; // st7
    double v4; // st6
    double v5; // st5
    double v6; // st4
    double v7; // st3
    float* result; // eax
    double v9; // st2
    float v10; // [esp+0h] [ebp-10h]
    float v11; // [esp+4h] [ebp-Ch]
    float v12; // [esp+8h] [ebp-8h]
    float v13; // [esp+Ch] [ebp-4h]
    float v14; // [esp+Ch] [ebp-4h]
    float v15; // [esp+18h] [ebp+8h]
    float v16; // [esp+1Ch] [ebp+Ch]
    float v17; // [esp+1Ch] [ebp+Ch]

    v13 = *a2 * 2.0;
    v16 = a2 [1] * 2.0;
    v3 = 2.0 * a2 [2];
    v4 = v13 * a2 [3];
    v5 = v16 * a2 [3];
    v6 = v3 * a2 [3];
    v10 = v13 * *a2;
    v14 = v16 * *a2;
    v12 = v3 * *a2;
    v11 = v16 * a2 [1];
    v17 = v3 * a2 [1];
    v7 = v3 * a2 [2];
    result = a1;
    *a1 = 1.0 - v11 - v7;
    a1 [1] = v14 + v6;
    a1 [2] = v12 - v5;
    a1 [3] = 0.0;
    a1 [4] = v14 - v6;
    v9 = 1.0 - v10;
    v15 = v9;
    result [5] = v9 - v7;
    result [6] = v17 + v4;
    result [7] = 0.0;
    result [8] = v12 + v5;
    result [9] = v17 - v4;
    result [10] = v15 - v11;
    result [11] = 0.0;
    result [12] = 0.0;
    result [13] = 0.0;
    result [14] = 0.0;
    result [15] = 1.0;
    return result;
}

//----- (0043EFEE) --------------------------------------------------------
float* __stdcall sub_43EFEE(float* a1, float a2, float a3, float a4, float a5) {
    float* result; // eax
    double v6; // st7
    double v7; // st7
    float v8; // [esp+8h] [ebp-8h]
    float v9; // [esp+Ch] [ebp-4h]
    float v10; // [esp+1Ch] [ebp+Ch]

    v8 = a2 * 0.5;
    v10 = cos(v8);
    v9 = sin(v8);
    result = a1;
    v6 = v10 / v9;
    *a1 = v6 / a3;
    a1 [1] = 0.0;
    a1 [2] = 0.0;
    a1 [3] = 0.0;
    a1 [4] = 0.0;
    a1 [5] = v6;
    a1 [6] = 0.0;
    a1 [7] = 0.0;
    a1 [8] = 0.0;
    a1 [9] = 0.0;
    v7 = a5 / (a5 - a4);
    a1 [10] = v7;
    a1 [11] = 1.0;
    a1 [12] = 0.0;
    a1 [13] = 0.0;
    a1 [14] = -(v7 * a4);
    a1 [15] = 0.0;
    return result;
}

//----- (0043F082) --------------------------------------------------------
float* __cdecl sub_43F082(float* a1, float* a2, float* a3) {
    float* result; // eax
    float v4; // [esp+8h] [ebp-Ch]
    float v5; // [esp+Ch] [ebp-8h]
    float v6; // [esp+10h] [ebp-4h]

    v4 = a3 [2] * a2 [1] - a2 [2] * a3 [1];
    v5 = a2 [2] * *a3 - a3 [2] * *a2;
    result = a1;
    v6 = *a2 * a3 [1] - *a3 * a2 [1];
    *a1 = v4;
    a1 [1] = v5;
    a1 [2] = v6;
    return result;
}

//----- (0043F0CE) --------------------------------------------------------
float* __stdcall sub_43F0CE(float* a1, float* a2) {
    float* v2; // esi
    long double v3; // st7
    float* result; // eax
    float* v5; // esi
    long double v6; // st7
    float v7 [3]; // [esp+8h] [ebp-Ch] BYREF

    v2 = a2;
    v3 = *a2 * *a2 + a2 [1] * a2 [1] + a2 [2] * a2 [2];
    if(v3 - 1.0 >= -0.0000099999997 && v3 - 1.0 <= 0.0000099999997) {
        result = a1;
        if(a1 == a2)
            return result;
        goto LABEL_4;
    }
    result = a1;
    if(v3 > 9.9999994e-11) {
        v6 = 1.0 / sqrt(v3);
        v7 [0] = v6 * *a2;
        v7 [1] = v6 * a2 [1];
        v2 = v7;
        v7 [2] = v6 * a2 [2];
        LABEL_4:
        *result = *v2;
        v5 = v2 + 1;
        result [1] = *v5;
        result [2] = v5 [1];
        return result;
    }
    *a1 = 0.0;
    a1 [1] = 0.0;
    a1 [2] = 0.0;
    return result;
}

//----- (0043F175) --------------------------------------------------------
float* __stdcall sub_43F175(float* a1, float* a2, float* a3) {
    double v3; // st5
    double v4; // st6
    double v5; // st7
    double v6; // st7
    double v7; // st7
    float v9; // [esp+0h] [ebp-4h]

    v3 = *a2 * a3 [1] + a2 [1] * a3 [5] + a2 [2] * a3 [9] + a3 [13];
    v4 = *a2 * a3 [2] + a2 [1] * a3 [6] + a2 [2] * a3 [10] + a3 [14];
    v5 = *a2 * a3 [3] + a2 [1] * a3 [7] + a2 [2] * a3 [11] + a3 [15];
    *a1 = *a2 * *a3 + a2 [1] * a3 [4] + a2 [2] * a3 [8] + a3 [12];
    a1 [1] = v3;
    a1 [2] = v4;
    v9 = v5;
    v6 = v9 - 1.0;
    if(v6 < -0.0000099999997 || v6 > 0.0000099999997) {
        v7 = 1.0 / v9;
        *a1 = v7 * *a1;
        a1 [1] = v7 * a1 [1];
        a1 [2] = v7 * a1 [2];
    }
    return a1;
}

//----- (0043F245) --------------------------------------------------------
float* __stdcall sub_43F245(float* a1, float* a2, float* a3, char* a4, char* a5, char* a6) {
    float* v6; // esi
    double v7; // st7
    double v8; // st6
    double v9; // st7
    double v10; // st6
    char* v12; // [esp-4h] [ebp-58h]
    _DWORD v13 [16]; // [esp+Ch] [ebp-48h] BYREF
    __int64 v14; // [esp+4Ch] [ebp-8h]

    v6 = (float*) v13;
    switch((a4 != 0) | (2 * ((a5 != 0) | (2 * (a6 != 0))))) {
        case 0:
            sub_403670(v13);
            break;
        case 1:
            v6 = (float*) a4;
            break;
        case 2:
            v6 = (float*) a5;
            break;
        case 3:
            sub_43EC4B((char*) v13, a5, a4);
            break;
        case 4:
            v6 = (float*) a6;
            break;
        case 5:
            v12 = a4;
            goto LABEL_9;
        case 6:
            v12 = a5;
            LABEL_9:
            sub_43EC4B((char*) v13, a6, v12);
            break;
        case 7:
            sub_43EC4B((char*) v13, a6, a5);
            sub_43EC4B((char*) v13, (char*) v13, a4);
            break;
        default:
            break;
    }
    sub_43F175(a1, a2, v6);
    if(a3) {
        v7 = *a1 + 1.0;
        v14 = *((unsigned int*) a3 + 2);
        v8 = (double) v14;
        v14 = *(unsigned int*) a3;
        *a1 = v7 * v8 * 0.5 + (double) (unsigned int) v14;
        *(float*) &v14 = a3 [3];
        v9 = 1.0 - a1 [1];
        v10 = (double) v14;
        v14 = *((unsigned int*) a3 + 1);
        a1 [1] = v9 * v10 * 0.5 + (double) v14;
        a1 [2] = (a3 [5] - a3 [4]) * a1 [2] + a3 [4];
    }
    return a1;
}

//----- (0043F362) --------------------------------------------------------
int __stdcall sub_43F362(int a1, float* a2, float* a3, int* a4, float* a5, float* a6, float* a7) {
    int v7; // ecx
    int v8; // ecx
    int v9; // esi
    int v10; // eax
    char v12 [64]; // [esp+8h] [ebp-64h] BYREF
    float v13 [16]; // [esp+48h] [ebp-24h] BYREF
    int v14 [16]; // [esp+88h] [ebp+1Ch] BYREF

    if(a4) {
        if(a3) {
            *(float*) &v14 [14] = 0.0;
            v7 = *a4;
            *(float*) &v14 [13] = 0.0;
            v14 [0] = v7;
            v8 = a4 [1];
            *(float*) &v14 [12] = 0.0;
            v14 [10] = a4 [2];
            *(float*) &v14 [11] = 0.0;
            v14 [5] = v8;
            *(float*) &v14 [9] = 0.0;
            *(float*) &v14 [8] = 0.0;
            *(float*) &v14 [7] = 0.0;
            *(float*) &v14 [6] = 0.0;
            *(float*) &v14 [4] = 0.0;
            *(float*) &v14 [3] = 0.0;
            *(float*) &v14 [2] = 0.0;
            *(float*) &v14 [1] = 0.0;
            *(float*) &v14 [15] = 1.0;
            sub_43EF0C(v13, a3);
            if(a2) {
                sub_43ED2E((int) v12, (int) v13);
                v9 = a1;
                sub_403670((_DWORD*) a1);
                *(float*) (a1 + 48) = *(float*) (a1 + 48) - *a2;
                *(float*) (a1 + 52) = *(float*) (a1 + 52) - a2 [1];
                *(float*) (a1 + 56) = *(float*) (a1 + 56) - a2 [2];
                sub_43EC4B((char*) v9, (char*) v9, v12);
                sub_43EC4B((char*) v9, (char*) v9, (char*) v14);
                sub_43EC4B((char*) v9, (char*) v9, (char*) v13);
                *(float*) (a1 + 48) = *(float*) (a1 + 48) + *a2;
                *(float*) (a1 + 52) = a2 [1] + *(float*) (a1 + 52);
                *(float*) (a1 + 56) = a2 [2] + *(float*) (a1 + 56);
            }
            else {
                v9 = a1;
                sub_43ED2E(a1, (int) v13);
                sub_43EC4B((char*) v9, (char*) v9, (char*) v14);
                sub_43EC4B((char*) v9, (char*) v9, (char*) v13);
            }
        }
        else {
            v9 = a1;
            *(float*) (a1 + 56) = 0.0;
            *(float*) (a1 + 52) = 0.0;
            *(float*) (a1 + 48) = 0.0;
            *(float*) (a1 + 44) = 0.0;
            *(float*) (a1 + 36) = 0.0;
            *(float*) (a1 + 32) = 0.0;
            *(float*) (a1 + 28) = 0.0;
            *(float*) (a1 + 24) = 0.0;
            *(float*) (a1 + 16) = 0.0;
            *(float*) (a1 + 12) = 0.0;
            *(float*) (a1 + 8) = 0.0;
            *(float*) (a1 + 4) = 0.0;
            *(_DWORD*) a1 = *a4;
            *(_DWORD*) (a1 + 20) = a4 [1];
            v10 = a4 [2];
            *(float*) (a1 + 60) = 1.0;
            *(_DWORD*) (a1 + 40) = v10;
        }
    }
    else {
        v9 = a1;
        sub_403670((_DWORD*) a1);
    }
    if(a6) {
        sub_43EF0C(v13, a6);
        if(a5) {
            *(float*) (v9 + 48) = *(float*) (v9 + 48) - *a5;
            *(float*) (v9 + 52) = *(float*) (v9 + 52) - a5 [1];
            *(float*) (v9 + 56) = *(float*) (v9 + 56) - a5 [2];
            sub_43EC4B((char*) v9, (char*) v9, (char*) v13);
            *(float*) (v9 + 48) = *(float*) (v9 + 48) + *a5;
            *(float*) (v9 + 52) = *(float*) (v9 + 52) + a5 [1];
            *(float*) (v9 + 56) = *(float*) (v9 + 56) + a5 [2];
        }
        else {
            sub_43EC4B((char*) v9, (char*) v9, (char*) v13);
        }
    }
    if(a7) {
        *(float*) (v9 + 48) = *(float*) (v9 + 48) + *a7;
        *(float*) (v9 + 52) = a7 [1] + *(float*) (v9 + 52);
        *(float*) (v9 + 56) = a7 [2] + *(float*) (v9 + 56);
    }
    return v9;
}
// 43F362: using guessed type float var_80[16];

//----- (0043F561) --------------------------------------------------------
float* __stdcall sub_43F561(float* a1, float* a2, float* a3, float* a4) {
    float* result; // eax
    float v6; // ecx
    double v7; // st7
    double v8; // st7
    double v9; // st6
    float v10; // ecx
    double v11; // st7
    double v12; // st6
    float v13; // [esp+4h] [ebp-24h] BYREF
    float v14; // [esp+8h] [ebp-20h]
    float v15; // [esp+Ch] [ebp-1Ch]
    float v16; // [esp+10h] [ebp-18h] BYREF
    float v17; // [esp+14h] [ebp-14h]
    float v18; // [esp+18h] [ebp-10h]
    float v19; // [esp+1Ch] [ebp-Ch] BYREF
    float v20; // [esp+20h] [ebp-8h]
    float v21; // [esp+24h] [ebp-4h]

    v19 = *a3 - *a2;
    v20 = a3 [1] - a2 [1];
    v21 = a3 [2] - a2 [2];
    sub_43F0CE(&v19, &v19);
    sub_43F082(&v16, a4, &v19);
    sub_43F0CE(&v16, &v16);
    sub_43F082(&v13, &v19, &v16);
    result = a1;
    v6 = v17;
    *a1 = v16;
    v7 = v17;
    a1 [4] = v6;
    a1 [8] = v18;
    v8 = v7 * a2 [1] + v16 * *a2;
    v9 = v18 * a2 [2];
    a1 [1] = v13;
    a1 [5] = v14;
    a1 [9] = v15;
    v10 = v19;
    a1 [12] = -(v8 + v9);
    v11 = v14 * a2 [1] + v13 * *a2;
    v12 = v15 * a2 [2];
    a1 [2] = v10;
    a1 [6] = v20;
    a1 [10] = v21;
    a1 [13] = -(v11 + v12);
    a1 [14] = -(v20 * a2 [1] + v19 * *a2 + v21 * a2 [2]);
    a1 [3] = 0.0;
    a1 [7] = 0.0;
    a1 [11] = 0.0;
    a1 [15] = 1.0;
    return result;
}

//----- (0043F667) --------------------------------------------------------
int __stdcall sub_43F667(int a1, LOGFONTA* lplf, _DWORD* a3) {
    _DWORD* v3; // eax
    _DWORD* v4; // esi
    int v6; // edi

    if(!a1 || !lplf || !a3)
        return -2005530516;
    v3 = operator new(0x50u);
    if(v3)
        v4 = sub_440781(v3);
    else
        v4 = 0;
    if(!v4)
        return -2147024882;
    v6 = sub_440616(v4, a1, lplf);
    if(v6 >= 0) {
        *a3 = v4;
        return 0;
    }
    else {
        sub_4405D7(v4);
        j__free(v4);
        return v6;
    }
}

//----- (0043F6DB) --------------------------------------------------------
int __userpurge sub_43F6DB(int a1, int a2, _DWORD* a3) {
    _DWORD* v4; // eax
    _DWORD* v5; // esi
    int v6; // edi

    if(!a2 || !a3)
        return -2005530516;
    v4 = operator new(0x18u);
    if(v4)
        v5 = sub_440EEC(v4);
    else
        v5 = 0;
    if(!v5)
        return -2147024882;
    v6 = sub_4407DC((int) v5, (int) a3, a1, a2);
    if(v6 >= 0) {
        *a3 = v5;
        return 0;
    }
    else {
        sub_44079C(v5);
        j__free(v5);
        return v6;
    }
}

//----- (0043F745) --------------------------------------------------------
int __stdcall sub_43F745(int a1, HANDLE h, _DWORD* a3) {
    LOGFONTA pv; // [esp+0h] [ebp-3Ch] BYREF

    if(GetObjectA(h, 60, &pv))
        return sub_43F667(a1, &pv, a3);
    else
        return -2005530516;
}

//----- (0043F778) --------------------------------------------------------
_DWORD* __cdecl sub_43F778(int a1) {
    _DWORD* result; // eax

    result = &unk_4786D8;
    if(off_478B88 <= &unk_4786D8)
        return &unk_478B60;
    while(a1 != *result) {
        result += 10;
        if(result >= off_478B88)
            return &unk_478B60;
    }
    return result;
}
// 478B88: using guessed type void *off_478B88;

//----- (0043F79C) --------------------------------------------------------
int __usercall sub_43F79C(int a1, _DWORD* a2) {
    int v3; // eax
    int v4; // edx
    int result; // eax
    unsigned int* v6; // esi
    int v7; // edi
    int v8; // ebx
    unsigned int v9; // ecx
    unsigned int v10; // edx

    if(!a2 [8])
        return -1;
    v3 = a2 [1];
    v4 = *(_DWORD*) (a1 + 4);
    if(v3 != v4 && (!v3 && v4 == 3 || v3 == 3 && v4 != 3 || v3 == 2 && v4 != 2 || v3 == 1 && v4 != 1))
        return -1;
    result = 0;
    v6 = a2 + 3;
    v7 = a1 - (_DWORD) a2;
    v8 = 5;
    do {
        v9 = *(unsigned int*) ((char*) v6 + v7);
        v10 = *v6;
        if(v9 >= *v6) {
            if(v9 > *v6) {
                if(v10)
                    result += (v9 - v10) << 16;
                else
                    result += 0x1000000;
            }
        }
        else if(v9) {
            result += v10 - v9;
        }
        else {
            result += 256;
        }
        ++v6;
        --v8;
    }
    while(v8);
    return result;
}

//----- (0043F81C) --------------------------------------------------------
int __usercall sub_43F81C(
    int a1,
    unsigned int* a2,
    unsigned int* a3,
    int* a4,
    int* a5,
    int a6,
    int* a7,
    unsigned int a8,
    int a9) {
    unsigned int v11; // ecx
    unsigned int v12; // eax
    bool v13; // zf
    unsigned int v14; // eax
    bool v15; // cc
    unsigned int v16; // eax
    unsigned int v17; // eax
    unsigned int v18; // ebx
    int v19; // eax
    unsigned int v20; // eax
    unsigned int v21; // esi
    unsigned int v22; // edx
    unsigned int i; // eax
    unsigned int v24; // ecx
    unsigned int j; // eax
    unsigned int v26; // eax
    unsigned int v27; // edi
    int* v28; // ebx
    int v29; // esi
    unsigned int v30; // eax
    int v31; // ecx
    int v32 [10]; // [esp+Ch] [ebp-134h] BYREF
    int v33 [15]; // [esp+34h] [ebp-10Ch] BYREF
    int v34; // [esp+70h] [ebp-D0h]
    unsigned int v35; // [esp+8Ch] [ebp-B4h]
    unsigned int v36; // [esp+90h] [ebp-B0h]
    unsigned int v37; // [esp+94h] [ebp-ACh]
    int v38; // [esp+9Ch] [ebp-A4h]
    char v39 [12]; // [esp+108h] [ebp-38h] BYREF
    int v40; // [esp+114h] [ebp-2Ch]
    _DWORD* v41; // [esp+118h] [ebp-28h]
    int v42; // [esp+11Ch] [ebp-24h]
    int v43; // [esp+120h] [ebp-20h] BYREF
    int v44; // [esp+124h] [ebp-1Ch]
    int v45; // [esp+128h] [ebp-18h]
    int v46; // [esp+12Ch] [ebp-14h]
    int v47; // [esp+130h] [ebp-10h]
    unsigned int v48; // [esp+134h] [ebp-Ch]
    unsigned int v49; // [esp+138h] [ebp-8h]
    unsigned int v50; // [esp+13Ch] [ebp-4h]
    unsigned int v51; // [esp+160h] [ebp+20h]
    int v52; // [esp+164h] [ebp+24h]

    if(!a1)
        return -2005530516;
    if(a6 == -1)
        a6 = 0;
    if(a6 != (a6 & 3) || a9 == 2 && (a6 & 3) != 0 || a8 >= 3)
        return -2005530516;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) a1 + 24))(a1, &v43);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) a1 + 28))(a1, v33);
    (*(void(__stdcall**)(int, char*))(*(_DWORD*) a1 + 32))(a1, v39);
    if(a2)
        v51 = *a2;
    else
        v51 = -1;
    if(a3)
        v11 = *a3;
    else
        v11 = -1;
    v50 = v11;
    if(a4)
        v49 = *a4;
    else
        v49 = -1;
    if(v51 == -1) {
        if(v11 == -1) {
            v11 = 256;
            v51 = 256;
            LABEL_28:
            v50 = v11;
            goto LABEL_29;
        }
        v51 = v11;
    }
    else if(v11 == -1) {
        v11 = v51;
        v50 = v51;
    }
    if(!v51)
        v51 = 1;
    if(!v11) {
        v11 = 1;
        goto LABEL_28;
    }
    LABEL_29:
    if(a9 == 1) {
        if(v51 > v11) {
            v11 = v51;
            v50 = v51;
        }
        v51 = v11;
    }
    if(v49 == -1 || !v49)
        v49 = 1;
    if(a9 == 2) {
        v12 = v37;
        if(v49 > v37)
            v49 = v37;
        if(v51 > v37)
            v51 = v37;
    }
    else {
        if(v51 > v35)
            v51 = v35;
        if(v11 > v36) {
            v11 = v36;
            v50 = v36;
        }
        if(a9)
            goto LABEL_54;
        if((v34 & 0x20) != 0)
            v38 = 1;
        if(!v38)
            goto LABEL_54;
        if(v51 > v11 * v38)
            v51 = v11 * v38;
        v12 = v51 * v38;
    }
    if(v11 > v12) {
        v11 = v12;
        v50 = v12;
    }
    LABEL_54:
    v45 = 2;
    v46 = 0x20000;
    v47 = 0x40000;
    v13 = (v34 & *(&v45 + a9)) == 0;
    v42 = 4 * a9;
    if(v13) {
        v18 = v49;
    }
    else {
        v14 = v51;
        v15 = v51 <= 1;
        v51 = 1;
        if(!v15) {
            do
                v51 *= 2;
            while(v51 < v14);
        }
        v16 = v11;
        v15 = v11 <= 1;
        v11 = 1;
        v50 = 1;
        if(!v15) {
            do
                v11 *= 2;
            while(v11 < v16);
            v50 = v11;
        }
        v17 = v49;
        v15 = v49 <= 1;
        v18 = 1;
        v49 = 1;
        if(!v15) {
            do
                v18 *= 2;
            while(v18 < v17);
            v49 = v18;
        }
    }
    if(a7) {
        v19 = *a7;
        if(*a7 == 827611204 || v19 == 844388420 || v19 == 861165636 || v19 == 877942852 || v19 == 894720068) {
            v11 = (v11 + 3) & 0xFFFFFFFC;
            v51 = (v51 + 3) & 0xFFFFFFFC;
            v50 = v11;
        }
    }
    v45 = 0x4000;
    v46 = 0x10000;
    v47 = 0x8000;
    if(a5)
        v48 = *a5;
    else
        v48 = -1;
    if((v34 & *(&v45 + a9)) == 0
       || (v20 = v51, ((v51 - 1) & v51) != 0)
       || ((v11 - 1) & v11) != 0
       || ((v18 - 1) & v18) != 0) {
        v48 = 1;
    }
    else {
        v21 = 1;
        while(v20 && (v20 & 1) == 0) {
            v20 >>= 1;
            ++v21;
        }
        v22 = 1;
        for(i = v11; i; ++v22) {
            if((i & 1) != 0)
                break;
            i >>= 1;
        }
        v24 = 1;
        for(j = v18; j; ++v24) {
            if((j & 1) != 0)
                break;
            j >>= 1;
        }
        v26 = v21;
        if(v21 <= v22)
            v26 = v22;
        if(a9 == 2 && v24 > v26)
            v26 = v24;
        if(v48 > v26 || !v48)
            v48 = v26;
    }
    v45 = 3;
    v46 = 5;
    v47 = 4;
    if(a7)
        v52 = *a7;
    else
        v52 = 0;
    v44 = 0;
    v41 = sub_43F778(v52);
    v27 = -1;
    v28 = (int*) &unk_4786D8;
    if(off_478B88 > &unk_4786D8) {
        do {
            if(v28 [9]
               && (*(int(__stdcall**)(int, int, int, int, int, _DWORD, int))(*(_DWORD*) v43 + 40))(
               v43,
               v33 [1],
               v33 [0],
               v40,
               a6,
               *(int*) ((char*) &v45 + v42),
               *v28) >= 0) {
                v29 = *v28;
                if(*v28 == v52) {
                    v44 = v52;
                    break;
                }
                if(v28 [8]) {
                    v30 = sub_43F79C((int) v41, v28);
                    if(v30 < v27 || v30 == v27 && (unsigned int) v28 [2] < v32 [2]) {
                        v44 = v29;
                        qmemcpy(v32, v28, sizeof(v32));
                        v27 = v30;
                    }
                }
            }
            v28 += 10;
        }
        while(v28 < off_478B88);
    }
    (*(void(__stdcall**)(int))(*(_DWORD*) v43 + 8))(v43);
    v31 = v44;
    if(!v44)
        return -2005530518;
    if(a2)
        *a2 = v51;
    if(a3)
        *a3 = v50;
    if(a4)
        *a4 = v49;
    if(a5)
        *a5 = v48;
    if(a7)
        *a7 = v31;
    return 0;
}
// 478B88: using guessed type void *off_478B88;
// 43F81C: using guessed type char var_38[12];

//----- (0043FBFE) --------------------------------------------------------
int __stdcall sub_43FBFE(int a1, int a2, int* a3, int a4, int a5, int a6, int a7, int* a8, float* a9, int a10) {
    int v10; // edi
    int v11; // esi
    int v13; // ecx
    int v14; // ecx
    int v15; // ebx
    int v16; // eax
    int v17 [19]; // [esp+Ch] [ebp-8Ch] BYREF
    int v18 [19]; // [esp+58h] [ebp-40h] BYREF
    int v19 [6]; // [esp+A4h] [ebp+Ch] BYREF
    unsigned int v20; // [esp+BCh] [ebp+24h]
    unsigned int v21; // [esp+C0h] [ebp+28h]
    float* v22 [3]; // [esp+C4h] [ebp+2Ch] BYREF
    int v23 [2]; // [esp+D0h] [ebp+38h] BYREF
    int v24; // [esp+D8h] [ebp+40h] BYREF
    int v25; // [esp+DCh] [ebp+44h]
    unsigned int v26; // [esp+E0h] [ebp+48h]
    unsigned int v27; // [esp+E4h] [ebp+4Ch]
    int v28; // [esp+F8h] [ebp+60h]

    sub_440F0A(v22);
    v10 = a1;
    if(!a1 || !a4 || !a8)
        goto LABEL_2;
    if(a9 == (float*) -1)
        a9 = (float*) (2 * (sub_43F778(a5) [1] != 3) + 524290);
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) a1 + 32))(a1, v19);
    if(!a3) {
        v26 = v20;
        v24 = 0;
        v25 = 0;
        v27 = v21;
        goto LABEL_15;
    }
    v24 = *a3;
    v25 = a3 [1];
    v26 = a3 [2];
    v27 = a3 [3];
    if(v24 < 0 || v26 > v20 || v24 > (int) v26 || v25 < 0 || v27 > v21 || v25 > (int) v27) {
        LABEL_2:
        v11 = -2005530516;
        LABEL_32:
        sub_440F14(v22);
        return v11;
    }
    v10 = a1;
    LABEL_15:
    if(v19 [0] != 827611204
       && v19 [0] != 844388420
       && v19 [0] != 844715353
       && v19 [0] != 861165636
       && v19 [0] != 877942852
       && v19 [0] != 894720068
       && v19 [0] != 1498831189) {
        v28 = (*(int(__stdcall**)(int, int*, int*, _DWORD))(*(_DWORD*) v10 + 36))(v10, v23, &v24, 0);
        if(v28 < 0) {
            sub_440F14(v22);
            return v28;
        }
        v26 -= v24;
        v27 -= v25;
        v24 = 0;
        v25 = 0;
        goto LABEL_26;
    }
    v16 = (*(int(__stdcall**)(int, int*, _DWORD, _DWORD))(*(_DWORD*) v10 + 36))(v10, v23, 0, 0);
    if(v16 < 0) {
        v11 = v16;
        goto LABEL_32;
    }
    LABEL_26:
    v18 [10] = v24;
    v18 [11] = v25;
    v18 [12] = v26;
    v18 [13] = v27;
    v18 [0] = v23 [1];
    v17 [0] = a4;
    v18 [2] = v23 [0];
    v17 [2] = a6;
    v18 [1] = v19 [0];
    v17 [1] = a5;
    v18 [18] = a2;
    v17 [17] = a10;
    v18 [6] = v20;
    v17 [18] = a7;
    v13 = *a8;
    v18 [7] = v21;
    v17 [10] = v13;
    v17 [11] = a8 [1];
    v14 = a8 [2];
    v18 [9] = 1;
    v18 [15] = 1;
    v17 [15] = 1;
    v17 [12] = v14;
    v17 [13] = a8 [3];
    memset(&v18 [3], 0, 12);
    v18 [17] = 0;
    v18 [8] = 0;
    v18 [14] = 0;
    v17 [3] = 0;
    v17 [14] = 0;
    v15 = sub_44411A(v22, (float*) v18, (float*) v17, a9);
    if(v15 >= 0)
        v15 = 0;
    (*(void(__stdcall**)(int))(*(_DWORD*) v10 + 40))(v10);
    sub_440F14(v22);
    return v15;
}
// 43FBFE: using guessed type int var_44[6];

//----- (0043FE34) --------------------------------------------------------
int __stdcall sub_43FE34(int a1, unsigned int* a2, unsigned int* a3, int* a4, int a5, int* a6, unsigned int a7) {
    return sub_43F81C(a1, a2, a3, 0, a4, a5, a6, a7, 0);
}

//----- (0043FE5C) --------------------------------------------------------
int __stdcall sub_43FE5C(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8) {
    int result; // eax
    int v9; // edi

    if(!a1 || !a8)
        return -2005530516;
    v9 = a5;
    if(a5 == -1)
        v9 = 0;
    result = sub_43FE34(a1, (unsigned int*) &a2, (unsigned int*) &a3, &a4, v9, &a6, a7);
    if(result >= 0) {
        result = (*(int(__stdcall**)(int, int, int, int, int, int, unsigned int, int))(*(_DWORD*) a1 + 80))(
            a1,
            a2,
            a3,
            a4,
            v9,
            a6,
            a7,
            a8);
        if(result >= 0)
            return 0;
    }
    return result;
}

//----- (0043FEC2) --------------------------------------------------------
int __stdcall sub_43FEC2(
    int a1,
    int a2,
    int* a3,
    unsigned __int8* a4,
    unsigned int a5,
    int* a6,
    float* a7,
    int a8,
    _DWORD* a9) {
    int v9; // eax
    int v10; // esi
    int v12 [5]; // [esp+Ch] [ebp-40h] BYREF
    int v13; // [esp+20h] [ebp-2Ch]
    int v14; // [esp+24h] [ebp-28h]
    int v15; // [esp+28h] [ebp-24h]
    int v16; // [esp+3Ch] [ebp-10h] BYREF
    int v17; // [esp+40h] [ebp-Ch]
    int v18; // [esp+44h] [ebp-8h]
    int v19; // [esp+48h] [ebp-4h]

    sub_44422C(v12);
    if(!a1 || !a4 || !a5)
        goto LABEL_13;
    v9 = sub_445B24((int) v12, a4, a5, a9);
    if(v9 >= 0) {
        if(a6) {
            v16 = *a6;
            v17 = a6 [1];
            v18 = a6 [2];
            v19 = a6 [3];
            if(v16 < 0 || v18 > v13 || v16 > v18 || v17 < 0 || v19 > v14 || v17 > v19) {
                LABEL_13:
                v10 = -2005530516;
                goto LABEL_14;
            }
        }
        else {
            v16 = v12 [3];
            v17 = v12 [4];
            v18 = v13;
            v19 = v14;
        }
        v9 = sub_43FBFE(a1, a2, a3, v12 [1], v12 [0], v12 [2], v15, &v16, a7, a8);
        if(v9 >= 0) {
            v10 = 0;
            goto LABEL_14;
        }
    }
    v10 = v9;
    LABEL_14:
    sub_444245((int) v12);
    return v10;
}

//----- (0043FF78) --------------------------------------------------------
int __stdcall sub_43FF78(int a1, int a2, int* a3, int a4, int a5, int* a6, float* a7, int a8) {
    int result; // eax
    int v9; // esi
    int v10 [6]; // [esp+Ch] [ebp-38h] BYREF
    unsigned int v11; // [esp+24h] [ebp-20h]
    unsigned int v12; // [esp+28h] [ebp-1Ch]
    int v13; // [esp+2Ch] [ebp-18h] BYREF
    int v14; // [esp+30h] [ebp-14h]
    unsigned int v15; // [esp+34h] [ebp-10h]
    unsigned int v16; // [esp+38h] [ebp-Ch]
    int v17 [2]; // [esp+3Ch] [ebp-8h] BYREF

    if(!a1 || !a4)
        return -2005530516;
    (*(void(__stdcall**)(int, int*))(*(_DWORD*) a4 + 32))(a4, v10);
    if(a6) {
        v13 = *a6;
        v14 = a6 [1];
        v15 = a6 [2];
        v16 = a6 [3];
        if(v13 < 0 || v15 > v11 || v13 > (int) v15 || v14 < 0 || v16 > v12 || v14 > (int) v16)
            return -2005530516;
    }
    else {
        v15 = v11;
        v13 = 0;
        v14 = 0;
        v16 = v12;
    }
    if(v10 [0] == 827611204
       || v10 [0] == 844388420
       || v10 [0] == 844715353
       || v10 [0] == 861165636
       || v10 [0] == 877942852
       || v10 [0] == 894720068
       || v10 [0] == 1498831189) {
        result = (*(int(__stdcall**)(int, int*, _DWORD, int))(*(_DWORD*) a4 + 36))(a4, v17, 0, 16);
        if(result < 0)
            return result;
    }
    else {
        result = (*(int(__stdcall**)(int, int*, int*, int))(*(_DWORD*) a4 + 36))(a4, v17, &v13, 16);
        if(result < 0)
            return result;
        v15 -= v13;
        v16 -= v14;
        v13 = 0;
        v14 = 0;
    }
    v9 = sub_43FBFE(a1, a2, a3, v17 [1], v10 [0], v17 [0], a5, &v13, a7, a8);
    if(v9 >= 0)
        v9 = 0;
    (*(void(__stdcall**)(int))(*(_DWORD*) a4 + 40))(a4);
    return v9;
}
// 43FF78: using guessed type int var_38[6];

//----- (00440095) --------------------------------------------------------
int __stdcall sub_440095(int a1, int a2, unsigned int a3, float* a4) {
    int v4; // esi
    unsigned int v5; // eax
    unsigned int v6; // ebx
    int v8; // edi
    unsigned int v9; // ebx
    int v10 [8]; // [esp+Ch] [ebp-2Ch] BYREF
    unsigned int v11; // [esp+2Ch] [ebp-Ch]
    int v12; // [esp+30h] [ebp-8h]
    int v13; // [esp+34h] [ebp-4h] BYREF

    v4 = a1;
    if(!a1)
        return -2005530516;
    if(a4 == (float*) -1) {
        (*(void(__stdcall**)(int, _DWORD, int*))(*(_DWORD*) a1 + 56))(a1, 0, v10);
        a4 = (float*) (sub_43F778(v10 [0]) [1] != 3 ? 5 : 2);
    }
    v5 = (*(int(__stdcall**)(int))(*(_DWORD*) v4 + 52))(v4);
    v6 = a3;
    v11 = v5;
    if(a3 == -1)
        v6 = 0;
    if(v6 >= v5)
        return -2005530516;
    v13 = 0;
    a1 = 0;
    if((unsigned __int8) a4 == 2 || (v12 = 0, (unsigned __int8) a4 == 5))
        v12 = 1;
    v8 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*) v4 + 60))(v4, v6, &v13);
    if(v8 >= 0) {
        v9 = v6 + 1;
        a3 = v9;
        if(v9 < v11) {
            while(1) {
                v8 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*) v4 + 60))(v4, v9, &a1);
                if(v8 < 0)
                    goto LABEL_26;
                v8 = sub_43FF78(a1, a2, 0, v13, a2, 0, a4, 0);
                if(v8 < 0)
                    goto LABEL_26;
                if(v12) {
                    if(v13)
                        (*(void(__stdcall**)(int))(*(_DWORD*) v13 + 8))(v13);
                    v13 = a1;
                }
                else {
                    if(!a1)
                        goto LABEL_24;
                    (*(void(__stdcall**)(int))(*(_DWORD*) a1 + 8))(a1);
                }
                a1 = 0;
                LABEL_24:
                if(++a3 >= v11)
                    break;
                v9 = a3;
            }
        }
        v8 = 0;
    }
    LABEL_26:
    if(v13) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v13 + 8))(v13);
        v13 = 0;
    }
    if(a1)
        (*(void(__stdcall**)(int))(*(_DWORD*) a1 + 8))(a1);
    return v8;
}
// 440095: using guessed type int var_2C[8];

//----- (004401C6) --------------------------------------------------------
int __stdcall sub_4401C6(
    int a1,
    unsigned __int8* a2,
    unsigned int a3,
    int a4,
    int a5,
    unsigned int a6,
    int a7,
    unsigned int a8,
    unsigned int a9,
    float* a10,
    float* a11,
    int a12,
    int a13,
    int* a14,
    int* a15) {
    int v15; // esi
    int v16; // eax
    int v18; // eax
    int v19; // esi
    int v20; // ebx
    unsigned int v21; // edx
    int v22; // ecx
    int v23; // eax
    unsigned int v24; // ecx
    _BYTE* v25; // eax
    int v26; // edi
    BOOL v27; // eax
    int* v28; // esi
    int v29; // ecx
    int v30 [256]; // [esp+8h] [ebp-43Ch] BYREF
    int v31 [7]; // [esp+408h] [ebp-3Ch] BYREF
    int v32; // [esp+424h] [ebp-20h]
    int v33; // [esp+430h] [ebp-14h]
    int v34; // [esp+438h] [ebp-Ch] BYREF
    int v35; // [esp+43Ch] [ebp-8h] BYREF
    int v36; // [esp+440h] [ebp-4h] BYREF
    int v37; // [esp+450h] [ebp+Ch]
    unsigned int v38; // [esp+454h] [ebp+10h]

    sub_44422C(v31);
    v36 = 0;
    v35 = 0;
    v34 = 0;
    if(!a1 || !a2 || !a3 || !a15) {
        v15 = -2005530516;
        LABEL_8:
        sub_444245((int) v31);
        return v15;
    }
    v16 = sub_445B24((int) v31, a2, a3, (_DWORD*) a13);
    if(v16 < 0) {
        v15 = v16;
        goto LABEL_8;
    }
    v18 = v33;
    v38 = 1;
    while(v18) {
        ++v38;
        v18 = *(_DWORD*) (v18 + 40);
    }
    if(!a4 || a4 == -1)
        a4 = v31 [5];
    if(!a5 || a5 == -1)
        a5 = v31 [6];
    v19 = a12;
    v20 = v31 [0];
    if(!a8) {
        if(!a12) {
            a8 = 22;
            if(v31 [0] == 20)
                goto LABEL_32;
            goto LABEL_31;
        }
        if(v31 [0] != 20) {
            if(v31 [0] <= 21) {
                LABEL_31:
                a8 = v31 [0];
                goto LABEL_32;
            }
            if(v31 [0] > 23) {
                if(v31 [0] == 24 || v31 [0] == 27 || v31 [0] == 30) {
                    a8 = 25;
                    goto LABEL_32;
                }
                if(v31 [0] == 50) {
                    a8 = 51;
                    goto LABEL_32;
                }
                goto LABEL_31;
            }
        }
        a8 = 21;
    }
    LABEL_32:
    if(a10 == (float*) -1)
        a10 = (float*) (2 * (sub_43F778(v31 [0]) [1] != 3) + 524290);
    if(a11 == (float*) -1)
        a11 = (float*) (sub_43F778(v20) [1] != 3 ? 5 : 2);
    if((_BYTE) a10 == 1 || (unsigned __int8) a11 == 2 || (a13 = 0, (unsigned __int8) a11 == 5))
        a13 = 1;
    if(v32) {
        a12 = v19 & 0xFF00FF00 | ((unsigned __int8) v19 << 16) | BYTE2(a12);
        v21 = 0;
        v22 = v32 - (_DWORD) v30;
        do {
            v23 = *(int*) ((char*) &v30 [v21] + v22);
            if(v23 == a12)
                v30 [v21] = 0;
            else
                v30 [v21] = v23;
            ++v21;
        }
        while(v21 < 0x100);
        a12 = 0;
    }
    else {
        memset(v30, 0xFFu, sizeof(v30));
    }
    if(!a14) {
        if(a8 != 40) {
            if(a8 != 41)
                goto LABEL_57;
            v24 = 0;
            a8 = 22;
            v25 = (_BYTE*) (v32 + 3);
            while(*v25 == 0xFF) {
                ++v24;
                v25 += 4;
                if(v24 >= 0x100)
                    goto LABEL_57;
            }
        }
        a8 = 21;
        goto LABEL_57;
    }
    qmemcpy(a14, v30, 0x400u);
    LABEL_57:
    v26 = sub_43FE34(a1, (unsigned int*) &a4, (unsigned int*) &a5, (int*) &a6, a7, (int*) &a8, a9);
    if(v26 < 0)
        goto LABEL_76;
    v26 = (*(int(__stdcall**)(int, int, int, unsigned int, int, unsigned int, unsigned int, int*))(*(_DWORD*) a1 + 80))(
        a1,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        &v35);
    if(v26 < 0)
        goto LABEL_76;
    v37 = v35;
    v27 = a9 == 0;
    a9 = v27;
    if(v27) {
        v26 = (*(int(__stdcall**)(int, int, int, unsigned int, _DWORD, unsigned int, int, int*))(*(_DWORD*) a1 + 80))(
            a1,
            a4,
            a5,
            a6,
            0,
            a8,
            2,
            &v34);
        if(v26 < 0)
            goto LABEL_76;
        v37 = v34;
    }
    a8 = 0;
    v28 = v31;
    if(v38) {
        while(a8 < a6) {
            v26 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*) v37 + 60))(v37, a8, &v36);
            if(v26 < 0)
                goto LABEL_76;
            v26 = sub_43FBFE(v36, (int) a14, 0, v28 [1], *v28, v28 [2], (int) v30, v28 + 3, a10, a12);
            if(v36) {
                (*(void(__stdcall**)(int))(*(_DWORD*) v36 + 8))(v36);
                v36 = 0;
            }
            if(v26 < 0)
                goto LABEL_76;
            if(++a8 >= v38)
                break;
            v28 = (int*) v28 [10];
        }
    }
    if(!a13) {
        while(a8 < a6) {
            v26 = (*(int(__stdcall**)(int, unsigned int, int*))(*(_DWORD*) v37 + 60))(v37, a8, &v36);
            if(v26 < 0)
                goto LABEL_76;
            v26 = sub_43FBFE(v36, (int) a14, 0, v28 [1], *v28, v28 [2], (int) v30, v28 + 3, a11, a12);
            if(v36) {
                (*(void(__stdcall**)(int))(*(_DWORD*) v36 + 8))(v36);
                v36 = 0;
            }
            if(v26 < 0)
                goto LABEL_76;
            ++a8;
        }
        goto LABEL_73;
    }
    if(v38 >= a6 || (v26 = sub_440095(v37, (int) v30, v38 - 1, a11), v26 >= 0)) {
        LABEL_73:
        if(!a9 || (v26 = (*(int(__stdcall**)(int, int, int))(*(_DWORD*) a1 + 116))(a1, v34, v35), v26 >= 0)) {
            v29 = v35;
            v35 = 0;
            *a15 = v29;
            v26 = 0;
        }
    }
    LABEL_76:
    if(v36) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v36 + 8))(v36);
        v36 = 0;
    }
    if(v35) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v35 + 8))(v35);
        v35 = 0;
    }
    if(v34) {
        (*(void(__stdcall**)(int))(*(_DWORD*) v34 + 8))(v34);
        v34 = 0;
    }
    sub_444245((int) v31);
    return v26;
}
// 4401C6: using guessed type int var_43C[256];

//----- (004405D7) --------------------------------------------------------
void __thiscall sub_4405D7(_DWORD* this) {
    void* v2; // eax
    _DWORD* v3; // ecx
    int v4; // esi

    v2 = (void*) this [2];
    *this = &off_46D034;
    if(v2)
        DeleteObject(v2);
    v3 = (_DWORD*) this [18];
    if(v3)
        sub_445FB7(v3);
    v4 = this [19];
    if(v4)
        (*(void(__stdcall**)(int))(*(_DWORD*) v4 + 8))(v4);
}
// 46D034: using guessed type int (__stdcall *off_46D034)(int, int, int);

//----- (00440609) --------------------------------------------------------
int __stdcall sub_440609(int a1) {
    return ++ * (_DWORD*) (a1 + 4);
}

//----- (00440616) --------------------------------------------------------
int __thiscall sub_440616(_DWORD* this, int a2, LOGFONTA* lplf) {
    int result; // eax
    HFONT FontIndirectA; // eax

    if(!a2 || !lplf)
        return -2005530516;
    result = sub_445FCC(a2, this + 18);
    if(result >= 0) {
        FontIndirectA = CreateFontIndirectA(lplf);
        this [2] = FontIndirectA;
        if(FontIndirectA) {
            this [19] = a2;
            (*(void(__stdcall**)(int))(*(_DWORD*) a2 + 4))(a2);
            return 0;
        }
        else {
            return -2147024882;
        }
    }
    return result;
}

//----- (00440668) --------------------------------------------------------
int __stdcall sub_440668(int a1, _DWORD* a2) {
    if(!a2)
        return -2005530516;
    *a2 = *(_DWORD*) (a1 + 76);
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 76) + 4))(*(_DWORD*) (a1 + 76));
    return 0;
}

//----- (0044068E) --------------------------------------------------------
int __stdcall sub_44068E(int a1, void* a2) {
    if(!a2)
        return -2005530516;
    qmemcpy(a2, (const void*) (a1 + 12), 0x3Cu);
    return 0;
}

//----- (004406B2) --------------------------------------------------------
int __stdcall sub_4406B2(int a1) {
    return sub_445F45(*(_DWORD*) (a1 + 72));
}

//----- (004406C1) --------------------------------------------------------
int __stdcall sub_4406C1(int a1) {
    return sub_445F87(*(_DWORD*) (a1 + 72));
}

//----- (004406D0) --------------------------------------------------------
HGDIOBJ __stdcall sub_4406D0(int a1, LPCWCH lpWideCharStr, int cchWideChar, int* a4, UINT format, int a6) {
    return sub_446048(*(_DWORD*) (a1 + 72), *(HGDIOBJ*) (a1 + 8), lpWideCharStr, cchWideChar, a4, format, a6, 0);
}

//----- (004406F6) --------------------------------------------------------
HGDIOBJ __stdcall sub_4406F6(int a1, LPCWCH lpWideCharStr, int cchWideChar, int* a4, UINT format, int a6) {
    return sub_446048(*(_DWORD*) (a1 + 72), *(HGDIOBJ*) (a1 + 8), lpWideCharStr, cchWideChar, a4, format, a6, (LPSTR) 1);
}

//----- (0044071C) --------------------------------------------------------
int __stdcall sub_44071C(int a1, const void* a2, _DWORD* a3) {
    if(memcmp(a2, &unk_46D0D8, 0x10u) && memcmp(a2, &unk_46FEE0, 0x10u))
        return -2147467262;
    *a3 = a1;
    (*(void(__stdcall**)(int))(*(_DWORD*) a1 + 4))(a1);
    return 0;
}

//----- (00440760) --------------------------------------------------------
int __stdcall sub_440760(_DWORD* Block) {
    bool v1; // zf
    int result; // eax

    v1 = Block [1]-- == 1;
    result = Block [1];
    if(v1) {
        sub_4405D7(Block);
        j__free(Block);
        return 0;
    }
    return result;
}

//----- (00440781) --------------------------------------------------------
_DWORD* __thiscall sub_440781(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    *this = &off_46D034;
    this [1] = 1;
    this [2] = 0;
    this [18] = 0;
    this [19] = 0;
    return result;
}
// 46D034: using guessed type int (__stdcall *off_46D034)(int, int, int);

//----- (0044079C) --------------------------------------------------------
int __thiscall sub_44079C(_DWORD* this) {
    int result; // eax

    result = this [2];
    *this = &off_46D058;
    if(result) {
        if(this [5])
            (*(void(__stdcall**)(int, _DWORD))(*(_DWORD*) result + 224))(result, this [5]);
        if(this [4])
            (*(void(__stdcall**)(_DWORD, _DWORD))(*(_DWORD*) this [2] + 224))(this [2], this [4]);
        return (*(int(__stdcall**)(_DWORD))(*(_DWORD*) this [2] + 8))(this [2]);
    }
    return result;
}
// 46D058: using guessed type int (__stdcall *off_46D058)(int, int, int);

//----- (004407DC) --------------------------------------------------------
int __userpurge sub_4407DC(int a1, int a2, int a3, int a4) {
    int result; // eax
    int v6; // ecx
    int v9; // [esp+19Ch] [ebp-E0h]
    int v10; // [esp+1A0h] [ebp-DCh]
    unsigned int i; // [esp+1A4h] [ebp-D8h]
    char v12 [4]; // [esp+1A8h] [ebp-D4h] BYREF
    int v13; // [esp+1ACh] [ebp-D0h]
    char v14; // [esp+1DCh] [ebp-A0h]
    char v15; // [esp+1E0h] [ebp-9Ch]

    if(!a4)
        return -2005530516;
    *(_DWORD*) (a1 + 8) = a4;
    (*(void(__stdcall**)(int))(*(_DWORD*) a4 + 4))(a4);
    result = (*(int(__stdcall**)(_DWORD, char*))(**(_DWORD**) (a1 + 8) + 28))(*(_DWORD*) (a1 + 8), v12);
    if(result >= 0) {
        for(i = 0; i < 2; ++i) {
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 208))(*(_DWORD*) (a1 + 8), a3, a2);
            (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**) (a1 + 8) + 304))(*(_DWORD*) (a1 + 8), 324);
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 128, 0);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 8, 3);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 22, 1);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 136, 1);
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 151, 0);
            (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 167, 0);
            (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 164, 1);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 1, 4);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 2, 2);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 3, 0);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 4, 4);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 5, 2);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 6, 0);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 1, 1, 1);
            (*(void(__stdcall**)(_DWORD, int, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 1, 4, 1);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 16, 2);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 17, 2);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 18, 0);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 11, 0);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 13, 3);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, int))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 14, 3);
            (*(void(__stdcall**)(_DWORD, _DWORD, int, _DWORD))(**(_DWORD**) (a1 + 8) + 252))(*(_DWORD*) (a1 + 8), 0, 24, 0);
            if((v14 & 0x10) != 0 && (v15 & 0x20) != 0) {
                (*(void(__stdcall**)(_DWORD, int, int, int, int))(**(_DWORD**) (a1 + 8) + 200))(
                    *(_DWORD*) (a1 + 8),
                    27,
                    1,
                    v9,
                    v10);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 19, 5);
                v10 = 6;
                v9 = 20;
            }
            else {
                (*(void(__stdcall**)(_DWORD, int, int, int, int))(**(_DWORD**) (a1 + 8) + 200))(
                    *(_DWORD*) (a1 + 8),
                    15,
                    1,
                    v9,
                    v10);
                (*(void(__stdcall**)(_DWORD, int, int))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 25, 7);
                v10 = 127;
                v9 = 24;
            }
            (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8));
            if(v13) {
                v6 = a1 + 20;
            }
            else {
                (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD))(**(_DWORD**) (a1 + 8) + 244))(*(_DWORD*) (a1 + 8), 0, 0);
                (*(void(__stdcall**)(_DWORD, _DWORD, _DWORD, _DWORD))(**(_DWORD**) (a1 + 8) + 332))(
                    *(_DWORD*) (a1 + 8),
                    0,
                    0,
                    0);
                v6 = a1 + 16;
            }
            a2 = v6;
            a3 = *(_DWORD*) (a1 + 8);
            (*(void (**)(void))(*(_DWORD*) a3 + 212))();
        }
        return 0;
    }
    return result;
}
// 4407DC: could not find valid save-restore pair for ebx
// 4407DC: could not find valid save-restore pair for ebp
// 4409C3: variable 'v9' is possibly undefined
// 4409C3: variable 'v10' is possibly undefined
// 4407DC: using guessed type char var_D4[4];

//----- (00440A63) --------------------------------------------------------
int __stdcall sub_440A63(int a1, _DWORD* a2) {
    if(!a2)
        return -2005530516;
    *a2 = *(_DWORD*) (a1 + 8);
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (a1 + 8) + 4))(*(_DWORD*) (a1 + 8));
    return 0;
}

//----- (00440A89) --------------------------------------------------------
int __stdcall sub_440A89(int a1) {
    if(*(_DWORD*) (a1 + 12))
        return -2147467259;
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (a1 + 8) + 220))(*(_DWORD*) (a1 + 8), *(_DWORD*) (a1 + 16));
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (a1 + 8) + 216))(*(_DWORD*) (a1 + 8), *(_DWORD*) (a1 + 20));
    *(_DWORD*) (a1 + 12) = 1;
    return 0;
}

//----- (00440AC6) --------------------------------------------------------
int __stdcall sub_440AC6(int a1) {
    if(!*(_DWORD*) (a1 + 12))
        return -2147467259;
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (a1 + 8) + 216))(*(_DWORD*) (a1 + 8), *(_DWORD*) (a1 + 16));
    *(_DWORD*) (a1 + 12) = 0;
    return 0;
}

//----- (00440AF1) --------------------------------------------------------
int __stdcall sub_440AF1(int a1, const void* a2, _DWORD* a3) {
    if(memcmp(a2, &unk_46D0C8, 0x10u) && memcmp(a2, &unk_46FEE0, 0x10u))
        return -2147467262;
    *a3 = a1;
    (*(void(__stdcall**)(int))(*(_DWORD*) a1 + 4))(a1);
    return 0;
}

//----- (00440B35) --------------------------------------------------------
int __stdcall sub_440B35(_DWORD* Block) {
    bool v1; // zf
    int result; // eax

    v1 = Block [1]-- == 1;
    result = Block [1];
    if(v1) {
        sub_44079C(Block);
        j__free(Block);
        return 0;
    }
    return result;
}

//----- (00440B56) --------------------------------------------------------
int __stdcall sub_440B56(int a1, int a2, int a3, int* a4, int* a5, float a6, int* a7, int a8) {
    double v8; // st7
    float* v9; // eax
    char v11 [64]; // [esp+8h] [ebp-74h] BYREF
    float v12 [4]; // [esp+48h] [ebp-34h] BYREF
    int v13 [3]; // [esp+58h] [ebp-24h] BYREF
    int v14 [3]; // [esp+64h] [ebp-18h] BYREF
    int v15 [3]; // [esp+70h] [ebp-Ch] BYREF

    if(a4) {
        v13 [0] = *a4;
        *(float*) &v13 [2] = 1.0;
        v13 [1] = a4 [1];
    }
    if(a5) {
        v14 [0] = *a5;
        *(float*) &v14 [2] = 0.0;
        v14 [1] = a5 [1];
    }
    v8 = a6;
    if(a6 != 0.0) {
        v12 [0] = 0.0;
        v12 [1] = 0.0;
        v12 [2] = sin(-0.5 * v8);
        v12 [3] = cos(-0.5 * v8);
    }
    if(a7) {
        v15 [0] = *a7;
        *(float*) &v15 [2] = 0.0;
        v15 [1] = a7 [1];
    }
    if(v8 == 0.0)
        v9 = 0;
    else
        v9 = v12;
    sub_43F362((int) v11, 0, 0, a4 != 0 ? v13 : 0, a5 != 0 ? (float*) v14 : 0, v9, a7 != 0 ? (float*) v15 : 0);
    return (*(int(__stdcall**)(int, int, int, char*, int))(*(_DWORD*) a1 + 24))(a1, a2, a3, v11, a8);
}

//----- (00440C2D) --------------------------------------------------------
int __stdcall sub_440C2D(int a1, int a2, int* a3, float* a4, int a5) {
    int v5; // ecx
    int v6; // edx
    int v7; // eax
    int v8; // esi
    int result; // eax
    double v10; // st5
    double v11; // st4
    float* v12; // esi
    int v13; // edi
    float* v14; // eax
    int v15; // ecx
    double v16; // st7
    int v17; // edi
    BOOL v18; // ebx
    float v19; // [esp+Ch] [ebp-4Ch] BYREF
    float v20 [4]; // [esp+10h] [ebp-48h] BYREF
    __int64 v21; // [esp+20h] [ebp-38h]
    float v22; // [esp+28h] [ebp-30h]
    int v23; // [esp+2Ch] [ebp-2Ch]
    float v24; // [esp+30h] [ebp-28h]
    float v25; // [esp+34h] [ebp-24h]
    int v26; // [esp+38h] [ebp-20h]
    int v27; // [esp+3Ch] [ebp-1Ch]
    float v28; // [esp+40h] [ebp-18h]
    int v29; // [esp+44h] [ebp-14h]
    int v30; // [esp+48h] [ebp-10h]
    float v31; // [esp+4Ch] [ebp-Ch]
    float v32; // [esp+50h] [ebp-8h]
    int v33; // [esp+54h] [ebp-4h]
    int v34; // [esp+58h] [ebp+0h]
    float v35; // [esp+5Ch] [ebp+4h]
    int v36; // [esp+60h] [ebp+8h]
    float v37; // [esp+64h] [ebp+Ch]
    float v38; // [esp+68h] [ebp+10h]
    float v39; // [esp+6Ch] [ebp+14h]
    int v40; // [esp+70h] [ebp+18h]
    __int64 v41; // [esp+74h] [ebp+1Ch]
    int v42 [6]; // [esp+7Ch] [ebp+24h] BYREF
    int v43; // [esp+94h] [ebp+3Ch]
    int v44; // [esp+98h] [ebp+40h]
    __int64 v45; // [esp+9Ch] [ebp+44h]
    int v46; // [esp+A4h] [ebp+4Ch]
    int v47; // [esp+A8h] [ebp+50h]
    int v48; // [esp+ACh] [ebp+54h]
    int v49; // [esp+B0h] [ebp+58h]
    __int64 v50; // [esp+B4h] [ebp+5Ch]
    float v51; // [esp+CCh] [ebp+74h]
    float v52; // [esp+CCh] [ebp+74h]

    if(!a2)
        return -2005530516;
    (*(void(__stdcall**)(int, _DWORD, int*))(*(_DWORD*) a2 + 56))(a2, 0, v42);
    if(a3) {
        v46 = *a3;
        v47 = a3 [1];
        v48 = a3 [2];
        v49 = a3 [3];
        if(v46 < 0)
            return -2005530516;
        v5 = v48;
        if(v46 > v48)
            return -2005530516;
        v6 = v43;
        if(v46 > v43)
            return -2005530516;
        if(v47 < 0)
            return -2005530516;
        v7 = v49;
        if(v47 > v49)
            return -2005530516;
        v8 = v44;
        if(v47 > v44)
            return -2005530516;
    }
    else {
        v6 = v43;
        v8 = v44;
        v5 = v43;
        v7 = v44;
        *(float*) &v46 = 0.0;
        *(float*) &v47 = 0.0;
        v48 = v43;
        v49 = v44;
    }
    v51 = 1.0 / (double) (unsigned int) v6;
    v10 = 1.0 / (double) (unsigned int) v8;
    v11 = (double) v46 * v51;
    *(float*) &v45 = (double) v48 * v51;
    *((float*) &v45 + 1) = (double) v47 * v10;
    v52 = (double) v49 * v10;
    v19 = 0.0;
    *(float*) &v50 = v11;
    v20 [0] = 0.0;
    *((float*) &v50 + 1) = *((float*) &v45 + 1);
    v20 [1] = 0.0;
    v20 [2] = 1.0;
    *(float*) &v47 = (float) (v7 - v47);
    v21 = v50;
    LODWORD(v20 [3]) = a5;
    v22 = 0.0;
    *(float*) &v50 = v11;
    v23 = v47;
    v24 = 0.0;
    v25 = 1.0;
    *(float*) &v46 = (float) (v5 - v46);
    v27 = v50;
    v26 = a5;
    v28 = v52;
    v29 = v46;
    v30 = v47;
    v31 = 0.0;
    v32 = 1.0;
    *(float*) &v47 = 0.0;
    *(float*) &v48 = 0.0;
    v34 = v45;
    v35 = v52;
    *(float*) &v49 = 1.0;
    v33 = a5;
    v36 = v46;
    *(float*) &v50 = *(float*) &v45;
    v37 = 0.0;
    v38 = 0.0;
    HIDWORD(v50) = HIDWORD(v45);
    v39 = 1.0;
    v41 = v45;
    v40 = a5;
    if(a4) {
        v12 = &v19;
        v13 = 4;
        do {
            sub_43EBB2(v12, v12, a4);
            v12 += 7;
            --v13;
        }
        while(v13);
    }
    v14 = v20;
    v15 = 4;
    do {
        v16 = v14 [2] * 0.5;
        *(v14 - 1) = *(v14 - 1) - v16;
        *v14 = *v14 - v16;
        v14 += 7;
        --v15;
        *(v14 - 5) = 1.0 / *(v14 - 5);
    }
    while(v15);
    v17 = *(_DWORD*) (a1 + 12);
    v18 = (a5 & 0xFF000000) != -16777216;
    if((a5 & 0xFF000000) == -16777216) {
        if(v42 [0] <= 52) {
            if(v42 [0] < 51
               && v42 [0] != 21
               && (v42 [0] <= 24 || v42 [0] > 26 && (v42 [0] <= 27 || v42 [0] > 29 && (v42 [0] <= 39 || v42 [0] > 41)))) {
                goto LABEL_32;
            }
            LABEL_31:
            v18 = 1;
            goto LABEL_32;
        }
        if(v42 [0] == 844388420 || v42 [0] == 861165636 || v42 [0] == 877942852 || v42 [0] == 894720068)
            goto LABEL_31;
    }
    LABEL_32:
    if(v17 || (result = (*(int(__stdcall**)(int))(*(_DWORD*) a1 + 16))(a1), result >= 0)) {
        (*(void(__stdcall**)(_DWORD, _DWORD, int))(**(_DWORD**) (a1 + 8) + 244))(*(_DWORD*) (a1 + 8), 0, a2);
        (*(void(__stdcall**)(_DWORD, int, BOOL))(**(_DWORD**) (a1 + 8) + 200))(*(_DWORD*) (a1 + 8), 27, v18);
        (*(void(__stdcall**)(_DWORD, int, int, float*, int))(**(_DWORD**) (a1 + 8) + 288))(
            *(_DWORD*) (a1 + 8),
            6,
            2,
            &v19,
            28);
        if(v17)
            return 0;
        result = (*(int(__stdcall**)(int))(*(_DWORD*) a1 + 28))(a1);
        if(result >= 0)
            return 0;
    }
    return result;
}
// 440C2D: using guessed type int var_40[6];
// 440C2D: using guessed type float var_B0;
// 440C2D: using guessed type float var_94;

//----- (00440EEC) --------------------------------------------------------
_DWORD* __thiscall sub_440EEC(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    *this = &off_46D058;
    this [1] = 1;
    this [2] = 0;
    this [3] = 0;
    this [4] = 0;
    this [5] = 0;
    return result;
}
// 46D058: using guessed type int (__stdcall *off_46D058)(int, int, int);

//----- (00440F0A) --------------------------------------------------------
_DWORD* __thiscall sub_440F0A(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    this [1] = 0;
    *this = 0;
    return result;
}

//----- (00440F14) --------------------------------------------------------
int __thiscall sub_440F14(_DWORD* this) {
    int(__thiscall * **v2)(_DWORD, int); // ecx
    int result; // eax

    v2 = (int(__thiscall***)(_DWORD, int))this [1];
    if(v2)
        result = (**v2)(v2, 1);
    if(*this)
        return (**(int(__thiscall***)(_DWORD, int)) * this)(*this, 1);
    return result;
}

//----- (00440F32) --------------------------------------------------------
void __thiscall sub_440F32(int this) {
    void* v2; // esi

    j__free(*(void**) this);
    v2 = *(void**) (this + 8);
    if(v2) {
        sub_440F32(v2);
        j__free(v2);
    }
}

//----- (00440F54) --------------------------------------------------------
_DWORD* __cdecl sub_440F54(unsigned int a1, signed int a2, int a3) {
    double v3; // st7
    unsigned int v4; // edi
    size_t v5; // esi
    double v6; // st6
    __int64 v7; // rax
    _DWORD* v8; // edi
    int v9; // ebx
    int v10; // esi
    double v11; // st7
    double X; // st7
    int v13; // edx
    double v14; // st7
    int v15; // ecx
    float* v16; // eax
    double v17; // st6
    float* v18; // eax
    _DWORD* v20; // [esp+28h] [ebp-3Ch]
    int v21; // [esp+2Ch] [ebp-38h]
    float v22; // [esp+30h] [ebp-34h]
    float v23; // [esp+34h] [ebp-30h]
    float v24; // [esp+38h] [ebp-2Ch]
    float v25; // [esp+3Ch] [ebp-28h]
    int i; // [esp+40h] [ebp-24h]
    float v27; // [esp+44h] [ebp-20h]
    float v28; // [esp+48h] [ebp-1Ch]
    unsigned int v29; // [esp+4Ch] [ebp-18h]
    float v30; // [esp+50h] [ebp-14h]
    float v31; // [esp+54h] [ebp-10h]
    unsigned int v32; // [esp+58h] [ebp-Ch]
    float v33; // [esp+5Ch] [ebp-8h]
    float v34; // [esp+60h] [ebp-4h]

    if(a1) {
        if(a2) {
            v28 = (float) (unsigned int) a2;
            v3 = (double) a1;
            v4 = 0;
            v23 = v3;
            v5 = 16;
            v6 = v28 / v3;
            v25 = v6;
            v22 = 0.5 / v6;
            do {
                v7 = (__int64) (((double) v4 - 0.5) * v6 + v6 - ((double) v4 - 0.5) * v6 + (double) (a3 != 0) + 1.0);
                ++v4;
                v5 += 16 * v7 + 12;
            }
            while(v4 < a1);
            v8 = operator new(v5);
            if(v8) {
                v9 = 0;
                v29 = 0;
                v34 = 0.0;
                v10 = 1;
                while(1) {
                    v32 = 0;
                    v20 = &v8 [v10];
                    v21 = v10 * 4;
                    ++v10;
                    do {
                        v24 = (float) v29;
                        v11 = (double) v32 + v24 - 0.5;
                        v31 = v11;
                        X = v11 * v25;
                        v27 = X;
                        v33 = v25 + X;
                        if(!a3) {
                            if(X < 0.0) {
                                X = 0.0;
                                v27 = 0.0;
                            }
                            if(v33 > (double)v28)
                                v33 = (float) (unsigned int) a2;
                        }
                        v13 = (__int64) floor(X);
                        v14 = (double) v13;
                        if(v14 < v33) {
                            v15 = v13 - a2;
                            for(i = v13 - a2; ; v15 = i) {
                                v30 = v14 + 1.0;
                                if(v13 >= 0) {
                                    if(v13 < a2)
                                        v15 = v13;
                                }
                                else {
                                    v15 = v13 + a2;
                                }
                                if(v15 != v9) {
                                    if(v34 > 0.0000099999997) {
                                        v16 = (float*) &v8 [v10];
                                        *(_DWORD*) v16 = v9;
                                        v10 += 2;
                                        v16 [1] = v34;
                                    }
                                    v9 = v15;
                                    v34 = 0.0;
                                }
                                if(v14 < v27)
                                    v14 = v27;
                                if(v30 > (double)v33)
                                    v30 = v33;
                                if(a3)
                                    goto LABEL_33;
                                if(v31 < 0.0) {
                                    v17 = 1.0;
                                    goto LABEL_34;
                                }
                                if(v31 + 1.0 < v23)
                                    LABEL_33:
                                v17 = (v30 + v14) * v22 - v31;
                                else
                                    v17 = 0.0;
                                LABEL_34:
                                if(v32)
                                    v17 = 1.0 - v17;
                                ++v13;
                                ++i;
                                v34 = (v30 - v14) * v17 + v34;
                                v14 = (double) v13;
                                if(v14 >= v33)
                                    break;
                            }
                        }
                        ++v32;
                    }
                    while(v32 < 2);
                    if(v34 > 0.0000099999997) {
                        v18 = (float*) &v8 [v10];
                        v10 += 2;
                        *(_DWORD*) v18 = v9;
                        v18 [1] = v34;
                    }
                    v34 = 0.0;
                    ++v29;
                    *v20 = v10 * 4 - v21;
                    if(v29 >= a1) {
                        *v8 = v10 * 4;
                        return v8;
                    }
                }
            }
        }
    }
    return 0;
}
// 440FB1: conditional instruction was optimized away because %arg_0.4!=0
// 441017: conditional instruction was optimized away because %arg_0.4!=0

//----- (004411F5) --------------------------------------------------------
int __thiscall sub_4411F5(_DWORD* this) {
    _DWORD* v2; // edx
    int v3; // edi
    int v4; // ebx
    float* v5; // edi
    unsigned int v6; // ebx
    _DWORD* v7; // edi
    float* v8; // eax
    float* v9; // edi
    float* v10; // eax
    void** v11; // ebx
    void* v12; // eax
    float* v13; // edx
    float* v14; // eax
    float* v15; // ebx
    _DWORD* v16; // ecx
    float* v17; // eax
    double v18; // st7
    float* v19; // edi
    float* v20; // edi
    float* v21; // edi
    float* v22; // ebx
    float* v23; // edi
    double v24; // st7
    _DWORD* v25; // ecx
    unsigned int i; // ebx
    _DWORD** v27; // edi
    _DWORD* v28; // edi
    int v29; // esi
    unsigned int v31; // [esp+Ch] [ebp-38h]
    float* v32; // [esp+10h] [ebp-34h]
    float* v33; // [esp+14h] [ebp-30h]
    float* v34; // [esp+18h] [ebp-2Ch]
    float* v35; // [esp+1Ch] [ebp-28h]
    unsigned int v36; // [esp+20h] [ebp-24h]
    float* v37; // [esp+24h] [ebp-20h]
    int v38; // [esp+28h] [ebp-1Ch]
    float* v39; // [esp+2Ch] [ebp-18h]
    float* v40; // [esp+30h] [ebp-14h]
    int v41; // [esp+34h] [ebp-10h]
    void** v42; // [esp+38h] [ebp-Ch]
    _DWORD* Block; // [esp+3Ch] [ebp-8h]
    float* v44; // [esp+40h] [ebp-4h]
    unsigned int v45; // [esp+40h] [ebp-4h]

    v2 = (_DWORD*) this [1];
    v39 = 0;
    Block = 0;
    v42 = 0;
    v37 = 0;
    if(v2 [2] != 1)
        return -2147467259;
    v3 = *this;
    if(*(_DWORD*) (*this + 8) != 1 || v2 [1046] != 1 || *(_DWORD*) (v3 + 4184) != 1)
        return -2147467259;
    v4 = ((this [2] >> 17) & 1) == 0;
    v5 = (float*) sub_440F54(*(_DWORD*) (v3 + 4176), v2 [1044], (this [2] & 0x10000) == 0);
    v34 = v5;
    if(v5 && (v39 = (float*) sub_440F54(*(_DWORD*) (*this + 4180), *(_DWORD*) (this [1] + 4180), v4)) != 0) {
        v36 = (unsigned int) v5 + *(_DWORD*) v5;
        v6 = (unsigned int) v39 + *(_DWORD*) v39;
        v31 = v6;
        v7 = operator new(4 * *(_DWORD*) (this [1] + 4180));
        Block = v7;
        if(v7
           && (v41 = 0,
           memset(v7, 0, 4 * *(_DWORD*) (this [1] + 4180)),
           (v37 = (float*)operator new(16 * *(_DWORD*) (*this + 4176))) != 0)) {
            v38 = 0;
            v8 = v39 + 1;
            if((unsigned int) (v39 + 1) < v6) {
                do {
                    v9 = (float*) ((char*) v8 + *(_DWORD*) v8);
                    v10 = v8 + 1;
                    v40 = v9;
                    v35 = v10;
                    if(v10 < v9) {
                        v44 = v10;
                        do {
                            if(!Block [*(_DWORD*) v44]) {
                                v11 = v42;
                                if(v42) {
                                    v42 = (void**) v42 [2];
                                }
                                else {
                                    v11 = (void**)operator new(0xCu);
                                    if(!v11)
                                        goto LABEL_42;
                                    v12 = operator new(16 * *(_DWORD*) (this [1] + 4176));
                                    *v11 = v12;
                                    if(!v12) {
                                        sub_440F32((int) v11);
                                        j__free(v11);
                                        goto LABEL_42;
                                    }
                                }
                                memset(*v11, 0, 16 * *(_DWORD*) (this [1] + 4176));
                                *((float*) v11 + 1) = 0.0;
                                v11 [2] = 0;
                                ++v41;
                                v9 = v40;
                                Block [*(_DWORD*) v44] = v11;
                            }
                            v44 += 2;
                        }
                        while(v44 < v9);
                        (*(void(__thiscall**)(_DWORD, int, _DWORD, float*))(*(_DWORD*) *this + 4))(*this, v38, 0, v37);
                        v14 = v34 + 1;
                        if((unsigned int) (v34 + 1) < v36) {
                            v13 = v37 + 2;
                            do {
                                v15 = (float*) ((char*) v14 + *(_DWORD*) v14);
                                v32 = v15;
                                v45 = (unsigned int) v35;
                                v33 = v14 + 1;
                                do {
                                    v16 = (_DWORD*) Block [*(_DWORD*) v45];
                                    v17 = v33;
                                    if(v33 < v15) {
                                        do {
                                            v18 = v17 [1] * *(float*) (v45 + 4);
                                            *(float*) (*v16 + 16 * *(_DWORD*) v17) = v18 * *(v13 - 2) + *(float*) (*v16 + 16 * *(_DWORD*) v17);
                                            v19 = (float*) (16 * *(_DWORD*) v17 + *v16 + 4);
                                            *v19 = v18 * *(v13 - 1) + *v19;
                                            v20 = (float*) (16 * *(_DWORD*) v17 + *v16 + 8);
                                            *v20 = v18 * *v13 + *v20;
                                            v21 = (float*) (16 * *(_DWORD*) v17 + *v16 + 12);
                                            v15 = v32;
                                            v17 += 2;
                                            *v21 = v18 * v13 [1] + *v21;
                                        }
                                        while(v17 < v32);
                                        v9 = v40;
                                    }
                                    v45 += 8;
                                }
                                while(v45 < (unsigned int) v9);
                                v13 += 4;
                                v14 = v15;
                            }
                            while((unsigned int) v15 < v36);
                        }
                        v22 = v35;
                        do {
                            v23 = (float*) Block [*(_DWORD*) v22];
                            v24 = v22 [1] + v23 [1];
                            v23 [1] = v24;
                            if(v24 + 0.0000099999997 >= 1.0) {
                                (*(void(__fastcall**)(_DWORD, float*, _DWORD, _DWORD, _DWORD))(*(_DWORD*) this [1] + 8))(
                                    this [1],
                                    v13,
                                    *(_DWORD*) v22,
                                    0,
                                    *(_DWORD*) v23);
                                Block [*(_DWORD*) v22] = 0;
                                --v41;
                                *((_DWORD*) v23 + 2) = v42;
                                v42 = (void**) v23;
                            }
                            v22 += 2;
                        }
                        while(v22 < v40);
                        v6 = v31;
                        v9 = v40;
                    }
                    ++v38;
                    v8 = v9;
                }
                while((unsigned int) v9 < v6);
                if(v41) {
                    v25 = (_DWORD*) this [1];
                    for(i = 0; i < v25 [1045]; ++i) {
                        v27 = (_DWORD**) &Block [i];
                        if(*v27) {
                            (*(void(__thiscall**)(_DWORD*, unsigned int, _DWORD, _DWORD))(*v25 + 8))(v25, i, 0, **v27);
                            v28 = *v27;
                            if(v28) {
                                sub_440F32((int) v28);
                                j__free(v28);
                            }
                            if(!--v41)
                                break;
                        }
                        v25 = (_DWORD*) this [1];
                    }
                }
            }
            v29 = 0;
        }
        else {
            LABEL_42:
            v29 = -2147024882;
        }
    }
    else {
        v29 = -2147467259;
    }
    j__free(Block);
    if(v42) {
        sub_440F32((int) v42);
        j__free(v42);
    }
    j__free(v39);
    j__free(v34);
    j__free(v37);
    j__free(0);
    return v29;
}
// 4414BC: variable 'v13' is possibly undefined

//----- (004415AB) --------------------------------------------------------
int __thiscall sub_4415AB(_DWORD* this) {
    int v2; // edx
    int v3; // eax
    int v4; // edi
    _DWORD* v5; // ebx
    void** v6; // ebx
    _DWORD* v7; // edi
    float* v8; // eax
    float* v9; // edx
    float* v10; // eax
    void* v11; // eax
    char* v12; // edi
    unsigned int v13; // edx
    char* v14; // edi
    char v15; // cl
    _DWORD* v16; // eax
    unsigned int v17; // edi
    _DWORD* v18; // eax
    float* v19; // edx
    char* v20; // ecx
    int v21; // eax
    char* j; // ecx
    double v23; // st7
    float* v24; // edi
    float* k; // edi
    double v26; // st7
    _DWORD* v27; // ecx
    _DWORD* v28; // ecx
    unsigned int m; // edi
    int* v30; // eax
    int v31; // eax
    int v32; // esi
    void** Block; // [esp+8h] [ebp-50h]
    void* Blocka; // [esp+8h] [ebp-50h]
    unsigned int v36; // [esp+Ch] [ebp-4Ch]
    _DWORD* v37; // [esp+10h] [ebp-48h]
    int v38; // [esp+14h] [ebp-44h]
    float* v39; // [esp+14h] [ebp-44h]
    unsigned int v40; // [esp+18h] [ebp-40h]
    unsigned int v41; // [esp+1Ch] [ebp-3Ch]
    int v42; // [esp+20h] [ebp-38h]
    _DWORD* v43; // [esp+24h] [ebp-34h]
    int v44; // [esp+28h] [ebp-30h]
    char* v45; // [esp+2Ch] [ebp-2Ch]
    char* v46; // [esp+30h] [ebp-28h]
    float* v47; // [esp+34h] [ebp-24h]
    _DWORD* v48; // [esp+38h] [ebp-20h]
    float* v49; // [esp+3Ch] [ebp-1Ch]
    float* v50; // [esp+40h] [ebp-18h]
    unsigned int v51; // [esp+40h] [ebp-18h]
    float* v52; // [esp+44h] [ebp-14h]
    unsigned int v53; // [esp+44h] [ebp-14h]
    void** v54; // [esp+48h] [ebp-10h]
    int v55; // [esp+4Ch] [ebp-Ch]
    _DWORD* v56; // [esp+50h] [ebp-8h]
    float* v57; // [esp+54h] [ebp-4h]
    float* i; // [esp+54h] [ebp-4h]

    v2 = this [1];
    v48 = 0;
    v49 = 0;
    v56 = 0;
    v54 = 0;
    v47 = 0;
    if(*(_DWORD*) (v2 + 8) != 1 || *(_DWORD*) (*this + 8) != 1)
        return -2147467259;
    v3 = this [2];
    v4 = (v3 & 0x20000) == 0;
    v38 = (v3 & 0x40000) == 0;
    v5 = sub_440F54(*(_DWORD*) (*this + 4176), *(_DWORD*) (v2 + 4176), (v3 & 0x10000) == 0);
    v37 = v5;
    if(v5
       && (v48 = sub_440F54(*(_DWORD*) (*this + 4180), *(_DWORD*) (this [1] + 4180), v4)) != 0
       && (v49 = (float*) sub_440F54(*(_DWORD*) (*this + 4184), *(_DWORD*) (this [1] + 4184), v38)) != 0) {
        v41 = (unsigned int) v5 + *v5;
        v40 = (unsigned int) v48 + *v48;
        v6 = (void**) ((char*) v49 + *(_DWORD*) v49);
        Block = v6;
        v7 = operator new(4 * *(_DWORD*) (this [1] + 4184));
        v56 = v7;
        if(v7
           && (v55 = 0,
           memset(v7, 0, 4 * *(_DWORD*) (this [1] + 4184)),
           (v47 = (float*)operator new(16 * *(_DWORD*) (*this + 4176))) != 0)) {
            v42 = 0;
            v8 = v49 + 1;
            if(v49 + 1 < (float*) v6) {
                do {
                    v9 = (float*) ((char*) v8 + *(_DWORD*) v8);
                    v10 = v8 + 1;
                    v50 = v9;
                    v39 = v10;
                    while(1) {
                        v57 = v10;
                        if(v10 >= v9)
                            break;
                        v6 = (void**) v56 [*(_DWORD*) v10];
                        if(!v6) {
                            v6 = v54;
                            if(v54) {
                                v54 = (void**) v54 [2];
                            }
                            else {
                                v6 = (void**)operator new(0xCu);
                                if(!v6)
                                    goto LABEL_56;
                                v11 = operator new(16 * *(_DWORD*) (this [1] + 4176) * *(_DWORD*) (this [1] + 4180));
                                *v6 = v11;
                                if(!v11) {
                                    sub_440F32((int) v6);
                                    j__free(v6);
                                    goto LABEL_56;
                                }
                            }
                            v12 = (char*) *v6;
                            v13 = 16 * *(_DWORD*) (this [1] + 4176) * *(_DWORD*) (this [1] + 4180);
                            memset(*v6, 0, 4 * (v13 >> 2));
                            v14 = &v12 [4 * (v13 >> 2)];
                            v15 = v13;
                            v9 = v50;
                            memset(v14, 0, v15 & 3);
                            *((float*) v6 + 1) = 0.0;
                            v6 [2] = 0;
                            ++v55;
                            v56 [*(_DWORD*) v57] = v6;
                        }
                        v10 = v57 + 2;
                    }
                    v44 = 0;
                    v16 = v48 + 1;
                    v43 = v48 + 1;
                    if((unsigned int) (v48 + 1) < v40) {
                        while(1) {
                            v17 = (unsigned int) v16 + *v16;
                            v36 = v17;
                            (*(void(__thiscall**)(_DWORD, int, int, float*))(*(_DWORD*) *this + 4))(*this, v44, v42, v47);
                            v18 = v37 + 1;
                            v45 = (char*) (v37 + 1);
                            if((unsigned int) (v37 + 1) < v41) {
                                v19 = v47 + 2;
                                while(1) {
                                    v20 = (char*) v18 + *v18;
                                    v46 = v20;
                                    for(i = v39; i < v50; i += 2) {
                                        v52 = (float*) (v43 + 1);
                                        if((unsigned int) (v43 + 1) < v17) {
                                            do {
                                                v21 = *(_DWORD*) v56 [*(_DWORD*) i] + 16 * *(_DWORD*) v52 * *(_DWORD*) (this [1] + 4176);
                                                for(j = v45 + 4; j < v46; j += 8) {
                                                    v23 = *((float*) j + 1) * i [1] * v52 [1];
                                                    *(float*) (v21 + 16 * *(_DWORD*) j) = v23 * *(v19 - 2) + *(float*) (v21 + 16 * *(_DWORD*) j);
                                                    *(float*) (16 * *(_DWORD*) j + v21 + 4) = v23 * *(v19 - 1)
                                                        + *(float*) (16 * *(_DWORD*) j + v21 + 4);
                                                    *(float*) (16 * *(_DWORD*) j + v21 + 8) = v23 * *v19 + *(float*) (16 * *(_DWORD*) j + v21 + 8);
                                                    v24 = (float*) (16 * *(_DWORD*) j + v21 + 12);
                                                    *v24 = v23 * v19 [1] + *v24;
                                                }
                                                v52 += 2;
                                                v17 = v36;
                                            }
                                            while((unsigned int) v52 < v36);
                                            v20 = v46;
                                        }
                                    }
                                    v19 += 4;
                                    v45 = v20;
                                    if((unsigned int) v20 >= v41)
                                        break;
                                    v18 = v20;
                                }
                            }
                            ++v44;
                            v43 = (_DWORD*) v17;
                            if(v17 >= v40)
                                break;
                            v16 = (_DWORD*) v17;
                        }
                        v9 = v50;
                    }
                    for(k = v39; k < v9; k += 2) {
                        v6 = (void**) v56 [*(_DWORD*) k];
                        v26 = k [1] + *((float*) v6 + 1);
                        *((float*) v6 + 1) = v26;
                        if(v26 + 0.0000099999997 >= 1.0) {
                            v27 = (_DWORD*) this [1];
                            v53 = 0;
                            if(v27 [1045]) {
                                do {
                                    (*(void(__stdcall**)(unsigned int, _DWORD, unsigned int))(*v27 + 8))(
                                        v53,
                                        *(_DWORD*) k,
                                        (unsigned int) *v6 + 16 * v53 * v27 [1044]);
                                    ++v53;
                                    v27 = (_DWORD*) this [1];
                                }
                                while(v53 < v27 [1045]);
                                v9 = v50;
                            }
                            v56 [*(_DWORD*) k] = 0;
                            --v55;
                            v6 [2] = v54;
                            v54 = v6;
                        }
                    }
                    ++v42;
                    v8 = v9;
                }
                while(v9 < (float*) Block);
                if(v55) {
                    v28 = (_DWORD*) this [1];
                    for(m = 0; m < v28 [1046]; ++m) {
                        v30 = &v56 [m];
                        if(*v30) {
                            v51 = 0;
                            if(v28 [1045]) {
                                do {
                                    (*(void(__stdcall**)(unsigned int, unsigned int, unsigned int))(*v28 + 8))(
                                        v51,
                                        m,
                                        (unsigned int) *v6 + 16 * v51 * v28 [1044]);
                                    ++v51;
                                    v28 = (_DWORD*) this [1];
                                }
                                while(v51 < v28 [1045]);
                                v30 = &v56 [m];
                            }
                            v31 = *v30;
                            Blocka = (void*) v31;
                            if(v31) {
                                sub_440F32(v31);
                                j__free(Blocka);
                            }
                            if(!--v55)
                                break;
                        }
                        v28 = (_DWORD*) this [1];
                    }
                }
            }
            v32 = 0;
        }
        else {
            LABEL_56:
            v32 = -2147024882;
        }
    }
    else {
        v32 = -2147467259;
    }
    j__free(v56);
    if(v54) {
        sub_440F32((int) v54);
        j__free(v54);
    }
    j__free(v49);
    j__free(v48);
    j__free(v37);
    j__free(v47);
    j__free(0);
    return v32;
}

//----- (00441A82) --------------------------------------------------------
int __thiscall sub_441A82(_DWORD* this) {
    _DWORD* v1; // edi
    unsigned int v2; // esi
    int v3; // eax
    unsigned int v4; // ecx
    int v5; // edx
    unsigned int v7; // eax
    _DWORD* v8; // edx
    char* v9; // ebx
    int v10; // eax
    int v11; // ecx
    int v12; // [esp-4h] [ebp-28h]
    unsigned int v13; // [esp+Ch] [ebp-18h]
    int v14; // [esp+10h] [ebp-14h]
    unsigned int v15; // [esp+14h] [ebp-10h]
    int v16; // [esp+18h] [ebp-Ch]
    unsigned int v17; // [esp+1Ch] [ebp-8h]
    unsigned int v18; // [esp+1Ch] [ebp-8h]
    char* i; // [esp+20h] [ebp-4h]

    v1 = (_DWORD*) *this;
    v2 = *(_DWORD*) (*this + 4148);
    v17 = *(_DWORD*) (*this + 4144);
    if((((unsigned __int8) v2 | (unsigned __int8) (*(_BYTE*) (*this + 4144) | *(_BYTE*) (*this + 4152) | *(_BYTE*) (*this + 4156))) & 3) != 0)
        return -2147467259;
    v3 = this [1];
    v4 = *(_DWORD*) (v3 + 4148);
    if((((unsigned __int8) v4 | (unsigned __int8) (*(_DWORD*) (v3 + 4144) | *(_BYTE*) (v3 + 4152) | *(_BYTE*) (v3 + 4156))) & 3) != 0)
        return -2147467259;
    v5 = *(_DWORD*) (v3 + 4);
    if(v5 == 827611204) {
        v12 = 8;
    }
    else {
        if(v5 != 844388420 && v5 != 861165636 && v5 != 877942852 && v5 != 894720068)
            return -2147467259;
        v12 = 16;
    }
    v13 = v12 * (*(_DWORD*) (v3 + 4176) >> 2);
    v16 = *(_DWORD*) (v3 + 24)
        + v12 * (*(_DWORD*) (v3 + 4144) >> 2)
        + *(_DWORD*) (v3 + 4160) * *(_DWORD*) (v3 + 4172)
        + *(_DWORD*) (v3 + 4168) * (v4 >> 2);
    v15 = 0;
    v14 = v1 [6] + v12 * (v17 >> 2) + v1 [1040] * v1 [1043] + v1 [1042] * (v2 >> 2);
    if(*(_DWORD*) (v3 + 4184)) {
        v7 = *(_DWORD*) (v3 + 4180);
        v8 = this;
        do {
            v18 = 0;
            v9 = (char*) v16;
            for(i = (char*) v14; v18 < v7; i += *(_DWORD*) (*v8 + 4168)) {
                v18 += 4;
                qmemcpy(v9, i, v13);
                v10 = v8 [1];
                v9 += *(_DWORD*) (v10 + 4168);
                v7 = *(_DWORD*) (v10 + 4180);
            }
            v11 = v8 [1];
            v16 += *(_DWORD*) (*v8 + 4172) + *(_DWORD*) (v11 + 4172);
            ++v15;
        }
        while(v15 < *(_DWORD*) (v11 + 4184));
    }
    return 0;
}

//----- (00441C03) --------------------------------------------------------
int sub_441C03() {
    return -2147467263;
}

//----- (00441C09) --------------------------------------------------------
int __fastcall sub_441C09(_DWORD* a1) {
    int v1; // edx
    unsigned int* v2; // ebp
    char* v3; // eax
    int v4; // edi
    char* v5; // esi
    char* v6; // edi
    unsigned int v7; // esi
    unsigned int v8; // edx
    unsigned int v9; // ebx
    unsigned int* v10; // eax
    bool v11; // cf
    unsigned int* v13; // [esp+Ch] [ebp-20h]
    char* v14; // [esp+10h] [ebp-1Ch]
    char* v15; // [esp+14h] [ebp-18h]
    unsigned int* v16; // [esp+18h] [ebp-14h]
    char* v17; // [esp+1Ch] [ebp-10h]
    unsigned int v18; // [esp+20h] [ebp-Ch]
    _DWORD* v19; // [esp+24h] [ebp-8h]
    char* i; // [esp+28h] [ebp-4h]

    v1 = *a1;
    v2 = *(unsigned int**) (a1 [1] + 24);
    v3 = *(char**) (*a1 + 24);
    v4 = *(_DWORD*) (*a1 + 4168);
    v5 = &v3 [v4 * *(_DWORD*) (*a1 + 4180)];
    v19 = a1;
    v16 = v2;
    v17 = v3;
    for(i = v5; v3 < v5; v17 = v3) {
        v6 = &v3 [v4];
        v13 = v2;
        v14 = v3;
        v15 = v6;
        v18 = (unsigned int) &v3 [4 * *(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v18) {
            do {
                v7 = *((_DWORD*) v3 + 1);
                v8 = *((_DWORD*) v6 + 1);
                v9 = (((v7 >> 2) & 0x3FC03FC0)
                      + ((*(_DWORD*) v6 >> 2) & 0x3FC03FC0)
                      + ((*(_DWORD*) v3 >> 2) & 0x3FC03FC0)
                      + ((v8 >> 2) & 0x3FC03FC0)
                      + 8388736) ^ ((((v7 & 0xFF00FF)
                                    + (*(_DWORD*) v6 & 0xFF00FF)
                                    + (*(_DWORD*) v3 & 0xFF00FF)
                                    + (v8 & 0xFF00FF)
                                    + 131074) >> 2) ^ (((v7 >> 2) & 0xFFC03FC0)
                                    + ((*(_DWORD*) v6 >> 2) & 0xFFC03FC0)
                                    + ((*(_DWORD*) v3 >> 2) & 0xFFC03FC0)
                                    + ((v8 >> 2) & 0xFFC03FC0)
                                    - 8388480)) & 0xFF00FF;
                v10 = v13++;
                *v10 = v9;
                v3 = v14 + 8;
                v6 = v15 + 8;
                v11 = (unsigned int) (v14 + 8) < v18;
                v14 += 8;
                v15 += 8;
            }
            while(v11);
            a1 = v19;
            v2 = v16;
            v3 = v17;
            v5 = i;
        }
        v2 = (unsigned int*) ((char*) v2 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v4 = *(_DWORD*) (*a1 + 4168);
        v3 += 2 * v4;
        v16 = v2;
    }
    return 0;
}

//----- (00441D67) --------------------------------------------------------
int __fastcall sub_441D67(_DWORD* a1) {
    int v1; // eax
    char* v2; // esi
    int v3; // edi
    char* v4; // edx
    char* v5; // ebp
    char* v6; // ebx
    unsigned int* v7; // eax
    bool v8; // cf
    unsigned int* v10; // [esp+8h] [ebp-1Ch]
    unsigned int* v11; // [esp+Ch] [ebp-18h]
    char* v12; // [esp+10h] [ebp-14h]
    char* v13; // [esp+14h] [ebp-10h]
    unsigned int v14; // [esp+18h] [ebp-Ch]
    _DWORD* v15; // [esp+1Ch] [ebp-8h]
    char* i; // [esp+20h] [ebp-4h]

    v11 = *(unsigned int**) (a1 [1] + 24);
    v1 = *a1;
    v2 = *(char**) (*a1 + 24);
    v3 = *(_DWORD*) (*a1 + 4168);
    v4 = &v2 [v3 * *(_DWORD*) (*a1 + 4180)];
    v15 = a1;
    for(i = v4; v2 < v4; v2 += 2 * v3) {
        v10 = v11;
        v5 = v2;
        v6 = &v2 [v3];
        v12 = v2;
        v13 = &v2 [v3];
        v14 = (unsigned int) &v2 [4 * *(_DWORD*) (v1 + 4176)];
        if((unsigned int) v2 < v14) {
            do {
                v7 = v10++;
                *v7 = (((*((_DWORD*) v5 + 1) & 0xFF00)
                       + (*(_DWORD*) v6 & 0xFF00)
                       + (*(_DWORD*) v5 & 0xFF00)
                       + (*((_DWORD*) v6 + 1) & 0xFF00)
                       + 512) & 0x3FC00 | ((*((_DWORD*) v5 + 1) & 0xFF00FF)
                       + (*(_DWORD*) v6 & 0xFF00FF)
                       + (*(_DWORD*) v5 & 0xFF00FF)
                       + (*((_DWORD*) v6 + 1) & 0xFF00FF)
                       + 131074) & 0x3FC03FCu) >> 2;
                v5 = v12 + 8;
                v6 = v13 + 8;
                v8 = (unsigned int) (v12 + 8) < v14;
                v12 += 8;
                v13 += 8;
            }
            while(v8);
            a1 = v15;
            v4 = i;
        }
        v11 = (unsigned int*) ((char*) v11 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v3 = *(_DWORD*) (*a1 + 4168);
    }
    return 0;
}

//----- (00441E83) --------------------------------------------------------
int __fastcall sub_441E83(_DWORD* a1) {
    int v1; // esi
    int v2; // edi
    unsigned __int16* v3; // eax
    unsigned __int16* v4; // ebp
    _WORD* v5; // edi
    unsigned __int16* v6; // ebx
    int v7; // ecx
    int v8; // esi
    int v9; // eax
    __int16 v10; // bx
    _WORD* v11; // eax
    bool v12; // cf
    _WORD* v14; // [esp+Ch] [ebp-24h]
    _WORD* v15; // [esp+10h] [ebp-20h]
    unsigned __int16* v16; // [esp+14h] [ebp-1Ch]
    _WORD* v17; // [esp+18h] [ebp-18h]
    unsigned __int16* v18; // [esp+1Ch] [ebp-14h]
    unsigned int v19; // [esp+24h] [ebp-Ch]
    _DWORD* v20; // [esp+28h] [ebp-8h]
    unsigned __int16* i; // [esp+2Ch] [ebp-4h]

    v1 = *a1;
    v2 = *(_DWORD*) (*a1 + 4168);
    v15 = *(_WORD**) (a1 [1] + 24);
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = (unsigned __int16*) ((char*) v3 + v2 * *(_DWORD*) (*a1 + 4180));
    v20 = a1;
    v18 = v3;
    for(i = v4; v3 < v4; v18 = v3) {
        v14 = v15;
        v5 = (unsigned __int16*) ((char*) v3 + v2);
        v6 = v3;
        v16 = v3;
        v17 = v5;
        v19 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v19) {
            do {
                v7 = *v6;
                v8 = v6 [1];
                v9 = (unsigned __int16) v5 [1];
                v10 = (((*v5 & 0xF81F) + (v7 & 0xF81F) + (v9 & 0xF81F) + (v8 & 0xF81Fu) + 4098) >> 2) ^ ((((v8 & 0xFFFF07E0)
                                                                                                         + (*v5 & 0x7E0)
                                                                                                         + (v7 & 0xFFFF07E0)
                                                                                                         + (v9 & 0xFFFF07E0)
                                                                                                         + 64) >> 2) ^ (((*v5 & 0xF81F) + (v7 & 0xFFFFF81F) + (v9 & 0xFFFFF81F) + (v8 & 0xFFFFF81F) + 4098) >> 2)) & 0x7E0;
                v11 = v14++;
                *v11 = v10;
                v6 = v16 + 2;
                v5 = v17 + 2;
                v12 = (unsigned int) (v16 + 2) < v19;
                v16 += 2;
                v17 += 2;
            }
            while(v12);
            a1 = v20;
            v3 = v18;
            v4 = i;
        }
        v15 = (_WORD*) ((char*) v15 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v2 = *(_DWORD*) (*a1 + 4168);
        v3 += v2;
    }
    return 0;
}

//----- (00441FD3) --------------------------------------------------------
int __fastcall sub_441FD3(_DWORD* a1) {
    int v1; // eax
    int v2; // ebx
    unsigned __int16* v3; // esi
    unsigned __int16* v4; // edx
    unsigned __int16* v5; // ebx
    unsigned __int16* v6; // ebp
    int v7; // edx
    int v8; // eax
    int v9; // ebx
    unsigned int v10; // ebp
    int v11; // eax
    _WORD* v12; // eax
    _WORD* v14; // [esp+8h] [ebp-20h]
    _WORD* v15; // [esp+Ch] [ebp-1Ch]
    unsigned __int16* v16; // [esp+10h] [ebp-18h]
    unsigned __int16* v17; // [esp+14h] [ebp-14h]
    int v18; // [esp+18h] [ebp-10h]
    unsigned __int16* v19; // [esp+1Ch] [ebp-Ch]
    _DWORD* v20; // [esp+20h] [ebp-8h]
    unsigned __int16* i; // [esp+24h] [ebp-4h]

    v15 = *(_WORD**) (a1 [1] + 24);
    v1 = *a1;
    v2 = *(_DWORD*) (*a1 + 4168);
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = (unsigned __int16*) ((char*) v3 + v2 * *(_DWORD*) (*a1 + 4180));
    v20 = a1;
    for(i = v4; v3 < v4; v3 += v2) {
        v14 = v15;
        v5 = (unsigned __int16*) ((char*) v3 + v2);
        v6 = v3;
        v16 = v3;
        v17 = v5;
        v19 = &v3 [*(_DWORD*) (v1 + 4176)];
        if(v3 < v19) {
            do {
                v7 = v6 [1];
                v8 = v5 [1];
                v9 = *v5;
                v18 = *v6;
                v10 = (v7 & 0xFFFF03E0) + (v9 & 0xFFFF03E0) + (v18 & 0xFFFF03E0) + (v8 & 0xFFFF03E0) + 64;
                v11 = (v9 & 0x7C1F) + (v18 & 0x7C1F) + (v8 & 0x7C1F);
                v5 = v17 + 2;
                v17 += 2;
                LOWORD(v10) = ((v11 + (v7 & 0x7C1Fu) + 2050) >> 2) & 0x7C1F | (v10 >> 2) & 0x3E0;
                v12 = v14++;
                *v12 = v10;
                v6 = v16 + 2;
                v16 += 2;
            }
            while(v16 < v19);
            a1 = v20;
            v4 = i;
        }
        v15 = (_WORD*) ((char*) v15 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v2 = *(_DWORD*) (*a1 + 4168);
    }
    return 0;
}

//----- (004420F7) --------------------------------------------------------
int __fastcall sub_4420F7(_DWORD* a1) {
    int v1; // esi
    char* v2; // edx
    int v3; // edi
    char* v4; // ebp
    char* v5; // edi
    char* v6; // ebx
    __int16 v7; // si
    __int16 v8; // dx
    __int16 v9; // di
    _WORD* v10; // ecx
    bool v11; // cf
    _WORD* v13; // [esp+Ch] [ebp-24h]
    _WORD* v14; // [esp+10h] [ebp-20h]
    char* v15; // [esp+14h] [ebp-1Ch]
    char* v16; // [esp+18h] [ebp-18h]
    char* v17; // [esp+1Ch] [ebp-14h]
    unsigned int v18; // [esp+24h] [ebp-Ch]
    _DWORD* v19; // [esp+28h] [ebp-8h]
    char* i; // [esp+2Ch] [ebp-4h]

    v1 = *a1;
    v2 = *(char**) (*a1 + 24);
    v3 = *(_DWORD*) (*a1 + 4168);
    v4 = &v2 [v3 * *(_DWORD*) (*a1 + 4180)];
    v19 = a1;
    v14 = *(_WORD**) (a1 [1] + 24);
    v17 = v2;
    for(i = v4; v2 < v4; v17 = v2) {
        v13 = v14;
        v5 = &v2 [v3];
        v6 = v2;
        v15 = v2;
        v16 = v5;
        v18 = (unsigned int) &v2 [2 * *(_DWORD*) (v1 + 4176)];
        if((unsigned int) v2 < v18) {
            do {
                v7 = *((_WORD*) v6 + 1);
                v8 = *((_WORD*) v5 + 1);
                v9 = *(_WORD*) v5;
                v10 = v13++;
                *v10 = (((v9 & 0x83E0) + (*(_WORD*) v6 & 0x83E0) + (v8 & 0x83E0) + (v7 & 0x83E0u) + 65600) >> 2) ^ ((((v7 & 0x7C1F) + (v9 & 0x7C1F) + (*(_WORD*) v6 & 0x7C1F) + (v8 & 0x7C1Fu) + 2050) >> 2) ^ (((v9 & 0x83E0) + (*(_WORD*) v6 & 0x83E0) + (v8 & 0x83E0) + (v7 & 0x83E0u) + 65600) >> 2)) & 0x7C1F;
                v6 = v15 + 4;
                v5 = v16 + 4;
                v11 = (unsigned int) (v15 + 4) < v18;
                v15 += 4;
                v16 += 4;
            }
            while(v11);
            a1 = v19;
            v2 = v17;
            v4 = i;
        }
        v14 = (_WORD*) ((char*) v14 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v3 = *(_DWORD*) (*a1 + 4168);
        v2 += 2 * v3;
    }
    return 0;
}

//----- (00442246) --------------------------------------------------------
int __fastcall sub_442246(_DWORD* a1) {
    int v1; // esi
    int v2; // edi
    unsigned __int16* v3; // eax
    unsigned __int16* v4; // ebp
    _WORD* v5; // edi
    unsigned __int16* v6; // ebx
    int v7; // ecx
    int v8; // esi
    int v9; // eax
    __int16 v10; // bx
    _WORD* v11; // eax
    bool v12; // cf
    _WORD* v14; // [esp+Ch] [ebp-24h]
    _WORD* v15; // [esp+10h] [ebp-20h]
    unsigned __int16* v16; // [esp+14h] [ebp-1Ch]
    _WORD* v17; // [esp+18h] [ebp-18h]
    unsigned __int16* v18; // [esp+1Ch] [ebp-14h]
    unsigned int v19; // [esp+24h] [ebp-Ch]
    _DWORD* v20; // [esp+28h] [ebp-8h]
    unsigned __int16* i; // [esp+2Ch] [ebp-4h]

    v1 = *a1;
    v2 = *(_DWORD*) (*a1 + 4168);
    v15 = *(_WORD**) (a1 [1] + 24);
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = (unsigned __int16*) ((char*) v3 + v2 * *(_DWORD*) (*a1 + 4180));
    v20 = a1;
    v18 = v3;
    for(i = v4; v3 < v4; v18 = v3) {
        v14 = v15;
        v5 = (unsigned __int16*) ((char*) v3 + v2);
        v6 = v3;
        v16 = v3;
        v17 = v5;
        v19 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v19) {
            do {
                v7 = *v6;
                v8 = v6 [1];
                v9 = (unsigned __int16) v5 [1];
                v10 = (((*v5 & 0xF0F0) + (v7 & 0xF0F0) + (v9 & 0xF0F0) + (v8 & 0xF0F0u) + 8224) >> 2) ^ ((((v8 & 0xFFFF0F0F)
                                                                                                         + (*v5 & 0xF0F)
                                                                                                         + (v7 & 0xFFFF0F0F)
                                                                                                         + (v9 & 0xFFFF0F0F)
                                                                                                         + 514) >> 2) ^ (((*v5 & 0xF0F0) + (v7 & 0xFFFFF0F0) + (v9 & 0xFFFFF0F0) + (v8 & 0xFFFFF0F0) + 8224) >> 2)) & 0xF0F;
                v11 = v14++;
                *v11 = v10;
                v6 = v16 + 2;
                v5 = v17 + 2;
                v12 = (unsigned int) (v16 + 2) < v19;
                v16 += 2;
                v17 += 2;
            }
            while(v12);
            a1 = v20;
            v3 = v18;
            v4 = i;
        }
        v15 = (_WORD*) ((char*) v15 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v2 = *(_DWORD*) (*a1 + 4168);
        v3 += v2;
    }
    return 0;
}

//----- (00442399) --------------------------------------------------------
int __fastcall sub_442399(_DWORD* a1) {
    int v1; // edx
    _BYTE* v2; // ebp
    unsigned __int8* v3; // eax
    int v4; // edi
    unsigned __int8* v5; // esi
    unsigned __int8* v6; // edi
    unsigned __int8* v7; // ebx
    int v8; // ebp
    int v9; // esi
    int v10; // eax
    int v11; // edi
    char v12; // dl
    _BYTE* v13; // eax
    bool v14; // cf
    _BYTE* v16; // [esp+Ch] [ebp-20h]
    unsigned __int8* v17; // [esp+10h] [ebp-1Ch]
    unsigned __int8* v18; // [esp+14h] [ebp-18h]
    _BYTE* v19; // [esp+18h] [ebp-14h]
    unsigned __int8* v20; // [esp+1Ch] [ebp-10h]
    unsigned int v21; // [esp+20h] [ebp-Ch]
    _DWORD* v22; // [esp+24h] [ebp-8h]
    unsigned __int8* i; // [esp+28h] [ebp-4h]

    v1 = *a1;
    v2 = *(_BYTE**) (a1 [1] + 24);
    v3 = *(unsigned __int8**) (*a1 + 24);
    v4 = *(_DWORD*) (*a1 + 4168);
    v5 = &v3 [v4 * *(_DWORD*) (*a1 + 4180)];
    v22 = a1;
    v19 = v2;
    v20 = v3;
    for(i = v5; v3 < v5; v20 = v3) {
        v6 = &v3 [v4];
        v7 = v3;
        v16 = v2;
        v17 = v3;
        v18 = v6;
        v21 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v21) {
            do {
                v8 = *v7;
                v9 = v7 [1];
                v10 = v6 [1];
                v11 = *v6;
                LOWORD(v8) = v8 & 0xE3;
                LOWORD(v9) = v9 & 0xE3;
                v12 = (((v11 & 0xE3) + v8 + (v10 & 0xE3u) + v9 + 66) >> 2) ^ ((((v11 & 0xFFFF00E3)
                                                                              + (*v7 & 0xE3)
                                                                              + (v10 & 0xFFFF00E3)
                                                                              + (v7 [1] & 0xE3)
                                                                              + 66) >> 2) ^ (((v11 & 0x1C)
                                                                              + (*v7 & 0x1C)
                                                                              + (v10 & 0x1C)
                                                                              + (v7 [1] & 0x1Cu)
                                                                              + 8) >> 2)) & 0x1C;
                v13 = v16++;
                v7 = v17 + 2;
                v6 = v18 + 2;
                v14 = (unsigned int) (v17 + 2) < v21;
                *v13 = v12;
                v17 += 2;
                v18 += 2;
            }
            while(v14);
            a1 = v22;
            v2 = v19;
            v3 = v20;
            v5 = i;
        }
        v2 += *(_DWORD*) (a1 [1] + 4168);
        v1 = *a1;
        v4 = *(_DWORD*) (*a1 + 4168);
        v3 += 2 * v4;
        v19 = v2;
    }
    return 0;
}

//----- (004424D8) --------------------------------------------------------
int __thiscall sub_4424D8(_DWORD* this) {
    _BYTE* v1; // ebx
    int v2; // eax
    unsigned __int8* v3; // edx
    int v4; // edi
    unsigned __int8* v5; // esi
    unsigned int v6; // eax
    unsigned __int8* v7; // edi
    bool i; // cf
    int v9; // edi
    int v10; // ebx
    unsigned int v11; // ebx
    _BYTE* v12; // edi
    _BYTE* v14; // [esp+Ch] [ebp-10h]
    unsigned __int8* v15; // [esp+10h] [ebp-Ch]
    _BYTE* v16; // [esp+14h] [ebp-8h]
    unsigned __int8* v17; // [esp+18h] [ebp-4h]

    v1 = *(_BYTE**) (this [1] + 24);
    v2 = *this;
    v3 = *(unsigned __int8**) (*this + 24);
    v4 = *(_DWORD*) (*this + 4168);
    v5 = &v3 [v4 * *(_DWORD*) (*this + 4180)];
    while(1) {
        v14 = v1;
        if(v3 >= v5)
            break;
        v6 = (unsigned int) &v3 [*(_DWORD*) (v2 + 4176)];
        v7 = &v3 [v4];
        v16 = v1;
        v17 = v3;
        for(i = (unsigned int) v3 < v6; ; i = (unsigned int) v17 < v6) {
            v15 = v7;
            if(!i)
                break;
            v9 = *v7 + v17 [1] + v7 [1];
            v10 = *v17;
            v17 += 2;
            v11 = v9 + v10 + 2;
            v12 = v16++;
            *v12 = v11 >> 2;
            v7 = v15 + 2;
        }
        v1 = &v14 [*(_DWORD*) (this [1] + 4168)];
        v2 = *this;
        v4 = *(_DWORD*) (*this + 4168);
        v3 += 2 * v4;
    }
    return 0;
}

//----- (00442573) --------------------------------------------------------
int __fastcall sub_442573(_DWORD* a1) {
    int v1; // edx
    int v2; // ebp
    unsigned __int16* v3; // eax
    unsigned __int16* v4; // edi
    unsigned __int16* v5; // ebp
    unsigned __int16* v6; // ebx
    int v7; // edx
    int v8; // edi
    int v9; // eax
    int v10; // ebp
    unsigned int v11; // ebx
    int v12; // ecx
    int v13; // eax
    unsigned int v14; // edx
    int v15; // ebp
    unsigned int v16; // ecx
    int v17; // edi
    unsigned int v18; // edx
    _WORD* v19; // eax
    bool v20; // cf
    _WORD* v22; // [esp+8h] [ebp-24h]
    _WORD* v23; // [esp+Ch] [ebp-20h]
    int v24; // [esp+10h] [ebp-1Ch]
    unsigned __int16* v25; // [esp+14h] [ebp-18h]
    unsigned __int16* v26; // [esp+18h] [ebp-14h]
    unsigned __int16* v27; // [esp+1Ch] [ebp-10h]
    unsigned int v28; // [esp+20h] [ebp-Ch]
    _DWORD* v29; // [esp+24h] [ebp-8h]
    unsigned __int16* i; // [esp+28h] [ebp-4h]

    v1 = *a1;
    v2 = *(_DWORD*) (*a1 + 4168);
    v23 = *(_WORD**) (a1 [1] + 24);
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = (unsigned __int16*) ((char*) v3 + v2 * *(_DWORD*) (*a1 + 4180));
    v29 = a1;
    v27 = v3;
    for(i = v4; v3 < v4; v27 = v3) {
        v22 = v23;
        v5 = (unsigned __int16*) ((char*) v3 + v2);
        v6 = v3;
        v25 = v3;
        v26 = v5;
        v28 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v28) {
            do {
                v7 = *v6;
                v8 = v6 [1];
                v9 = v5 [1];
                v10 = *v5;
                v24 = v7;
                LOWORD(v7) = *v6 & 0xE3;
                v11 = (v10 & 0xFFFF00E3) + v7 + (v9 & 0xFFFF00E3);
                HIWORD(v12) = HIWORD(v9);
                v13 = v9 & 0xFF1C;
                LOWORD(v12) = v13;
                v14 = (v11 + (v8 & 0xFFFF00E3) + 66) >> 2;
                HIWORD(v11) = HIWORD(v10);
                v15 = v10 & 0xFF1C;
                LOWORD(v11) = v15;
                v16 = v11 + (v24 & 0xFFFFFF1C) + v12;
                HIWORD(v11) = HIWORD(v8);
                v17 = v8 & 0xFF1C;
                LOWORD(v11) = v17;
                LOBYTE(v14) = ((v16 + v11 + 520) >> 2) ^ v14;
                v18 = ((v15 + (v24 & 0xFF1Cu) + v13 + v17 + 520) >> 2) ^ v14 & 0xFFFF00E3;
                v19 = v22++;
                v6 = v25 + 2;
                v5 = v26 + 2;
                v20 = (unsigned int) (v25 + 2) < v28;
                *v19 = v18;
                v25 += 2;
                v26 += 2;
            }
            while(v20);
            a1 = v29;
            v3 = v27;
            v4 = i;
        }
        v23 = (_WORD*) ((char*) v23 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v2 = *(_DWORD*) (*a1 + 4168);
        v3 += v2;
    }
    return 0;
}

//----- (004426BF) --------------------------------------------------------
int __fastcall sub_4426BF(_DWORD* a1) {
    _WORD* v1; // ebp
    int v2; // eax
    unsigned __int16* v3; // esi
    int v4; // edi
    unsigned __int16* v5; // edx
    unsigned __int16* v6; // edi
    unsigned __int16* v7; // ebx
    int v8; // edx
    int v9; // eax
    int v10; // ebx
    int v11; // edi
    unsigned int v12; // ebp
    unsigned int v13; // eax
    unsigned int v14; // ebp
    _WORD* v15; // eax
    _WORD* v17; // [esp+Ch] [ebp-1Ch]
    unsigned __int16* v18; // [esp+10h] [ebp-18h]
    unsigned __int16* v19; // [esp+14h] [ebp-14h]
    _WORD* v20; // [esp+18h] [ebp-10h]
    unsigned int v21; // [esp+1Ch] [ebp-Ch]
    _DWORD* v22; // [esp+20h] [ebp-8h]
    unsigned __int16* i; // [esp+24h] [ebp-4h]

    v1 = *(_WORD**) (a1 [1] + 24);
    v2 = *a1;
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = *(_DWORD*) (*a1 + 4168);
    v5 = (unsigned __int16*) ((char*) v3 + v4 * *(_DWORD*) (*a1 + 4180));
    v22 = a1;
    v20 = v1;
    for(i = v5; v3 < v5; v20 = v1) {
        v6 = (unsigned __int16*) ((char*) v3 + v4);
        v7 = v3;
        v17 = v1;
        v18 = v3;
        v19 = v6;
        v21 = (unsigned int) &v3 [*(_DWORD*) (v2 + 4176)];
        if((unsigned int) v3 < v21) {
            do {
                v8 = v7 [1];
                v9 = v6 [1];
                v10 = *v7;
                v11 = *v6;
                v12 = (v11 & 0xFFFF00F0) + (v10 & 0xFFFF00F0) + (v9 & 0xFFFF00F0) + (v8 & 0xFFFF00F0) + 32;
                LOWORD(v9) = v9 & 0xF0F;
                LOWORD(v10) = v10 & 0xF0F;
                LOWORD(v11) = v11 & 0xF0F;
                LOWORD(v8) = v8 & 0xF0F;
                v13 = (unsigned int) (v11 + v10 + v9 + v8 + 514) >> 2;
                LOWORD(v13) = v13 & 0xF0F;
                v7 = v18 + 2;
                v6 = v19 + 2;
                v18 = v7;
                v19 += 2;
                v14 = v13 | (v12 >> 2) & 0xFFFF00F0;
                v15 = v17++;
                *v15 = v14;
            }
            while((unsigned int) v7 < v21);
            a1 = v22;
            v1 = v20;
            v5 = i;
        }
        v1 = (_WORD*) ((char*) v1 + *(_DWORD*) (a1 [1] + 4168));
        v2 = *a1;
        v4 = *(_DWORD*) (*a1 + 4168);
        v3 += v4;
    }
    return 0;
}

//----- (004427E0) --------------------------------------------------------
int __fastcall sub_4427E0(_DWORD* a1) {
    int v1; // edx
    int v2; // ebp
    unsigned __int16* v3; // eax
    unsigned __int16* v4; // edi
    unsigned __int16* v5; // ebp
    unsigned __int16* v6; // ebx
    int v7; // edx
    int v8; // edi
    int v9; // eax
    int v10; // ebp
    unsigned int v11; // ebx
    int v12; // ecx
    int v13; // eax
    unsigned int v14; // edx
    int v15; // ebp
    unsigned int v16; // ecx
    int v17; // edi
    unsigned int v18; // edx
    _WORD* v19; // eax
    bool v20; // cf
    _WORD* v22; // [esp+8h] [ebp-24h]
    _WORD* v23; // [esp+Ch] [ebp-20h]
    int v24; // [esp+10h] [ebp-1Ch]
    unsigned __int16* v25; // [esp+14h] [ebp-18h]
    unsigned __int16* v26; // [esp+18h] [ebp-14h]
    unsigned __int16* v27; // [esp+1Ch] [ebp-10h]
    unsigned int v28; // [esp+20h] [ebp-Ch]
    _DWORD* v29; // [esp+24h] [ebp-8h]
    unsigned __int16* i; // [esp+28h] [ebp-4h]

    v1 = *a1;
    v2 = *(_DWORD*) (*a1 + 4168);
    v23 = *(_WORD**) (a1 [1] + 24);
    v3 = *(unsigned __int16**) (*a1 + 24);
    v4 = (unsigned __int16*) ((char*) v3 + v2 * *(_DWORD*) (*a1 + 4180));
    v29 = a1;
    v27 = v3;
    for(i = v4; v3 < v4; v27 = v3) {
        v22 = v23;
        v5 = (unsigned __int16*) ((char*) v3 + v2);
        v6 = v3;
        v25 = v3;
        v26 = v5;
        v28 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v28) {
            do {
                v7 = *v6;
                v8 = v6 [1];
                v9 = v5 [1];
                v10 = *v5;
                v24 = v7;
                LOWORD(v7) = (unsigned __int8) *v6;
                v11 = (v10 & 0xFFFF00FF) + v7 + (v9 & 0xFFFF00FF);
                HIWORD(v12) = HIWORD(v9);
                v13 = v9 & 0xFF00;
                LOWORD(v12) = v13;
                v14 = (v11 + (v8 & 0xFFFF00FF) + 2) >> 2;
                HIWORD(v11) = HIWORD(v10);
                v15 = v10 & 0xFF00;
                LOWORD(v11) = v15;
                v16 = v11 + (v24 & 0xFFFFFF00) + v12;
                HIWORD(v11) = HIWORD(v8);
                v17 = v8 & 0xFF00;
                LOWORD(v11) = v17;
                LOBYTE(v14) = ((v16 + v11 + 512) >> 2) ^ v14;
                v18 = ((v15 + (v24 & 0xFF00u) + v13 + v17 + 512) >> 2) ^ v14 & 0xFFFF00FF;
                v19 = v22++;
                v6 = v25 + 2;
                v5 = v26 + 2;
                v20 = (unsigned int) (v25 + 2) < v28;
                *v19 = v18;
                v25 += 2;
                v26 += 2;
            }
            while(v20);
            a1 = v29;
            v3 = v27;
            v4 = i;
        }
        v23 = (_WORD*) ((char*) v23 + *(_DWORD*) (a1 [1] + 4168));
        v1 = *a1;
        v2 = *(_DWORD*) (*a1 + 4168);
        v3 += v2;
    }
    return 0;
}

//----- (0044292C) --------------------------------------------------------
int __fastcall sub_44292C(_DWORD* a1) {
    int v1; // edx
    _BYTE* v2; // ebp
    unsigned __int8* v3; // eax
    int v4; // edi
    unsigned __int8* v5; // esi
    unsigned __int8* v6; // edi
    unsigned __int8* v7; // ebx
    int v8; // ebp
    int v9; // esi
    int v10; // eax
    int v11; // edi
    char v12; // dl
    _BYTE* v13; // eax
    bool v14; // cf
    _BYTE* v16; // [esp+Ch] [ebp-20h]
    unsigned __int8* v17; // [esp+10h] [ebp-1Ch]
    unsigned __int8* v18; // [esp+14h] [ebp-18h]
    _BYTE* v19; // [esp+18h] [ebp-14h]
    unsigned __int8* v20; // [esp+1Ch] [ebp-10h]
    unsigned int v21; // [esp+20h] [ebp-Ch]
    _DWORD* v22; // [esp+24h] [ebp-8h]
    unsigned __int8* i; // [esp+28h] [ebp-4h]

    v1 = *a1;
    v2 = *(_BYTE**) (a1 [1] + 24);
    v3 = *(unsigned __int8**) (*a1 + 24);
    v4 = *(_DWORD*) (*a1 + 4168);
    v5 = &v3 [v4 * *(_DWORD*) (*a1 + 4180)];
    v22 = a1;
    v19 = v2;
    v20 = v3;
    for(i = v5; v3 < v5; v20 = v3) {
        v6 = &v3 [v4];
        v7 = v3;
        v16 = v2;
        v17 = v3;
        v18 = v6;
        v21 = (unsigned int) &v3 [*(_DWORD*) (v1 + 4176)];
        if((unsigned int) v3 < v21) {
            do {
                v8 = *v7;
                v9 = v7 [1];
                v10 = v6 [1];
                v11 = *v6;
                LOWORD(v8) = v8 & 0xF0;
                LOWORD(v9) = v9 & 0xF0;
                v12 = (((v11 & 0xF0) + v8 + (v10 & 0xF0u) + v9 + 32) >> 2) ^ ((((v11 & 0xFFFF00F0)
                                                                              + (*v7 & 0xF0)
                                                                              + (v10 & 0xFFFF00F0)
                                                                              + (v7 [1] & 0xF0)
                                                                              + 32) >> 2) ^ (((v11 & 0xF)
                                                                              + (*v7 & 0xF)
                                                                              + (v10 & 0xF)
                                                                              + (v7 [1] & 0xFu)
                                                                              + 2) >> 2)) & 0xF;
                v13 = v16++;
                v7 = v17 + 2;
                v6 = v18 + 2;
                v14 = (unsigned int) (v17 + 2) < v21;
                *v13 = v12;
                v17 += 2;
                v18 += 2;
            }
            while(v14);
            a1 = v22;
            v2 = v19;
            v3 = v20;
            v5 = i;
        }
        v2 += *(_DWORD*) (a1 [1] + 4168);
        v1 = *a1;
        v4 = *(_DWORD*) (*a1 + 4168);
        v3 += 2 * v4;
        v19 = v2;
    }
    return 0;
}

//----- (00442A6B) --------------------------------------------------------
int sub_442A6B() {
    int result; // eax
    int v1; // [esp+0h] [ebp-8h]

    result = v1;
    dword_6E61D4 = v1;
    return result;
}
// 442A82: variable 'v1' is possibly undefined
// 6E61D4: using guessed type int dword_6E61D4;

//----- (00442A8E) --------------------------------------------------------
int sub_442A8E() {
    return dword_6E61D4;
}
// 6E61D4: using guessed type int dword_6E61D4;

//----- (00442A9E) --------------------------------------------------------
int __thiscall sub_442A9E(_DWORD* this) {
    _DWORD* v1; // ebx
    _DWORD* v2; // eax
    _DWORD* v3; // ecx
    char* v5; // edx
    char* v6; // ebx
    unsigned int v7; // [esp+Ch] [ebp-10h]
    unsigned int i; // [esp+10h] [ebp-Ch]
    _DWORD* v9; // [esp+14h] [ebp-8h]
    unsigned int v10; // [esp+18h] [ebp-4h]

    v1 = this;
    v2 = (_DWORD*) this [1];
    v3 = (_DWORD*) *this;
    v9 = v1;
    if(v2 [1] != v3 [1])
        return -2147467259;
    if(v3 [4])
        return -2147467259;
    if(v2 [1044] != v3 [1044])
        return -2147467259;
    v7 = v2 [1045];
    if(v7 != v3 [1045] || v2 [1046] != v3 [1046])
        return -2147467259;
    if(!v2 [3])
        return sub_441A82(v1);
    if(v2 [5] && v2 + 12 != v3 + 12 && memcmp(v2 + 12, v3 + 12, 0x400u))
        return -2147467259;
    v10 = 0;
    if(v2 [1046]) {
        while(1) {
            v5 = (char*) (v2 [6] + v10 * v2 [1043]);
            v6 = (char*) (*(_DWORD*) (*v9 + 24) + v10 * *(_DWORD*) (*v1 + 4172));
            for(i = 0; i < v7; v7 = v2 [1045]) {
                qmemcpy(v5, v6, v2 [1047]);
                v2 = (_DWORD*) v9 [1];
                v6 += *(_DWORD*) (*v9 + 4168);
                v5 += v2 [1042];
                ++i;
            }
            ++v10;
            v2 = (_DWORD*) v9 [1];
            if(v10 >= v2 [1046])
                break;
            v1 = v9;
        }
    }
    return 0;
}

//----- (00442BD0) --------------------------------------------------------
int __thiscall sub_442BD0(_DWORD* this) {
    _DWORD* v2; // ecx
    int v3; // edx
    int v4; // eax
    void* v5; // ebp
    unsigned int v6; // ebx
    int v7; // eax
    unsigned int v8; // eax
    unsigned int i; // edi

    v2 = (_DWORD*) this [1];
    v3 = *this;
    v4 = v2 [1044];
    if(v4 != *(_DWORD*) (*this + 4176))
        return -2147467259;
    if(v2 [1045] != *(_DWORD*) (v3 + 4180))
        return -2147467259;
    if(v2 [1046] != *(_DWORD*) (v3 + 4184))
        return -2147467259;
    v5 = operator new(16 * v4);
    v6 = 0;
    if(!v5)
        return -2147467259;
    v7 = this [1];
    if(*(_DWORD*) (v7 + 4184)) {
        v8 = *(_DWORD*) (v7 + 4180);
        do {
            for(i = 0; i < v8; ++i) {
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*) *this + 4))(*this, i, v6, v5);
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*) this [1] + 8))(
                    this [1],
                    i,
                    v6,
                    v5);
                v8 = *(_DWORD*) (this [1] + 4180);
            }
            ++v6;
        }
        while(v6 < *(_DWORD*) (this [1] + 4184));
    }
    j__free(v5);
    return 0;
}

//----- (00442C72) --------------------------------------------------------
int __thiscall sub_442C72(_DWORD* this) {
    _DWORD* v2; // eax
    int v3; // ecx
    unsigned int v4; // edi
    unsigned int v5; // ecx
    unsigned int v6; // ebx
    void* v7; // edi
    void* v9; // eax
    unsigned int i; // ebx
    unsigned int j; // edi
    unsigned int k; // edi
    _DWORD* v13; // ecx
    unsigned int v14; // ebx
    _DWORD* v15; // ecx
    unsigned int v16; // eax
    unsigned int m; // edi
    void* Block; // [esp+Ch] [ebp-10h]
    void* v19; // [esp+10h] [ebp-Ch]
    unsigned int v20; // [esp+14h] [ebp-8h]
    unsigned int v21; // [esp+18h] [ebp-4h]

    if(*((_BYTE*) this + 8) != 1)
        return -2147467259;
    v2 = (_DWORD*) this [1];
    v3 = *this;
    v4 = *(_DWORD*) (*this + 4176);
    if(v2 [1044] > v4)
        v4 = v2 [1044];
    v20 = v2 [1045];
    if(v20 >= *(_DWORD*) (v3 + 4180))
        v20 = *(_DWORD*) (v3 + 4180);
    v5 = *(_DWORD*) (v3 + 4184);
    v21 = v2 [1046];
    if(v21 >= v5)
        v21 = v5;
    v6 = 16 * v4;
    v7 = operator new(16 * v4);
    Block = v7;
    if(!v7)
        return -2147467259;
    v9 = operator new(16 * *(_DWORD*) (this [1] + 4176));
    v19 = v9;
    if(v9) {
        memset(v7, 0, v6);
        memset(v9, 0, 16 * *(_DWORD*) (this [1] + 4176));
        for(i = 0; i < v21; ++i) {
            for(j = 0; j < v20; ++j) {
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*) *this + 4))(*this, j, i, Block);
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, void*))(*(_DWORD*) this [1] + 8))(
                    this [1],
                    j,
                    i,
                    Block);
            }
            for(k = v20; ; ++k) {
                v13 = (_DWORD*) this [1];
                if(k >= v13 [1045])
                    break;
                (*(void(__thiscall**)(_DWORD*, unsigned int, unsigned int, void*))(*v13 + 8))(v13, k, i, v19);
            }
        }
        v14 = v21;
        v15 = (_DWORD*) this [1];
        if(v21 < v15 [1046]) {
            v16 = v15 [1045];
            do {
                for(m = 0; m < v16; ++m) {
                    (*(void(__thiscall**)(_DWORD*, unsigned int, unsigned int, void*))(*v15 + 8))(v15, m, v14, v19);
                    v15 = (_DWORD*) this [1];
                    v16 = v15 [1045];
                }
                v15 = (_DWORD*) this [1];
                ++v14;
            }
            while(v14 < v15 [1046]);
        }
        j__free(Block);
        j__free(v19);
        return 0;
    }
    else {
        j__free(v7);
        return -2147467259;
    }
}

//----- (00442DE7) --------------------------------------------------------
int __thiscall sub_442DE7(_DWORD* this) {
    _DWORD* v3; // esi
    int v4; // eax
    unsigned int v5; // edi
    unsigned int v6; // esi
    int v7; // edx
    unsigned int v8; // esi
    _DWORD* v9; // eax
    unsigned int v10; // esi
    char* v11; // esi
    int v12; // [esp+4h] [ebp-30h]
    int v13; // [esp+8h] [ebp-2Ch]
    int v14; // [esp+Ch] [ebp-28h]
    int v15; // [esp+10h] [ebp-24h]
    int v16; // [esp+14h] [ebp-20h]
    _DWORD* v17; // [esp+18h] [ebp-1Ch]
    unsigned int v18; // [esp+1Ch] [ebp-18h]
    unsigned int v19; // [esp+20h] [ebp-14h]
    unsigned int v20; // [esp+24h] [ebp-10h]
    char* Block; // [esp+28h] [ebp-Ch]
    unsigned int v22; // [esp+2Ch] [ebp-8h]
    unsigned int i; // [esp+30h] [ebp-4h]

    if(*((_BYTE*) this + 8) != 2)
        return -2147467259;
    Block = (char*)operator new(16 * *(_DWORD*) (*this + 4176));
    if(!Block)
        return -2147024882;
    v17 = operator new(16 * *(_DWORD*) (this [1] + 4176));
    if(!v17) {
        j__free(Block);
        return -2147024882;
    }
    v3 = (_DWORD*) this [1];
    v4 = (*(_DWORD*) (*this + 4176) << 16) / v3 [1044];
    v5 = v3 [1045];
    v6 = v3 [1046];
    v18 = 0;
    v22 = 0;
    v14 = v4;
    v13 = (*(_DWORD*) (*this + 4180) << 16) / v5;
    v7 = (*(_DWORD*) (*this + 4184) << 16) % v6;
    v12 = (*(_DWORD*) (*this + 4184) << 16) / v6;
    do {
        v16 = -1;
        v8 = 0;
        v15 = 0;
        for(i = 0; i < v5; v15 += v13) {
            v20 = 0;
            v19 = 0;
            if(((v8 ^ v16) & 0xFFFF0000) != 0) {
                (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, char*))(*(_DWORD*) *this + 4))(
                    *this,
                    HIWORD(v8),
                    HIWORD(v18),
                    Block);
                v16 = v8;
            }
            if(*(_DWORD*) (this [1] + 4176)) {
                v9 = v17;
                do {
                    v10 = v20;
                    v20 += v14;
                    v11 = &Block [16 * HIWORD(v10)];
                    v7 = ++v19;
                    *v9 = *(_DWORD*) v11;
                    v11 += 4;
                    v9 [1] = *(_DWORD*) v11;
                    v11 += 4;
                    v9 [2] = *(_DWORD*) v11;
                    v9 [3] = *((_DWORD*) v11 + 1);
                    v9 += 4;
                }
                while(v19 < *(_DWORD*) (this [1] + 4176));
            }
            (*(void(__fastcall**)(_DWORD, int, unsigned int, unsigned int, _DWORD*))(*(_DWORD*) this [1] + 8))(
                this [1],
                v7,
                i,
                v22,
                v17);
            v8 = v13 + v15;
            ++i;
            v5 = *(_DWORD*) (this [1] + 4180);
        }
        v18 += v12;
        ++v22;
    }
    while(v22 < *(_DWORD*) (this [1] + 4184));
    j__free(Block);
    j__free(v17);
    return 0;
}
// 442E97: conditional instruction was optimized away because esi.4!=0
// 442F28: variable 'v7' is possibly undefined

//----- (00442F7D) --------------------------------------------------------
int __thiscall sub_442F7D(_DWORD* this) {
    _DWORD* v2; // esi
    _DWORD* v3; // eax
    int v4; // ecx
    unsigned int v5; // edi
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v16; // eax
    char* v17; // ecx
    char* v18; // eax
    int v19; // esi
    float* v20; // eax
    float* v21; // ecx
    float* v22; // edi
    double v23; // st6
    double v24; // st5
    double v25; // st4
    float* v26; // eax
    double v27; // st6
    double v28; // st5
    double v29; // st4
    float* v30; // eax
    float v31; // [esp+Ch] [ebp-60h]
    float v32; // [esp+10h] [ebp-5Ch]
    float v33; // [esp+1Ch] [ebp-50h]
    float v34; // [esp+28h] [ebp-44h]
    float v35; // [esp+34h] [ebp-38h]
    float v36; // [esp+38h] [ebp-34h]
    float v37; // [esp+3Ch] [ebp-30h]
    float v38; // [esp+40h] [ebp-2Ch]
    float v39; // [esp+44h] [ebp-28h]
    float v40; // [esp+48h] [ebp-24h]
    unsigned int v41; // [esp+4Ch] [ebp-20h]
    char* i; // [esp+4Ch] [ebp-20h]
    char* v43; // [esp+50h] [ebp-1Ch]
    float* v44; // [esp+54h] [ebp-18h]
    float* v45; // [esp+58h] [ebp-14h]
    unsigned int v46; // [esp+5Ch] [ebp-10h]
    unsigned int v47; // [esp+60h] [ebp-Ch]
    char* v48; // [esp+64h] [ebp-8h]
    char* Block; // [esp+68h] [ebp-4h]

    if(*((_BYTE*) this + 8) != 5)
        return -2147467259;
    v2 = (_DWORD*) this [1];
    if(v2 [2] != 1)
        return -2147467259;
    v3 = (_DWORD*) *this;
    if(*(_DWORD*) (*this + 8) != 1)
        return -2147467259;
    v4 = v2 [1044];
    v41 = v3 [1044];
    if(v4 != v41 >> 1 && (v4 != 1 || v3 [1044] != 1))
        return -2147467259;
    v5 = v3 [1045];
    v6 = v2 [1045];
    if(v6 != v5 >> 1 && (v6 != 1 || v5 != 1))
        return -2147467259;
    if(v2 [1046] != 1 || v3 [1046] != 1)
        return -2147467259;
    if((*((_BYTE*) this + 10) & 8) != 0)
        goto LABEL_43;
    v7 = v3 [1];
    if(v7 != v2 [1] || v41 < 2 || v5 < 2)
        goto LABEL_43;
    if(v7 <= 28) {
        if(v7 != 28) {
            switch(v7) {
                case 20:
                    goto LABEL_19;
                case 21:
                    v8 = sub_441C09(this);
                    goto LABEL_41;
                case 22:
                    v8 = sub_441D67(this);
                    goto LABEL_41;
                case 23:
                    v8 = sub_441E83(this);
                    goto LABEL_41;
                case 24:
                    v8 = sub_441FD3(this);
                    goto LABEL_41;
                case 25:
                    v8 = sub_4420F7(this);
                    goto LABEL_41;
                case 26:
                    v8 = sub_442246(this);
                    goto LABEL_41;
                case 27:
                    v8 = sub_442399(this);
                    goto LABEL_41;
                default:
                    goto LABEL_43;
            }
        }
        LABEL_36:
        v8 = sub_4424D8(this);
        goto LABEL_41;
    }
    v9 = v7 - 29;
    if(!v9) {
        v8 = sub_442573(this);
        LABEL_41:
        if(v8 >= 0)
            return 0;
        goto LABEL_43;
    }
    v10 = v9 - 1;
    if(!v10) {
        v8 = sub_4426BF(this);
        goto LABEL_41;
    }
    v11 = v10 - 10;
    if(!v11 || (v12 = v11 - 1) == 0) {
        LABEL_19:
        v8 = sub_441C03();
        goto LABEL_41;
    }
    v13 = v12 - 9;
    if(!v13)
        goto LABEL_36;
    v14 = v13 - 1;
    if(!v14) {
        v8 = sub_4427E0(this);
        goto LABEL_41;
    }
    if(v14 == 1) {
        v8 = sub_44292C(this);
        goto LABEL_41;
    }
    LABEL_43:
    v44 = (float*)operator new(16 * *(_DWORD*) (this [1] + 4176));
    if(!v44)
        return -2147024882;
    v16 = *(_DWORD*) (*this + 4176);
    if(*(_DWORD*) (*this + 4180) == 1) {
        v17 = (char*)operator new(16 * v16);
        Block = v17;
        v48 = v17;
    }
    else {
        Block = (char*)operator new(32 * v16);
        v48 = &Block [16 * *(_DWORD*) (*this + 4176)];
        v17 = v48;
    }
    v18 = Block;
    if(Block) {
        if(*(_DWORD*) (*this + 4176) != 1) {
            v18 = Block + 16;
            v17 += 16;
        }
        v47 = 0;
        v43 = v18;
        for(i = v17; v47 < *(_DWORD*) (this [1] + 4180); ++v47) {
            (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, char*))(*(_DWORD*) *this + 4))(*this, 2 * v47, 0, Block);
            if(v48 != Block)
                (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, char*))(*(_DWORD*) *this + 4))(
                    *this,
                    2 * v47 + 1,
                    0,
                    v48);
            v46 = 0;
            if(*(_DWORD*) (this [1] + 4176)) {
                v45 = v44;
                do {
                    v20 = (float*) &Block [32 * v46];
                    v21 = (float*) &v43 [32 * v46];
                    v22 = v45;
                    v23 = *v21 + *v20;
                    v45 += 4;
                    v24 = v21 [1] + v20 [1];
                    v35 = v21 [2] + v20 [2];
                    v25 = v21 [3] + v20 [3];
                    v26 = (float*) &v48 [32 * v46];
                    v36 = v25;
                    v33 = v23 + *v26;
                    v27 = v24 + v26 [1];
                    v28 = v35 + v26 [2];
                    v29 = v36 + v26 [3];
                    v30 = (float*) &i [32 * v46++];
                    v34 = v29;
                    v31 = v33 + *v30;
                    v32 = v27 + v30 [1];
                    v37 = v31 * 0.25;
                    v38 = v32 * 0.25;
                    v39 = (v28 + v30 [2]) * 0.25;
                    v40 = (v34 + v30 [3]) * 0.25;
                    *v22++ = v37;
                    *v22++ = v38;
                    *v22 = v39;
                    v22 [1] = v40;
                }
                while(v46 < *(_DWORD*) (this [1] + 4176));
            }
            (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, float*))(*(_DWORD*) this [1] + 8))(this [1], v47, 0, v44);
        }
        j__free(Block);
        v19 = 0;
    }
    else {
        v19 = -2147024882;
    }
    j__free(v44);
    return v19;
}

//----- (00443312) --------------------------------------------------------
int __thiscall sub_443312(int this) {
    _DWORD* v1; // esi
    _DWORD* v2; // ecx
    _DWORD* v3; // eax
    int v4; // edx
    int v5; // edi
    int v7; // eax
    char* v8; // edx
    int v9; // ecx
    char* v10; // ebx
    char* v11; // edi
    char* v12; // eax
    int v13; // esi
    int v14; // eax
    int v15; // edi
    float* v16; // ecx
    float* v17; // edx
    double v18; // st6
    double v19; // st5
    double v20; // st4
    float* v21; // ecx
    double v22; // st6
    double v23; // st5
    double v24; // st4
    float* v25; // ecx
    double v26; // st6
    double v27; // st5
    float* v28; // ecx
    double v29; // st5
    float* v30; // ecx
    double v31; // st6
    double v32; // st5
    float* v33; // ecx
    float* v34; // edi
    float* v35; // eax
    float v36; // [esp+Ch] [ebp-3Ch]
    float v37; // [esp+18h] [ebp-30h]
    float v38; // [esp+24h] [ebp-24h]
    float v39; // [esp+28h] [ebp-20h]
    float v40; // [esp+34h] [ebp-14h]
    float v41; // [esp+38h] [ebp-10h]
    float v42; // [esp+3Ch] [ebp-Ch]
    float v43; // [esp+40h] [ebp-8h]
    float v44; // [esp+4Ch] [ebp+4h]
    float v45; // [esp+58h] [ebp+10h]
    float v46; // [esp+5Ch] [ebp+14h]
    float v47; // [esp+60h] [ebp+18h]
    float v48; // [esp+64h] [ebp+1Ch]
    float v49; // [esp+68h] [ebp+20h]
    float v50; // [esp+6Ch] [ebp+24h]
    float v51; // [esp+70h] [ebp+28h]
    float v52; // [esp+74h] [ebp+2Ch]
    float v53; // [esp+80h] [ebp+38h]
    float v54; // [esp+84h] [ebp+3Ch]
    float v55; // [esp+88h] [ebp+40h]
    char* v57; // [esp+90h] [ebp+48h]
    char* i; // [esp+94h] [ebp+4Ch]
    char* v59; // [esp+98h] [ebp+50h]
    char* v60; // [esp+9Ch] [ebp+54h]
    float* v61; // [esp+A0h] [ebp+58h]
    char* v62; // [esp+A4h] [ebp+5Ch]
    unsigned int v63; // [esp+A8h] [ebp+60h]
    float* v64; // [esp+ACh] [ebp+64h]
    unsigned int v65; // [esp+B0h] [ebp+68h]
    char* v66; // [esp+B4h] [ebp+6Ch]
    char* Block; // [esp+B8h] [ebp+70h]
    unsigned int v68; // [esp+BCh] [ebp+74h]

    v1 = (_DWORD*) this;
    if(*(_BYTE*) (this + 8) != 5)
        return -2147467259;
    v2 = *(_DWORD**) (this + 4);
    if(v2 [2] != 1)
        return -2147467259;
    v3 = (_DWORD*) *v1;
    if(*(_DWORD*) (*v1 + 8) != 1)
        return -2147467259;
    v4 = v2 [1044];
    if(v4 != v3 [1044] >> 1 && (v4 != 1 || v3 [1044] != 1))
        return -2147467259;
    v5 = v2 [1045];
    if(v5 != v3 [1045] >> 1 && (v5 != 1 || v3 [1045] != 1))
        return -2147467259;
    if(v2 [1046] != v3 [1046] >> 1)
        return -2147467259;
    v61 = (float*)operator new(16 * v4);
    if(!v61)
        return -2147024882;
    v7 = *(_DWORD*) (*v1 + 4176);
    if(*(_DWORD*) (*v1 + 4180) == 1) {
        v8 = (char*)operator new(32 * v7);
        v9 = *(_DWORD*) (*v1 + 4176);
        v10 = &v8 [16 * v9];
        v11 = v10;
        Block = v8;
        v66 = v8;
        v62 = v10;
    }
    else {
        v12 = (char*)operator new(v7 << 6);
        v9 = *(_DWORD*) (*v1 + 4176);
        v66 = &v12 [32 * v9];
        v10 = &v12 [16 * v9];
        v62 = &v12 [48 * v9];
        v8 = v66;
        v11 = v62;
        Block = v12;
    }
    if(Block) {
        if(v9 == 1) {
            v59 = Block;
            v57 = v10;
        }
        else {
            v59 = Block + 16;
            v8 += 16;
            v57 = v10 + 16;
            v11 += 16;
        }
        v14 = v1 [1];
        v65 = 0;
        v60 = v8;
        for(i = v11; v65 < *(_DWORD*) (v14 + 4184); v14 = v1 [1]) {
            v68 = 0;
            if(*(_DWORD*) (v14 + 4180)) {
                do {
                    v15 = 2 * v65;
                    (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, char*))(*(_DWORD*) *v1 + 4))(
                        *v1,
                        2 * v68,
                        2 * v65,
                        Block);
                    if(v10 != Block)
                        (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*) *v1 + 4))(*v1, 2 * v68, v15 + 1, v10);
                    if(v66 != Block)
                        (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*) *v1 + 4))(*v1, 2 * v68 + 1, v15, v66);
                    if(v62 != v10 && v62 != v66)
                        (*(void(__thiscall**)(_DWORD, unsigned int, int, char*))(*(_DWORD*) *v1 + 4))(
                            *v1,
                            2 * v68 + 1,
                            v15 + 1,
                            v62);
                    v63 = 0;
                    if(*(_DWORD*) (v1 [1] + 4176)) {
                        v64 = v61;
                        do {
                            v16 = (float*) &Block [32 * v63];
                            v17 = (float*) &v59 [32 * v63];
                            v18 = *v16 + *v17;
                            v19 = v17 [1] + v16 [1];
                            v38 = v17 [2] + v16 [2];
                            v20 = v17 [3] + v16 [3];
                            v21 = (float*) &v10 [32 * v63];
                            v39 = v20;
                            v44 = v18 + *v21;
                            v22 = v19 + v21 [1];
                            v23 = v38 + v21 [2];
                            v24 = v39 + v21 [3];
                            v25 = (float*) &v57 [32 * v63];
                            v45 = v24;
                            v42 = v44 + *v25;
                            v43 = v22 + v25 [1];
                            v26 = v23 + v25 [2];
                            v27 = v45 + v25 [3];
                            v28 = (float*) &v66 [32 * v63];
                            v50 = v42 + *v28;
                            v51 = v43 + v28 [1];
                            v52 = v26 + v28 [2];
                            v29 = v27 + v28 [3];
                            v30 = (float*) &v60 [32 * v63];
                            v31 = v29;
                            v32 = v50 + *v30;
                            v53 = v51 + v30 [1];
                            v54 = v52 + v30 [2];
                            v55 = v31 + v30 [3];
                            v33 = (float*) &v62 [32 * v63];
                            v34 = v64;
                            v64 += 4;
                            v40 = v54 + v33 [2];
                            v35 = (float*) &i [32 * v63++];
                            v41 = v55 + v33 [3];
                            v36 = v32 + *v33 + *v35;
                            v37 = v41 + v35 [3];
                            v46 = v36 * 0.125;
                            v47 = (v53 + v33 [1] + v35 [1]) * 0.125;
                            v48 = (v40 + v35 [2]) * 0.125;
                            v49 = v37 * 0.125;
                            *v34++ = v46;
                            *v34++ = v47;
                            *v34 = v48;
                            v34 [1] = v49;
                        }
                        while(v63 < *(_DWORD*) (*(_DWORD*) (this + 4) + 4176));
                        v1 = (_DWORD*) this;
                    }
                    (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, float*))(*(_DWORD*) v1 [1] + 8))(
                        v1 [1],
                        v68++,
                        v65,
                        v61);
                }
                while(v68 < *(_DWORD*) (v1 [1] + 4180));
            }
            ++v65;
        }
        j__free(Block);
        v13 = 0;
    }
    else {
        v13 = -2147024882;
    }
    j__free(v61);
    return v13;
}

//----- (004436BB) --------------------------------------------------------
int* __usercall sub_4436BB(unsigned int a1, unsigned int a2, int a3) {
    int* v3; // eax
    int* v4; // esi
    unsigned int v6; // edx
    double X; // st7
    int v8; // eax
    unsigned int v9; // ecx
    double v10; // st7
    int* v11; // [esp+14h] [ebp-1Ch]
    float v12; // [esp+20h] [ebp-10h]
    float v13; // [esp+24h] [ebp-Ch]
    float v14; // [esp+28h] [ebp-8h]
    unsigned int i; // [esp+2Ch] [ebp-4h]

    v3 = (int*)operator new(16 * a1);
    v4 = v3;
    if(!v3)
        return 0;
    v11 = v3;
    sub_442A6B();
    for(i = v6; i < a1; *((float*) v4 - 1) = 1.0 - v10) {
        v12 = (double) a2 / (double) a1;
        X = (double) i * v12 - 0.5;
        v14 = X;
        v13 = floor(X);
        v8 = (int) v13;
        v9 = v8 + 1;
        if(v8 < 0)
            v8 = a3 != 0 ? a2 - 1 : 0;
        if(v9 >= a2)
            v9 = a3 == 0 ? a2 - 1 : 0;
        *v4 = v8;
        v4 [2] = v9;
        v4 += 4;
        ++i;
        v10 = 1.0 - (v14 - v13);
        *((float*) v4 - 3) = v10;
    }
    sub_442A8E();
    return v11;
}
// 4436FE: variable 'v6' is possibly undefined

//----- (0044378C) --------------------------------------------------------
int __thiscall sub_44378C(_DWORD* this) {
    _DWORD* v1; // esi
    int v2; // edx
    unsigned int v3; // eax
    int* v4; // eax
    int* v5; // edi
    char* v6; // eax
    char* v7; // ebx
    int* v8; // edi
    int v9; // eax
    int v10; // ecx
    char* v11; // eax
    float* v12; // eax
    double v13; // st7
    int v14; // ecx
    double v15; // st7
    double v16; // st6
    int v17; // edx
    float* v18; // ecx
    double v19; // st6
    double v20; // st7
    double v21; // st6
    double v22; // st5
    double v23; // st5
    float* v24; // edi
    int v25; // esi
    float v27; // [esp+Ch] [ebp-48h]
    float v28; // [esp+10h] [ebp-44h]
    float v29; // [esp+14h] [ebp-40h]
    float v30; // [esp+18h] [ebp-3Ch]
    float v31; // [esp+1Ch] [ebp-38h]
    float v32; // [esp+20h] [ebp-34h]
    float v33; // [esp+24h] [ebp-30h]
    float v34; // [esp+2Ch] [ebp-28h]
    float v35; // [esp+30h] [ebp-24h]
    float v36; // [esp+34h] [ebp-20h]
    float v37; // [esp+40h] [ebp-14h]
    float v38; // [esp+44h] [ebp-10h]
    float v39; // [esp+48h] [ebp-Ch]
    float v40; // [esp+4Ch] [ebp-8h]
    float v41; // [esp+50h] [ebp-4h]
    float v42; // [esp+54h] [ebp+0h]
    float v43; // [esp+5Ch] [ebp+8h]
    float v44; // [esp+60h] [ebp+Ch]
    float v45; // [esp+64h] [ebp+10h]
    float v46; // [esp+6Ch] [ebp+18h]
    float v47; // [esp+70h] [ebp+1Ch]
    float v48; // [esp+74h] [ebp+20h]
    float v49; // [esp+80h] [ebp+2Ch]
    float v50; // [esp+84h] [ebp+30h]
    float v51; // [esp+88h] [ebp+34h]
    float v52; // [esp+8Ch] [ebp+38h]
    float v53; // [esp+90h] [ebp+3Ch]
    float v54; // [esp+94h] [ebp+40h]
    int* v55; // [esp+9Ch] [ebp+48h]
    void* v57; // [esp+A4h] [ebp+50h]
    unsigned int v58; // [esp+A8h] [ebp+54h]
    int* Block; // [esp+ACh] [ebp+58h]
    float* v60; // [esp+B0h] [ebp+5Ch]
    char* v61; // [esp+B4h] [ebp+60h]
    int v62; // [esp+B8h] [ebp+64h]
    int v63; // [esp+BCh] [ebp+68h]
    unsigned int v64; // [esp+C0h] [ebp+6Ch]
    float* v65; // [esp+C4h] [ebp+70h]
    int v66; // [esp+C8h] [ebp+74h]
    int* v67; // [esp+C8h] [ebp+74h]

    v65 = 0;
    v57 = 0;
    v1 = this;
    v2 = this [1];
    if(*(_DWORD*) (v2 + 8) != 1)
        return -2147467259;
    if(*(_DWORD*) (*this + 8) != 1)
        return -2147467259;
    v3 = this [2];
    if((_BYTE) v3 != 3)
        return -2147467259;
    v66 = ((v3 >> 17) & 1) == 0;
    Block = sub_4436BB(*(_DWORD*) (v2 + 4176), *(_DWORD*) (*this + 4176), (v3 & 0x10000) == 0);
    v4 = sub_4436BB(*(_DWORD*) (v1 [1] + 4180), *(_DWORD*) (*v1 + 4180), v66);
    v5 = v4;
    v55 = v4;
    if(Block
       && v4
       && (v65 = (float*)operator new(16 * *(_DWORD*) (v1 [1] + 4176))) != 0
       && (v6 = (char*)operator new(32 * *(_DWORD*) (*v1 + 4176)), (v57 = v6) != 0)) {
        v64 = 0;
        v63 = -1;
        v62 = -1;
        v7 = &v6 [16 * *(_DWORD*) (*v1 + 4176)];
        v61 = v6;
        if(*(_DWORD*) (v1 [1] + 4180)) {
            v8 = v5 + 2;
            v67 = v8;
            do {
                v9 = *(v8 - 2);
                v58 = 0;
                if(v9 != v63) {
                    v10 = v62;
                    if(v9 == v62) {
                        v11 = v61;
                        v62 = -1;
                        v61 = v7;
                        v63 = v10;
                        v7 = v11;
                    }
                    else {
                        v63 = *(v8 - 2);
                        (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(*v1, v9, 0, v61);
                    }
                }
                if(*v8 != v62) {
                    v62 = *v8;
                    (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(*v1, *v8, 0, v7);
                }
                if(*(_DWORD*) (v1 [1] + 4176)) {
                    v12 = (float*) (Block + 3);
                    v60 = v65;
                    do {
                        v13 = *v12;
                        v14 = 16 * *((_DWORD*) v12 - 1);
                        v31 = v13 * *(float*) &v7 [v14];
                        v32 = v13 * *(float*) &v7 [v14 + 4];
                        v33 = v13 * *(float*) &v7 [v14 + 8];
                        v15 = v13 * *(float*) &v7 [v14 + 12];
                        v16 = *(v12 - 2);
                        v17 = 16 * *((_DWORD*) v12 - 3);
                        v37 = v16 * *(float*) &v7 [v17 + 4];
                        v38 = v16 * *(float*) &v7 [v17 + 8];
                        v18 = (float*) &v61 [v14];
                        v39 = v16 * *(float*) &v7 [v17 + 12];
                        v43 = v16 * *(float*) &v7 [v17] + v31;
                        v44 = v37 + v32;
                        v45 = v38 + v33;
                        v19 = *((float*) v8 + 1);
                        v34 = v43 * v19;
                        v35 = v44 * v19;
                        v36 = v45 * v19;
                        v20 = (v39 + v15) * v19;
                        v21 = *v12;
                        v52 = v21 * *v18;
                        v53 = v21 * v18 [1];
                        v54 = v21 * v18 [2];
                        v22 = *(v12 - 2);
                        v12 += 4;
                        ++v58;
                        v49 = v22 * *(float*) &v61 [v17 + 4];
                        v50 = v22 * *(float*) &v61 [v17 + 8];
                        v51 = v22 * *(float*) &v61 [v17 + 12];
                        v46 = v22 * *(float*) &v61 [v17] + v52;
                        v47 = v49 + v53;
                        v48 = v50 + v54;
                        v23 = *((float*) v8 - 1);
                        v24 = v60;
                        v60 += 4;
                        v40 = v46 * v23;
                        v41 = v47 * v23;
                        v42 = v48 * v23;
                        v27 = v40 + v34;
                        v28 = v41 + v35;
                        v29 = v42 + v36;
                        v30 = (v51 + v21 * v18 [3]) * v23 + v20;
                        *v24++ = v27;
                        *v24++ = v28;
                        *v24 = v29;
                        v24 [1] = v30;
                        v8 = v67;
                    }
                    while(v58 < *(_DWORD*) (this [1] + 4176));
                    v1 = this;
                }
                (*(void(__thiscall**)(_DWORD, unsigned int, _DWORD, float*))(*(_DWORD*) v1 [1] + 8))(v1 [1], v64, 0, v65);
                v8 += 4;
                ++v64;
                v67 = v8;
            }
            while(v64 < *(_DWORD*) (v1 [1] + 4180));
        }
        v25 = 0;
    }
    else {
        v25 = -2147024882;
    }
    j__free(Block);
    j__free(v55);
    j__free(v65);
    j__free(v57);
    return v25;
}

//----- (00443ACD) --------------------------------------------------------
int __thiscall sub_443ACD(_DWORD* this) {
    _DWORD* v1; // esi
    int v2; // ebx
    int v3; // eax
    int* v4; // eax
    int* v5; // ebx
    char* v6; // eax
    int v7; // edi
    char* v8; // ecx
    char* v9; // edi
    int v10; // eax
    int* v11; // ebx
    int v12; // eax
    int v13; // ecx
    char* v14; // ecx
    char* v15; // eax
    float* v16; // eax
    double v17; // st7
    int v18; // ecx
    double v19; // st6
    int v20; // edx
    double v21; // st6
    double v22; // st7
    double v23; // st6
    double v24; // st5
    double v25; // st5
    double v26; // st7
    double v27; // st6
    double v28; // st7
    double v29; // st6
    double v30; // st6
    double v31; // st5
    float* v32; // ecx
    double v33; // st5
    double v34; // st6
    double v35; // st5
    double v36; // st4
    double v37; // st4
    double v38; // st3
    double v39; // st5
    float* v40; // edi
    int v41; // esi
    float v43; // [esp+Ch] [ebp-11Ch]
    float v44; // [esp+10h] [ebp-118h]
    float v45; // [esp+14h] [ebp-114h]
    float v46; // [esp+18h] [ebp-110h]
    float v47; // [esp+1Ch] [ebp-10Ch]
    float v48; // [esp+20h] [ebp-108h]
    float v49; // [esp+24h] [ebp-104h]
    float v50; // [esp+2Ch] [ebp-FCh]
    float v51; // [esp+30h] [ebp-F8h]
    float v52; // [esp+34h] [ebp-F4h]
    float v53; // [esp+3Ch] [ebp-ECh]
    float v54; // [esp+40h] [ebp-E8h]
    float v55; // [esp+44h] [ebp-E4h]
    float v56; // [esp+4Ch] [ebp-DCh]
    float v57; // [esp+50h] [ebp-D8h]
    float v58; // [esp+54h] [ebp-D4h]
    float v59; // [esp+5Ch] [ebp-CCh]
    float v60; // [esp+60h] [ebp-C8h]
    float v61; // [esp+64h] [ebp-C4h]
    float v62; // [esp+6Ch] [ebp-BCh]
    float v63; // [esp+70h] [ebp-B8h]
    float v64; // [esp+74h] [ebp-B4h]
    float v65; // [esp+7Ch] [ebp-ACh]
    float v66; // [esp+80h] [ebp-A8h]
    float v67; // [esp+84h] [ebp-A4h]
    float v68; // [esp+8Ch] [ebp-9Ch]
    float v69; // [esp+90h] [ebp-98h]
    float v70; // [esp+94h] [ebp-94h]
    float v71; // [esp+9Ch] [ebp-8Ch]
    float v72; // [esp+A0h] [ebp-88h]
    float v73; // [esp+A4h] [ebp-84h]
    float v74; // [esp+ACh] [ebp-7Ch]
    float v75; // [esp+B0h] [ebp-78h]
    float v76; // [esp+B4h] [ebp-74h]
    float v77; // [esp+BCh] [ebp-6Ch]
    float v78; // [esp+C0h] [ebp-68h]
    float v79; // [esp+C4h] [ebp-64h]
    float v80; // [esp+CCh] [ebp-5Ch]
    float v81; // [esp+D0h] [ebp-58h]
    float v82; // [esp+D4h] [ebp-54h]
    float v83; // [esp+DCh] [ebp-4Ch]
    float v84; // [esp+E0h] [ebp-48h]
    float v85; // [esp+E4h] [ebp-44h]
    float v86; // [esp+F0h] [ebp-38h]
    float v87; // [esp+F4h] [ebp-34h]
    float v88; // [esp+F8h] [ebp-30h]
    float v89; // [esp+100h] [ebp-28h]
    float v90; // [esp+104h] [ebp-24h]
    float v91; // [esp+108h] [ebp-20h]
    float v92; // [esp+10Ch] [ebp-1Ch]
    float v93; // [esp+110h] [ebp-18h]
    float v94; // [esp+114h] [ebp-14h]
    float v95; // [esp+11Ch] [ebp-Ch]
    float v96; // [esp+120h] [ebp-8h]
    float v97; // [esp+124h] [ebp-4h]
    float v98; // [esp+12Ch] [ebp+4h]
    float v99; // [esp+130h] [ebp+8h]
    float v100; // [esp+134h] [ebp+Ch]
    float v101; // [esp+140h] [ebp+18h]
    float v102; // [esp+144h] [ebp+1Ch]
    float v103; // [esp+148h] [ebp+20h]
    float v104; // [esp+150h] [ebp+28h]
    float v105; // [esp+154h] [ebp+2Ch]
    float v106; // [esp+158h] [ebp+30h]
    int* v107; // [esp+15Ch] [ebp+34h]
    float* v109; // [esp+164h] [ebp+3Ch]
    void* v110; // [esp+168h] [ebp+40h]
    int* Block; // [esp+16Ch] [ebp+44h]
    char* v112; // [esp+170h] [ebp+48h]
    char* v113; // [esp+174h] [ebp+4Ch]
    unsigned int v114; // [esp+178h] [ebp+50h]
    float* v115; // [esp+17Ch] [ebp+54h]
    char* v116; // [esp+180h] [ebp+58h]
    unsigned int v117; // [esp+184h] [ebp+5Ch]
    int v118; // [esp+188h] [ebp+60h]
    unsigned int v119; // [esp+188h] [ebp+60h]
    char* v120; // [esp+18Ch] [ebp+64h]
    int v121; // [esp+190h] [ebp+68h]
    int* v122; // [esp+190h] [ebp+68h]
    int v123; // [esp+194h] [ebp+6Ch]
    int v124; // [esp+198h] [ebp+70h]
    float* v125; // [esp+19Ch] [ebp+74h]

    v115 = 0;
    v110 = 0;
    v1 = this;
    v2 = this [1];
    if(*(_DWORD*) (v2 + 8) != 1)
        return -2147467259;
    if(*(_DWORD*) (*this + 8) != 1)
        return -2147467259;
    v3 = this [2];
    if((_BYTE) v3 != 3)
        return -2147467259;
    v121 = (v3 & 0x20000) == 0;
    v118 = (v3 & 0x40000) == 0;
    Block = sub_4436BB(*(_DWORD*) (v2 + 4176), *(_DWORD*) (*this + 4176), (v3 & 0x10000) == 0);
    v122 = sub_4436BB(*(_DWORD*) (v1 [1] + 4180), *(_DWORD*) (*v1 + 4180), v121);
    v4 = sub_4436BB(*(_DWORD*) (v1 [1] + 4184), *(_DWORD*) (*v1 + 4184), v118);
    v5 = v4;
    v107 = v4;
    if(Block
       && v122
       && v4
       && (v115 = (float*)operator new(16 * *(_DWORD*) (v1 [1] + 4176))) != 0
       && (v6 = (char*)operator new(*(_DWORD*) (*v1 + 4176) << 6), (v110 = v6) != 0)) {
        v7 = *(_DWORD*) (*v1 + 4176);
        v117 = 0;
        v120 = &v6 [16 * v7];
        v8 = &v6 [32 * v7];
        v9 = &v6 [48 * v7];
        v116 = v6;
        v10 = v1 [1];
        v112 = v8;
        v113 = v9;
        if(*(_DWORD*) (v10 + 4184)) {
            v125 = (float*) (v5 + 2);
            do {
                v114 = 0;
                v123 = -1;
                v124 = -1;
                if(*(_DWORD*) (v10 + 4180)) {
                    v11 = v122 + 2;
                    do {
                        v12 = *(v11 - 2);
                        v119 = 0;
                        if(v12 != v123) {
                            v13 = v124;
                            if(v12 == v124) {
                                v124 = -1;
                                v123 = v13;
                                v14 = v120;
                                v120 = v116;
                                v15 = v112;
                                v112 = v9;
                                v116 = v14;
                                v113 = v15;
                                v9 = v15;
                            }
                            else {
                                v123 = *(v11 - 2);
                                (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(
                                    *v1,
                                    v12,
                                    *((_DWORD*) v125 - 2),
                                    v116);
                                (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(
                                    *v1,
                                    v123,
                                    *(_DWORD*) v125,
                                    v112);
                            }
                        }
                        if(*v11 != v124) {
                            v124 = *v11;
                            (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(
                                *v1,
                                *v11,
                                *((_DWORD*) v125 - 2),
                                v120);
                            (*(void(__thiscall**)(_DWORD, int, _DWORD, char*))(*(_DWORD*) *v1 + 4))(*v1, v124, *(_DWORD*) v125, v9);
                        }
                        if(*(_DWORD*) (v1 [1] + 4176)) {
                            v16 = (float*) (Block + 3);
                            v109 = v115;
                            do {
                                v17 = *v16;
                                v18 = 16 * *((_DWORD*) v16 - 1);
                                v71 = v17 * *(float*) &v9 [v18];
                                v72 = v17 * *(float*) &v9 [v18 + 4];
                                v73 = v17 * *(float*) &v9 [v18 + 8];
                                v19 = *(v16 - 2);
                                v20 = 16 * *((_DWORD*) v16 - 3);
                                v104 = v19 * *(float*) &v9 [v20 + 4];
                                v105 = v19 * *(float*) &v9 [v20 + 8];
                                v106 = v19 * *(float*) &v9 [v20 + 12];
                                v95 = v19 * *(float*) &v9 [v20] + v71;
                                v96 = v104 + v72;
                                v97 = v105 + v73;
                                v21 = *((float*) v11 + 1);
                                v53 = v95 * v21;
                                v54 = v96 * v21;
                                v55 = v97 * v21;
                                v22 = (v106 + v17 * *(float*) &v9 [v18 + 12]) * v21;
                                v23 = *v16;
                                v47 = v23 * *(float*) &v112 [v18];
                                v48 = v23 * *(float*) &v112 [v18 + 4];
                                v49 = v23 * *(float*) &v112 [v18 + 8];
                                v24 = *(v16 - 2);
                                v89 = v24 * *(float*) &v112 [v20 + 4];
                                v90 = v24 * *(float*) &v112 [v20 + 8];
                                v91 = v24 * *(float*) &v112 [v20 + 12];
                                v65 = v24 * *(float*) &v112 [v20] + v47;
                                v66 = v89 + v48;
                                v67 = v90 + v49;
                                v25 = *((float*) v11 - 1);
                                v83 = v65 * v25;
                                v84 = v66 * v25;
                                v85 = v67 * v25;
                                v77 = v83 + v53;
                                v78 = v84 + v54;
                                v79 = v85 + v55;
                                v26 = (v91 + v23 * *(float*) &v112 [v18 + 12]) * v25 + v22;
                                v27 = v125 [1];
                                v50 = v77 * v27;
                                v51 = v78 * v27;
                                v52 = v79 * v27;
                                v28 = v26 * v27;
                                v29 = *v16;
                                v59 = v29 * *(float*) &v120 [v18];
                                v60 = v29 * *(float*) &v120 [v18 + 4];
                                v61 = v29 * *(float*) &v120 [v18 + 8];
                                v30 = v29 * *(float*) &v120 [v18 + 12];
                                v31 = *(v16 - 2);
                                v101 = v31 * *(float*) &v120 [v20 + 4];
                                v102 = v31 * *(float*) &v120 [v20 + 8];
                                v32 = (float*) &v116 [v18];
                                v103 = v31 * *(float*) &v120 [v20 + 12];
                                v98 = v31 * *(float*) &v120 [v20] + v59;
                                v99 = v101 + v60;
                                v100 = v102 + v61;
                                v33 = *((float*) v11 + 1);
                                v68 = v98 * v33;
                                v69 = v99 * v33;
                                v70 = v100 * v33;
                                v34 = (v103 + v30) * v33;
                                v35 = *v16;
                                v92 = v35 * *v32;
                                v93 = v35 * v32 [1];
                                v94 = v35 * v32 [2];
                                v36 = *(v16 - 2);
                                v86 = v36 * *(float*) &v116 [v20 + 4];
                                v87 = v36 * *(float*) &v116 [v20 + 8];
                                v88 = v36 * *(float*) &v116 [v20 + 12];
                                v80 = v36 * *(float*) &v116 [v20] + v92;
                                v81 = v86 + v93;
                                v82 = v87 + v94;
                                v37 = *((float*) v11 - 1);
                                v74 = v80 * v37;
                                v75 = v81 * v37;
                                v76 = v82 * v37;
                                v38 = (v88 + v35 * v32 [3]) * v37;
                                v62 = v74 + v68;
                                v63 = v75 + v69;
                                v64 = v76 + v70;
                                v39 = *(v125 - 1);
                                v56 = v62 * v39;
                                v57 = v63 * v39;
                                v58 = v64 * v39;
                                v40 = v109;
                                v109 += 4;
                                v43 = v56 + v50;
                                v16 += 4;
                                ++v119;
                                v44 = v57 + v51;
                                v45 = v58 + v52;
                                v46 = (v38 + v34) * v39 + v28;
                                *v40++ = v43;
                                *v40++ = v44;
                                *v40 = v45;
                                v40 [1] = v46;
                                v9 = v113;
                            }
                            while(v119 < *(_DWORD*) (this [1] + 4176));
                            v1 = this;
                        }
                        (*(void(__thiscall**)(_DWORD, unsigned int, unsigned int, float*))(*(_DWORD*) v1 [1] + 8))(
                            v1 [1],
                            v114,
                            v117,
                            v115);
                        v11 += 4;
                        ++v114;
                    }
                    while(v114 < *(_DWORD*) (v1 [1] + 4180));
                }
                v125 += 4;
                ++v117;
                v10 = v1 [1];
            }
            while(v117 < *(_DWORD*) (v10 + 4184));
        }
        v41 = 0;
    }
    else {
        v41 = -2147024882;
    }
    j__free(Block);
    j__free(v122);
    j__free(v107);
    j__free(v115);
    j__free(v110);
    return v41;
}

//----- (0044411A) --------------------------------------------------------
int __thiscall sub_44411A(float** this, float* Block, float* a3, float* a4) {
    float* v5; // eax
    float* v6; // eax
    int v7; // ebx
    float* v8; // ecx

    this [1] = 0;
    *this = 0;
    this [2] = a4;
    if(!(_WORD) a4 || (unsigned __int16) a4 > 5u || ((unsigned int) a4 & 0xFFF00000) != 0)
        return -2005530516;
    *((_DWORD*) Block + 16) = (unsigned int) a4 & 0x80000;
    v5 = sub_4496CA(Block);
    this [1] = v5;
    if(v5
       && (v6 = sub_4496CA(a3), (*this = v6) != 0)
       && *((_DWORD*) this [1] + 2) == *((_DWORD*) v6 + 2)
       && (sub_442A9E(this) >= 0
       || sub_442BD0(this) >= 0
       || sub_442C72(this) >= 0
       || sub_442DE7(this) >= 0
       || sub_442F7D(this) >= 0
       || sub_443312((int) this) >= 0
       || sub_44378C(this) >= 0
       || sub_443ACD(this) >= 0
       || sub_4411F5(this) >= 0
       || sub_4415AB(this) >= 0)) {
        v7 = 0;
    }
    else {
        v7 = -2147467259;
    }
    v8 = this [1];
    if(v8) {
        (**(void(__thiscall***)(float*, int))v8)(v8, 1);
        this [1] = 0;
    }
    if(*this) {
        (**(void(__thiscall***)(float*, int)) * this)(*this, 1);
        *this = 0;
    }
    return v7;
}

//----- (0044422C) --------------------------------------------------------
_DWORD* __thiscall sub_44422C(_DWORD* this) {
    _DWORD* result; // eax

    result = this;
    *this = 0;
    this [1] = 0;
    this [7] = 0;
    this [8] = 0;
    this [9] = 0;
    this [10] = 0;
    this [11] = 0;
    return result;
}

//----- (00444245) --------------------------------------------------------
void __thiscall sub_444245(int this) {
    void* v2; // edi
    void* v3; // esi

    if(*(_DWORD*) (this + 4) && *(_DWORD*) (this + 32))
        j__free(*(void**) (this + 4));
    if(*(_DWORD*) (this + 28) && *(_DWORD*) (this + 36))
        j__free(*(void**) (this + 28));
    v2 = *(void**) (this + 40);
    if(v2) {
        sub_444245(*(_DWORD*) (this + 40));
        j__free(v2);
    }
    v3 = *(void**) (this + 44);
    if(v3) {
        sub_444245(v3);
        j__free(v3);
    }
}

//----- (0044429E) --------------------------------------------------------
int __thiscall sub_44429E(int* this, int a2, unsigned int a3) {
    int* v3; // esi
    int v5; // ebx
    unsigned __int16 v6; // dx
    int v7; // eax
    int v8; // eax
    unsigned int v9; // eax
    int v10; // ecx
    int v11; // ebx
    int v12; // eax
    int v13; // eax
    unsigned int v14; // ebx
    void* v15; // eax
    _BYTE* v16; // eax
    int v17; // ecx
    int v19; // eax
    int v20; // eax
    int v21; // ecx
    unsigned int v22; // ecx
    unsigned int v23; // eax
    char* v24; // eax
    char* v25; // edx
    int v26; // ecx
    char* v27; // ebx
    int v28; // eax
    __int16 v29; // di
    int v30; // ecx
    unsigned int v31; // eax
    unsigned int v32; // eax
    int v33; // ecx
    int v34; // eax
    int v35; // eax
    char* v36; // edi
    char v37; // si
    int v38; // ecx
    int v39; // eax
    unsigned int j; // ecx
    unsigned int v41; // eax
    char* v42; // edi
    unsigned __int8* v43; // esi
    unsigned int v44; // [esp+Ch] [ebp-1Ch]
    unsigned int v45; // [esp+Ch] [ebp-1Ch]
    unsigned int v46; // [esp+10h] [ebp-18h]
    int v47; // [esp+10h] [ebp-18h]
    unsigned int i; // [esp+14h] [ebp-14h]
    char* v50; // [esp+18h] [ebp-10h]
    unsigned int v51; // [esp+1Ch] [ebp-Ch]
    unsigned int v52; // [esp+1Ch] [ebp-Ch]
    int v53; // [esp+20h] [ebp-8h]
    char* v54; // [esp+20h] [ebp-8h]
    char* v55; // [esp+24h] [ebp-4h]
    unsigned int v56; // [esp+30h] [ebp+8h]
    int v57; // [esp+34h] [ebp+Ch]
    char* v58; // [esp+34h] [ebp+Ch]

    v3 = this;
    if(a3 < 0x28 || *(_DWORD*) a2 < 0x28u)
        return -2147467259;
    v5 = *(_DWORD*) (a2 + 8);
    v56 = *(_DWORD*) (a2 + 4);
    if(v5 <= 0)
        v53 = -v5;
    else
        v53 = v5;
    v6 = *(_WORD*) (a2 + 14);
    v7 = *(_DWORD*) (a2 + 32);
    if(v6 <= 8u && !v7)
        v7 = 1 << v6;
    v46 = *(_DWORD*) a2 + 4 * v7;
    if(v46 > a3)
        return -2147467259;
    if(*(_WORD*) (a2 + 12) != 1)
        return -2147467259;
    if(v5 < 0) {
        v8 = *(_DWORD*) (a2 + 16);
        if(v8) {
            if(v8 != 3)
                return -2147467259;
        }
    }
    v9 = *(_DWORD*) (a2 + 16);
    if(v9 <= 2) {
        if(v6 == 1 || v6 == 4 || v6 == 8) {
            v14 = *(_DWORD*) (a2 + 32);
            v57 = 41;
            v44 = v14;
            if(!v14) {
                v14 = 1 << v6;
                v44 = 1 << v6;
            }
            this [9] = 1;
            v15 = operator new(0x400u);
            v3 [7] = (int) v15;
            if(!v15)
                return -2147024882;
            v51 = 0;
            v16 = (_BYTE*) (a2 + *(_DWORD*) a2);
            if(v14) {
                do {
                    v17 = 4 * v51;
                    *(_BYTE*) (v17 + v3 [7]) = v16 [2];
                    *(_BYTE*) (v3 [7] + v17 + 1) = v16 [1];
                    *(_BYTE*) (v3 [7] + v17 + 2) = *v16;
                    *(_BYTE*) (v3 [7] + v17 + 3) = -1;
                    ++v51;
                    v14 = v44;
                    v16 += 4;
                }
                while(v51 < v44);
            }
            while(v14 < 0x100) {
                v19 = 4 * v14;
                *(_BYTE*) (v19 + v3 [7]) = -1;
                *(_BYTE*) (v3 [7] + v19 + 1) = -1;
                *(_BYTE*) (v3 [7] + v19 + 2) = -1;
                *(_BYTE*) (v3 [7] + v19 + 3) = -1;
                ++v14;
            }
            goto LABEL_73;
        }
        if(v6 != 16) {
            if(v6 != 24) {
                if(v6 != 32)
                    return -2147467259;
                LABEL_62:
                v57 = 22;
                goto LABEL_73;
            }
            LABEL_30:
            v57 = 20;
            goto LABEL_73;
        }
        goto LABEL_63;
    }
    if(v9 == 3) {
        if(*(_DWORD*) a2 < 0x6Cu)
            return -2147467259;
        v10 = *(_DWORD*) (a2 + 48);
        v11 = *(_DWORD*) (a2 + 40);
        v12 = *(unsigned __int16*) (a2 + 14);
        if(v6 != 16) {
            if(v12 != 24) {
                if(v12 != 32 || v10 != 255 || *(_DWORD*) (a2 + 44) != 65280 || v11 != 16711680)
                    return -2147467259;
                if(*(_DWORD*) (a2 + 52)) {
                    if(*(_DWORD*) (a2 + 52) == -16777216) {
                        v57 = 21;
                        goto LABEL_73;
                    }
                    return -2147467259;
                }
                goto LABEL_62;
            }
            if(v10 != 255 || *(_DWORD*) (a2 + 44) != 65280 || v11 != 16711680 || *(_DWORD*) (a2 + 52))
                return -2147467259;
            goto LABEL_30;
        }
        if(v10 == 255 && *(_DWORD*) (a2 + 44) == 255 && v11 == 255 && *(_DWORD*) (a2 + 52) == 65280) {
            v57 = 51;
            goto LABEL_73;
        }
        if(v10 != 31)
            goto LABEL_46;
        v13 = *(_DWORD*) (a2 + 44);
        if(v13 == 2016 && v11 == 63488 && !*(_DWORD*) (a2 + 52)) {
            v57 = 23;
            goto LABEL_73;
        }
        if(v13 != 992 || v11 != 31744)
            goto LABEL_46;
        if(*(_DWORD*) (a2 + 52)) {
            if(*(_DWORD*) (a2 + 52) == 0x8000) {
                v57 = 25;
                goto LABEL_73;
            }
            LABEL_46:
            if(v10 == 15 && *(_DWORD*) (a2 + 44) == 240 && v11 == 3840 && *(_DWORD*) (a2 + 52) == 61440) {
                v57 = 26;
            }
            else {
                if(v10 != 3 || *(_DWORD*) (a2 + 44) != 28 || v11 != 224 || *(_DWORD*) (a2 + 52) != 65280)
                    return -2147467259;
                v57 = 29;
            }
            LABEL_73:
            if(*(_WORD*) (a2 + 14) == 1) {
                v22 = v56 >> 3;
            }
            else {
                if(*(_WORD*) (a2 + 14) != 4) {
                    v20 = v56 * (*(unsigned __int16*) (a2 + 14) >> 3);
                    v21 = v20 + 3;
                    goto LABEL_79;
                }
                v22 = v56 >> 1;
            }
            v20 = v56;
            v21 = v22 + 3;
            LABEL_79:
            v52 = v21 & 0xFFFFFFFC;
            v45 = v20;
            *v3 = v57;
            v3 [5] = v56;
            v23 = (v20 + 3) & 0xFFFFFFFC;
            v3 [2] = v23;
            v3 [3] = 0;
            v3 [4] = 0;
            v3 [6] = v53;
            if(*(int*) (a2 + 8) < 0 && *(_WORD*) (a2 + 14) >= 8u) {
                v3 [8] = 0;
                v3 [1] = a2 + v46;
                return 0;
            }
            v3 [8] = 1;
            v24 = (char*)operator new(v53 * v23);
            v58 = v24;
            v3 [1] = (int) v24;
            if(!v24)
                return -2147024882;
            v25 = (char*) (v46 + a2);
            v26 = v3 [2];
            if(*(int*) (a2 + 8) >= 0) {
                v47 = -v26;
                v27 = &v24 [v26 * (v53 - 1)];
            }
            else {
                v47 = v3 [2];
                v27 = v24;
            }
            v28 = *(_DWORD*) (a2 + 16);
            v55 = v27;
            v50 = v27;
            v54 = &v58 [v53 * v26];
            if(v28 == 2) {
                while(v27 >= v58) {
                    if(*v25) {
                        v33 = 0;
                        do {
                            if((v33 & 1) != 0)
                                LOBYTE(v34) = v25 [1] & 0xF;
                            else
                                v34 = (unsigned __int8) v25 [1] >> 4;
                            v27 [v33++] = v34;
                        }
                        while(v33 < (unsigned __int8) *v25);
                        v3 = this;
                        v27 += (unsigned __int8) *v25;
                    }
                    else if(v25 [1]) {
                        if(v25 [1] == 1) {
                            v27 = &v58 [-v3 [2]];
                        }
                        else if(v25 [1] == 2) {
                            v27 += (unsigned __int8) v25 [2] - v3 [2] * (unsigned __int8) v25 [3];
                            v25 += 2;
                        }
                        else {
                            v30 = 0;
                            if(v25 [1]) {
                                do {
                                    v31 = (unsigned __int8) v25 [(v30 >> 1) + 2];
                                    if((v30 & 1) != 0)
                                        LOBYTE(v31) = v31 & 0xF;
                                    else
                                        v31 >>= 4;
                                    v27 [v30++] = v31;
                                }
                                while(v30 < (unsigned __int8) v25 [1]);
                                v3 = this;
                            }
                            v32 = (unsigned __int8) v25 [1];
                            v27 += v32;
                            v25 += ((v32 >> 1) + 1) & 0xFFFFFFFE;
                        }
                    }
                    else {
                        v27 = &v50 [-v3 [2]];
                        v50 = v27;
                    }
                    v25 += 2;
                }
                return 0;
            }
            if(v28 != 1) {
                v29 = *(_WORD*) (a2 + 14);
                if(v29 == 1) {
                    while(v27 >= v58 && v27 < v54) {
                        for(i = 0; i < v56; ++i)
                            v27 [i] = ((unsigned __int8) v25 [i >> 3] >> (7 - (i & 7))) & 1;
                        v27 += v47;
                        v25 += v52;
                    }
                }
                else if(v29 == 4) {
                    while(v27 >= v58 && v27 < v54) {
                        for(j = 0; j < v56; ++j) {
                            v41 = (unsigned __int8) v25 [j >> 1];
                            if((j & 1) != 0)
                                LOBYTE(v41) = v41 & 0xF;
                            else
                                v41 >>= 4;
                            v27 [j] = v41;
                        }
                        v27 += v47;
                        v25 += v52;
                    }
                }
                else {
                    while(v27 >= v58 && v27 < v54) {
                        v42 = v27;
                        v27 += v47;
                        qmemcpy(v42, v25, 4 * (v45 >> 2));
                        v43 = (unsigned __int8*) &v25 [4 * (v45 >> 2)];
                        v25 += v52;
                        qmemcpy(&v42 [4 * (v45 >> 2)], v43, v45 & 3);
                    }
                }
                return 0;
            }
            while(1) {
                if(v27 < v58)
                    return 0;
                if(*v25) {
                    v36 = v27;
                    LOBYTE(v27) = v25 [1];
                    BYTE1(v27) = (_BYTE) v27;
                    v37 = *v25;
                    v38 = (unsigned __int8) *v25 >> 2;
                    v39 = (_DWORD) v27 << 16;
                    LOWORD(v39) = (_WORD) v27;
                    memset32(v36, v39, v38);
                    memset(&v36 [4 * v38], (char) v27, v37 & 3);
                    v27 = &v55 [(unsigned __int8) *v25];
                }
                else {
                    switch(v25 [1]) {
                        case 0:
                            v27 = &v50 [-v3 [2]];
                            v50 = v27;
                            goto LABEL_125;
                        case 1:
                            v27 = &v58 [-v3 [2]];
                            goto LABEL_125;
                        case 2:
                            v27 += (unsigned __int8) v25 [2] - v3 [2] * (unsigned __int8) v25 [3];
                            v25 += 2;
                            goto LABEL_125;
                    }
                    qmemcpy(v27, v25 + 2, (unsigned __int8) v25 [1]);
                    v35 = (unsigned __int8) v25 [1];
                    v27 += v35;
                    v25 += (v35 + 1) & 0xFFFFFFFE;
                }
                v3 = this;
                LABEL_125:
                v55 = v27;
                v25 += 2;
            }
        }
        LABEL_63:
        v57 = 24;
        goto LABEL_73;
    }
    return -2147467263;
}
// 444393: conditional instruction was optimized away because ebx.4==FF0000
// 44445A: conditional instruction was optimized away because ebx.4==7C00

//----- (004448D9) --------------------------------------------------------
void __cdecl __noreturn sub_4448D9(int a1) {
    (*(void(__cdecl**)(int))(*(_DWORD*) a1 + 8))(a1);
    longjmp((int*) (*(_DWORD*) a1 + 132), 1);
}

//----- (004448F5) --------------------------------------------------------
int __cdecl sub_4448F5(int a1) {
    char v2 [200]; // [esp+0h] [ebp-C8h] BYREF

    return (*(int(__cdecl**)(int, char*))(*(_DWORD*) a1 + 12))(a1, v2);
}
// 4448F5: using guessed type char var_C8[200];

//----- (00444912) --------------------------------------------------------
char __cdecl sub_444912(int a1) {
    _DWORD* v1; // eax

    v1 = *(_DWORD**) (a1 + 20);
    *v1 = v1 [7];
    v1 [1] = v1 [8];
    return 1;
}

//----- (00444927) --------------------------------------------------------
_DWORD* __cdecl sub_444927(int a1, int a2) {
    _DWORD* result; // eax

    result = *(_DWORD**) (a1 + 20);
    *result += a2;
    result [1] -= a2;
    return result;
}

//----- (00444939) --------------------------------------------------------
int __thiscall sub_444939(_DWORD* this, int a2, int a3) {
    int v3; // esi
    _DWORD* v4; // eax
    unsigned int v5; // eax
    _DWORD* v6; // esi
    unsigned int v7; // ecx
    int v8; // ecx
    unsigned int v9; // eax
    void* v10; // eax
    const void** v11; // edi
    char* v12; // ebx
    int* v13; // esi
    _BYTE* v14; // eax
    int* i; // ecx
    int v16; // ebx
    unsigned __int16 v17; // dx
    int v19; // [esp-4h] [ebp-284h]
    size_t v20; // [esp-4h] [ebp-284h]
    void(__cdecl __noreturn * v21)(int); // [esp+Ch] [ebp-274h] BYREF
    int(__cdecl * v22)(int); // [esp+14h] [ebp-26Ch]
    char v23 [64]; // [esp+90h] [ebp-1F0h] BYREF
    void(__cdecl __noreturn * *v24)(int); // [esp+D0h] [ebp-1B0h] BYREF
    int v25; // [esp+D4h] [ebp-1ACh]
    _DWORD* v26; // [esp+E4h] [ebp-19Ch]
    unsigned int v27; // [esp+12Ch] [ebp-154h]
    unsigned int v28; // [esp+130h] [ebp-150h]
    int v29; // [esp+138h] [ebp-148h]
    unsigned int v30; // [esp+148h] [ebp-138h]
    const void** v31; // [esp+278h] [ebp-8h]
    _DWORD* v32; // [esp+27Ch] [ebp-4h]

    v32 = this;
    v24 = sub_44BB62(&v21);
    v21 = sub_4448D9;
    v22 = nullsub_1;
    if(_setjmp3(v23, 0, v19))
        goto LABEL_2;
    sub_449D54(&v24, 61, 424);
    v4 = (_DWORD*) (*(int(__cdecl**)(void(__cdecl __noreturn***)(int), _DWORD, int))v25)(&v24, 0, 36);
    v26 = v4;
    v4 [8] = a3;
    v4 [2] = nullsub_1;
    v4 [3] = sub_444912;
    v4 [4] = sub_444927;
    v4 [5] = sub_44B8D8;
    v4 [6] = nullsub_1;
    v4 [1] = 0;
    *v4 = 0;
    v4 [7] = a2;
    sub_44A0D3(&v24, 1);
    v22 = sub_4448F5;
    sub_44A25E((int) &v24);
    if(v29 == 1) {
        v6 = v32;
        v5 = v27;
        *v32 = 50;
        v6 [2] = v5;
    }
    else {
        if(v29 != 3) {
            LABEL_2:
            v3 = -2147467259;
            goto LABEL_22;
        }
        v5 = v27;
        v6 = v32;
        v7 = 4 * v27;
        *v32 = 22;
        v6 [2] = v7;
    }
    v8 = v6 [2];
    v6 [5] = v5;
    v9 = v28;
    v20 = v28 * v8;
    v6 [8] = 1;
    v6 [3] = 0;
    v6 [4] = 0;
    v6 [6] = v9;
    v10 = operator new(v20);
    v6 [1] = v10;
    if(v10
       && (v11 = (const void**) (*(int(__cdecl**)(void(__cdecl __noreturn***)(int), int, unsigned int, int))(v25 + 8))(
       &v24,
       1,
       v29 * v27,
       1),
       (v31 = v11) != 0)) {
        if(*v6 == 50) {
            v12 = (char*) v6 [1];
            if(v30 < v28) {
                while(1) {
                    sub_44A1DA(&v24, (int) v11, 1);
                    qmemcpy(v12, *v11, v27);
                    v12 += v27;
                    if(v30 >= v28)
                        break;
                    v11 = v31;
                }
            }
        }
        else if(*v6 == 22) {
            v13 = (int*) v6 [1];
            while(v30 < v28) {
                sub_44A1DA(&v24, (int) v11, 1);
                v14 = *v11;
                for(i = &v13 [v27]; v13 < i; ++v13) {
                    v16 = (unsigned __int8) v14 [2];
                    HIBYTE(v17) = *v14;
                    v14 += 3;
                    LOBYTE(v17) = *(v14 - 2);
                    *v13 = v16 | (v17 << 8);
                }
            }
        }
        sub_44A032((int) &v24);
        v3 = 0;
    }
    else {
        v3 = -2147024882;
    }
    LABEL_22:
    sub_449E14((int) &v24);
    return v3;
}
// 444978: variable 'v19' is possibly undefined
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);
// 444939: using guessed type char var_1F0[64];

//----- (00444B8E) --------------------------------------------------------
int __thiscall sub_444B8E(int* this, unsigned __int8* a2, unsigned int a3) {
    int* v3; // esi
    unsigned __int8 v5; // cl
    int v6; // edx
    int v7; // eax
    unsigned int v8; // edi
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // ecx
    int v13; // ecx
    int v14; // ecx
    int v15; // ecx
    unsigned int v16; // eax
    void* v17; // edx
    unsigned __int16* v18; // edi
    unsigned int v19; // eax
    unsigned int v20; // eax
    unsigned int v21; // ecx
    int v22; // edx
    unsigned int v23; // edx
    unsigned int v24; // edx
    _BYTE* v25; // esi
    unsigned int v26; // ecx
    size_t v27; // eax
    char* v28; // eax
    char* v30; // edx
    unsigned int v31; // eax
    int v32; // ecx
    unsigned int v33; // [esp+Ch] [ebp-30h]
    unsigned int v34; // [esp+Ch] [ebp-30h]
    unsigned int v35; // [esp+10h] [ebp-2Ch]
    int v37; // [esp+18h] [ebp-24h]
    BOOL v38; // [esp+1Ch] [ebp-20h]
    BOOL v39; // [esp+20h] [ebp-1Ch]
    int v40; // [esp+24h] [ebp-18h]
    int v41; // [esp+24h] [ebp-18h]
    char v42; // [esp+28h] [ebp-14h]
    unsigned int v43; // [esp+28h] [ebp-14h]
    int v44; // [esp+2Ch] [ebp-10h]
    int v45; // [esp+2Ch] [ebp-10h]
    _BYTE* v46; // [esp+30h] [ebp-Ch]
    char* v47; // [esp+30h] [ebp-Ch]
    int v48; // [esp+34h] [ebp-8h]
    unsigned int v49; // [esp+38h] [ebp-4h]
    int v50; // [esp+44h] [ebp+8h]
    _BYTE* v51; // [esp+44h] [ebp+8h]
    unsigned int v52; // [esp+48h] [ebp+Ch]
    unsigned int v53; // [esp+48h] [ebp+Ch]
    unsigned int v54; // [esp+48h] [ebp+Ch]

    v3 = this;
    if(a3 < 0x12)
        return -2147467259;
    v5 = a2 [1];
    if((v5 & 0xFE) != 0)
        return -2147467259;
    v6 = a2 [2];
    if((v6 & 0xFFFFFFF4) != 0 || !*((_WORD*) a2 + 6) || !*((_WORD*) a2 + 7))
        return -2147467259;
    v7 = a2 [7];
    v44 = 0;
    v8 = (unsigned int) (v7 + 7) >> 3;
    if(v5) {
        v9 = v7 - 15;
        if(v9) {
            v10 = v9 - 1;
            if(v10) {
                v11 = v10 - 8;
                if(v11) {
                    if(v11 != 8)
                        return -2147467259;
                    v44 = 21;
                }
                else {
                    v44 = 20;
                }
            }
            else {
                v44 = 25;
            }
        }
        else {
            v44 = 24;
        }
    }
    v12 = a2 [16];
    v49 = (unsigned int) (v12 + 7) >> 3;
    if((v6 & 3) == 1) {
        if(!a2 [1] || a2 [16] != 8)
            return -2147467259;
        v48 = 41;
    }
    else if((v6 & 3) == 2) {
        v13 = v12 - 15;
        if(v13) {
            v14 = v13 - 1;
            if(v14) {
                v15 = v14 - 8;
                if(v15) {
                    if(v15 != 8)
                        return -2147467259;
                    v48 = 21;
                }
                else {
                    v48 = 20;
                }
            }
            else {
                v48 = 25;
            }
        }
        else {
            v48 = 24;
        }
    }
    else {
        if((v6 & 3) != 3 || a2 [16] != 8)
            return -2147467259;
        v48 = 50;
    }
    v37 = v6 & 8;
    v38 = (a2 [17] & 0x20) == 32;
    v16 = *a2;
    v52 = a3 - 18;
    v39 = (a2 [17] & 0x10) != 16;
    if(v52 < v16)
        return -2147467259;
    v53 = v52 - v16;
    v50 = (int) &a2 [v16 + 18];
    v33 = v8 * *(unsigned __int16*) (a2 + 5);
    if(v53 < v33)
        return -2147467259;
    if(v48 == 41) {
        if(*(unsigned __int16*) (a2 + 5) + *(unsigned __int16*) (a2 + 3) > 256)
            return -2147467259;
        v17 = operator new(0x400u);
        v3 [7] = (int) v17;
        if(!v17)
            return -2147024882;
        v3 [9] = 1;
        memset(v17, 0xFFu, 0x400u);
        v18 = (unsigned __int16*) v50;
        v19 = v3 [7] + 4 * *(unsigned __int16*) (a2 + 3);
        v46 = (_BYTE*) v19;
        v35 = v19 + 4 * *(unsigned __int16*) (a2 + 5);
        if(v19 < v35) {
            LOBYTE(v20) = v53;
            LOBYTE(v21) = v53;
            while(1) {
                LOBYTE(v22) = v42;
                if(v44 == 20)
                    break;
                switch(v44) {
                    case 21:
                        v40 = HIBYTE(*(_DWORD*) v18);
                        LOBYTE(v20) = BYTE2(*(_DWORD*) v18);
                        LOBYTE(v21) = BYTE1(*(_DWORD*) v18);
                        LOBYTE(v22) = *(_DWORD*) v18;
                        v18 += 2;
                        goto LABEL_47;
                    case 24:
                        v24 = *v18;
                        v20 = (8 * ((v24 >> 10) & 0x1F)) | (((v24 >> 10) & 0x1F) >> 2);
                        v21 = (8 * ((v24 >> 5) & 0x1F)) | (((v24 >> 5) & 0x1F) >> 2);
                        v22 = (8 * (v24 & 0x1F)) | ((unsigned __int8) (v24 & 0x1F) >> 2);
                        ++v18;
                        LABEL_46:
                        LOBYTE(v40) = -1;
                        goto LABEL_47;
                    case 25:
                        v40 = 255 * (*v18 >> 15);
                        v23 = *v18;
                        v20 = (8 * ((v23 >> 10) & 0x1F)) | (((v23 >> 10) & 0x1F) >> 2);
                        v21 = (8 * ((v23 >> 5) & 0x1F)) | (((v23 >> 5) & 0x1F) >> 2);
                        v22 = (8 * (v23 & 0x1F)) | ((unsigned __int8) (v23 & 0x1F) >> 2);
                        ++v18;
                        LABEL_47:
                        v42 = v22;
                        break;
                }
                v25 = v46;
                v46 += 4;
                v25 [2] = v22;
                v25 [3] = v40;
                *v25 = v20;
                v25 [1] = v21;
                if((unsigned int) v46 >= v35) {
                    v3 = this;
                    goto LABEL_50;
                }
            }
            LOBYTE(v20) = *((_BYTE*) v18 + 2);
            LOBYTE(v21) = *((_BYTE*) v18 + 1);
            LOBYTE(v22) = *(_BYTE*) v18;
            v18 = (unsigned __int16*) ((char*) v18 + 3);
            goto LABEL_46;
        }
    }
    LABEL_50:
    v54 = v53 - v33;
    v26 = v33 + v50;
    v27 = v49 * *((unsigned __int16*) a2 + 6) * *((unsigned __int16*) a2 + 7);
    *v3 = v48;
    v3 [1] = v33 + v50;
    v3 [2] = v49 * *((unsigned __int16*) a2 + 6);
    v3 [3] = 0;
    v3 [4] = 0;
    v3 [5] = *((unsigned __int16*) a2 + 6);
    v51 = (_BYTE*) (v33 + v50);
    v3 [6] = *((unsigned __int16*) a2 + 7);
    if(v37 || !v38 || !v39) {
        v28 = (char*)operator new(v27);
        v3 [1] = (int) v28;
        if(v28) {
            v3 [8] = 1;
            if(v38)
                v30 = v28;
            else
                v30 = &v28 [v3 [2] * (*((unsigned __int16*) a2 + 7) - 1)];
            v45 = 0;
            if(!*((_WORD*) a2 + 7))
                return 0;
            while(1) {
                v47 = v39 ? v30 : &v30 [v3 [2] - v49];
                v31 = *((unsigned __int16*) a2 + 6);
                v43 = 0;
                if(*((_WORD*) a2 + 6))
                    break;
                LABEL_81:
                if(v38)
                    v30 += v3 [2];
                else
                    v30 -= v3 [2];
                if(++v45 >= (unsigned int) *((unsigned __int16*) a2 + 7))
                    return 0;
            }
            while(1) {
                if(v37) {
                    if(!v54)
                        return -2147467259;
                    v32 = *v51 & 0x80;
                    v31 = (*v51++ & 0x7F) + 1;
                    --v54;
                    v41 = v32;
                }
                else {
                    v41 = 0;
                }
                v43 += v31;
                if(v31)
                    break;
                LABEL_78:
                if(v41) {
                    v51 += v49;
                    v54 -= v49;
                }
                v31 = *((unsigned __int16*) a2 + 6);
                if(v43 >= v31)
                    goto LABEL_81;
            }
            while(1) {
                v34 = v31 - 1;
                if(v54 < v49)
                    return -2147467259;
                qmemcpy(v47, v51, v49);
                if(!v41) {
                    v51 += v49;
                    v54 -= v49;
                }
                if(v39)
                    v47 += v49;
                else
                    v47 -= v49;
                --v31;
                if(!v34) {
                    v3 = this;
                    goto LABEL_78;
                }
            }
        }
        return -2147024882;
    }
    if(v54 >= v27) {
        v3 [1] = v26;
        v3 [8] = 0;
        return 0;
    }
    return -2147467259;
}
// 444D73: variable 'v42' is possibly undefined
// 444E57: variable 'v40' is possibly undefined

//----- (00445006) --------------------------------------------------------
unsigned int __thiscall sub_445006(_DWORD* this, _BYTE* a2, unsigned int a3) {
    _BYTE* v4; // edi
    bool v5; // zf
    int v6; // ebx
    int v7; // ecx
    _BYTE* v8; // eax
    unsigned __int8* v10; // edi
    unsigned __int8 v11; // al
    int v12; // [esp+Ch] [ebp-18h]
    int v13; // [esp+10h] [ebp-14h]
    _BYTE* v14; // [esp+14h] [ebp-10h]
    _BYTE* v15; // [esp+18h] [ebp-Ch]
    unsigned int v16; // [esp+1Ch] [ebp-8h]
    int v17; // [esp+20h] [ebp-4h]
    unsigned int v18; // [esp+30h] [ebp+Ch]
    unsigned int v19; // [esp+30h] [ebp+Ch]

    if(a3 < 2 || *a2 != 80)
        return -2147467259;
    if(a2 [1] == 51) {
        v12 = 1;
    }
    else {
        if(a2 [1] != 54)
            return -2147467259;
        v12 = 0;
    }
    v4 = a2 + 2;
    v5 = a3 == 2;
    v18 = a3 - 2;
    v6 = 0;
    v15 = a2 + 2;
    v17 = 0;
    v13 = 0;
    v16 = 255;
    if(v5)
        return -2147467259;
    while(v12 || v17 != 3) {
        if(!isspace((unsigned __int8) *v4)) {
            if(*v4 != 35) {
                if(v18) {
                    do {
                        if(isspace((unsigned __int8) *v4))
                            break;
                        if(!isdigit((unsigned __int8) *v4))
                            return -2147467259;
                        v7 = (unsigned __int8) *v4++;
                        v5 = v18-- == 1;
                        v6 = v7 + 10 * v6 - 48;
                        v15 = v4;
                    }
                    while(!v5);
                }
                if(v17) {
                    if(v17 == 1) {
                        if(!v6)
                            return -2147467259;
                        v8 = operator new(4 * v13 * v6);
                        this [1] = v8;
                        if(!v8)
                            return -2147024882;
                        this [3] = 0;
                        a2 = v8;
                        this [4] = 0;
                        v14 = &v8 [4 * v13 * v6];
                        v4 = v15;
                        this [8] = 1;
                        *this = 22;
                        this [2] = 4 * v13;
                        this [5] = v13;
                        this [6] = v6;
                        goto LABEL_38;
                    }
                    if(v17 != 2) {
                        switch(v17) {
                            case 3:
                                if(a2 >= v14)
                                    return -2147467259;
                                *(_DWORD*) a2 = ((255 * v6 / v16) | 0xFFFFFF00) << 16;
                                break;
                            case 4:
                                *(_DWORD*) a2 |= (255 * v6 / v16) << 8;
                                break;
                            case 5:
                                *(_DWORD*) a2 |= 255 * v6 / v16;
                                a2 += 4;
                                if(a2 == v14)
                                    return 0;
                                v17 = 2;
                                break;
                        }
                        goto LABEL_38;
                    }
                    v16 = v6;
                }
                else {
                    v13 = v6;
                }
                if(!v6)
                    return -2147467259;
                LABEL_38:
                ++v17;
                goto LABEL_39;
            }
            for(; v18; --v18) {
                if(*v4 == 10)
                    break;
                ++v4;
            }
        }
        ++v4;
        --v18;
        v15 = v4;
        LABEL_39:
        v6 = 0;
        if(!v18)
            return -2147467259;
    }
    if(v16 > 0xFF)
        return -2147467259;
    if(v18 > 1 && *v4 == 13) {
        ++v4;
        --v18;
    }
    v10 = v4 + 1;
    v19 = v18 - 1;
    if(v19) {
        do {
            if(a2 >= v14)
                break;
            v11 = 255 * (unsigned int) *v10 / v16;
            v10 += 3;
            *(_DWORD*) a2 = (255 * (unsigned int) *(v10 - 1) / v16) | (((255 * (unsigned int) *(v10 - 2) / v16) | ((v11 | 0xFFFFFF00) << 8)) << 8);
            v5 = v19 == 3;
            v19 -= 3;
            a2 += 4;
        }
        while(!v5);
    }
    return v14 != a2 ? 0x80004005 : 0;
}
// 445039: conditional instruction was optimized away because al.1==50
// 445124: variable 'v14' is possibly undefined

//----- (00445288) --------------------------------------------------------
unsigned int __cdecl sub_445288(jmp_buf Buf, void* a2, unsigned int a3) {
    int v3; // ebx
    unsigned int result; // eax

    v3 = Buf [21];
    if(a3 > *(_DWORD*) (v3 + 4))
        sub_44BC5A(Buf, (int) "read error");
    qmemcpy(a2, *(const void**) v3, a3);
    result = a3;
    *(_DWORD*) v3 += a3;
    *(_DWORD*) (v3 + 4) -= a3;
    return result;
}

//----- (004452CB) --------------------------------------------------------
int __thiscall sub_4452CB(_DWORD* this, int a2, unsigned int a3) {
    int* v4; // eax
    _DWORD* v5; // esi
    unsigned __int8 v6; // al
    int v7; // esi
    unsigned int v8; // eax
    int v9; // eax
    void* v10; // eax
    void* v11; // ecx
    unsigned int i; // eax
    double v13; // st7
    __int64 v14; // rax
    int v15; // ecx
    bool v16; // cc
    int j; // eax
    void* v18; // eax
    int v19; // eax
    int v20; // edi
    int v21; // ecx
    char v22; // bl
    int v23; // edi
    int v24; // ecx
    int v25; // eax
    int* __attribute__((__org_typedef(jmp_buf))) v26; // [esp+8h] [ebp-168h]
    int v27; // [esp+Ch] [ebp-164h]
    size_t v28; // [esp+Ch] [ebp-164h]
    int v29; // [esp+10h] [ebp-160h]
    char v30 [256]; // [esp+1Ch] [ebp-154h]
    double v31; // [esp+11Ch] [ebp-54h] BYREF
    long double v32; // [esp+124h] [ebp-4Ch]
    int v33 [2]; // [esp+12Ch] [ebp-44h] BYREF
    int v34; // [esp+134h] [ebp-3Ch] BYREF
    _DWORD* v35; // [esp+138h] [ebp-38h]
    unsigned int v36; // [esp+13Ch] [ebp-34h] BYREF
    int v37; // [esp+140h] [ebp-30h] BYREF
    int v38; // [esp+144h] [ebp-2Ch] BYREF
    int v39; // [esp+148h] [ebp-28h] BYREF
    int v40; // [esp+14Ch] [ebp-24h] BYREF
    int v41; // [esp+150h] [ebp-20h] BYREF
    void* Block; // [esp+154h] [ebp-1Ch]
    int v43; // [esp+158h] [ebp-18h]
    unsigned int v44; // [esp+15Ch] [ebp-14h] BYREF
    int v45; // [esp+160h] [ebp-10h] BYREF
    int v46; // [esp+164h] [ebp-Ch]
    int v47; // [esp+168h] [ebp-8h] BYREF
    int* __attribute__((__org_typedef(jmp_buf))) Buf; // [esp+16Ch] [ebp-4h] BYREF

    v35 = this;
    Buf = 0;
    v47 = 0;
    Block = 0;
    if(sub_44DFFC(a2, 0, a3))
        return -2147467259;
    v4 = sub_44BCDC("1.0.5", 0, (int) sub_44BC35, (int) nullsub_1);
    Buf = v4;
    if(!v4)
        goto LABEL_67;
    v47 = (int) sub_44E10C((int) v4);
    if(!v47)
        goto LABEL_67;
    if(!_setjmp3(Buf, 0, v29)) {
        v33 [0] = a2;
        v33 [1] = a3;
        sub_44DFBD(Buf, (int) v33, (int(__cdecl*)(int, int))sub_445288);
        sub_44BDDF(Buf, v47);
        sub_44C5A6((int) Buf, v47, &v36, &v44, &v40, &v38, 0, 0, 0);
        v5 = v35;
        if(v38) {
            switch(v38) {
                case 2:
                    *v35 = 20;
                    break;
                case 3:
                    *v35 = 41;
                    break;
                case 4:
                    *v35 = 51;
                    break;
                case 6:
                    *v35 = 21;
                    break;
            }
        }
        else {
            *v35 = 50;
        }
        if(v40 == 16)
            sub_44C858((int) Buf);
        if(v40 < 8)
            sub_44C71A((int) Buf);
        if(!v38 && v40 < 8)
            sub_44C897((int) Buf);
        if(sub_44C57B((int) Buf, v47, &v37)) {
            sub_44DEFA((int) Buf, v47, v37);
        }
        else if(sub_44C552((int) Buf, v47, &v31)) {
            sub_44C861((int) Buf, 2.2, v31);
        }
        if(*v5 != 41 && sub_44C50C((int) Buf, v47, 16)) {
            sub_44C897((int) Buf);
            if(*v5 == 20) {
                *v5 = 21;
            }
            else if(*v5 == 50) {
                *v5 = 51;
            }
        }
        if(*v5 == 20 || *v5 == 21)
            sub_44C711((int) Buf);
        if(*v5 == 20) {
            sub_44C74C((int) Buf, 0xFFu, 1);
            *v5 = 22;
        }
        sub_44BF53(Buf, v47);
        switch(*v5) {
            case 0x14:
                v46 = 3;
                break;
            case 0x15:
            case 0x16:
                v46 = 4;
                break;
            case 0x29:
            case 0x32:
                v46 = 1;
                break;
            case 0x33:
                v46 = 2;
                break;
        }
        v6 = sub_44C53C((int) Buf, v47);
        if(v46 == v6) {
            v27 = v47;
            v5 [5] = v36;
            v8 = v44;
            v26 = Buf;
            v5 [3] = 0;
            v5 [4] = 0;
            v5 [6] = v8;
            v9 = sub_44C526((int) v26, v27);
            v5 [2] = v9;
            v10 = operator new(v44 * v9);
            v5 [1] = v10;
            if(v10) {
                v28 = 4 * v44;
                v5 [8] = 1;
                v11 = operator new(v28);
                Block = v11;
                if(v11) {
                    for(i = 0; i < v44; ++i)
                        *((_DWORD*) v11 + i) = v5 [1] + i * v5 [2];
                    sub_44C31B(Buf, (char**) v11);
                    if(*v5 == 41) {
                        v39 = 0;
                        v41 = 0;
                        if(sub_44C50C((int) Buf, v47, 8))
                            sub_44C677((int) Buf, v47, &v45, &v41);
                        if(sub_44C50C((int) Buf, v47, 16))
                            sub_44C6AA((int) Buf, v47, &v34, &v39, 0);
                        if(*((float*) Buf + 76) <= 0.000001 || *((float*) Buf + 77) <= 0.000001) {
                            for(j = 0; j < 256; ++j)
                                v30 [j] = j;
                        }
                        else {
                            v13 = *((float*) Buf + 76);
                            v43 = 0;
                            v32 = 1.0 / (v13 * *((float*) Buf + 77));
                            do {
                                v14 = (__int64) (pow((double) v43 * 0.00392156862745098, v32) * 255.0 + 0.5);
                                v15 = v43++;
                                v16 = v43 < 256;
                                v30 [v15] = v14;
                            }
                            while(v16);
                        }
                        v18 = operator new(0x400u);
                        v5 [7] = v18;
                        if(!v18)
                            goto LABEL_67;
                        v19 = 0;
                        v16 = v39 <= 0;
                        v5 [9] = 1;
                        if(!v16) {
                            v20 = 0;
                            do {
                                v21 = 4 * v19;
                                *(_BYTE*) (v21 + v5 [7]) = v30 [*(unsigned __int8*) (v20 + v45)];
                                *(_BYTE*) (v21 + v5 [7] + 1) = v30 [*(unsigned __int8*) (v20 + v45 + 1)];
                                *(_BYTE*) (v21 + v5 [7] + 2) = v30 [*(unsigned __int8*) (v20 + v45 + 2)];
                                v22 = *(_BYTE*) (v19 + v34);
                                ++v19;
                                *(_BYTE*) (v21 + v5 [7] + 3) = v22;
                                v20 += 3;
                            }
                            while(v19 < v39);
                        }
                        if(v19 < v41) {
                            v23 = 3 * v19;
                            do {
                                v24 = 4 * v19;
                                *(_BYTE*) (v24 + v5 [7]) = v30 [*(unsigned __int8*) (v23 + v45)];
                                *(_BYTE*) (v24 + v5 [7] + 1) = v30 [*(unsigned __int8*) (v23 + v45 + 1)];
                                *(_BYTE*) (v24 + v5 [7] + 2) = v30 [*(unsigned __int8*) (v23 + v45 + 2)];
                                *(_BYTE*) (v24 + v5 [7] + 3) = -1;
                                ++v19;
                                v23 += 3;
                            }
                            while(v19 < v41);
                        }
                        if(v19 < 256) {
                            v25 = 4 * v19;
                            do {
                                *(_BYTE*) (v25 + v5 [7]) = -1;
                                *(_BYTE*) (v25 + v5 [7] + 1) = -1;
                                *(_BYTE*) (v25 + v5 [7] + 2) = -1;
                                *(_BYTE*) (v25 + v5 [7] + 3) = -1;
                                v25 += 4;
                            }
                            while(v25 < 1024);
                        }
                    }
                    v7 = 0;
                    goto LABEL_78;
                }
            }
            LABEL_67:
            v7 = -2147024882;
            goto LABEL_78;
        }
    }
    v7 = -2147467259;
    LABEL_78:
    if(Buf)
        sub_44C48B((void**) &Buf, (void**) &v47, 0);
    if(Block)
        j__free(Block);
    return v7;
}
// 44533D: variable 'v29' is possibly undefined
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);
// 4452CB: using guessed type char var_154[256];

//----- (004457E1) --------------------------------------------------------
int __thiscall sub_4457E1(_DWORD* this, _DWORD* a2, unsigned int a3) {
    _DWORD* v3; // edx
    int v4; // ecx
    int v5; // ecx
    int v6; // esi
    int v7; // ecx
    _DWORD* v8; // eax
    _DWORD* v9; // eax
    _DWORD* v10; // eax
    _DWORD* v11; // eax
    int v12; // ecx
    int v13; // ebx
    unsigned int v14; // ebx
    int v16; // [esp+Ch] [ebp-34h]
    int v17; // [esp+10h] [ebp-30h]
    int v18; // [esp+14h] [ebp-2Ch]
    int v19; // [esp+18h] [ebp-28h]
    unsigned int v21; // [esp+20h] [ebp-20h]
    unsigned int v22; // [esp+24h] [ebp-1Ch]
    _DWORD* v23; // [esp+28h] [ebp-18h]
    _DWORD* v24; // [esp+2Ch] [ebp-14h]
    _DWORD* v25; // [esp+30h] [ebp-10h]
    int v26; // [esp+34h] [ebp-Ch]
    int v27; // [esp+38h] [ebp-8h]
    int v28; // [esp+48h] [ebp+8h]
    unsigned int v29; // [esp+4Ch] [ebp+Ch]
    unsigned int v30; // [esp+4Ch] [ebp+Ch]

    v3 = this;
    if(a3 < 4)
        return -2147467259;
    if(*a2 != 542327876)
        return -2147467259;
    v29 = a3 - 4;
    if(v29 < 0x7C)
        return -2147467259;
    v30 = v29 - 124;
    v23 = a2 + 32;
    this [3] = 0;
    this [4] = 0;
    this [5] = a2 [4];
    this [6] = a2 [3];
    v4 = a2 [28] & 0xFC00;
    if(v4 == 64512) {
        v21 = 6;
    }
    else {
        if(v4)
            return -2147467259;
        v21 = 1;
    }
    v22 = a2 [7];
    if(!v22)
        v22 = 1;
    v5 = a2 [21];
    v6 = 827611204;
    if(v5 == 827611204
       || (v6 = 844388420, v5 == 844388420)
       || (v6 = 861165636, v5 == 861165636)
       || (v6 = 877942852, v5 == 877942852)
       || (v6 = 894720068, v5 == 894720068)) {
        v28 = v6;
        LABEL_37:
        v26 = 0;
        while(1) {
            v16 = v3 [3];
            v17 = v3 [4];
            v18 = v3 [5];
            v19 = v3 [6];
            if(v26) {
                v8 = operator new(0x30u);
                if(v8)
                    v9 = sub_44422C(v8);
                else
                    v9 = 0;
                if(!v9)
                    return -2147024882;
                v3 = this;
                v25 [11] = v9;
                v25 = v9;
            }
            else {
                v25 = v3;
            }
            v27 = 0;
            if(v22) {
                while(1) {
                    if(v27) {
                        v11 = operator new(0x30u);
                        if(v11)
                            v10 = sub_44422C(v11);
                        else
                            v10 = 0;
                        if(!v10)
                            return -2147024882;
                        v3 = this;
                        v24 [10] = v10;
                        v24 = v10;
                    }
                    else {
                        v10 = v25;
                        v24 = v25;
                    }
                    if(v28 > 844388419)
                        break;
                    if(v28 <= 22) {
                        v12 = 4 * v18;
                    }
                    else {
                        if(v28 > 26) {
                            v12 = 8 * ((v18 + 3) >> 2);
                            LABEL_61:
                            v13 = (v19 + 3) >> 2;
                            goto LABEL_62;
                        }
                        v12 = 2 * v18;
                    }
                    v13 = v19;
                    LABEL_62:
                    v14 = v12 * v13;
                    v10 [3] = v16;
                    *v10 = v28;
                    v10 [4] = v17;
                    v10 [1] = v23;
                    v10 [5] = v18;
                    v10 [2] = v12;
                    v10 [6] = v19;
                    v10 [7] = 0;
                    v10 [8] = 0;
                    v10 [9] = 0;
                    if(v30 < v14)
                        return -2147467259;
                    v23 = (_DWORD*) ((char*) v23 + v14);
                    v30 -= v14;
                    if(v18 == 1)
                        v18 = 1;
                    else
                        v18 >>= 1;
                    if(v19 == 1)
                        v19 = 1;
                    else
                        v19 >>= 1;
                    if(++v27 >= v22)
                        goto LABEL_70;
                }
                v12 = 16 * ((v18 + 3) >> 2);
                goto LABEL_61;
            }
            LABEL_70:
            if(++v26 >= v21)
                return 0;
        }
    }
    v7 = a2 [20];
    if(v7 == 65 && a2 [22] == 32 && a2 [26] == -16777216) {
        v28 = 21;
        goto LABEL_37;
    }
    if(v7 == 64 && a2 [22] == 32) {
        v28 = 22;
        goto LABEL_37;
    }
    if(v7 == 64) {
        if(a2 [22] == 16 && a2 [24] == 2016) {
            v28 = 23;
            goto LABEL_37;
        }
        if(a2 [22] == 16 && a2 [24] == 992) {
            v28 = 24;
            goto LABEL_37;
        }
    }
    if(v7 == 65) {
        if(a2 [22] == 16 && a2 [26] == 0x8000) {
            v28 = 25;
            goto LABEL_37;
        }
        if(a2 [22] == 16 && a2 [26] == 61440) {
            v28 = 26;
            goto LABEL_37;
        }
    }
    return -2147467259;
}
// 445904: conditional instruction was optimized away because ecx.4==40
// 445940: conditional instruction was optimized away because ecx.4==41
// 445969: conditional instruction was optimized away because %var_20.4 is in (==1|==6)
// 445A0A: conditional instruction was optimized away because %arg_0.4 is in (15..1A|==31545844)
// 445A1C: conditional instruction was optimized away because %arg_0.4==31545844
// 445A54: conditional instruction was optimized away because %arg_0.4==35545844
// 4459AC: variable 'v25' is possibly undefined
// 4459F3: variable 'v24' is possibly undefined

//----- (00445AF4) --------------------------------------------------------
int __thiscall sub_445AF4(int* this, int a2, unsigned int a3) {
    if(a3 >= 0xE && *(_WORD*) a2 == 19778 && *(_DWORD*) (a2 + 2) <= a3)
        return sub_44429E(this, a2 + 14, a3 - 14);
    else
        return -2147467259;
}

//----- (00445B24) --------------------------------------------------------
int __thiscall sub_445B24(int this, unsigned __int8* a2, unsigned int a3, _DWORD* a4) {
    int v4; // ebx
    unsigned int v6; // eax
    void* v7; // edi
    void* v8; // edi
    _DWORD* i; // eax
    int v11; // [esp+Ch] [ebp-4h]

    v11 = 0;
    v4 = a3;
    do {
        switch(v11) {
            case 0:
                v6 = sub_445AF4((int*) this, (int) a2, a3);
                goto LABEL_16;
            case 1:
                v6 = sub_445006((_DWORD*) this, a2, a3);
                goto LABEL_16;
            case 2:
                v6 = sub_4457E1((_DWORD*) this, a2, a3);
                goto LABEL_16;
            case 3:
                v6 = sub_444939((_DWORD*) this, (int) a2, a3);
                goto LABEL_16;
            case 4:
                v6 = sub_4452CB((_DWORD*) this, (int) a2, a3);
                goto LABEL_16;
            case 5:
                v6 = sub_444B8E((int*) this, a2, a3);
                goto LABEL_16;
            case 6:
                v6 = sub_44429E((int*) this, (int) a2, a3);
                LABEL_16:
                v4 = v6;
                break;
        }
        if(v4 >= 0)
            break;
        if(*(_DWORD*) (this + 4) && *(_DWORD*) (this + 32))
            j__free(*(void**) (this + 4));
        if(*(_DWORD*) (this + 28) && *(_DWORD*) (this + 36))
            j__free(*(void**) (this + 28));
        v7 = *(void**) (this + 40);
        if(v7) {
            sub_444245(*(_DWORD*) (this + 40));
            j__free(v7);
        }
        v8 = *(void**) (this + 44);
        if(v8) {
            sub_444245(*(_DWORD*) (this + 44));
            j__free(v8);
        }
        ++v11;
        *(_DWORD*) (this + 4) = 0;
        *(_DWORD*) (this + 28) = 0;
        *(_DWORD*) (this + 32) = 0;
        *(_DWORD*) (this + 36) = 0;
        *(_DWORD*) (this + 40) = 0;
        *(_DWORD*) (this + 44) = 0;
    }
    while(v11 < 7);
    if(v11 == 7)
        return -2005529767;
    if(a4) {
        *a4 = 0;
        a4 [1] = 0;
        a4 [2] = 0;
        a4 [3] = 0;
        a4 [4] = 0;
        *a4 = *(_DWORD*) (this + 20);
        a4 [1] = *(_DWORD*) (this + 24);
        a4 [2] = 1;
        a4 [3] = 1;
        a4 [4] = *(_DWORD*) this;
        for(i = (_DWORD*) (this + 40); *i; i = (_DWORD*) (*i + 40))
            ++a4 [3];
    }
    return 0;
}

//----- (00445C7E) --------------------------------------------------------
_DWORD* __thiscall sub_445C7E(_DWORD* this) {
    _DWORD* result; // eax
    _DWORD* v2; // ecx
    int v3; // esi

    result = this;
    *this = 1;
    this [1] = 0;
    this [3] = 0;
    this [2] = 0;
    v2 = this + 12;
    v3 = 8;
    do {
        *(v2 - 8) = 0;
        *v2++ = 0;
        --v3;
    }
    while(v3);
    result [23] = 0;
    result [24] = 0;
    result [25] = 0;
    result [37] = 0;
    result [26] = 0;
    result [40] = 0;
    return result;
}

//----- (00445CBD) --------------------------------------------------------
int* __thiscall sub_445CBD(int this) {
    int v2; // ecx
    _DWORD* v3; // edi
    int v4; // ebx
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // ecx
    int* result; // eax

    v2 = *(_DWORD*) (this + 96);
    if(v2)
        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**) (this + 4) + 224))(*(_DWORD*) (this + 4), v2);
    if(*(_DWORD*) (this + 100))
        (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (this + 4) + 224))(
            *(_DWORD*) (this + 4),
            *(_DWORD*) (this + 100));
    v3 = (_DWORD*) (this + 16);
    v4 = 8;
    do {
        v5 = v3 [8];
        if(v5) {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*) v5 + 8))(v3 [8]);
            v3 [8] = 0;
        }
        if(*v3) {
            (*(void(__stdcall**)(_DWORD))(*(_DWORD*) *v3 + 8))(*v3);
            *v3 = 0;
        }
        ++v3;
        --v4;
    }
    while(v4);
    v6 = *(_DWORD*) (this + 12);
    if(v6) {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) v6 + 8))(*(_DWORD*) (this + 12));
        *(_DWORD*) (this + 12) = 0;
    }
    v7 = *(_DWORD*) (this + 4);
    if(v7) {
        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) v7 + 8))(*(_DWORD*) (this + 4));
        *(_DWORD*) (this + 4) = 0;
    }
    if(*(_DWORD*) (this + 148))
        DeleteObject(*(HGDIOBJ*) (this + 148));
    if(*(_DWORD*) (this + 104))
        DeleteDC(*(HDC*) (this + 104));
    v8 = dword_6E61D8;
    result = &dword_6E61D8;
    if(dword_6E61D8) {
        do {
            if(v8 == this)
                break;
            result = (int*) (v8 + 160);
            v8 = *(_DWORD*) (v8 + 160);
        }
        while(v8);
        if(*result)
            *result = *(_DWORD*) (*result + 160);
    }
    return result;
}
// 6E61D8: using guessed type int dword_6E61D8;

//----- (00445D88) --------------------------------------------------------
void __thiscall sub_445D88(_DWORD* this) {
    ++* this;
}

//----- (00445D8B) --------------------------------------------------------
int __thiscall sub_445D8B(int this, int a2) {
    int result; // eax
    unsigned int j; // edi
    int v5; // ecx
    HDC CompatibleDC; // eax
    HBITMAP DIBSection; // eax
    int v8; // [esp-1Ch] [ebp-3Ch]
    char v9 [16]; // [esp+Ch] [ebp-14h] BYREF
    int v10; // [esp+1Ch] [ebp-4h]
    int savedregs; // [esp+20h] [ebp+0h] BYREF
    _DWORD* i; // [esp+28h] [ebp+8h]

    *(_DWORD*) (this + 160) = dword_6E61D8;
    dword_6E61D8 = this;
    *(_DWORD*) (this + 4) = a2;
    (*(void(__stdcall**)(int))(*(_DWORD*) a2 + 4))(a2);
    result = (*(int(__stdcall**)(_DWORD, char*))(**(_DWORD**) (this + 4) + 36))(*(_DWORD*) (this + 4), v9);
    if(result >= 0) {
        v8 = *(_DWORD*) (this + 4);
        *(_DWORD*) (this + 84) = 64;
        *(_DWORD*) (this + 88) = 16;
        *(_DWORD*) (this + 80) = 21;
        result = sub_43FE34(v8, (unsigned int*) (this + 84), (unsigned int*) (this + 88), 0, 0, (int*) (this + 80), 1u);
        if(result >= 0) {
            v10 = 0;
            for(i = (_DWORD*) (this + 16); ; ++i) {
                result = sub_43FE5C(
                    *(_DWORD*) (this + 4),
                    *(_DWORD*) (this + 84),
                    *(_DWORD*) (this + 88),
                    1,
                    0,
                    *(_DWORD*) (this + 80),
                    1u,
                    (int) i);
                if(result < 0)
                    break;
                result = (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD*))(*(_DWORD*) *i + 60))(*i, 0, i + 8);
                if(result < 0)
                    break;
                if((unsigned int)++v10 >= 8) {
                    for(j = 0; j < 2; ++j) {
                        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 4) + 208))(*(_DWORD*) (this + 4));
                        (*(void(__stdcall**)(_DWORD, int, _DWORD))(**(_DWORD**) (this + 4) + 200))(*(_DWORD*) (this + 4), 7, 0);
                        v5 = this + 96;
                        if(j)
                            v5 = this + 100;
                        (*(void(__stdcall**)(_DWORD, int))(**(_DWORD**) (this + 4) + 212))(*(_DWORD*) (this + 4), v5);
                    }
                    result = sub_43F6DB((int) &savedregs, *(_DWORD*) (this + 4), (_DWORD*) (this + 12));
                    if(result >= 0) {
                        memset((void*) (this + 108), 0, 0x28u);
                        *(_DWORD*) (this + 108) = 40;
                        *(_DWORD*) (this + 112) = 256;
                        *(_DWORD*) (this + 116) = 256;
                        *(_WORD*) (this + 120) = 1;
                        *(_DWORD*) (this + 124) = 0;
                        *(_WORD*) (this + 122) = 32;
                        *(_DWORD*) (this + 156) = 21;
                        CompatibleDC = CreateCompatibleDC(0);
                        *(_DWORD*) (this + 104) = CompatibleDC;
                        if(CompatibleDC
                           && (*(_DWORD*) (this + 116) = -*(_DWORD*) (this + 116),
                           DIBSection = CreateDIBSection(
                           CompatibleDC,
                           (const BITMAPINFO*) (this + 108),
                           0,
                           (void**) (this + 152),
                           0,
                           0),
                           (*(_DWORD*) (this + 148) = DIBSection) != 0)) {
                            *(_DWORD*) (this + 116) = -*(_DWORD*) (this + 116);
                            SetBkMode(*(HDC*) (this + 104), 2);
                            SetBkColor(*(HDC*) (this + 104), 0);
                            SetTextColor(*(HDC*) (this + 104), 0xFFFFFFu);
                            SelectObject(*(HDC*) (this + 104), *(HGDIOBJ*) (this + 148));
                            return 0;
                        }
                        else {
                            return -2147024882;
                        }
                    }
                    return result;
                }
            }
        }
    }
    return result;
}
// 6E61D8: using guessed type int dword_6E61D8;
// 445D8B: using guessed type char var_14[16];

//----- (00445F45) --------------------------------------------------------
int __thiscall sub_445F45(int this) {
    if(*(_DWORD*) (this + 92))
        return -2147467259;
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (this + 4) + 220))(*(_DWORD*) (this + 4), *(_DWORD*) (this + 96));
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 12) + 16))(*(_DWORD*) (this + 12));
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (this + 4) + 216))(
        *(_DWORD*) (this + 4),
        *(_DWORD*) (this + 100));
    *(_DWORD*) (this + 92) = 1;
    return 0;
}

//----- (00445F87) --------------------------------------------------------
int __thiscall sub_445F87(int this) {
    if(!*(_DWORD*) (this + 92))
        return -2147467259;
    (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 12) + 28))(*(_DWORD*) (this + 12));
    (*(void(__stdcall**)(_DWORD, _DWORD))(**(_DWORD**) (this + 4) + 216))(*(_DWORD*) (this + 4), *(_DWORD*) (this + 96));
    *(_DWORD*) (this + 92) = 0;
    return 0;
}

//----- (00445FB7) --------------------------------------------------------
void __thiscall sub_445FB7(_DWORD* Block) {
    if((*Block)-- == 1) {
        sub_445CBD((int) Block);
        j__free(Block);
    }
}

//----- (00445FCC) --------------------------------------------------------
int __cdecl sub_445FCC(int a1, _DWORD* a2) {
    _DWORD* i; // ecx
    _DWORD* v3; // eax
    _DWORD* v4; // esi
    int v5; // ecx
    int v7; // edi

    for(i = (_DWORD*) dword_6E61D8; i; i = (_DWORD*) i [40]) {
        if(i [1] == a1) {
            sub_445D88(i);
            *a2 = v5;
            return 0;
        }
    }
    v3 = operator new(0xA4u);
    if(v3)
        v4 = sub_445C7E(v3);
    else
        v4 = 0;
    if(!v4)
        return -2147024882;
    v7 = sub_445D8B((int) v4, a1);
    if(v7 < 0) {
        sub_445CBD((int) v4);
        j__free(v4);
        return v7;
    }
    *a2 = v4;
    return 0;
}
// 44600C: variable 'v5' is possibly undefined
// 6E61D8: using guessed type int dword_6E61D8;

//----- (00446048) --------------------------------------------------------
HGDIOBJ __thiscall sub_446048(
    int this,
    HGDIOBJ h,
    LPCWCH lpWideCharStr,
    int cchWideChar,
    int* a5,
    UINT format,
    int a7,
    LPSTR lpMultiByteStr) {
    LONG v10; // esi
    void* v11; // esp
    int v12; // eax
    unsigned int v13; // edx
    unsigned int v14; // eax
    int v15; // esi
    int v16; // ecx
    int v17; // edx
    int v18; // ecx
    _DWORD* v19; // edi
    HBITMAP v20; // eax
    HBITMAP v21; // edi
    void* v22; // eax
    LONG biHeight; // ecx
    LONG biWidth; // eax
    int v25; // eax
    int v26; // eax
    char* v27; // edi
    unsigned int v28; // esi
    bool i; // cf
    int v31; // eax
    int* v32; // eax
    char* v33; // edx
    int* v34; // ecx
    unsigned int v35; // edi
    unsigned int v36; // ecx
    unsigned int v37; // esi
    unsigned int v38; // eax
    bool v39; // zf
    int* v40; // edx
    _DWORD* v41; // ecx
    unsigned int v42; // eax
    int v43; // eax
    int v44; // [esp-10h] [ebp-F4h]
    HDC v45; // [esp-8h] [ebp-ECh]
    CHAR v46 [12]; // [esp+Ch] [ebp-D8h] BYREF
    struct _OSVERSIONINFOA VersionInformation; // [esp+18h] [ebp-CCh] BYREF
    int v48 [4]; // [esp+ACh] [ebp-38h] BYREF
    __int64 v49; // [esp+BCh] [ebp-28h]
    __int64 v50; // [esp+C4h] [ebp-20h]
    float v51 [2]; // [esp+CCh] [ebp-18h] BYREF
    BITMAPINFO pbmi; // [esp+D4h] [ebp-10h] BYREF
    int v53; // [esp+100h] [ebp+1Ch]
    unsigned int v54; // [esp+104h] [ebp+20h]
    UINT v55; // [esp+108h] [ebp+24h]
    int v56; // [esp+10Ch] [ebp+28h] BYREF
    unsigned int v57; // [esp+110h] [ebp+2Ch]
    unsigned int v58; // [esp+114h] [ebp+30h]
    int v59; // [esp+118h] [ebp+34h]
    int v60; // [esp+11Ch] [ebp+38h]
    int v61; // [esp+120h] [ebp+3Ch]
    struct tagRECT rc; // [esp+124h] [ebp+40h] BYREF
    void* ppvBits; // [esp+134h] [ebp+50h] BYREF
    unsigned int v64; // [esp+138h] [ebp+54h]
    int cbMultiByte; // [esp+13Ch] [ebp+58h]
    HGDIOBJ ha; // [esp+148h] [ebp+64h]
    _DWORD* hb; // [esp+148h] [ebp+64h]
    HGDIOBJ hc; // [esp+148h] [ebp+64h]
    LPCWCH lpWideCharStra; // [esp+14Ch] [ebp+68h]
    int cchWideChara; // [esp+150h] [ebp+6Ch]
    unsigned int v71; // [esp+154h] [ebp+70h]
    UINT formata; // [esp+158h] [ebp+74h]
    LPSTR lpMultiByteStra; // [esp+160h] [ebp+7Ch]

    if(!lpWideCharStr || !a5)
        return 0;
    v10 = a5 [3] - a5 [1];
    v71 = a5 [2] - *a5;
    v64 = v10;
    if(lpMultiByteStr) {
        VersionInformation.dwOSVersionInfoSize = 148;
        GetVersionExA(&VersionInformation);
        if(VersionInformation.dwPlatformId != 2) {
            cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, 0, 0, 0, 0);
            v11 = alloca(cbMultiByte);
            WideCharToMultiByte(0, 0, lpWideCharStr, cchWideChar, v46, cbMultiByte, 0, 0);
            lpMultiByteStr = 0;
            v10 = v64;
            lpWideCharStr = (LPCWCH) v46;
            cchWideChar = cbMultiByte;
        }
    }
    SelectObject(*(HDC*) (this + 104), h);
    rc.right = v71;
    rc.bottom = v10;
    rc.left = 0;
    rc.top = 0;
    if(lpMultiByteStr)
        v12 = DrawTextW(*(HDC*) (this + 104), lpWideCharStr, cchWideChar, &rc, format | 0x400);
    else
        v12 = DrawTextA(*(HDC*) (this + 104), (LPCSTR) lpWideCharStr, cchWideChar, &rc, format | 0x400);
    v13 = rc.right - rc.left;
    rc.left = 0;
    ha = (HGDIOBJ) v12;
    v14 = rc.bottom - rc.top;
    rc.top = 0;
    rc.right = v13;
    rc.bottom = v14;
    ppvBits = (void*) (format & 0x400);
    if((format & 0x400) == 0) {
        if((format & 0x100) != 0 || v13 < v71) {
            v71 = v13;
        }
        else {
            v13 = v71;
            rc.right = v71;
        }
        if((format & 0x100) != 0 || v14 < v64) {
            v64 = v14;
        }
        else {
            v14 = v64;
            rc.bottom = v64;
        }
    }
    if((format & 2) != 0) {
        v15 = a5 [2];
        v58 = v15 - v13;
        v60 = v15;
    }
    else {
        v16 = *a5;
        if((format & 1) != 0)
            v16 = (int) (a5 [2] + v16 - v13) >> 1;
        v58 = v16;
        v60 = v13 + v16;
    }
    if((format & 8) != 0) {
        v17 = a5 [3];
        v59 = v17 - v14;
        v61 = v17;
    }
    else {
        v18 = a5 [1];
        if((format & 4) != 0)
            v18 = (int) (a5 [3] + v18 - v14) >> 1;
        v59 = v18;
        v61 = v14 + v18;
    }
    if(!ppvBits) {
        if(v71 <= *(_DWORD*) (this + 112) && v64 <= *(_DWORD*) (this + 116)) {
            LABEL_48:
            v26 = *(unsigned __int16*) (this + 122) >> 3;
            v27 = *(char**) (this + 152);
            v28 = (v26 * *(_DWORD*) (this + 112) + 3) & 0xFFFFFFFC;
            ppvBits = (void*) (v71 * v26);
            cbMultiByte = (int) &v27 [v64 * v28];
            for(i = (unsigned int) v27 < cbMultiByte; ; i = (unsigned int) hc + v28 < cbMultiByte) {
                hc = v27;
                if(!i)
                    break;
                memset(v27, 0, (unsigned int) ppvBits);
                v27 += v28;
            }
            v45 = *(HDC*) (this + 104);
            if(lpMultiByteStr)
                v31 = DrawTextW(v45, lpWideCharStr, cchWideChar, &rc, format);
            else
                v31 = DrawTextA(v45, (LPCSTR) lpWideCharStr, cchWideChar, &rc, format);
            ha = (HGDIOBJ) v31;
            if(*(_DWORD*) (this + 80) != 21) {
                v32 = *(int**) (this + 152);
                if((unsigned int) v32 < cbMultiByte) {
                    v33 = (char*) ppvBits;
                    do {
                        v34 = (int*) &v33 [(_DWORD) v32];
                        while(v32 < v34) {
                            *v32 = (*v32 << 24) | 0xFFFFFF;
                            ++v32;
                        }
                        v32 = (int*) ((char*) v32 + v28 - (_DWORD) v33);
                    }
                    while((unsigned int) v32 < cbMultiByte);
                }
            }
            cbMultiByte = *(_DWORD*) (this + 92);
            if(!cbMultiByte)
                sub_445F45(this);
            v35 = 0;
            lpMultiByteStra = 0;
            if(v64) {
                while(1) {
                    v36 = v35 + *(_DWORD*) (this + 88);
                    cchWideChara = v36;
                    if(v36 > v64) {
                        v36 = v64;
                        cchWideChara = v64;
                    }
                    v37 = 0;
                    if(v71)
                        break;
                    LABEL_85:
                    v35 += *(_DWORD*) (this + 88);
                    lpMultiByteStra = (LPSTR) v35;
                    if(v35 >= v64)
                        goto LABEL_86;
                }
                formata = v36 - v35;
                while(1) {
                    v38 = v37 + *(_DWORD*) (this + 84);
                    if(v38 > v71)
                        v38 = v71;
                    pbmi.bmiColors [0] = 0;
                    v53 = 0;
                    v48 [2] = v38;
                    v39 = *(_DWORD*) (this + 80) == 21;
                    v54 = v38 - v37;
                    v48 [0] = v37;
                    v48 [1] = v35;
                    v48 [3] = v36;
                    v55 = formata;
                    if(v39) {
                        if((*(int(__stdcall**)(_DWORD, int*, RGBQUAD*, _DWORD))(**(_DWORD**) (this
                           + 4 * *(_DWORD*) (this + 8)
                           + 48)
                           + 36))(
                           *(_DWORD*) (this + 4 * *(_DWORD*) (this + 8) + 48),
                           &v56,
                           pbmi.bmiColors,
                           0) < 0)
                            break;
                        v40 = (int*) v57;
                        v41 = (_DWORD*) (*(_DWORD*) (this + 152) + 4 * (v37 + v35 * *(_DWORD*) (this + 112)));
                        v42 = v57 + v55 * v56;
                        lpWideCharStra = (LPCWCH) v57;
                        if(v57 < v42) {
                            do {
                                ppvBits = &v40 [v54];
                                if(v40 < ppvBits) {
                                    do
                                        *v40++ = (*v41++ << 24) | 0xFFFFFF;
                                    while(v40 < ppvBits);
                                    lpWideCharStra = (LPCWCH) v40;
                                }
                                v41 += *(_DWORD*) (this + 112) - v54;
                                v40 = (int*) ((char*) lpWideCharStra + v56 - 4 * v54);
                                lpWideCharStra = (LPCWCH) v40;
                            }
                            while((unsigned int) v40 < v42);
                            v35 = (unsigned int) lpMultiByteStra;
                        }
                        (*(void(__stdcall**)(_DWORD))(**(_DWORD**) (this + 4 * *(_DWORD*) (this + 8) + 48) + 40))(*(_DWORD*) (this + 4 * *(_DWORD*) (this + 8) + 48));
                    }
                    else if(sub_43FBFE(
                        *(_DWORD*) (this + 4 * *(_DWORD*) (this + 8) + 48),
                        0,
                        (int*) pbmi.bmiColors,
                        *(_DWORD*) (this + 152),
                        *(_DWORD*) (this + 156),
                        *(_DWORD*) (this + 112) * (*(unsigned __int16*) (this + 122) >> 3),
                        0,
                        v48,
                        (float*) 2,
                        0) < 0) {
                        break;
                    }
                    v50 = v37 + v58;
                    v49 = v35 + v59;
                    v43 = *(_DWORD*) (this + 12);
                    v51 [0] = (float) v50;
                    v51 [1] = (float) v49;
                    if((*(int(__stdcall**)(int, _DWORD, RGBQUAD*, _DWORD, _DWORD, _DWORD, float*, int))(*(_DWORD*) v43 + 20))(
                        v43,
                        *(_DWORD*) (this + 4 * *(_DWORD*) (this + 8) + 16),
                        pbmi.bmiColors,
                        0,
                        0,
                        0.0,
                        v51,
                        a7) < 0)
                        break;
                    v37 += *(_DWORD*) (this + 84);
                    *(_DWORD*) (this + 8) = ((unsigned __int8) *(_DWORD*) (this + 8) + 1) & 7;
                    if(v37 >= v71)
                        goto LABEL_85;
                    v36 = cchWideChara;
                }
            }
            LABEL_86:
            if(!cbMultiByte)
                sub_445F87(this);
            return ha;
        }
        qmemcpy(&pbmi, (const void*) (this + 108), 0x28u);
        while(pbmi.bmiHeader.biWidth < v71)
            pbmi.bmiHeader.biWidth += pbmi.bmiHeader.biWidth >> 1;
        while(pbmi.bmiHeader.biHeight < v64)
            pbmi.bmiHeader.biHeight += pbmi.bmiHeader.biHeight >> 1;
        pbmi.bmiHeader.biHeight = -pbmi.bmiHeader.biHeight;
        v20 = CreateDIBSection(*(HDC*) (this + 104), &pbmi, 0, &ppvBits, 0, 0);
        v21 = v20;
        if(v20) {
            pbmi.bmiHeader.biHeight = -pbmi.bmiHeader.biHeight;
            SelectObject(*(HDC*) (this + 104), v20);
            DeleteObject(*(HGDIOBJ*) (this + 148));
            v22 = ppvBits;
            biHeight = pbmi.bmiHeader.biHeight;
            *(_DWORD*) (this + 148) = v21;
            *(_DWORD*) (this + 152) = v22;
            biWidth = pbmi.bmiHeader.biWidth;
            *(_DWORD*) (this + 112) = pbmi.bmiHeader.biWidth;
            *(_DWORD*) (this + 84) = biWidth;
            v44 = *(_DWORD*) (this + 4);
            *(_DWORD*) (this + 116) = biHeight;
            *(_DWORD*) (this + 88) = biHeight;
            *(_DWORD*) (this + 80) = 21;
            if(sub_43FE34(v44, (unsigned int*) (this + 84), (unsigned int*) (this + 88), 0, 0, (int*) (this + 80), 1u) >= 0) {
                cbMultiByte = 0;
                hb = (_DWORD*) (this + 16);
                while(1) {
                    v25 = hb [8];
                    if(v25) {
                        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) v25 + 8))(hb [8]);
                        hb [8] = 0;
                    }
                    if(*hb) {
                        (*(void(__stdcall**)(_DWORD))(*(_DWORD*) *hb + 8))(*hb);
                        *hb = 0;
                    }
                    if(sub_43FE5C(
                        *(_DWORD*) (this + 4),
                        *(_DWORD*) (this + 84),
                        *(_DWORD*) (this + 88),
                        1,
                        0,
                        *(_DWORD*) (this + 80),
                        1u,
                        (int) hb) < 0
                        || (*(int(__stdcall**)(_DWORD, _DWORD, _DWORD*))(*(_DWORD*) *hb + 60))(*hb, 0, hb + 8) < 0) {
                        break;
                    }
                    ++cbMultiByte;
                    ++hb;
                    if((unsigned int) cbMultiByte >= 8)
                        goto LABEL_48;
                }
            }
        }
        return 0;
    }
    *a5 = v58;
    v19 = a5 + 1;
    *v19++ = v59;
    *v19 = v60;
    v19 [1] = v61;
    return ha;
}

//----- (004465E2) --------------------------------------------------------
void __thiscall sub_4465E2(_DWORD* this) {
    *this = &off_46D0E8;
}
// 46D0E8: using guessed type int (__thiscall *off_46D0E8)(void *Block, char);

//----- (004465EC) --------------------------------------------------------
float* __thiscall sub_4465EC(float* this, unsigned int a2) {
    float* result; // eax

    result = this;
    *this = (double) BYTE2(a2) * 0.0039215689;
    this [1] = (double) BYTE1(a2) * 0.0039215689;
    this [2] = (double) (unsigned __int8) a2 * 0.0039215689;
    this [3] = (double) HIBYTE(a2) * 0.0039215689;
    return result;
}

//----- (00446642) --------------------------------------------------------
char* __thiscall sub_446642(_DWORD* this, int a2, int a3, float* a4) {
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [2 * this [1044]]; result < i; *(a4 - 1) = 1.0) {
        v7 = *result;
        result += 2;
        *a4 = (double) v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double) *(result - 1) * 0.0078125;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (004466AB) --------------------------------------------------------
_BYTE* __thiscall sub_4466AB(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* result; // eax
    _BYTE* i; // esi
    int v7; // [esp+Ch] [ebp+8h]
    int v8; // [esp+Ch] [ebp+8h]

    result = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [2 * this [1044]]; result < i; *(a4 - 1) = (double) v8 * 0.015873017) {
        v7 = (char) (8 * (*(unsigned __int16*) result >> 5)) >> 3;
        *a4 = (double) ((char) (8 * *result) >> 3) * 0.0625;
        a4 += 4;
        *(a4 - 3) = (double) v7 * 0.0625;
        *(a4 - 2) = 0.0;
        v8 = *(_WORD*) result >> 10;
        result += 2;
    }
    return result;
}

//----- (00446741) --------------------------------------------------------
char* __thiscall sub_446741(_DWORD* this, int a2, int a3, float* a4) {
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [4 * this [1044]]; result < i; *(a4 - 1) = (double) (unsigned __int8) *(result - 2) * 0.0039215689) {
        v7 = *result;
        result += 4;
        *a4 = (double) v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double) *(result - 3) * 0.0078125;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (004467B9) --------------------------------------------------------
char* __thiscall sub_4467B9(_DWORD* this, int a2, int a3, float* a4) {
    char* result; // eax
    char* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (char*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [4 * this [1044]]; result < i; *(a4 - 1) = (double) *(result - 1) * 0.0078125) {
        v7 = *result;
        result += 4;
        *a4 = (double) v7 * 0.0078125;
        a4 += 4;
        *(a4 - 3) = (double) *(result - 3) * 0.0078125;
        *(a4 - 2) = (double) *(result - 2) * 0.0078125;
    }
    return result;
}

//----- (00446837) --------------------------------------------------------
__int16* __thiscall sub_446837(_DWORD* this, int a2, int a3, float* a4) {
    __int16* result; // eax
    __int16* i; // edx
    int v7; // [esp+8h] [ebp+8h]

    result = (__int16*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [2 * this [1044]]; result < i; *(a4 - 1) = 1.0) {
        v7 = *result;
        result += 2;
        *a4 = (double) v7 * 0.000030517578;
        a4 += 4;
        *(a4 - 3) = (double) *(result - 1) * 0.000030517578;
        *(a4 - 2) = 0.0;
    }
    return result;
}

//----- (004468A1) --------------------------------------------------------
unsigned int* __thiscall sub_4468A1(_DWORD* this, int a2, int a3, float* a4) {
    unsigned int* result; // eax
    unsigned int* i; // edi
    unsigned int v7; // ecx
    int v8; // [esp+Ch] [ebp+8h]

    result = (unsigned int*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &result [this [1044]]; result < i; *(a4 - 1) = 1.0) {
        v7 = *result;
        v8 = (__int16) (32 * (*result >> 10)) >> 5;
        *a4 = (double) ((__int16) (*(_WORD*) result++ << 6) >> 6) * 0.001953125;
        a4 += 4;
        *(a4 - 3) = (double) v8 * 0.0009765625;
        *(a4 - 2) = (double) ((__int16) (32 * (v7 >> 21)) >> 5) * 0.0009765625;
    }
    return result;
}

//----- (00446940) --------------------------------------------------------
float* __thiscall sub_446940(float* this, float* a2, float* a3) {
    double v3; // st7
    double v4; // st6
    double v5; // st5
    float* result; // eax

    v3 = this [3] - a3 [3];
    v4 = this [2] - a3 [2];
    v5 = this [1] - a3 [1];
    result = a2;
    *a2 = *this - *a3;
    a2 [1] = v5;
    a2 [2] = v4;
    a2 [3] = v3;
    return result;
}

//----- (0044696C) --------------------------------------------------------
int sub_44696C() {
    int result; // eax
    int v1; // [esp+0h] [ebp-8h]

    result = v1;
    dword_6E61DC = v1;
    return result;
}
// 446983: variable 'v1' is possibly undefined
// 6E61DC: using guessed type int dword_6E61DC;

//----- (0044698F) --------------------------------------------------------
int sub_44698F() {
    return dword_6E61DC;
}
// 6E61DC: using guessed type int dword_6E61DC;

//----- (0044699F) --------------------------------------------------------
float* __thiscall sub_44699F(float* this, float* a2, unsigned int a3, int a4) {
    void* v6; // ecx
    unsigned int v7; // edx
    float* v8; // ecx
    float* v9; // eax
    int v10; // ecx
    int v11; // esi
    int v12; // edi
    _DWORD* v13; // ecx
    int v14; // edx
    int v15; // eax
    bool v16; // zf
    float v18 [4]; // [esp+Ch] [ebp-10h] BYREF
    int v19; // [esp+24h] [ebp+8h]

    *(_DWORD*) this = &off_46D0E8;
    this [6] = *a2;
    this [1] = a2 [1];
    this [1042] = a2 [2];
    this [1043] = a2 [3];
    qmemcpy(this + 1036, a2 + 10, 0x18u);
    sub_4465EC(v18, *((_DWORD*) a2 + 17));
    this [7] = v18 [0];
    this [8] = v18 [1];
    this [9] = v18 [2];
    this [10] = v18 [3];
    *((_DWORD*) this + 4) = *((_DWORD*) a2 + 17) != 0;
    v6 = &unk_4793A8;
    if(!*((_DWORD*) a2 + 16))
        v6 = &unk_479328;
    *((_DWORD*) this + 11) = v6;
    *((_DWORD*) this + 1048) = a3 >> 3;
    *((_DWORD*) this + 3) = a3 != 0;
    *((_DWORD*) this + 2) = a4;
    if(a4 == 2) {
        *((_DWORD*) this + 2) = 1;
        *((_DWORD*) this + 5) = 1;
        if(*((_DWORD*) a2 + 18)) {
            v7 = 0;
            v8 = this + 13;
            do {
                v19 = *(unsigned __int8*) (v7 + *((_DWORD*) a2 + 18));
                v7 += 4;
                *(v8 - 1) = (double) v19 * 0.0039215689;
                *v8 = (double) *(unsigned __int8*) (v7 + *((_DWORD*) a2 + 18) - 3) * 0.0039215689;
                v8 += 4;
                *(v8 - 3) = (double) *(unsigned __int8*) (v7 + *((_DWORD*) a2 + 18) - 2) * 0.0039215689;
                *(v8 - 2) = (double) *(unsigned __int8*) (v7 + *((_DWORD*) a2 + 18) - 1) * 0.0039215689;
            }
            while(v7 < 0x400);
        }
        else {
            v9 = this + 14;
            v10 = 256;
            do {
                v9 [1] = 1.0;
                *v9 = 1.0;
                v9 += 4;
                --v10;
                *(v9 - 5) = 1.0;
                *(v9 - 6) = 1.0;
            }
            while(v10);
        }
    }
    else {
        this [5] = 0.0;
    }
    v11 = *((_DWORD*) this + 1037);
    v12 = *((_DWORD*) this + 1041);
    v13 = this + 1036;
    v14 = *((_DWORD*) this + 1038) - *((_DWORD*) this + 1036);
    *((_DWORD*) this + 1045) = *((_DWORD*) this + 1039) - v11;
    v15 = *((_DWORD*) this + 1048);
    *((_DWORD*) this + 1046) = v12 - *((_DWORD*) this + 1040);
    v16 = *((_DWORD*) this + 3) == 0;
    *((_DWORD*) this + 1044) = v14;
    *((_DWORD*) this + 1047) = v14 * v15;
    if(!v16) {
        *((_DWORD*) this + 6) += *v13 * v15
            + v11 * *((_DWORD*) this + 1042)
            + *((_DWORD*) this + 1040) * *((_DWORD*) this + 1043);
        *v13 = 0;
        this [1037] = 0.0;
        this [1040] = 0.0;
        this [1038] = this [1044];
        this [1039] = this [1045];
        this [1041] = this [1046];
    }
    return this;
}
// 46D0E8: using guessed type int (__thiscall *off_46D0E8)(void *Block, char);
// 44699F: using guessed type float var_10[4];

//----- (00446B88) --------------------------------------------------------
_DWORD* __thiscall sub_446B88(_DWORD* Block, char a2) {
    sub_4465E2(Block);
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}

//----- (00446BA4) --------------------------------------------------------
void __thiscall sub_446BA4(int this, unsigned int a2) {
    float* v2; // edx
    unsigned int v3; // esi

    if(a2 < a2 + 16 * *(_DWORD*) (this + 4176)) {
        v2 = (float*) (a2 + 8);
        v3 = ((unsigned int) (16 * *(_DWORD*) (this + 4176) - 1) >> 4) + 1;
        do {
            if(*(v2 - 2) == *(float*) (this + 28)
               && *(v2 - 1) == *(float*) (this + 32)
               && *v2 == *(float*) (this + 36)
               && v2 [1] == *(float*) (this + 40)) {
                v2 [1] = 0.0;
                *v2 = 0.0;
                *(v2 - 1) = 0.0;
                *(v2 - 2) = 0.0;
            }
            v2 += 4;
            --v3;
        }
        while(v3);
    }
}

//----- (00446C14) --------------------------------------------------------
int __thiscall sub_446C14(_DWORD* this, char a2, char a3, int a4) {
    int v5; // ebx
    _BYTE* v6; // edx
    unsigned int v7; // edi
    float* v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    float v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+20h] [ebp+Ch]

    v5 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v7 = 0;
    if(this [1044]) {
        v8 = (float*) (a4 + 4);
        do {
            v10 = *(float*) (v5 + 4 * (v7 & 3));
            v12 = v8 [1] * 255.0 + v10;
            *v6 = (int) v12;
            v13 = *v8 * 255.0 + v10;
            v6 [1] = (int) v13;
            v11 = *(v8 - 1) * 255.0 + v10;
            v6 [2] = (int) v11;
            v6 += 3;
            ++v7;
            v8 += 4;
        }
        while(v7 < this [1044]);
    }
    return sub_44698F();
}
// 446C83: variable 'v6' is possibly undefined

//----- (00446CD5) --------------------------------------------------------
int __thiscall sub_446CD5(_DWORD* this, char a2, char a3, int a4) {
    int* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // ebx
    int v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+24h] [ebp+8h]
    float v12; // [esp+24h] [ebp+8h]
    int v13; // [esp+28h] [ebp+Ch]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]
    float v16; // [esp+2Ch] [ebp+10h]

    v13 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v11 = *(float*) (v13 + 4 * (v6 & 3));
            v14 = *(v7 - 2) * 255.0 + v11;
            v8 = (int) v14;
            v15 = *(v7 - 1) * 255.0 + v11;
            v10 = (int) v15;
            v16 = *v7 * 255.0 + v11;
            v12 = v7 [1] * 255.0 + v11;
            v7 += 4;
            *v5++ = (int) v16 | ((v10 | ((v8 | ((int) v12 << 8)) << 8)) << 8);
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 446DB0: variable 'v5' is possibly undefined

//----- (00446DCE) --------------------------------------------------------
int __thiscall sub_446DCE(_DWORD* this, char a2, char a3, int a4) {
    int* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    int v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+10h]
    float v14; // [esp+24h] [ebp+10h]

    v12 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v10 = *(float*) (v12 + 4 * (v6 & 3));
            v13 = *(v7 - 2) * 255.0 + v10;
            v8 = (int) v13;
            v14 = *(v7 - 1) * 255.0 + v10;
            v11 = *v7 * 255.0 + v10;
            v7 += 4;
            *v5++ = (int) v11 | (((int) v14 | (v8 << 8)) << 8);
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 446E88: variable 'v5' is possibly undefined

//----- (00446EA5) --------------------------------------------------------
int __thiscall sub_446EA5(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    int v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+10h]
    float v14; // [esp+24h] [ebp+10h]

    v12 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v10 = *(float*) (v12 + 4 * (v6 & 3));
            v13 = *(v7 - 2) * 31.0 + v10;
            v8 = (int) v13;
            v14 = *(v7 - 1) * 63.0 + v10;
            v11 = *v7 * 31.0 + v10;
            v7 += 4;
            *v5++ = (int) v11 | (32 * ((int) v14 | ((_WORD) v8 << 6)));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 446F5F: variable 'v5' is possibly undefined

//----- (00446F7C) --------------------------------------------------------
int __thiscall sub_446F7C(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    int v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+10h]
    float v14; // [esp+24h] [ebp+10h]

    v12 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v10 = *(float*) (v12 + 4 * (v6 & 3));
            v13 = *(v7 - 2) * 31.0 + v10;
            v8 = (int) v13;
            v14 = *(v7 - 1) * 31.0 + v10;
            v11 = *v7 * 31.0 + v10;
            v7 += 4;
            *v5++ = (int) v11 | (32 * ((int) v14 | (32 * v8)));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 447036: variable 'v5' is possibly undefined

//----- (00447053) --------------------------------------------------------
int __thiscall sub_447053(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // ebx
    int v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+24h] [ebp+8h]
    float v12; // [esp+24h] [ebp+8h]
    int v13; // [esp+28h] [ebp+Ch]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]
    float v16; // [esp+2Ch] [ebp+10h]

    v13 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v11 = *(float*) (v13 + 4 * (v6 & 3));
            v14 = *(v7 - 2) * 31.0 + v11;
            v8 = (int) v14;
            v15 = *(v7 - 1) * 31.0 + v11;
            v10 = (int) v15;
            v16 = *v7 * 31.0 + v11;
            v12 = v11 + v7 [1];
            v7 += 4;
            *v5++ = (int) v16 | (32 * (v10 | (32 * (v8 | (32 * (int) v12)))));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 447128: variable 'v5' is possibly undefined

//----- (00447146) --------------------------------------------------------
int __thiscall sub_447146(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // ebx
    int v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+24h] [ebp+8h]
    float v12; // [esp+24h] [ebp+8h]
    int v13; // [esp+28h] [ebp+Ch]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]
    float v16; // [esp+2Ch] [ebp+10h]

    v13 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v11 = *(float*) (v13 + 4 * (v6 & 3));
            v14 = *(v7 - 2) * 15.0 + v11;
            v8 = (int) v14;
            v15 = *(v7 - 1) * 15.0 + v11;
            v10 = (int) v15;
            v16 = *v7 * 15.0 + v11;
            v12 = v7 [1] * 15.0 + v11;
            v7 += 4;
            *v5++ = (int) v16 | (16 * (v10 | (16 * (v8 | (16 * (int) v12)))));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 447221: variable 'v5' is possibly undefined

//----- (0044723F) --------------------------------------------------------
int __thiscall sub_44723F(_DWORD* this, char a2, char a3, int a4) {
    _BYTE* v5; // edx
    unsigned int v6; // ecx
    float* v7; // edi
    int v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    int v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+10h]
    float v14; // [esp+24h] [ebp+10h]

    v12 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v10 = *(float*) (v12 + 4 * (v6 & 3));
            v13 = *(v7 - 2) * 7.0 + v10;
            v8 = (int) v13;
            v14 = *(v7 - 1) * 7.0 + v10;
            v11 = *v7 * 3.0 + v10;
            v7 += 4;
            *v5++ = (int) v11 | (4 * ((int) v14 | (8 * v8)));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 4472F5: variable 'v5' is possibly undefined

//----- (00447310) --------------------------------------------------------
int __thiscall sub_447310(_DWORD* this, char a2, char a3, int a4) {
    int v5; // edi
    _BYTE* v6; // edx
    unsigned int v7; // ecx
    float* v8; // ebx
    float v10; // [esp+10h] [ebp+8h]

    v5 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v7 = 0;
    if(this [1044]) {
        v8 = (float*) (a4 + 12);
        do {
            v10 = *(float*) (v5 + 4 * (v7 & 3)) + *v8 * 255.0;
            *v6++ = (int) v10;
            ++v7;
            v8 += 4;
        }
        while(v7 < this [1044]);
    }
    return sub_44698F();
}
// 447377: variable 'v6' is possibly undefined

//----- (00447392) --------------------------------------------------------
int __thiscall sub_447392(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // eax
    int v8; // ebx
    int v10; // [esp+8h] [ebp-14h]
    float v11; // [esp+24h] [ebp+8h]
    float v12; // [esp+24h] [ebp+8h]
    int v13; // [esp+28h] [ebp+Ch]
    float v14; // [esp+2Ch] [ebp+10h]
    float v15; // [esp+2Ch] [ebp+10h]
    float v16; // [esp+2Ch] [ebp+10h]

    v13 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v11 = *(float*) (v13 + 4 * (v6 & 3));
            v14 = *(v7 - 2) * 7.0 + v11;
            v8 = (int) v14;
            v15 = *(v7 - 1) * 7.0 + v11;
            v10 = (int) v15;
            v16 = *v7 * 3.0 + v11;
            v12 = v7 [1] * 255.0 + v11;
            v7 += 4;
            *v5++ = (int) v16 | (4 * (v10 | (8 * (v8 | (8 * (int) v12)))));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 44746D: variable 'v5' is possibly undefined

//----- (0044748B) --------------------------------------------------------
int __thiscall sub_44748B(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // edi
    float* v7; // ecx
    int v8; // eax
    float v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+8h]
    int v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+10h]
    float v14; // [esp+24h] [ebp+10h]

    v12 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 8);
        do {
            v10 = *(float*) (v12 + 4 * (v6 & 3));
            v13 = *(v7 - 2) * 15.0 + v10;
            v8 = (int) v13;
            v14 = *(v7 - 1) * 15.0 + v10;
            v11 = *v7 * 15.0 + v10;
            v7 += 4;
            *v5++ = (int) v11 | (16 * ((int) v14 | (16 * v8)));
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 447545: variable 'v5' is possibly undefined

//----- (00447562) --------------------------------------------------------
int __thiscall sub_447562(float* this, int a2, int a3, float* a4) {
    _WORD* v5; // edi
    unsigned int v6; // ebx
    __int16 v7; // cx
    float v9; // [esp+Ch] [ebp-24h] BYREF
    float v10; // [esp+10h] [ebp-20h]
    float v11; // [esp+14h] [ebp-1Ch]
    int v12; // [esp+1Ch] [ebp-14h]
    float v13; // [esp+20h] [ebp-10h]
    int v14; // [esp+24h] [ebp-Ch]
    unsigned int v15; // [esp+28h] [ebp-8h]
    float* v16; // [esp+2Ch] [ebp-4h]
    unsigned int v17; // [esp+38h] [ebp+8h]
    float v18; // [esp+38h] [ebp+8h]
    float* v19; // [esp+3Ch] [ebp+Ch]

    v5 = (_WORD*) (*((_DWORD*) this + 6) + a3 * *((_DWORD*) this + 1043) + a2 * *((_DWORD*) this + 1042));
    v14 = *((_DWORD*) this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(*((_DWORD*) this + 1044)) {
        v16 = a4 + 3;
        do {
            v15 = 0;
            v17 = 0;
            v13 = *(float*) (v14 + 4 * (v6 & 3));
            v19 = this + 12;
            do {
                sub_446940(a4, &v9, v19);
                if(v11 * v11 + v10 * v10 + v9 * v9 < 3.4028235e38)
                    v15 = v17;
                ++v17;
                v19 += 4;
            }
            while(v17 < 0x100);
            v18 = *v16 * 255.0 + v13;
            v12 = (int) v18;
            v16 += 4;
            LOBYTE(v7) = 0;
            HIBYTE(v7) = v12;
            *v5++ = v15 | v7;
            ++v6;
        }
        while(v6 < *((_DWORD*) this + 1044));
    }
    return sub_44698F();
}

//----- (0044765F) --------------------------------------------------------
int __thiscall sub_44765F(float* this, int a2, int a3, float* a4) {
    int result; // eax
    _BYTE* i; // esi
    char v7; // bl
    double v8; // st7
    float v9; // [esp+8h] [ebp-18h] BYREF
    float v10; // [esp+Ch] [ebp-14h]
    float v11; // [esp+10h] [ebp-10h]
    float v12; // [esp+14h] [ebp-Ch]
    float v13; // [esp+18h] [ebp-8h]
    unsigned int v14; // [esp+1Ch] [ebp-4h]
    unsigned int v15; // [esp+28h] [ebp+8h]
    float* v16; // [esp+2Ch] [ebp+Ch]

    v14 = 0;
    result = a3 * *((_DWORD*) this + 1043);
    for(i = (_BYTE*) (*((_DWORD*) this + 6) + result + a2 * *((_DWORD*) this + 1042));
        v14 < *((_DWORD*) this + 1044);
        result = v14) {
        v7 = 0;
        v13 = 3.4028235e38;
        v15 = 0;
        v16 = this + 12;
        do {
            sub_446940(a4, &v9, v16);
            v8 = v12 * v12 + v11 * v11 + v10 * v10 + v9 * v9;
            if(v8 < v13) {
                v7 = v15;
                v13 = v8;
            }
            ++v15;
            v16 += 4;
        }
        while(v15 < 0x100);
        a4 += 4;
        *i++ = v7;
        ++v14;
    }
    return result;
}

//----- (00447719) --------------------------------------------------------
int __thiscall sub_447719(_DWORD* this, char a2, char a3, int a4) {
    int v5; // edi
    _BYTE* v6; // edx
    unsigned int v7; // ebx
    float* v8; // eax
    float v10; // [esp+14h] [ebp+8h]

    v5 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v7 = 0;
    if(this [1044]) {
        v8 = (float*) (a4 + 4);
        do {
            v10 = (*(v8 - 1) * 0.21250001 + v8 [1] * 0.072099999 + *v8 * 0.71539998) * 255.0 + *(float*) (v5 + 4 * (v7 & 3));
            *v6++ = (int) v10;
            ++v7;
            v8 += 4;
        }
        while(v7 < this [1044]);
    }
    return sub_44698F();
}
// 44779C: variable 'v6' is possibly undefined

//----- (004477B7) --------------------------------------------------------
int __thiscall sub_4477B7(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    unsigned int v6; // eax
    float* v7; // edi
    __int16 v8; // bx
    int v10; // [esp+8h] [ebp-Ch]
    int v11; // [esp+1Ch] [ebp+8h]
    float v12; // [esp+20h] [ebp+Ch]
    float v13; // [esp+20h] [ebp+Ch]

    v11 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 4);
        do {
            v12 = (*(v7 - 1) * 0.21250001 + v7 [1] * 0.072099999 + *v7 * 0.71539998) * 255.0 + *(float*) (v11 + 4 * (v6 & 3));
            v10 = (int) v12;
            v13 = v7 [2] * 255.0 + *(float*) (v11 + 4 * (v6 & 3));
            LOBYTE(v8) = 0;
            HIBYTE(v8) = (int) v13;
            v7 += 4;
            *v5++ = v10 | v8;
            ++v6;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 44786D: variable 'v5' is possibly undefined

//----- (00447887) --------------------------------------------------------
int __thiscall sub_447887(_DWORD* this, char a2, char a3, int a4) {
    _BYTE* v5; // edx
    unsigned int v6; // ecx
    float* v7; // edi
    int v8; // ebx
    int v10; // [esp+18h] [ebp+8h]
    float v11; // [esp+1Ch] [ebp+Ch]
    float v12; // [esp+1Ch] [ebp+Ch]

    v10 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v6 = 0;
    if(this [1044]) {
        v7 = (float*) (a4 + 4);
        do {
            v11 = (*(v7 - 1) * 0.21250001 + v7 [1] * 0.072099999 + *v7 * 0.71539998) * 15.0 + *(float*) (v10 + 4 * (v6 & 3));
            v8 = (int) v11;
            v12 = v7 [2] * 15.0 + *(float*) (v10 + 4 * (v6 & 3));
            *v5++ = v8 | (16 * (int) v12);
            ++v6;
            v7 += 4;
        }
        while(v6 < this [1044]);
    }
    return sub_44698F();
}
// 447934: variable 'v5' is possibly undefined

//----- (0044794F) --------------------------------------------------------
int __thiscall sub_44794F(_DWORD* this, char a2, char a3, float* a4) {
    _WORD* v5; // edx
    unsigned int i; // eax
    int v8; // ecx
    __int16 v9; // bx
    int v11; // [esp+18h] [ebp+8h]
    float v12; // [esp+1Ch] [ebp+Ch]
    float v13; // [esp+1Ch] [ebp+Ch]

    v11 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    for(i = 0; i < this [1044]; ++i) {
        v12 = *a4 * 128.0 + *(float*) (v11 + 4 * (i & 3));
        v8 = (int) v12;
        v13 = a4 [1] * 128.0 + *(float*) (v11 + 4 * (i & 3));
        LOBYTE(v9) = v8;
        a4 += 4;
        HIBYTE(v9) = (int) v13;
        *v5++ = v9;
    }
    return sub_44698F();
}
// 4479E5: variable 'v5' is possibly undefined

//----- (004479FF) --------------------------------------------------------
int __thiscall sub_4479FF(_DWORD* this, char a2, char a3, int a4) {
    _WORD* v5; // edx
    float* v6; // edi
    char v7; // cl
    int v9; // [esp+14h] [ebp-4h]
    unsigned int v10; // [esp+20h] [ebp+8h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v9 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v10 = 0;
    if(this [1044]) {
        v6 = (float*) (a4 + 12);
        do {
            v11 = *(float*) (v9 + 4 * (v10 & 3));
            v13 = *(v6 - 3) * 16.0 + v11;
            v7 = (int) v13;
            v14 = *(v6 - 2) * 16.0 + v11;
            v12 = *v6 * 63.0 + v11;
            *v5++ = v7 & 0x1F | (32 * ((32 * (int) v12) | (int) v14 & 0x1F));
            ++v10;
            v6 += 4;
        }
        while(v10 < this [1044]);
    }
    return sub_44698F();
}
// 447ABC: variable 'v5' is possibly undefined

//----- (00447ADE) --------------------------------------------------------
int __thiscall sub_447ADE(_DWORD* this, char a2, char a3, int a4) {
    int* v5; // edx
    float* v6; // edi
    unsigned __int8 v7; // al
    unsigned __int16 v8; // bx
    int v10; // [esp+14h] [ebp-4h]
    unsigned int v11; // [esp+20h] [ebp+8h]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+24h] [ebp+Ch]
    float v14; // [esp+28h] [ebp+10h]
    float v15; // [esp+28h] [ebp+10h]

    v10 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v11 = 0;
    if(this [1044]) {
        v6 = (float*) (a4 + 12);
        do {
            v12 = *(float*) (v10 + 4 * (v11 & 3));
            v14 = *(v6 - 3) * 128.0 + v12;
            v7 = (int) v14;
            v15 = *(v6 - 2) * 128.0 + v12;
            v13 = *v6 * 255.0 + v12;
            HIBYTE(v8) = (int) v13;
            v6 += 4;
            LOBYTE(v8) = (int) v15;
            *v5++ = v7 | (v8 << 8);
            ++v11;
        }
        while(v11 < this [1044]);
    }
    return sub_44698F();
}
// 447BA2: variable 'v5' is possibly undefined

//----- (00447BC5) --------------------------------------------------------
int __thiscall sub_447BC5(_DWORD* this, char a2, char a3, int a4) {
    int* v5; // edx
    float* v6; // ecx
    int v8; // [esp+8h] [ebp-1Ch]
    int v9; // [esp+Ch] [ebp-18h]
    int v10; // [esp+20h] [ebp-4h]
    unsigned int v11; // [esp+2Ch] [ebp+8h]
    float v12; // [esp+30h] [ebp+Ch]
    float v13; // [esp+30h] [ebp+Ch]
    float v14; // [esp+34h] [ebp+10h]
    float v15; // [esp+34h] [ebp+10h]
    float v16; // [esp+34h] [ebp+10h]

    v10 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v11 = 0;
    if(this [1044]) {
        v6 = (float*) (a4 + 8);
        do {
            v12 = *(float*) (v10 + 4 * (v11 & 3));
            v14 = *(v6 - 2) * 128.0 + v12;
            v8 = (int) v14;
            v15 = *(v6 - 1) * 128.0 + v12;
            v9 = (int) v15;
            v16 = *v6 * 128.0 + v12;
            v13 = v6 [1] * 128.0 + v12;
            *v5++ = (unsigned __int8) v8 | (((unsigned __int8) v9 | ((((int) v13 << 8) | (unsigned __int8) (int) v16) << 8)) << 8);
            ++v11;
            v6 += 4;
        }
        while(v11 < this [1044]);
    }
    return sub_44698F();
}
// 447CB0: variable 'v5' is possibly undefined

//----- (00447CD6) --------------------------------------------------------
int __thiscall sub_447CD6(_DWORD* this, char a2, char a3, float* a4) {
    int* v5; // edx
    unsigned int i; // ebx
    unsigned __int16 v8; // cx
    int v10; // [esp+1Ch] [ebp+8h]
    float v11; // [esp+20h] [ebp+Ch]
    float v12; // [esp+20h] [ebp+Ch]

    v10 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    for(i = 0; i < this [1044]; a4 += 4) {
        v11 = *a4 * 32768.0 + *(float*) (v10 + 4 * (i & 3));
        v8 = (int) v11;
        v12 = a4 [1] * 32768.0 + *(float*) (v10 + 4 * (i & 3));
        *v5++ = v8 | ((int) v12 << 16);
        ++i;
    }
    return sub_44698F();
}
// 447D6A: variable 'v5' is possibly undefined

//----- (00447D87) --------------------------------------------------------
int __thiscall sub_447D87(_DWORD* this, char a2, char a3, int a4) {
    unsigned int* v5; // edx
    float* v6; // ecx
    __int16 v7; // di
    int v9; // [esp+14h] [ebp-4h]
    unsigned int v10; // [esp+20h] [ebp+8h]
    float v11; // [esp+24h] [ebp+Ch]
    float v12; // [esp+24h] [ebp+Ch]
    float v13; // [esp+28h] [ebp+10h]
    float v14; // [esp+28h] [ebp+10h]

    v9 = this [11] + 4 * ((a3 & 3) + 8 * (a2 & 3));
    sub_44696C();
    v10 = 0;
    if(this [1044]) {
        v6 = (float*) (a4 + 8);
        do {
            v11 = *(float*) (v9 + 4 * (v10 & 3));
            v13 = *(v6 - 2) * 512.0 + v11;
            v7 = (int) v13;
            v14 = *(v6 - 1) * 1024.0 + v11;
            v12 = *v6 * 1024.0 + v11;
            *v5++ = v7 & 0x3FF | (((int) v14 & 0x7FF | (((int) v12 & 0xFFFFFFFE) << 11)) << 10);
            ++v10;
            v6 += 4;
        }
        while(v10 < this [1044]);
    }
    return sub_44698F();
}
// 447E4D: variable 'v5' is possibly undefined

//----- (00447E73) --------------------------------------------------------
void __thiscall sub_447E73(_DWORD* this, int a2, int a3, float* a4) {
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    int v7; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v4 [this [1047]]; v4 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) v4 [2] * 0.0039215689;
        a4 += 4;
        *(a4 - 3) = (double) v4 [1] * 0.0039215689;
        v7 = *v4;
        v4 += 3;
        *(a4 - 2) = (double) v7 * 0.0039215689;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00447EFF) --------------------------------------------------------
void __thiscall sub_447EFF(_DWORD* this, int a2, int a3, float* a4) {
    unsigned int v4; // eax
    unsigned int i; // esi
    __int64 v7; // [esp+4h] [ebp-8h]

    v4 = this [6] + a3 * this [1043] + a2 * this [1042];
    for(i = v4 + 4 * this [1044]; v4 < i; *(a4 - 1) = (double) *(unsigned __int8*) (v4 - 1) * 0.0039215689) {
        *a4 = (double) *(unsigned __int8*) (v4 + 2) * 0.0039215689;
        a4 += 4;
        *(a4 - 3) = (double) *(unsigned __int8*) (v4 + 1) * 0.0039215689;
        v7 = (unsigned __int8) *(_DWORD*) v4;
        v4 += 4;
        *(a4 - 2) = (double) v7 * 0.0039215689;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00447FA1) --------------------------------------------------------
void __thiscall sub_447FA1(_DWORD* this, int a2, int a3, float* a4) {
    unsigned int v4; // eax
    unsigned int i; // esi
    __int64 v7; // [esp+4h] [ebp-8h]

    v4 = this [6] + a3 * this [1043] + a2 * this [1042];
    for(i = v4 + 4 * this [1044]; v4 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) *(unsigned __int8*) (v4 + 2) * 0.0039215689;
        a4 += 4;
        *(a4 - 3) = (double) *(unsigned __int8*) (v4 + 1) * 0.0039215689;
        v7 = (unsigned __int8) *(_DWORD*) v4;
        v4 += 4;
        *(a4 - 2) = (double) v7 * 0.0039215689;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448039) --------------------------------------------------------
void __thiscall sub_448039(_DWORD* this, int a2, int a3, float* a4) {
    _WORD* v5; // eax
    _WORD* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_WORD*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [this [1044]]; v5 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) (*v5 >> 11) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double) (((unsigned __int16) *v5 >> 5) & 0x3F) * 0.015873017;
        v7 = *(_BYTE*) v5++ & 0x1F;
        *(a4 - 2) = (double) v7 * 0.032258064;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004480DE) --------------------------------------------------------
void __thiscall sub_4480DE(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) ((*(unsigned __int16*) v5 >> 10) & 0x1F) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double) ((*(unsigned __int16*) v5 >> 5) & 0x1F) * 0.032258064;
        v7 = *v5 & 0x1F;
        v5 += 2;
        *(a4 - 2) = (double) v7 * 0.032258064;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448180) --------------------------------------------------------
void __thiscall sub_448180(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = (float) v7) {
        *a4 = (double) ((*(unsigned __int16*) v5 >> 10) & 0x1F) * 0.032258064;
        a4 += 4;
        *(a4 - 3) = (double) ((*(unsigned __int16*) v5 >> 5) & 0x1F) * 0.032258064;
        *(a4 - 2) = (double) (*v5 & 0x1F) * 0.032258064;
        v7 = *(_WORD*) v5 >> 15;
        v5 += 2;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448230) --------------------------------------------------------
void __thiscall sub_448230(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = (double) v7 * 0.06666667) {
        *a4 = (double) (v5 [1] & 0xF) * 0.06666667;
        a4 += 4;
        *(a4 - 3) = (double) ((*v5 >> 4) & 0xF) * 0.06666667;
        *(a4 - 2) = (double) (*v5 & 0xF) * 0.06666667;
        v7 = *(_WORD*) v5 >> 12;
        v5 += 2;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004482DF) --------------------------------------------------------
void __thiscall sub_4482DF(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [this [1044]]; v5 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) (*v5 >> 5) * 0.14285715;
        a4 += 4;
        *(a4 - 3) = (double) ((*v5 >> 2) & 7) * 0.14285715;
        v7 = *v5++ & 3;
        *(a4 - 2) = (double) v7 * 0.33333334;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448381) --------------------------------------------------------
void __thiscall sub_448381(_DWORD* this, int a2, int a3, float* a4) {
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    int v7; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v4 [this [1044]]; v4 < i; *(a4 - 1) = (double) v7 * 0.0039215689) {
        *a4 = 1.0;
        a4 += 4;
        *(a4 - 3) = 1.0;
        *(a4 - 2) = 1.0;
        v7 = *v4++;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004483F3) --------------------------------------------------------
void __thiscall sub_4483F3(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = (double) (unsigned __int8) *(v5 - 1) * 0.0039215689) {
        *a4 = (double) ((*v5 >> 5) & 7) * 0.14285715;
        a4 += 4;
        *(a4 - 3) = (double) ((*v5 >> 2) & 7) * 0.14285715;
        v7 = *v5 & 3;
        v5 += 2;
        *(a4 - 2) = (double) v7 * 0.33333334;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004484A5) --------------------------------------------------------
void __thiscall sub_4484A5(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    int v7; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = 1.0) {
        *a4 = (double) (v5 [1] & 0xF) * 0.06666667;
        a4 += 4;
        *(a4 - 3) = (double) ((*v5 >> 4) & 0xF) * 0.06666667;
        v7 = *v5 & 0xF;
        v5 += 2;
        *(a4 - 2) = (double) v7 * 0.06666667;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448544) --------------------------------------------------------
void __thiscall sub_448544(_DWORD* this, int a2, int a3, float* a4) {
    unsigned __int8* v4; // eax
    float* v6; // edi
    float* v7; // esi
    unsigned __int8* i; // [esp+8h] [ebp+8h]
    int v9; // [esp+10h] [ebp+10h]

    v4 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v4 [2 * this [1044]]; v4 < i; *(a4 - 1) = (double) v9 * 0.0039215689) {
        v6 = a4;
        a4 += 4;
        v7 = (float*) &this [4 * *v4 + 12];
        *v6 = *v7++;
        *++v6 = *v7++;
        *++v6 = *v7;
        v6 [1] = v7 [1];
        v9 = v4 [1];
        v4 += 2;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004485CB) --------------------------------------------------------
void __thiscall sub_4485CB(_DWORD* this, int a2, int a3, _DWORD* a4) {
    unsigned __int8* v4; // eax
    unsigned __int8* i; // edx
    _DWORD* v7; // esi
    _DWORD* v8; // edi

    v4 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v4 [this [1044]]; v4 < i; *v8 = v7 [1]) {
        v7 = &this [4 * *v4 + 12];
        *a4 = *v7++;
        a4 [1] = *v7++;
        a4 [2] = *v7;
        v8 = a4 + 3;
        ++v4;
        a4 += 4;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (0044862F) --------------------------------------------------------
void __thiscall sub_44862F(_DWORD* this, int a2, int a3, float* a4) {
    unsigned __int8* v4; // eax
    unsigned __int8* i; // esi
    double v7; // st7
    int v8; // [esp+14h] [ebp+10h]

    v4 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v4 [this [1044]]; v4 < i; *(a4 - 1) = 1.0) {
        v8 = *v4++;
        v7 = (double) v8 * 0.0039215689;
        a4 [2] = v7;
        a4 [1] = v7;
        *a4 = v7;
        a4 += 4;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (0044869D) --------------------------------------------------------
void __thiscall sub_44869D(_DWORD* this, int a2, int a3, float* a4) {
    unsigned __int8* v5; // eax
    unsigned __int8* i; // edi
    double v7; // st6
    int v8; // [esp+18h] [ebp+10h]

    v5 = (unsigned __int8*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [2 * this [1044]]; v5 < i; *(a4 - 1) = (double) *(v5 - 1) * 0.0039215689) {
        v8 = *v5;
        v5 += 2;
        v7 = (double) v8 * 0.0039215689;
        a4 [2] = v7;
        a4 [1] = v7;
        *a4 = v7;
        a4 += 4;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (00448726) --------------------------------------------------------
void __thiscall sub_448726(_DWORD* this, int a2, int a3, float* a4) {
    _BYTE* v5; // eax
    _BYTE* i; // edi
    double v7; // st6
    int v8; // [esp+18h] [ebp+10h]

    v5 = (_BYTE*) (this [6] + a3 * this [1043] + a2 * this [1042]);
    for(i = &v5 [this [1044]]; v5 < i; *(a4 - 1) = (double) v8 * 0.06666667) {
        v7 = (double) (*v5 & 0xF) * 0.06666667;
        a4 [2] = v7;
        a4 [1] = v7;
        *a4 = v7;
        v8 = *v5++ >> 4;
        a4 += 4;
    }
    if(this [4])
        sub_446BA4((int) this, (unsigned int) &a4 [-4 * this [1044]]);
}

//----- (004487AF) --------------------------------------------------------
int __thiscall sub_4487AF(int this, int a2) {
    unsigned int v3; // ecx
    unsigned int v4; // eax
    unsigned int v5; // eax
    void* v6; // eax

    sub_44699F((float*) this, (float*) a2, 0, 1);
    v3 = *(_DWORD*) (this + 4144) & 0xFFFFFFFE;
    v4 = (*(_DWORD*) (this + 4152) + 1) & 0xFFFFFFFE;
    *(_DWORD*) (this + 4208) = v4;
    v5 = v4 - v3;
    *(_DWORD*) (this + 4224) = v5;
    *(_DWORD*) this = &off_46D134;
    *(_DWORD*) (this + 4200) = v3;
    *(_DWORD*) (this + 4204) = 0;
    *(_DWORD*) (this + 4216) = 0;
    *(_DWORD*) (this + 4212) = 0;
    *(_DWORD*) (this + 4220) = 0;
    *(_DWORD*) (this + 4228) = 0;
    *(_DWORD*) (this + 4232) = 1;
    v6 = operator new(16 * v5);
    *(_DWORD*) (this + 4196) = v6;
    if(!v6)
        *(_DWORD*) (this + 4232) = 0;
    if(*(_DWORD*) (a2 + 4) == 1498831189) {
        *(_DWORD*) (this + 4236) = 8;
        *(_DWORD*) (this + 4240) = 0;
    }
    else {
        *(_DWORD*) (this + 4236) = 0;
        *(_DWORD*) (this + 4240) = 8;
    }
    return this;
}
// 46D134: using guessed type int (__thiscall *off_46D134)(void *Block, char);

//----- (00448880) --------------------------------------------------------
int __thiscall sub_448880(_DWORD* this) {
    int v2; // eax
    unsigned int v3; // ecx
    float* v4; // eax
    int v5; // esi
    int v6; // edi
    int v7; // ebx
    float v9; // [esp+4h] [ebp-24h]
    float v10; // [esp+4h] [ebp-24h]
    float v11; // [esp+Ch] [ebp-1Ch]
    float v12; // [esp+Ch] [ebp-1Ch]
    float v13; // [esp+14h] [ebp-14h]
    float v14; // [esp+14h] [ebp-14h]
    _WORD* v15; // [esp+1Ch] [ebp-Ch]
    unsigned int i; // [esp+20h] [ebp-8h]
    float v17; // [esp+24h] [ebp-4h]
    int v18; // [esp+24h] [ebp-4h]

    if(this [1057] && this [1058]) {
        v2 = this [1043] * this [1054];
        v3 = this [1050];
        v15 = (_WORD*) (this [6] + this [1042] * this [1051] + v2 + 2 * v3);
        v4 = (float*) this [1049];
        for(i = v3; i < this [1052]; *(v15 - 1) = ((_WORD) v18 << this [1060]) | ((_WORD) v6 << this [1059])) {
            v13 = v4 [4] * 65.481003 + v4 [6] * 24.966 + v4 [5] * 128.55299;
            v11 = v4 [2] * 112.0 - v4 [1] * 74.203003 - *v4 * 37.797001;
            v9 = *v4 * 112.0 - (v4 [1] * 93.786003 + v4 [2] * 18.214001);
            v17 = *v4 * 65.481003 + v4 [1] * 128.55299 + v4 [2] * 24.966 + 0.5;
            v5 = (int) v17 + 16;
            v14 = v13 + 0.5;
            v6 = (int) v14 + 16;
            v12 = v11 + 0.5;
            v7 = (int) v12 + 128;
            v10 = v9 + 0.5;
            v18 = (int) v10 + 128;
            if(v5 >= 0) {
                if(v5 > 255)
                    v5 = 255;
            }
            else {
                v5 = 0;
            }
            if(v6 >= 0) {
                if(v6 > 255)
                    LOWORD(v6) = 255;
            }
            else {
                LOWORD(v6) = 0;
            }
            if(v7 >= 0) {
                if(v7 > 255)
                    v7 = 255;
            }
            else {
                v7 = 0;
            }
            if(v18 >= 0) {
                if(v18 > 255)
                    LOWORD(v18) = 255;
            }
            else {
                LOWORD(v18) = 0;
            }
            i += 2;
            v4 += 8;
            *v15 = (v7 << this [1060]) | (v5 << this [1059]);
            v15 += 2;
        }
        this [1057] = 0;
    }
    return 0;
}

//----- (00448A73) --------------------------------------------------------
int __thiscall sub_448A73(int this, unsigned int a2, unsigned int a3, int a4) {
    int result; // eax
    unsigned int v6; // eax
    float* v7; // edx
    _WORD* v8; // ebx
    unsigned __int16 v9; // ax
    double v10; // st4
    _WORD* v11; // ebx
    unsigned __int16 v12; // ax
    double v13; // st4
    double v14; // st3
    double v15; // st3
    double v16; // st2
    double v17; // st2
    double v18; // st1
    double v19; // st1
    double v20; // st2
    double v21; // st2
    double v22; // st2
    double v23; // st4
    double v24; // st4
    double v25; // st4
    float v26; // [esp+Ch] [ebp-Ch]
    float v27; // [esp+10h] [ebp-8h]
    float v28; // [esp+10h] [ebp-8h]
    float v29; // [esp+14h] [ebp-4h]
    float v30; // [esp+14h] [ebp-4h]
    _WORD* v31; // [esp+20h] [ebp+8h]
    float v32; // [esp+20h] [ebp+8h]
    float v33; // [esp+20h] [ebp+8h]
    float v34; // [esp+20h] [ebp+8h]
    float v35; // [esp+20h] [ebp+8h]
    unsigned __int16 v36; // [esp+24h] [ebp+Ch]
    float v37; // [esp+24h] [ebp+Ch]
    float v38; // [esp+24h] [ebp+Ch]
    float v39; // [esp+24h] [ebp+Ch]
    unsigned int i; // [esp+28h] [ebp+10h]

    if(!*(_DWORD*) (this + 4232))
        return -2147024882;
    if(a2 < *(_DWORD*) (this + 4204)
       || a2 >= *(_DWORD*) (this + 4212)
       || a3 < *(_DWORD*) (this + 4216)
       || a3 >= *(_DWORD*) (this + 4220)) {
        result = sub_448880((_DWORD*) this);
        if(result < 0)
            return result;
        *(_DWORD*) (this + 4212) = a2 + 1;
        *(_DWORD*) (this + 4204) = a2;
        *(_DWORD*) (this + 4216) = a3;
        *(_DWORD*) (this + 4220) = a3 + 1;
        if(a4) {
            v6 = *(_DWORD*) (this + 4200);
            v7 = *(float**) (this + 4196);
            v8 = (_WORD*) (*(_DWORD*) (this + 24) + a3 * *(_DWORD*) (this + 4172) + a2 * *(_DWORD*) (this + 4168) + 2 * v6);
            v31 = v8;
            for(i = v6; i < *(_DWORD*) (this + 4208); v31 = v8) {
                v9 = *v8;
                v10 = (double) (unsigned __int8) (*v8 >> *(_WORD*) (this + 4236));
                v11 = v31;
                v36 = (unsigned __int8) (v9 >> *(_WORD*) (this + 4240));
                v12 = v31 [1];
                v27 = v10 - 16.0;
                v29 = (double) v36 - 128.0;
                v13 = (double) (unsigned __int8) (v12 >> *(_WORD*) (this + 4236)) - 16.0;
                v14 = (double) (unsigned __int8) (v12 >> *(_WORD*) (this + 4240)) - 128.0;
                v37 = v14;
                v15 = v14 * 0.0062589301;
                v16 = v27 * 0.0045662099;
                v32 = v16;
                v17 = v16 + v15;
                *v7 = v17;
                v28 = v29 * 0.00153632;
                v18 = v37 * 0.00318811;
                v26 = v18;
                v38 = v32 - v28 - v18;
                v7 [1] = v38;
                v19 = v29 * 0.0079107098;
                v33 = v19 + v32;
                v7 [2] = v33;
                v7 [3] = 1.0;
                if(v17 >= 0.0) {
                    if(v17 > 1.0)
                        v17 = 1.0;
                }
                else {
                    v17 = 0.0;
                }
                *v7 = v17;
                if(v38 >= 0.0) {
                    if(v38 <= 1.0)
                        v20 = v38;
                    else
                        v20 = 1.0;
                }
                else {
                    v20 = 0.0;
                }
                v7 [1] = v20;
                if(v33 >= 0.0) {
                    if(v33 <= 1.0)
                        v21 = v33;
                    else
                        v21 = 1.0;
                }
                else {
                    v21 = 0.0;
                }
                v7 [2] = v21;
                v34 = v13 * 0.0045662099;
                v22 = v13 * 0.0045662099 + v15;
                v23 = v22;
                v7 [4] = v22;
                v39 = v34 - v28 - v26;
                v7 [5] = v39;
                v30 = v19;
                v35 = v34 + v30;
                v7 [6] = v35;
                v7 [7] = 1.0;
                if(v22 >= 0.0) {
                    if(v22 > 1.0)
                        v23 = 1.0;
                }
                else {
                    v23 = 0.0;
                }
                v7 [4] = v23;
                if(v39 >= 0.0) {
                    if(v39 <= 1.0)
                        v24 = v39;
                    else
                        v24 = 1.0;
                }
                else {
                    v24 = 0.0;
                }
                v7 [5] = v24;
                if(v35 >= 0.0) {
                    if(v35 <= 1.0)
                        v25 = v35;
                    else
                        v25 = 1.0;
                }
                else {
                    v25 = 0.0;
                }
                i += 2;
                v7 [6] = v25;
                v8 = v11 + 2;
                v7 += 8;
            }
        }
    }
    return 0;
}

//----- (00448D44) --------------------------------------------------------
int __thiscall sub_448D44(_DWORD* this, int a2, int a3, const void* a4) {
    int result; // eax

    result = sub_448A73((int) this, this [1037] + a2, this [1040] + a3, this [1056] != this [1044]);
    if(result >= 0) {
        result = 16 * this [1044];
        qmemcpy((void*) (this [1049] + 16 * (this [1036] - this [1050])), a4, result);
        this [1057] = 1;
    }
    return result;
}

//----- (00448DBC) --------------------------------------------------------
void __thiscall sub_448DBC(_DWORD* this, int a2, int a3, void* a4) {
    if(sub_448A73((int) this, this [1037] + a2, this [1040] + a3, 1) >= 0) {
        qmemcpy(a4, (const void*) (this [1049] + 16 * (this [1036] - this [1050])), 16 * this [1044]);
        if(this [4])
            sub_446BA4((int) this, (unsigned int) a4);
    }
}

//----- (00448E2B) --------------------------------------------------------
int __thiscall sub_448E2B(int this, int a2) {
    unsigned int v3; // eax
    unsigned int v4; // ecx
    _DWORD* v5; // ebx
    void* v6; // eax
    int v8; // [esp+24h] [ebp+8h]

    sub_44699F((float*) this, (float*) a2, 0, 1);
    *(_DWORD*) this = &off_46D174;
    *(_DWORD*) (this + 4248) = 0;
    if(*(_DWORD*) (a2 + 24) == 1) {
        *(_DWORD*) (this + 4252) = 0;
    }
    else {
        if(*(_DWORD*) (a2 + 24) != 2) {
            *(_DWORD*) (this + 4252) = 3;
            goto LABEL_7;
        }
        *(_DWORD*) (this + 4252) = 1;
    }
    *(_DWORD*) (this + 4248) = 1;
    LABEL_7:
    if(*(_DWORD*) (a2 + 28) == 1) {
        *(_DWORD*) (this + 4256) = 0;
        goto LABEL_12;
    }
    if(*(_DWORD*) (a2 + 28) == 2) {
        *(_DWORD*) (this + 4256) = 1;
        LABEL_12:
        *(_DWORD*) (this + 4248) = 1;
        goto LABEL_13;
    }
    *(_DWORD*) (this + 4256) = 3;
    LABEL_13:
    v3 = (*(_DWORD*) (this + 4152) + 3) & 0xFFFFFFFC;
    v4 = *(_DWORD*) (this + 4144) & 0xFFFFFFFC;
    *(_DWORD*) (this + 4220) = v3;
    *(_DWORD*) (this + 4244) = 1;
    *(_DWORD*) (this + 4212) = v4;
    *(_DWORD*) (this + 4216) = 0;
    *(_DWORD*) (this + 4228) = 0;
    *(_DWORD*) (this + 4224) = 0;
    *(_DWORD*) (this + 4232) = 0;
    *(_DWORD*) (this + 4260) = 0;
    *(_DWORD*) (this + 4236) = v3 - v4;
    *(_DWORD*) (this + 4240) = 0;
    v5 = (_DWORD*) (this + 4196);
    v8 = 4;
    do {
        v6 = operator new(16 * *(_DWORD*) (this + 4236));
        *v5 = v6;
        if(!v6)
            *(_DWORD*) (this + 4244) = 0;
        ++v5;
        --v8;
    }
    while(v8);
    return this;
}
// 46D174: using guessed type int (__thiscall *off_46D174)(void *Block, char);

//----- (00448F42) --------------------------------------------------------
int __thiscall sub_448F42(_DWORD* this) {
    int v2; // eax
    bool v3; // cf
    int* v4; // edx
    float* v5; // eax
    double v6; // st7
    float* v7; // eax
    double v8; // st7
    unsigned int v9; // edi
    int* v10; // ecx
    unsigned int v11; // edx
    int v12; // eax
    int v13; // eax
    int v15 [16]; // [esp+4h] [ebp-7Ch] BYREF
    int v16; // [esp+44h] [ebp-3Ch]
    float v17; // [esp+48h] [ebp-38h]
    int v18; // [esp+4Ch] [ebp-34h]
    int v19; // [esp+50h] [ebp-30h]
    float v20; // [esp+54h] [ebp-2Ch]
    int v21; // [esp+58h] [ebp-28h]
    float v22; // [esp+5Ch] [ebp-24h]
    int v23; // [esp+60h] [ebp-20h]
    int v24; // [esp+64h] [ebp-1Ch]
    float v25; // [esp+68h] [ebp-18h]
    int v26; // [esp+6Ch] [ebp-14h]
    int v27; // [esp+70h] [ebp-10h]
    int v28; // [esp+74h] [ebp-Ch]
    _DWORD* v29; // [esp+78h] [ebp-8h]
    unsigned int v30; // [esp+7Ch] [ebp-4h]

    if(this [1060] && this [1061]) {
        v2 = this [1];
        if(v2 == 844388420 || (v28 = 0, v2 == 877942852))
            v28 = 1;
        v3 = this [1053] < this [1055];
        v30 = this [1053];
        if(v3) {
            do {
                sub_44696C();
                v4 = v15;
                if(v28) {
                    v29 = this + 1049;
                    v26 = 4;
                    do {
                        v5 = (float*) (*v29 + 16 * (v30 - this [1053]));
                        v27 = 4;
                        do {
                            v25 = *v5 * v5 [3] * 255.0 + 0.5;
                            v24 = (int) v25;
                            v25 = v5 [1] * v5 [3] * 255.0 + 0.5;
                            v23 = (int) v25;
                            v25 = v5 [3] * v5 [2] * 255.0 + 0.5;
                            LODWORD(v22) = (int) v25;
                            v6 = v5 [3] * 255.0;
                            v20 = v22;
                            v25 = v6 + 0.5;
                            v21 = (int) v25;
                            v5 += 4;
                            *v4++ = LODWORD(v22) | ((v23 | ((v24 | (v21 << 8)) << 8)) << 8);
                            --v27;
                        }
                        while(v27);
                        ++v29;
                        --v26;
                    }
                    while(v26);
                }
                else {
                    v29 = this + 1049;
                    v27 = 4;
                    do {
                        v7 = (float*) (*v29 + 16 * (v30 - this [1053]));
                        v26 = 4;
                        do {
                            v20 = *v7 * 255.0 + 0.5;
                            v19 = (int) v20;
                            v20 = v7 [1] * 255.0 + 0.5;
                            v18 = (int) v20;
                            v20 = v7 [2] * 255.0 + 0.5;
                            LODWORD(v17) = (int) v20;
                            v8 = v7 [3] * 255.0;
                            v25 = v17;
                            v20 = v8 + 0.5;
                            v16 = (int) v20;
                            v7 += 4;
                            *v4++ = LODWORD(v17) | ((v18 | ((v19 | (v16 << 8)) << 8)) << 8);
                            --v26;
                        }
                        while(v26);
                        ++v29;
                        --v27;
                    }
                    while(v27);
                }
                sub_44698F();
                v9 = 0;
                if(this [1062]) {
                    v10 = v15;
                    do {
                        v11 = 0;
                        v12 = 4 * (v9 & this [1064]);
                        do
                            *v10++ = v15 [v12 + (v11++ & this [1063])];
                        while(v11 < 4);
                        ++v9;
                    }
                    while(v9 < 4);
                }
                v13 = this [1];
                switch(v13) {
                    case 827611204:
                        sub_44E12E(v15, this [6] + this [1043] * this [1057] + this [1042] * (this [1054] >> 2) + 8 * (v30 >> 2));
                        break;
                    case 844388420:
                    case 861165636:
                        sub_44EC5E(
                            v15,
                            (_WORD*) (this [6] + 16 * (v30 >> 2) + this [1043] * this [1057] + this [1042] * (this [1054] >> 2)));
                        break;
                    case 877942852:
                    case 894720068:
                        sub_44ECB7(v15, this [6] + 16 * (v30 >> 2) + this [1043] * this [1057] + this [1042] * (this [1054] >> 2));
                        break;
                }
                v30 += 4;
            }
            while(v30 < this [1055]);
        }
        this [1060] = 0;
    }
    return 0;
}

//----- (0044926F) --------------------------------------------------------
int __thiscall sub_44926F(_DWORD* this, unsigned int a2, unsigned int a3, int a4) {
    int result; // eax
    unsigned int v6; // edi
    bool v7; // cc
    int v8; // eax
    unsigned int v9; // ebx
    int v10; // eax
    char* v11; // edx
    _DWORD* v12; // edi
    unsigned int v13; // ecx
    float* v14; // ecx
    double v15; // st7
    double v16; // st7
    double v17; // st7
    char v18 [64]; // [esp+Ch] [ebp-54h] BYREF
    __int64 v19; // [esp+4Ch] [ebp-14h]
    int v20; // [esp+54h] [ebp-Ch]
    int v21; // [esp+58h] [ebp-8h]
    int v22; // [esp+5Ch] [ebp-4h]
    BOOL v23; // [esp+70h] [ebp+10h]

    if(!this [1061])
        return -2147024882;
    if(a2 < this [1054] || a2 >= this [1056]) {
        v6 = a3;
    }
    else {
        v6 = a3;
        if(a3 >= this [1057] && a3 < this [1058])
            return 0;
    }
    result = sub_448F42(this);
    if(result >= 0) {
        this [1056] = (a2 & 0xFFFFFFFC) + 4;
        this [1058] = v6 + 1;
        v7 = this [1065] <= (a2 & 0xFFFFFFFC);
        this [1054] = a2 & 0xFFFFFFFC;
        this [1057] = v6;
        if(v7) {
            this [1065] = a2 & 0xFFFFFFFC;
            if(!a4)
                return 0;
        }
        v8 = this [1];
        v23 = v8 == 844388420 || v8 == 877942852;
        v9 = this [1053];
        if(v9 >= this [1055])
            return 0;
        LABEL_19:
        v10 = this [1];
        switch(v10) {
            case 827611204:
                sub_44E197((unsigned __int16*) (this [6] + v6 * this [1043] + this [1042] * (a2 >> 2) + 8 * (v9 >> 2)), v18);
                break;
            case 844388420:
            case 861165636:
                sub_44EADE(this [6] + 16 * (v9 >> 2) + v6 * this [1043] + this [1042] * (a2 >> 2), v18);
                break;
            case 877942852:
            case 894720068:
                sub_44EB2C((unsigned __int16*) (this [6] + 16 * (v9 >> 2) + v6 * this [1043] + this [1042] * (a2 >> 2)), v18);
                break;
        }
        v11 = v18;
        v12 = this + 1049;
        v21 = 4;
        while(1) {
            v13 = v9 - this [1053];
            v22 = 4;
            v14 = (float*) (*v12 + 16 * v13);
            do {
                v20 = (unsigned __int8) v11 [3];
                HIDWORD(v19) = 0;
                v14 [3] = (double) v20 * 0.0039215689;
                v20 = (unsigned __int8) v11 [2];
                *v14 = (double) v20 * 0.0039215689;
                v20 = (unsigned __int8) v11 [1];
                v14 [1] = (double) v20 * 0.0039215689;
                LODWORD(v19) = (unsigned __int8) *(_DWORD*) v11;
                v14 [2] = (double) v19 * 0.0039215689;
                if(!v23)
                    goto LABEL_43;
                if(0.0 == v14 [3]) {
                    *v14 = 0.0;
                    v14 [1] = 0.0;
                    v15 = 0.0;
                }
                else {
                    if(v14 [3] >= 1.0)
                        goto LABEL_43;
                    if(*v14 >= (double) v14 [3])
                        v16 = 1.0;
                    else
                        v16 = *v14 / v14 [3];
                    *v14 = v16;
                    if(v14 [1] >= (double) v14 [3])
                        v17 = 1.0;
                    else
                        v17 = v14 [1] / v14 [3];
                    v14 [1] = v17;
                    if(v14 [2] >= (double) v14 [3])
                        v15 = 1.0;
                    else
                        v15 = v14 [2] / v14 [3];
                }
                v14 [2] = v15;
                LABEL_43:
                v14 += 4;
                v11 += 4;
                --v22;
            }
            while(v22);
            ++v12;
            if(!--v21) {
                v9 += 4;
                if(v9 < this [1055]) {
                    v6 = a3;
                    goto LABEL_19;
                }
                return 0;
            }
        }
    }
    return result;
}

//----- (00449516) --------------------------------------------------------
int __thiscall sub_449516(_DWORD* this, int a2, int a3, const void* a4) {
    unsigned int v5; // edi
    int result; // eax

    v5 = this [1037] + a2;
    result = sub_44926F(this, v5, this [1040] + a3, this [1059] != this [1044]);
    if(result >= 0) {
        result = 16 * this [1044];
        qmemcpy((void*) (this [v5 - this [1054] + 1049] + 16 * (this [1036] - this [1053])), a4, result);
        this [1060] = 1;
    }
    return result;
}

//----- (0044959C) --------------------------------------------------------
void __thiscall sub_44959C(_DWORD* this, int a2, int a3, void* a4) {
    unsigned int v5; // edi

    v5 = this [1037] + a2;
    if(sub_44926F(this, v5, this [1040] + a3, 1) >= 0) {
        qmemcpy(a4, (const void*) (this [v5 - this [1054] + 1049] + 16 * (this [1036] - this [1053])), 16 * this [1044]);
        if(this [4])
            sub_446BA4((int) this, (unsigned int) a4);
    }
}

//----- (00449610) --------------------------------------------------------
_DWORD* __thiscall sub_449610(_DWORD* Block, char a2) {
    sub_44962C(Block);
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}

//----- (00449631) --------------------------------------------------------
void __thiscall sub_449631(int this) {
    *(_DWORD*) this = &off_46D134;
    sub_448880((_DWORD*) this);
    if(*(_DWORD*) (this + 4196))
        j__free(*(void**) (this + 4196));
    sub_4465E2((_DWORD*) this);
}
// 46D134: using guessed type int (__thiscall *off_46D134)(void *Block, char);

//----- (00449676) --------------------------------------------------------
void __thiscall sub_449676(void** this) {
    void** v2; // edi
    int v3; // ebx

    *this = &off_46D174;
    sub_448F42(this);
    v2 = this + 1049;
    v3 = 4;
    do {
        if(*v2)
            j__free(*v2);
        ++v2;
        --v3;
    }
    while(v3);
    sub_4465E2(this);
}
// 46D174: using guessed type int (__thiscall *off_46D174)(void *Block, char);

//----- (004496CA) --------------------------------------------------------
float* __cdecl sub_4496CA(float* Block) {
    int v1; // eax
    float* v2; // eax
    float* v3; // esi
    float* v4; // eax
    float* v5; // eax
    float* v6; // eax
    float* v7; // eax
    float* v8; // eax
    float* v9; // eax
    float* v10; // eax
    float* v11; // eax
    float* v12; // eax
    float* v13; // eax
    float* v14; // eax
    int v15; // eax
    int v16; // eax
    int v17; // eax
    int v18; // eax
    float* v19; // eax
    float* v20; // eax
    float* v21; // eax
    float* v22; // eax
    float* v23; // eax
    float* v24; // eax
    int v25; // eax
    int v26; // eax
    int v27; // eax
    float* v28; // eax
    float* v29; // eax
    float* v30; // eax
    float* v31; // eax
    float* v32; // eax
    float* v33; // eax

    v1 = *((_DWORD*) Block + 1);
    if(v1 > 827611204) {
        switch(v1) {
            case 844388420:
                v32 = (float*)operator new(0x10A8u);
                v3 = v32;
                if(!v32)
                    return 0;
                goto LABEL_80;
            case 844715353:
                v33 = (float*)operator new(0x1094u);
                v3 = v33;
                if(!v33)
                    return 0;
                break;
            case 861165636:
                v32 = (float*)operator new(0x10A8u);
                v3 = v32;
                if(!v32)
                    return 0;
                goto LABEL_80;
            case 877942852:
                v32 = (float*)operator new(0x10A8u);
                v3 = v32;
                if(!v32)
                    return 0;
                goto LABEL_80;
            case 894720068:
                v32 = (float*)operator new(0x10A8u);
                v3 = v32;
                if(!v32)
                    return 0;
                goto LABEL_80;
            case 1498831189:
                v33 = (float*)operator new(0x1094u);
                v3 = v33;
                if(!v33)
                    return 0;
                break;
            default:
                return 0;
        }
        sub_4487AF((int) v33, (int) Block);
        *(_DWORD*) v3 = &off_46D288;
        return v3;
    }
    if(v1 == 827611204) {
        v32 = (float*)operator new(0x10A8u);
        v3 = v32;
        if(!v32)
            return 0;
        LABEL_80:
        sub_448E2B((int) v32, (int) Block);
        *(_DWORD*) v3 = &off_46D294;
        return v3;
    }
    if(v1 > 40) {
        if(v1 > 61) {
            v25 = v1 - 62;
            if(v25) {
                v26 = v25 - 1;
                if(v26) {
                    v27 = v26 - 1;
                    if(v27) {
                        if(v27 == 1) {
                            v28 = (float*)operator new(0x1064u);
                            v3 = v28;
                            if(v28) {
                                sub_44699F(v28, Block, 0x20u, 3);
                                *(_DWORD*) v3 = &off_46D27C;
                                return v3;
                            }
                        }
                    }
                    else {
                        v29 = (float*)operator new(0x1064u);
                        v3 = v29;
                        if(v29) {
                            sub_44699F(v29, Block, 0x20u, 3);
                            *(_DWORD*) v3 = &off_46D270;
                            return v3;
                        }
                    }
                }
                else {
                    v30 = (float*)operator new(0x1064u);
                    v3 = v30;
                    if(v30) {
                        sub_44699F(v30, Block, 0x20u, 3);
                        *(_DWORD*) v3 = &off_46D264;
                        return v3;
                    }
                }
            }
            else {
                v31 = (float*)operator new(0x1064u);
                v3 = v31;
                if(v31) {
                    sub_44699F(v31, Block, 0x20u, 3);
                    *(_DWORD*) v3 = &off_46D258;
                    return v3;
                }
            }
        }
        else if(v1 == 61) {
            v24 = (float*)operator new(0x1064u);
            v3 = v24;
            if(v24) {
                sub_44699F(v24, Block, 0x10u, 3);
                *(_DWORD*) v3 = &off_46D24C;
                return v3;
            }
        }
        else {
            v15 = v1 - 41;
            if(v15) {
                v16 = v15 - 9;
                if(v16) {
                    v17 = v16 - 1;
                    if(v17) {
                        v18 = v17 - 1;
                        if(v18) {
                            if(v18 == 8) {
                                v19 = (float*)operator new(0x1064u);
                                v3 = v19;
                                if(v19) {
                                    sub_44699F(v19, Block, 0x10u, 3);
                                    *(_DWORD*) v3 = &off_46D240;
                                    return v3;
                                }
                            }
                        }
                        else {
                            v20 = (float*)operator new(0x1064u);
                            v3 = v20;
                            if(v20) {
                                sub_44699F(v20, Block, 8u, 1);
                                *(_DWORD*) v3 = &off_46D234;
                                return v3;
                            }
                        }
                    }
                    else {
                        v21 = (float*)operator new(0x1064u);
                        v3 = v21;
                        if(v21) {
                            sub_44699F(v21, Block, 0x10u, 1);
                            *(_DWORD*) v3 = &off_46D228;
                            return v3;
                        }
                    }
                }
                else {
                    v22 = (float*)operator new(0x1064u);
                    v3 = v22;
                    if(v22) {
                        sub_44699F(v22, Block, 8u, 1);
                        *(_DWORD*) v3 = &off_46D21C;
                        return v3;
                    }
                }
            }
            else {
                v23 = (float*)operator new(0x1064u);
                v3 = v23;
                if(v23) {
                    sub_44699F(v23, Block, 8u, 2);
                    *(_DWORD*) v3 = &off_46D210;
                    return v3;
                }
            }
        }
    }
    else {
        if(v1 != 40) {
            switch(v1) {
                case 20:
                    v2 = (float*)operator new(0x1064u);
                    v3 = v2;
                    if(!v2)
                        return 0;
                    sub_44699F(v2, Block, 0x18u, 1);
                    *(_DWORD*) v3 = &off_46D180;
                    break;
                case 21:
                    v4 = (float*)operator new(0x1064u);
                    v3 = v4;
                    if(!v4)
                        return 0;
                    sub_44699F(v4, Block, 0x20u, 1);
                    *(_DWORD*) v3 = &off_46D18C;
                    break;
                case 22:
                    v5 = (float*)operator new(0x1064u);
                    v3 = v5;
                    if(!v5)
                        return 0;
                    sub_44699F(v5, Block, 0x20u, 1);
                    *(_DWORD*) v3 = &off_46D198;
                    break;
                case 23:
                    v6 = (float*)operator new(0x1064u);
                    v3 = v6;
                    if(!v6)
                        return 0;
                    sub_44699F(v6, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1A4;
                    break;
                case 24:
                    v7 = (float*)operator new(0x1064u);
                    v3 = v7;
                    if(!v7)
                        return 0;
                    sub_44699F(v7, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1B0;
                    break;
                case 25:
                    v8 = (float*)operator new(0x1064u);
                    v3 = v8;
                    if(!v8)
                        return 0;
                    sub_44699F(v8, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1BC;
                    break;
                case 26:
                    v9 = (float*)operator new(0x1064u);
                    v3 = v9;
                    if(!v9)
                        return 0;
                    sub_44699F(v9, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1C8;
                    break;
                case 27:
                    v10 = (float*)operator new(0x1064u);
                    v3 = v10;
                    if(!v10)
                        return 0;
                    sub_44699F(v10, Block, 8u, 1);
                    *(_DWORD*) v3 = &off_46D1D4;
                    break;
                case 28:
                    v11 = (float*)operator new(0x1064u);
                    v3 = v11;
                    if(!v11)
                        return 0;
                    sub_44699F(v11, Block, 8u, 1);
                    *(_DWORD*) v3 = &off_46D1E0;
                    break;
                case 29:
                    v12 = (float*)operator new(0x1064u);
                    v3 = v12;
                    if(!v12)
                        return 0;
                    sub_44699F(v12, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1EC;
                    break;
                case 30:
                    v13 = (float*)operator new(0x1064u);
                    v3 = v13;
                    if(!v13)
                        return 0;
                    sub_44699F(v13, Block, 0x10u, 1);
                    *(_DWORD*) v3 = &off_46D1F8;
                    break;
                default:
                    return 0;
            }
            return v3;
        }
        v14 = (float*)operator new(0x1064u);
        v3 = v14;
        if(v14) {
            sub_44699F(v14, Block, 0x10u, 2);
            *(_DWORD*) v3 = &off_46D204;
            return v3;
        }
    }
    return 0;
}
// 46D180: using guessed type int (__thiscall *off_46D180)(void *Block, char);
// 46D18C: using guessed type int (__thiscall *off_46D18C)(void *Block, char);
// 46D198: using guessed type int (__thiscall *off_46D198)(void *Block, char);
// 46D1A4: using guessed type int (__thiscall *off_46D1A4)(void *Block, char);
// 46D1B0: using guessed type int (__thiscall *off_46D1B0)(void *Block, char);
// 46D1BC: using guessed type int (__thiscall *off_46D1BC)(void *Block, char);
// 46D1C8: using guessed type int (__thiscall *off_46D1C8)(void *Block, char);
// 46D1D4: using guessed type int (__thiscall *off_46D1D4)(void *Block, char);
// 46D1E0: using guessed type int (__thiscall *off_46D1E0)(void *Block, char);
// 46D1EC: using guessed type int (__thiscall *off_46D1EC)(void *Block, char);
// 46D1F8: using guessed type int (__thiscall *off_46D1F8)(void *Block, char);
// 46D204: using guessed type int (__thiscall *off_46D204)(void *Block, char);
// 46D210: using guessed type int (__thiscall *off_46D210)(void *Block, char);
// 46D21C: using guessed type int (__thiscall *off_46D21C)(void *Block, char);
// 46D228: using guessed type int (__thiscall *off_46D228)(void *Block, char);
// 46D234: using guessed type int (__thiscall *off_46D234)(void *Block, char);
// 46D240: using guessed type int (__thiscall *off_46D240)(void *Block, char);
// 46D24C: using guessed type int (__thiscall *off_46D24C)(void *Block, char);
// 46D258: using guessed type int (__thiscall *off_46D258)(void *Block, char);
// 46D264: using guessed type int (__thiscall *off_46D264)(void *Block, char);
// 46D270: using guessed type int (__thiscall *off_46D270)(void *Block, char);
// 46D27C: using guessed type int (__thiscall *off_46D27C)(void *Block, char);
// 46D288: using guessed type int (__thiscall *off_46D288)(void *Block, char);
// 46D294: using guessed type int (__thiscall *off_46D294)(void *Block, char);

//----- (00449CDA) --------------------------------------------------------
void* __thiscall sub_449CDA(void* Block, char a2) {
    sub_449631((int) Block);
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}

//----- (00449CF6) --------------------------------------------------------
void** __thiscall sub_449CF6(void** Block, char a2) {
    sub_449676(Block);
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}

//----- (00449D12) --------------------------------------------------------
void* __thiscall sub_449D12(void* Block, char a2) {
    sub_449D2E();
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}
// 449D2E: using guessed type int sub_449D2E(void);

//----- (00449D33) --------------------------------------------------------
void* __thiscall sub_449D33(void* Block, char a2) {
    sub_449D4F();
    if((a2 & 1) != 0)
        j__free(Block);
    return Block;
}
// 449D4F: using guessed type int sub_449D4F(void);

//----- (00449D54) --------------------------------------------------------
unsigned int __cdecl sub_449D54(_DWORD* a1, int a2, int a3) {
    int v3; // edx
    int v4; // ecx
    _DWORD* v5; // eax
    unsigned int result; // eax

    a1 [1] = 0;
    if(a2 != 61) {
        *(_DWORD*) (*a1 + 20) = 10;
        *(_DWORD*) (*a1 + 24) = 61;
        *(_DWORD*) (*a1 + 28) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if(a3 != 424) {
        *(_DWORD*) (*a1 + 20) = 19;
        *(_DWORD*) (*a1 + 24) = 424;
        *(_DWORD*) (*a1 + 28) = a3;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v3 = *a1;
    memset(a1, 0, 0x1A8u);
    *a1 = v3;
    *((_BYTE*) a1 + 12) = 1;
    sub_44FD78(a1);
    a1 [2] = 0;
    a1 [5] = 0;
    a1 [36] = 0;
    a1 [37] = 0;
    a1 [38] = 0;
    a1 [39] = 0;
    v4 = 4;
    v5 = a1 + 44;
    do {
        *(v5 - 4) = 0;
        *v5++ = 0;
        --v4;
    }
    while(v4);
    sub_44B9F1((int) a1);
    result = sub_44F3C2((int) a1);
    if(byte_479474 == 2) {
        result = sub_44EEB9();
        byte_479474 = result;
    }
    a1 [4] = 200;
    return result;
}
// 479474: using guessed type char byte_479474;

//----- (00449E19) --------------------------------------------------------
int __usercall sub_449E19(int a1) {
    int* v1; // eax
    int v2; // ecx
    int v3; // edx
    int v4; // edi
    _DWORD* v5; // eax
    int result; // eax

    switch(*(_DWORD*) (a1 + 32)) {
        case 1:
            *(_DWORD*) (a1 + 36) = 1;
            *(_DWORD*) (a1 + 40) = 1;
            break;
        case 3:
            if(*(_BYTE*) (a1 + 256))
                goto LABEL_17;
            if(!*(_BYTE*) (a1 + 262)) {
                v1 = *(int**) (a1 + 196);
                v2 = *v1;
                v3 = v1 [21];
                v4 = v1 [42];
                if(*v1 == 1) {
                    if(v3 == 2 && v4 == 3) {
                        *(_DWORD*) (a1 + 36) = 3;
                        goto LABEL_28;
                    }
                }
                else if(v2 == 82 && v3 == 71 && v4 == 66) {
                    *(_DWORD*) (a1 + 36) = 2;
                    goto LABEL_28;
                }
                v5 = (_DWORD*) (*(_DWORD*) a1 + 24);
                *v5 = v2;
                v5 [1] = v3;
                v5 [2] = v4;
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 107;
                (*(void(__cdecl**)(int, int))(*(_DWORD*) a1 + 4))(a1, 1);
                *(_DWORD*) (a1 + 36) = 3;
                goto LABEL_28;
            }
            if(!*(_BYTE*) (a1 + 263)) {
                *(_DWORD*) (a1 + 36) = 2;
                goto LABEL_28;
            }
            if(*(_BYTE*) (a1 + 263) == 1) {
                LABEL_17:
                *(_DWORD*) (a1 + 36) = 3;
            }
            else {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 110;
                *(_DWORD*) (*(_DWORD*) a1 + 24) = *(unsigned __int8*) (a1 + 263);
                (*(void(__cdecl**)(int, int))(*(_DWORD*) a1 + 4))(a1, -1);
                *(_DWORD*) (a1 + 36) = 3;
            }
            LABEL_28:
            *(_DWORD*) (a1 + 40) = 2;
            break;
        case 4:
            if(*(_BYTE*) (a1 + 262) && *(_BYTE*) (a1 + 263)) {
                if(*(_BYTE*) (a1 + 263) != 2) {
                    *(_DWORD*) (*(_DWORD*) a1 + 20) = 110;
                    *(_DWORD*) (*(_DWORD*) a1 + 24) = *(unsigned __int8*) (a1 + 263);
                    (*(void(__cdecl**)(int, int))(*(_DWORD*) a1 + 4))(a1, -1);
                }
                *(_DWORD*) (a1 + 36) = 5;
            }
            else {
                *(_DWORD*) (a1 + 36) = 4;
            }
            *(_DWORD*) (a1 + 40) = 4;
            break;
        default:
            *(_DWORD*) (a1 + 36) = 0;
            *(_DWORD*) (a1 + 40) = 0;
            break;
    }
    *(_BYTE*) (a1 + 64) = 0;
    *(_BYTE*) (a1 + 65) = 0;
    *(double*) (a1 + 56) = 1.0;
    *(_DWORD*) (a1 + 68) = 0;
    *(_BYTE*) (a1 + 74) = 0;
    *(_DWORD*) (a1 + 116) = 0;
    *(_BYTE*) (a1 + 88) = 0;
    *(_BYTE*) (a1 + 89) = 0;
    *(_BYTE*) (a1 + 90) = 0;
    result = 1;
    *(_DWORD*) (a1 + 44) = 1;
    *(_DWORD*) (a1 + 48) = 1;
    *(_BYTE*) (a1 + 72) = 1;
    *(_BYTE*) (a1 + 73) = 1;
    *(_DWORD*) (a1 + 76) = 2;
    *(_BYTE*) (a1 + 80) = 1;
    *(_DWORD*) (a1 + 84) = 256;
    return result;
}

//----- (00449F98) --------------------------------------------------------
int __cdecl sub_449F98(_DWORD* a1) {
    int v1; // eax
    int v2; // edi

    v1 = a1 [4];
    v2 = 0;
    switch(v1) {
        case 200:
            (*(void(__cdecl**)(_DWORD*))(a1 [99] + 4))(a1);
            (*(void(__cdecl**)(_DWORD*))(a1 [5] + 8))(a1);
            a1 [4] = 201;
            break;
        case 201:
            break;
        case 202:
            return 1;
        default:
            if(v1 > 202 && (v1 <= 208 || v1 == 210))
                return (*(int(__cdecl**)(_DWORD*))a1 [99])(a1);
            *(_DWORD*) (*a1 + 20) = 18;
            *(_DWORD*) (*a1 + 24) = a1 [4];
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            return v2;
    }
    v2 = (*(int(__cdecl**)(_DWORD*))a1 [99])(a1);
    if(v2 == 1) {
        sub_449E19((int) a1);
        a1 [4] = 202;
    }
    return v2;
}

//----- (0044A032) --------------------------------------------------------
char __cdecl sub_44A032(int a1) {
    int v1; // eax
    int v2; // eax

    v1 = *(_DWORD*) (a1 + 16);
    if((v1 == 205 || v1 == 206) && !*(_BYTE*) (a1 + 64)) {
        if(*(_DWORD*) (a1 + 120) < *(_DWORD*) (a1 + 96)) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 66;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        (*(void(__cdecl**)(int))(*(_DWORD*) (a1 + 380) + 4))(a1);
        *(_DWORD*) (a1 + 16) = 210;
    }
    else if(v1 == 207) {
        *(_DWORD*) (a1 + 16) = 210;
    }
    else if(v1 != 210) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 18;
        *(_DWORD*) (*(_DWORD*) a1 + 24) = *(_DWORD*) (a1 + 16);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    do {
        v2 = *(_DWORD*) (a1 + 396);
        if(*(_BYTE*) (v2 + 17)) {
            (*(void(__cdecl**)(int))(*(_DWORD*) (a1 + 20) + 24))(a1);
            sub_44FE2C(a1);
            return 1;
        }
    }
    while((*(int(__cdecl**)(int))v2)(a1));
    return 0;
}

//----- (0044A0D3) --------------------------------------------------------
int __cdecl sub_44A0D3(_DWORD* a1, char a2) {
    int v2; // eax
    int result; // eax

    v2 = a1 [4];
    if(v2 != 200 && v2 != 201) {
        *(_DWORD*) (*a1 + 20) = 18;
        *(_DWORD*) (*a1 + 24) = a1 [4];
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_449F98(a1);
    if(result == 1)
        return 1;
    if(result == 2) {
        if(a2) {
            *(_DWORD*) (*a1 + 20) = 50;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        sub_44FE2C((int) a1);
        return 2;
    }
    return result;
}

//----- (0044A136) --------------------------------------------------------
char __usercall sub_44A136(int a1) {
    unsigned int* v1; // edi
    unsigned int v2; // eax
    int v3; // ecx
    unsigned int v4; // ebp
    int v5; // eax

    if(*(_DWORD*) (a1 + 16) != 204) {
        (**(void(__cdecl***)(int))(a1 + 380))(a1);
        *(_DWORD*) (a1 + 120) = 0;
        *(_DWORD*) (a1 + 16) = 204;
    }
    if(*(_BYTE*) (*(_DWORD*) (a1 + 380) + 8)) {
        v1 = (unsigned int*) (a1 + 120);
        while(2) {
            v2 = *v1;
            while(v2 < *(_DWORD*) (a1 + 96)) {
                v3 = *(_DWORD*) (a1 + 8);
                if(v3) {
                    *(_DWORD*) (v3 + 4) = v2;
                    *(_DWORD*) (*(_DWORD*) (a1 + 8) + 8) = *(_DWORD*) (a1 + 96);
                    (**(void(__cdecl***)(int))(a1 + 8))(a1);
                }
                v4 = *v1;
                (*(void(__cdecl**)(int, _DWORD, int, _DWORD))(*(_DWORD*) (a1 + 384) + 4))(a1, 0, a1 + 120, 0);
                v2 = *v1;
                if(*v1 == v4)
                    return 0;
            }
            (*(void(__cdecl**)(int))(*(_DWORD*) (a1 + 380) + 4))(a1);
            (**(void(__cdecl***)(int))(a1 + 380))(a1);
            v5 = *(_DWORD*) (a1 + 380);
            *v1 = 0;
            if(*(_BYTE*) (v5 + 8))
                continue;
            break;
        }
    }
    *(_DWORD*) (a1 + 16) = (*(_BYTE*) (a1 + 65) != 0) + 205;
    return 1;
}

//----- (0044A1DA) --------------------------------------------------------
_DWORD* __cdecl sub_44A1DA(_DWORD* a1, int a2, int a3) {
    _DWORD* v3; // esi
    unsigned int v4; // ecx
    _DWORD* result; // eax
    int v6; // eax
    int v7; // eax

    v3 = a1;
    if(a1 [4] != 205) {
        *(_DWORD*) (*a1 + 20) = 18;
        *(_DWORD*) (*v3 + 24) = v3 [4];
        (*(void(__cdecl**)(_DWORD*)) * v3)(v3);
    }
    v4 = v3 [30];
    if(v4 < v3 [24]) {
        v6 = v3 [2];
        if(v6) {
            *(_DWORD*) (v6 + 4) = v4;
            *(_DWORD*) (v3 [2] + 8) = v3 [24];
            (*(void(__cdecl**)(_DWORD*))v3 [2])(v3);
        }
        v7 = v3 [96];
        a1 = 0;
        (*(void(__cdecl**)(_DWORD*, int, _DWORD**, int))(v7 + 4))(v3, a2, &a1, a3);
        result = a1;
        v3 [30] += a1;
    }
    else {
        *(_DWORD*) (*v3 + 20) = 119;
        (*(void(__cdecl**)(_DWORD*, int))(*v3 + 4))(v3, -1);
        return 0;
    }
    return result;
}

//----- (0044A25E) --------------------------------------------------------
char __cdecl sub_44A25E(int a1) {
    int v2; // eax
    void(__cdecl * *v3)(int); // eax
    int v4; // eax
    int v5; // ecx
    int v6; // eax
    int v7; // ecx

    if(*(_DWORD*) (a1 + 16) == 202) {
        sub_45046B(a1);
        if(*(_BYTE*) (a1 + 64)) {
            *(_DWORD*) (a1 + 16) = 207;
            return 1;
        }
        *(_DWORD*) (a1 + 16) = 203;
    }
    v2 = *(_DWORD*) (a1 + 16);
    if(v2 != 203) {
        if(v2 != 204) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 18;
            *(_DWORD*) (*(_DWORD*) a1 + 24) = *(_DWORD*) (a1 + 16);
            (**(void(__cdecl***)(int))a1)(a1);
        }
        return sub_44A136(a1);
    }
    if(!*(_BYTE*) (*(_DWORD*) (a1 + 396) + 16)) {
        LABEL_17:
        *(_DWORD*) (a1 + 132) = *(_DWORD*) (a1 + 124);
        return sub_44A136(a1);
    }
    while(1) {
        v3 = *(void(__cdecl***)(int))(a1 + 8);
        if(v3)
            (*v3)(a1);
        v4 = (**(int(__cdecl***)(int))(a1 + 396))(a1);
        if(!v4)
            return 0;
        if(v4 == 2)
            goto LABEL_17;
        v5 = *(_DWORD*) (a1 + 8);
        if(v5 && (v4 == 3 || v4 == 1)) {
            ++* (_DWORD*) (v5 + 4);
            v6 = *(_DWORD*) (a1 + 8);
            v7 = *(_DWORD*) (v6 + 8);
            if(*(_DWORD*) (v6 + 4) >= v7)
                *(_DWORD*) (v6 + 8) = v7 + *(_DWORD*) (a1 + 280);
        }
    }
}

//----- (0044A31F) --------------------------------------------------------
char __usercall sub_44A31F(int a1) {
    _BYTE* v1; // eax
    int v2; // ecx
    int v3; // eax

    *(_DWORD*) (*(_DWORD*) a1 + 20) = 101;
    (*(void(__cdecl**)(int, int))(*(_DWORD*) a1 + 4))(a1, 1);
    if(*(_BYTE*) (*(_DWORD*) (a1 + 400) + 80)) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 60;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v1 = (_BYTE*) (a1 + 218);
    v2 = 16;
    do {
        *(v1 - 16) = 0;
        *v1 = 1;
        v1 [16] = 5;
        ++v1;
        --v2;
    }
    while(v2);
    v3 = *(_DWORD*) (a1 + 400);
    *(_DWORD*) (a1 + 252) = 0;
    *(_DWORD*) (a1 + 36) = 0;
    *(_BYTE*) (a1 + 264) = 0;
    *(_BYTE*) (a1 + 256) = 0;
    *(_BYTE*) (a1 + 257) = 0;
    *(_BYTE*) (a1 + 262) = 0;
    *(_BYTE*) (a1 + 263) = 0;
    *(_WORD*) (a1 + 258) = 1;
    *(_WORD*) (a1 + 260) = 1;
    *(_BYTE*) (v3 + 80) = 1;
    return 1;
}

//----- (0044A3AD) --------------------------------------------------------
char __usercall sub_44A3AD(char a1, int a2, char a3) {
    unsigned __int8** v3; // ebx
    unsigned __int8* v4; // eax
    unsigned __int8* v5; // edi
    unsigned __int16 v6; // ax
    unsigned __int8* v7; // edi
    unsigned __int8* v8; // edi
    int v9; // eax
    unsigned __int8* v10; // edi
    unsigned __int16 v11; // ax
    unsigned __int8* v12; // edi
    unsigned __int8* v13; // edi
    unsigned __int16 v14; // ax
    unsigned __int8* v15; // edi
    unsigned __int8* v16; // edi
    int v17; // ecx
    _DWORD* v18; // eax
    unsigned __int8* v19; // edi
    _DWORD* v20; // eax
    int v22; // ecx
    unsigned __int8* v23; // edi
    int v24; // ecx
    unsigned __int8* v25; // edi
    int v26; // edx
    _DWORD* v27; // ecx
    int v28; // [esp+8h] [ebp-8h]
    unsigned __int8* v29; // [esp+Ch] [ebp-4h]
    unsigned __int8* v30; // [esp+Ch] [ebp-4h]
    unsigned __int8* v31; // [esp+Ch] [ebp-4h]
    unsigned __int8* v32; // [esp+Ch] [ebp-4h]
    unsigned __int8* v33; // [esp+Ch] [ebp-4h]
    unsigned __int8* v34; // [esp+Ch] [ebp-4h]
    unsigned __int8* v35; // [esp+Ch] [ebp-4h]
    unsigned __int8* v36; // [esp+Ch] [ebp-4h]
    unsigned __int8* v37; // [esp+Ch] [ebp-4h]
    unsigned __int8* v38; // [esp+Ch] [ebp-4h]
    unsigned __int8* v39; // [esp+Ch] [ebp-4h]
    int v40; // [esp+18h] [ebp+8h]
    int v41; // [esp+18h] [ebp+8h]
    int v42; // [esp+18h] [ebp+8h]
    _DWORD* v43; // [esp+18h] [ebp+8h]

    v3 = *(unsigned __int8***) (a2 + 20);
    v4 = v3 [1];
    v5 = *v3;
    *(_BYTE*) (a2 + 200) = a1;
    v29 = v4;
    *(_BYTE*) (a2 + 201) = a3;
    if(!v4) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v5 = *v3;
        v29 = v3 [1];
    }
    v30 = v29 - 1;
    LOBYTE(v6) = 0;
    HIBYTE(v6) = *v5;
    v7 = v5 + 1;
    v40 = v6;
    if(!v30) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v7 = *v3;
        v30 = v3 [1];
    }
    v31 = v30 - 1;
    v41 = *v7 + v40;
    v8 = v7 + 1;
    if(!v31) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v8 = *v3;
        v31 = v3 [1];
    }
    v9 = *v8;
    v32 = v31 - 1;
    v10 = v8 + 1;
    *(_DWORD*) (a2 + 192) = v9;
    if(!v32) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v10 = *v3;
        v32 = v3 [1];
    }
    v33 = v32 - 1;
    LOBYTE(v11) = 0;
    HIBYTE(v11) = *v10;
    v12 = v10 + 1;
    *(_DWORD*) (a2 + 28) = v11;
    if(!v33) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v12 = *v3;
        v33 = v3 [1];
    }
    v34 = v33 - 1;
    *(_DWORD*) (a2 + 28) += *v12;
    v13 = v12 + 1;
    if(!v34) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v13 = *v3;
        v34 = v3 [1];
    }
    v35 = v34 - 1;
    LOBYTE(v14) = 0;
    HIBYTE(v14) = *v13;
    v15 = v13 + 1;
    *(_DWORD*) (a2 + 24) = v14;
    if(!v35) {
        if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
            return 0;
        v15 = *v3;
        v35 = v3 [1];
    }
    v36 = v35 - 1;
    *(_DWORD*) (a2 + 24) += *v15;
    v16 = v15 + 1;
    if(!v36) {
        if(((unsigned __int8(__cdecl*)(int))v3 [3])(a2)) {
            v16 = *v3;
            v36 = v3 [1];
            goto LABEL_25;
        }
        return 0;
    }
    LABEL_25:
    v17 = *(_DWORD*) (a2 + 376);
    v37 = v36 - 1;
    v42 = v41 - 8;
    *(_DWORD*) (a2 + 32) = *v16;
    v18 = (_DWORD*) (*(_DWORD*) a2 + 24);
    *v18 = v17;
    v18 [1] = *(_DWORD*) (a2 + 24);
    v18 [2] = *(_DWORD*) (a2 + 28);
    v18 [3] = *(_DWORD*) (a2 + 32);
    *(_DWORD*) (*(_DWORD*) a2 + 20) = 99;
    v19 = v16 + 1;
    (*(void(__cdecl**)(int, int))(*(_DWORD*) a2 + 4))(a2, 1);
    if(*(_BYTE*) (*(_DWORD*) (a2 + 400) + 81)) {
        *(_DWORD*) (*(_DWORD*) a2 + 20) = 57;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if(!*(_DWORD*) (a2 + 28) || !*(_DWORD*) (a2 + 24) || *(int*) (a2 + 32) <= 0) {
        *(_DWORD*) (*(_DWORD*) a2 + 20) = 31;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if(v42 != 3 * *(_DWORD*) (a2 + 32)) {
        *(_DWORD*) (*(_DWORD*) a2 + 20) = 9;
        (**(void(__cdecl***)(int))a2)(a2);
    }
    if(!*(_DWORD*) (a2 + 196))
        *(_DWORD*) (a2 + 196) = (**(int(__cdecl***)(int, int, int))(a2 + 4))(a2, 1, 84 * *(_DWORD*) (a2 + 32));
    v28 = 0;
    v20 = *(_DWORD**) (a2 + 196);
    v43 = v20;
    if(*(int*) (a2 + 32) > 0) {
        while(1) {
            v20 [1] = v28;
            if(!v37) {
                if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
                    return 0;
                v19 = *v3;
                v37 = v3 [1];
                v20 = v43;
            }
            v22 = *v19;
            v38 = v37 - 1;
            v23 = v19 + 1;
            *v20 = v22;
            if(!v38) {
                if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
                    return 0;
                v23 = *v3;
                v38 = v3 [1];
                v20 = v43;
            }
            v24 = *v23;
            v39 = v38 - 1;
            v25 = v23 + 1;
            v20 [2] = (v24 >> 4) & 0xF;
            v20 [3] = v24 & 0xF;
            if(!v39) {
                if(!((unsigned __int8(__cdecl*)(int))v3 [3])(a2))
                    return 0;
                v25 = *v3;
                v39 = v3 [1];
                v20 = v43;
            }
            v26 = *v20;
            v37 = v39 - 1;
            v20 [4] = *v25;
            v27 = (_DWORD*) (*(_DWORD*) a2 + 24);
            *v27 = v26;
            v27 [1] = v20 [2];
            v27 [2] = v20 [3];
            v27 [3] = v20 [4];
            *(_DWORD*) (*(_DWORD*) a2 + 20) = 100;
            v19 = v25 + 1;
            (*(void(__cdecl**)(int, int))(*(_DWORD*) a2 + 4))(a2, 1);
            ++v28;
            v43 += 21;
            if(v28 >= *(_DWORD*) (a2 + 32))
                break;
            v20 = v43;
        }
    }
    *(_BYTE*) (*(_DWORD*) (a2 + 400) + 81) = 1;
    v3 [1] = v37;
    *v3 = v19;
    return 1;
}

//----- (0044A6A8) --------------------------------------------------------
char __usercall sub_44A6A8(_DWORD* a1) {
    unsigned __int8** v1; // edi
    unsigned __int8* v2; // ebx
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // ebx
    unsigned __int8* v5; // ebx
    int v6; // eax
    unsigned __int8* v7; // ebx
    int v8; // eax
    unsigned __int8* v9; // ebx
    int v10; // eax
    int v11; // ecx
    _DWORD* v12; // ebx
    _DWORD* v13; // eax
    int v14; // eax
    unsigned __int8* v15; // ebx
    int v16; // eax
    unsigned __int8* v17; // ebx
    int v18; // ecx
    _DWORD* v19; // eax
    int v21; // [esp+8h] [ebp-20h]
    int v22; // [esp+Ch] [ebp-1Ch]
    int v23; // [esp+10h] [ebp-18h]
    _DWORD* v24; // [esp+14h] [ebp-14h]
    int v25; // [esp+18h] [ebp-10h]
    int v26; // [esp+1Ch] [ebp-Ch]
    int v27; // [esp+1Ch] [ebp-Ch]
    int v28; // [esp+1Ch] [ebp-Ch]
    unsigned __int8* v29; // [esp+20h] [ebp-8h]
    unsigned __int8* v30; // [esp+24h] [ebp-4h]
    unsigned __int8* v31; // [esp+24h] [ebp-4h]
    unsigned __int8* v32; // [esp+24h] [ebp-4h]
    unsigned __int8* v33; // [esp+24h] [ebp-4h]
    unsigned __int8* v34; // [esp+24h] [ebp-4h]
    unsigned __int8* v35; // [esp+24h] [ebp-4h]
    unsigned __int8* v36; // [esp+24h] [ebp-4h]

    v1 = (unsigned __int8**) a1 [5];
    v2 = *v1;
    v30 = v1 [1];
    if(!*(_BYTE*) (a1 [100] + 81)) {
        *(_DWORD*) (*a1 + 20) = 61;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if(!v30) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v2 = *v1;
        v30 = v1 [1];
    }
    v31 = v30 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v26 = v3;
    if(!v31) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v4 = *v1;
        v31 = v1 [1];
    }
    v32 = v31 - 1;
    v27 = *v4 + v26;
    v5 = v4 + 1;
    if(!v32) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v5 = *v1;
        v32 = v1 [1];
    }
    v6 = *v5;
    v33 = v32 - 1;
    v7 = v5 + 1;
    v22 = v6;
    if(v27 != 2 * v6 + 6 || v6 < 1 || v6 > 4) {
        *(_DWORD*) (*a1 + 20) = 9;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        v6 = v22;
    }
    *(_DWORD*) (*a1 + 20) = 102;
    *(_DWORD*) (*a1 + 24) = v6;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    v23 = 0;
    a1 [72] = v22;
    if(v22 > 0) {
        v24 = a1 + 73;
        do {
            if(!v33) {
                if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                    return 0;
                v7 = *v1;
                v33 = v1 [1];
            }
            v8 = *v7;
            v34 = v33 - 1;
            v9 = v7 + 1;
            v25 = v8;
            if(!v34) {
                if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                    return 0;
                v9 = *v1;
                v34 = v1 [1];
            }
            v10 = *v9;
            v33 = v34 - 1;
            v11 = a1 [8];
            v28 = 0;
            v29 = v9 + 1;
            v12 = (_DWORD*) a1 [49];
            v21 = v10;
            if(v11 <= 0) {
                LABEL_27:
                *(_DWORD*) (*a1 + 20) = 5;
                *(_DWORD*) (*a1 + 24) = v25;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                v10 = v21;
            }
            else {
                while(v25 != *v12) {
                    ++v28;
                    v12 += 21;
                    if(v28 >= v11)
                        goto LABEL_27;
                }
            }
            *v24 = v12;
            v12 [6] = v10 & 0xF;
            v12 [5] = (v10 >> 4) & 0xF;
            v13 = (_DWORD*) (*a1 + 24);
            *v13 = v25;
            v13 [1] = v12 [5];
            v13 [2] = v12 [6];
            *(_DWORD*) (*a1 + 20) = 103;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            ++v23;
            ++v24;
            v7 = v29;
        }
        while(v23 < v22);
    }
    if(!v33) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v7 = *v1;
        v33 = v1 [1];
    }
    v14 = *v7;
    v35 = v33 - 1;
    v15 = v7 + 1;
    a1 [90] = v14;
    if(!v35) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v15 = *v1;
        v35 = v1 [1];
    }
    v16 = *v15;
    v36 = v35 - 1;
    v17 = v15 + 1;
    a1 [91] = v16;
    if(v36) {
        LABEL_38:
        v18 = (int) *v17 >> 4;
        a1 [93] = *v17 & 0xF;
        v19 = (_DWORD*) *a1;
        a1 [92] = v18 & 0xF;
        v19 += 6;
        *v19 = a1 [90];
        v19 [1] = a1 [91];
        v19 [2] = a1 [92];
        v19 [3] = a1 [93];
        *(_DWORD*) (*a1 + 20) = 104;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        *(_DWORD*) (a1 [100] + 84) = 0;
        ++a1 [31];
        v1 [1] = v36 - 1;
        *v1 = v17 + 1;
        return 1;
    }
    if(((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1)) {
        v17 = *v1;
        v36 = v1 [1];
        goto LABEL_38;
    }
    return 0;
}

//----- (0044A991) --------------------------------------------------------
char __cdecl sub_44A991(_DWORD* a1) {
    char** v2; // edi
    char* v3; // ebx
    unsigned __int16 v4; // ax
    char* v5; // ebx
    char* v6; // ebx
    char v7; // al
    int v8; // ecx
    bool v9; // cc
    __int16 v11; // cx
    __int16 v12; // dx
    __int16 v13; // ax
    unsigned __int16 v14; // cx
    __int16 v15; // ax
    _DWORD* v16; // eax
    int v17; // eax
    int v18; // ecx
    char v19 [5]; // [esp+Ch] [ebp-18h]
    unsigned __int8 v20; // [esp+11h] [ebp-13h]
    unsigned __int8 v21; // [esp+12h] [ebp-12h]
    char v22; // [esp+13h] [ebp-11h]
    unsigned __int8 v23; // [esp+14h] [ebp-10h]
    unsigned __int8 v24; // [esp+15h] [ebp-Fh]
    unsigned __int8 v25; // [esp+16h] [ebp-Eh]
    unsigned __int8 v26; // [esp+17h] [ebp-Dh]
    __int16 v27; // [esp+18h] [ebp-Ch]
    int v28; // [esp+1Ch] [ebp-8h]
    int v29; // [esp+20h] [ebp-4h]
    unsigned __int8* v30; // [esp+2Ch] [ebp+8h]
    unsigned __int8* v31; // [esp+2Ch] [ebp+8h]
    unsigned __int8* v32; // [esp+2Ch] [ebp+8h]

    v2 = (char**) a1 [5];
    v3 = *v2;
    v30 = (unsigned __int8*) v2 [1];
    if(!v30) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
            return 0;
        v3 = *v2;
        v30 = (unsigned __int8*) v2 [1];
    }
    v31 = v30 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v29 = v4;
    if(v31)
        goto LABEL_7;
    if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
        return 0;
    v5 = *v2;
    v31 = (unsigned __int8*) v2 [1];
    LABEL_7:
    v32 = v31 - 1;
    v29 = (unsigned __int8) *v5 + v29 - 2;
    v6 = v5 + 1;
    if(v29 < 14) {
        v18 = v29;
        *(_DWORD*) (*a1 + 20) = 76;
        *(_DWORD*) (*a1 + 24) = v18;
    }
    else {
        v28 = 0;
        do {
            if(!v32) {
                if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
                    return 0;
                v6 = *v2;
                v32 = (unsigned __int8*) v2 [1];
            }
            --v32;
            v7 = *v6;
            v8 = v28;
            ++v6;
            v9 = ++v28 < 14;
            v19 [v8] = v7;
        }
        while(v9);
        v29 -= 14;
        if(v19 [0] == 74 && v19 [1] == 70 && v19 [2] == 73 && v19 [3] == 70 && !v19 [4]) {
            if(v20 == 1) {
                if(v21 > 2u) {
                    *(_DWORD*) (*a1 + 20) = 88;
                    *(_DWORD*) (*a1 + 24) = 1;
                    *(_DWORD*) (*a1 + 28) = v21;
                    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
                }
            }
            else {
                *(_DWORD*) (*a1 + 20) = 115;
                *(_DWORD*) (*a1 + 24) = v20;
                *(_DWORD*) (*a1 + 28) = v21;
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
            }
            v11 = v24;
            v12 = v26;
            *((_BYTE*) a1 + 257) = v22;
            v13 = v23;
            *((_BYTE*) a1 + 256) = 1;
            v14 = (v13 << 8) + v11;
            v15 = v25;
            *((_WORD*) a1 + 129) = v14;
            *((_WORD*) a1 + 130) = v12 + (v15 << 8);
            v16 = (_DWORD*) (*a1 + 24);
            *v16 = v14;
            v16 [1] = *((unsigned __int16*) a1 + 130);
            v16 [2] = *((unsigned __int8*) a1 + 257);
            *(_DWORD*) (*a1 + 20) = 86;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            if(v27) {
                *(_DWORD*) (*a1 + 20) = 89;
                *(_DWORD*) (*a1 + 24) = (unsigned __int8) v27;
                *(_DWORD*) (*a1 + 28) = HIBYTE(v27);
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
            }
            v17 = v29;
            if(v29 == 3 * (unsigned __int8) v27 * HIBYTE(v27))
                goto LABEL_31;
            *(_DWORD*) (*a1 + 20) = 87;
        }
        else {
            *(_DWORD*) (*a1 + 20) = 76;
            v17 = v29 + 14;
        }
        *(_DWORD*) (*a1 + 24) = v17;
    }
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    LABEL_31:
    v9 = v29 <= 0;
    *v2 = v6;
    v2 [1] = (char*) v32;
    if(!v9)
        (*(void(__cdecl**)(_DWORD*, int))(a1 [5] + 16))(a1, v29);
    return 1;
}

//----- (0044ABCD) --------------------------------------------------------
char __cdecl sub_44ABCD(_DWORD* a1) {
    char** v2; // edi
    char* v3; // ebx
    unsigned __int16 v4; // ax
    char* v5; // ebx
    char* v6; // ebx
    char v7; // al
    int v8; // ecx
    bool v9; // cc
    int v10; // edx
    _DWORD* v11; // eax
    int v12; // ecx
    int v13; // edx
    unsigned __int8 v14; // al
    int v16; // ecx
    char v17 [11]; // [esp+Ch] [ebp-14h]
    unsigned __int8 v18; // [esp+17h] [ebp-9h]
    int v19; // [esp+18h] [ebp-8h]
    int v20; // [esp+1Ch] [ebp-4h]
    unsigned __int8* v21; // [esp+28h] [ebp+8h]
    unsigned __int8* v22; // [esp+28h] [ebp+8h]
    unsigned __int8* v23; // [esp+28h] [ebp+8h]

    v2 = (char**) a1 [5];
    v3 = *v2;
    v21 = (unsigned __int8*) v2 [1];
    if(!v21) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
            return 0;
        v3 = *v2;
        v21 = (unsigned __int8*) v2 [1];
    }
    v22 = v21 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v20 = v4;
    if(v22)
        goto LABEL_7;
    if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
        return 0;
    v5 = *v2;
    v22 = (unsigned __int8*) v2 [1];
    LABEL_7:
    v23 = v22 - 1;
    v20 = (unsigned __int8) *v5 + v20 - 2;
    v6 = v5 + 1;
    if(v20 < 12) {
        v16 = v20;
        *(_DWORD*) (*a1 + 20) = 77;
        *(_DWORD*) (*a1 + 24) = v16;
        goto LABEL_22;
    }
    v19 = 0;
    do {
        if(!v23) {
            if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
                return 0;
            v6 = *v2;
            v23 = (unsigned __int8*) v2 [1];
        }
        --v23;
        v7 = *v6;
        v8 = v19;
        ++v6;
        v9 = ++v19 < 12;
        v17 [v8] = v7;
    }
    while(v9);
    v20 -= 12;
    if(v17 [0] != 65 || v17 [1] != 100 || v17 [2] != 111 || v17 [3] != 98 || v17 [4] != 101) {
        *(_DWORD*) (*a1 + 20) = 77;
        *(_DWORD*) (*a1 + 24) = v20 + 12;
        LABEL_22:
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        goto LABEL_23;
    }
    v10 = (unsigned __int8) v17 [8];
    v11 = (_DWORD*) (*a1 + 24);
    *v11 = (unsigned __int8) v17 [6] + ((unsigned __int8) v17 [5] << 8);
    v12 = v10 + ((unsigned __int8) v17 [7] << 8);
    v13 = (unsigned __int8) v17 [10];
    v11 [1] = v12;
    v11 [2] = v13 + ((unsigned __int8) v17 [9] << 8);
    v11 [3] = v18;
    *(_DWORD*) (*a1 + 20) = 75;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    v14 = v18;
    *((_BYTE*) a1 + 262) = 1;
    *((_BYTE*) a1 + 263) = v14;
    LABEL_23:
    v9 = v20 <= 0;
    *v2 = v6;
    v2 [1] = (char*) v23;
    if(!v9)
        (*(void(__cdecl**)(_DWORD*, int))(a1 [5] + 16))(a1, v20);
    return 1;
}

//----- (0044AD47) --------------------------------------------------------
char __usercall sub_44AD47(_DWORD* a1) {
    unsigned __int8** v1; // edi
    unsigned __int8* v2; // ebx
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // ebx
    unsigned __int8* v5; // ebx
    int v6; // eax
    unsigned __int8* v7; // ebx
    int v8; // eax
    int v9; // eax
    int v11; // [esp+8h] [ebp-10h]
    int v12; // [esp+Ch] [ebp-Ch]
    int v13; // [esp+10h] [ebp-8h]
    int v14; // [esp+10h] [ebp-8h]
    int v15; // [esp+10h] [ebp-8h]
    unsigned __int8* v16; // [esp+14h] [ebp-4h]
    unsigned __int8* v17; // [esp+14h] [ebp-4h]
    unsigned __int8* v18; // [esp+14h] [ebp-4h]
    unsigned __int8* v19; // [esp+14h] [ebp-4h]

    v1 = (unsigned __int8**) a1 [5];
    v2 = *v1;
    v16 = v1 [1];
    if(!v16) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v2 = *v1;
        v16 = v1 [1];
    }
    v17 = v16 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v13 = v3;
    if(v17)
        goto LABEL_7;
    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
        return 0;
    v4 = *v1;
    v17 = v1 [1];
    LABEL_7:
    v18 = v17 - 1;
    v14 = *v4 + v13;
    v5 = v4 + 1;
    v15 = v14 - 2;
    while(v15 > 0) {
        if(!v18) {
            if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                return 0;
            v5 = *v1;
            v18 = v1 [1];
        }
        v6 = *v5;
        v19 = v18 - 1;
        v7 = v5 + 1;
        v12 = v6;
        if(!v19) {
            if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                return 0;
            v7 = *v1;
            v19 = v1 [1];
        }
        v8 = *v7;
        v18 = v19 - 1;
        v15 -= 2;
        *(_DWORD*) (*a1 + 20) = 78;
        *(_DWORD*) (*a1 + 24) = v12;
        v11 = v8;
        *(_DWORD*) (*a1 + 28) = v8;
        v5 = v7 + 1;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        v9 = v12;
        if(v12 >= 32) {
            *(_DWORD*) (*a1 + 20) = 26;
            *(_DWORD*) (*a1 + 24) = v12;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            v9 = v12;
        }
        if(v9 < 16) {
            *((_BYTE*) a1 + v9 + 202) = v11 & 0xF;
            *((_BYTE*) a1 + v9 + 218) = v11 >> 4;
            if((unsigned __int8) (v11 & 0xF) > (unsigned __int8)(v11 >> 4)) {
                *(_DWORD*) (*a1 + 20) = 27;
                *(_DWORD*) (*a1 + 24) = v11;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
        }
        else {
            *((_BYTE*) a1 + v9 + 218) = v11;
        }
    }
    v1 [1] = v18;
    *v1 = v5;
    return 1;
}
// 44AE1F: conditional instruction was optimized away because %var_C.4<100u

//----- (0044AE9E) --------------------------------------------------------
char __usercall sub_44AE9E(_DWORD* a1) {
    int v1; // esi
    int v2; // eax
    char* v3; // edi
    unsigned __int16 v4; // ax
    char* v5; // edi
    int v6; // eax
    char* v7; // edi
    int v8; // eax
    int v9; // ecx
    int v10; // ecx
    char* v11; // edi
    unsigned __int8 v12; // cl
    _DWORD* v13; // eax
    _DWORD* v14; // eax
    int i; // edi
    char v16; // al
    unsigned int v17; // eax
    int* v18; // edi
    int v19; // edi
    int v20; // eax
    char v22 [256]; // [esp+8h] [ebp-130h] BYREF
    int v23; // [esp+108h] [ebp-30h]
    int v24; // [esp+10Ch] [ebp-2Ch]
    int v25; // [esp+110h] [ebp-28h]
    int v26; // [esp+114h] [ebp-24h]
    int v27; // [esp+118h] [ebp-20h]
    int v28; // [esp+11Ch] [ebp-1Ch]
    unsigned __int8 v29; // [esp+120h] [ebp-18h]
    int v30; // [esp+124h] [ebp-14h]
    int v31; // [esp+128h] [ebp-10h]
    int v32; // [esp+12Ch] [ebp-Ch]
    char* v33; // [esp+130h] [ebp-8h]
    int v34; // [esp+134h] [ebp-4h]

    v1 = a1 [5];
    v2 = *(_DWORD*) (v1 + 4);
    v3 = *(char**) v1;
    v24 = v1;
    v34 = v2;
    if(!v2) {
        if(!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
            return 0;
        v33 = *(char**) v1;
        v3 = v33;
        v34 = *(_DWORD*) (v1 + 4);
    }
    --v34;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v32 = v4;
    if(v34)
        goto LABEL_7;
    if(!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
        return 0;
    v33 = *(char**) v1;
    v5 = v33;
    v34 = *(_DWORD*) (v1 + 4);
    LABEL_7:
    v6 = (unsigned __int8) *v5;
    --v34;
    v7 = v5 + 1;
    v32 = v6 + v32 - 2;
    while(v32 > 0) {
        if(!v34) {
            if(!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                return 0;
            v33 = *(char**) v1;
            v7 = v33;
            v34 = *(_DWORD*) (v1 + 4);
        }
        v8 = (unsigned __int8) *v7;
        v9 = *a1;
        --v34;
        *(_DWORD*) (v9 + 20) = 79;
        v10 = *a1;
        v23 = v8;
        *(_DWORD*) (v10 + 24) = v8;
        v11 = v7 + 1;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        LOBYTE(v25) = 0;
        v30 = 0;
        v31 = 1;
        do {
            if(!v34) {
                if(!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                    return 0;
                v33 = *(char**) v1;
                v11 = v33;
                v34 = *(_DWORD*) (v1 + 4);
            }
            v12 = *v11;
            --v34;
            *((_BYTE*) &v25 + v31) = v12;
            v30 += v12;
            ++v11;
            ++v31;
            v33 = v11;
        }
        while(v31 <= 16);
        v13 = (_DWORD*) (*a1 + 24);
        *v13 = BYTE1(v25);
        v13 [1] = BYTE2(v25);
        v13 [2] = HIBYTE(v25);
        v32 -= 17;
        v13 [3] = (unsigned __int8) v26;
        v13 [4] = BYTE1(v26);
        v13 [5] = BYTE2(v26);
        v13 [6] = HIBYTE(v26);
        v13 [7] = (unsigned __int8) v27;
        *(_DWORD*) (*a1 + 20) = 85;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 2);
        v14 = (_DWORD*) (*a1 + 24);
        *v14 = BYTE1(v27);
        v14 [1] = BYTE2(v27);
        v14 [2] = HIBYTE(v27);
        v14 [3] = (unsigned __int8) v28;
        v14 [4] = BYTE1(v28);
        v14 [5] = BYTE2(v28);
        v14 [6] = HIBYTE(v28);
        v14 [7] = v29;
        *(_DWORD*) (*a1 + 20) = 85;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 2);
        if(v30 > 256 || v30 > v32) {
            *(_DWORD*) (*a1 + 20) = 28;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        for(i = 0; i < v30; ++i) {
            if(!v34) {
                if(!(*(unsigned __int8(__cdecl**)(_DWORD*))(v1 + 12))(a1))
                    return 0;
                v33 = *(char**) v1;
                v34 = *(_DWORD*) (v1 + 4);
            }
            --v34;
            v16 = *v33++;
            v22 [i] = v16;
        }
        v32 -= v30;
        v17 = v23;
        if((v23 & 0x10) != 0) {
            v17 = v23 - 16;
            v18 = &a1 [v23 + 28];
            v31 = (int) v18;
        }
        else {
            v31 = (int) &a1 [v23 + 40];
            v18 = (int*) v31;
        }
        if(v17 >= 4) {
            *(_DWORD*) (*a1 + 20) = 29;
            *(_DWORD*) (*a1 + 24) = v17;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        if(!*v18)
            *v18 = sub_44FE85((int) a1);
        v19 = *v18;
        v20 = v31;
        *(_DWORD*) v19 = v25;
        v19 += 4;
        *(_DWORD*) v19 = v26;
        v19 += 4;
        *(_DWORD*) v19 = v27;
        v19 += 4;
        *(_DWORD*) v19 = v28;
        *(_BYTE*) (v19 + 4) = v29;
        qmemcpy((void*) (*(_DWORD*) v20 + 17), v22, 0x100u);
        v7 = v33;
        v1 = v24;
    }
    *(_DWORD*) (v1 + 4) = v34;
    *(_DWORD*) v1 = v7;
    return 1;
}
// 44AE9E: using guessed type char var_130[256];

//----- (0044B132) --------------------------------------------------------
char __usercall sub_44B132(_DWORD* a1) {
    unsigned __int8** v1; // esi
    unsigned __int8* v2; // ebx
    unsigned __int16 v3; // ax
    unsigned __int8* v4; // ebx
    unsigned __int8* v5; // ebx
    int v6; // ecx
    int v7; // eax
    int v8; // ecx
    int v9; // eax
    int* v10; // eax
    __int16 v11; // ax
    int v12; // ecx
    unsigned __int16* v13; // ebx
    _DWORD* v14; // eax
    int v16; // [esp+8h] [ebp-1Ch]
    int v17; // [esp+Ch] [ebp-18h]
    int v18; // [esp+10h] [ebp-14h]
    int* v19; // [esp+10h] [ebp-14h]
    int* v20; // [esp+10h] [ebp-14h]
    int v21; // [esp+10h] [ebp-14h]
    __int16 v22; // [esp+14h] [ebp-10h]
    __int16 v23; // [esp+14h] [ebp-10h]
    int v24; // [esp+18h] [ebp-Ch]
    int v25; // [esp+18h] [ebp-Ch]
    int v26; // [esp+18h] [ebp-Ch]
    unsigned __int8* v27; // [esp+1Ch] [ebp-8h]
    unsigned __int8* v28; // [esp+20h] [ebp-4h]
    unsigned __int8* v29; // [esp+20h] [ebp-4h]
    unsigned __int8* v30; // [esp+20h] [ebp-4h]

    v1 = (unsigned __int8**) a1 [5];
    v2 = *v1;
    v28 = v1 [1];
    if(!v28) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v2 = *v1;
        v28 = v1 [1];
    }
    v29 = v28 - 1;
    LOBYTE(v3) = 0;
    HIBYTE(v3) = *v2;
    v4 = v2 + 1;
    v24 = v3;
    if(v29)
        goto LABEL_7;
    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
        return 0;
    v4 = *v1;
    v29 = v1 [1];
    LABEL_7:
    v30 = v29 - 1;
    v25 = *v4 + v24;
    v5 = v4 + 1;
    v26 = v25 - 2;
    while(v26 > 0) {
        if(!v30) {
            if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                return 0;
            v5 = *v1;
            v30 = v1 [1];
        }
        v6 = *v5;
        --v30;
        *(_DWORD*) (*a1 + 20) = 80;
        v7 = v6;
        v8 = v6 & 0xF;
        *(_DWORD*) (*a1 + 24) = v8;
        v18 = v8;
        v17 = v7 >> 4;
        *(_DWORD*) (*a1 + 28) = v7 >> 4;
        ++v5;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        v9 = v18;
        if(v18 >= 4) {
            *(_DWORD*) (*a1 + 20) = 30;
            *(_DWORD*) (*a1 + 24) = v18;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            v9 = v18;
        }
        v10 = &a1 [v9 + 36];
        v19 = v10;
        if(!*v10) {
            *v10 = sub_44FE69((int) a1);
            v10 = v19;
        }
        v16 = *v10;
        v20 = dword_46EA70;
        do {
            if(v17) {
                if(!v30) {
                    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1 [1];
                }
                --v30;
                LOBYTE(v11) = 0;
                HIBYTE(v11) = *v5++;
                v22 = v11;
                if(!v30) {
                    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1 [1];
                }
                v23 = *v5 + v22;
            }
            else {
                if(!v30) {
                    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
                        return 0;
                    v5 = *v1;
                    v30 = v1 [1];
                }
                v23 = *v5;
            }
            --v30;
            v12 = *v20++;
            v27 = ++v5;
            *(_WORD*) (v16 + 2 * v12) = v23;
        }
        while((int) v20 < (int) &unk_46EB70);
        if(*(int*) (*a1 + 104) >= 2) {
            v13 = (unsigned __int16*) (v16 + 4);
            v21 = 8;
            do {
                v14 = (_DWORD*) (*a1 + 24);
                *v14 = *(v13 - 2);
                v14 [1] = *(v13 - 1);
                v14 [2] = *v13;
                v14 [3] = v13 [1];
                v14 [4] = v13 [2];
                v14 [5] = v13 [3];
                v14 [6] = v13 [4];
                v14 [7] = v13 [5];
                *(_DWORD*) (*a1 + 20) = 92;
                (*(void(__cdecl**)(_DWORD*))(*a1 + 4))(a1);
                v13 += 8;
                --v21;
            }
            while(v21);
            v5 = v27;
        }
        v26 -= 65;
        if(v17)
            v26 -= 64;
    }
    v1 [1] = v30;
    *v1 = v5;
    return 1;
}
// 46EA70: using guessed type int dword_46EA70[64];

//----- (0044B37C) --------------------------------------------------------
char __cdecl sub_44B37C(int a1) {
    int v1; // eax
    unsigned __int8** v2; // esi
    unsigned __int8* v3; // ebx
    unsigned __int8* v4; // edi
    unsigned __int16 v5; // cx
    unsigned __int8* v6; // ebx
    unsigned __int8* v7; // edi
    unsigned __int8* v8; // ebx
    unsigned __int8* v9; // edi
    unsigned __int16 v10; // cx
    unsigned __int8* v11; // ebx
    unsigned __int8* v12; // edi
    int v14; // [esp+Ch] [ebp-4h]
    int v15; // [esp+Ch] [ebp-4h]
    int v16; // [esp+Ch] [ebp-4h]
    int v17; // [esp+Ch] [ebp-4h]

    v1 = a1;
    v2 = *(unsigned __int8***) (a1 + 20);
    v3 = v2 [1];
    v4 = *v2;
    if(!v3) {
        if(!((unsigned __int8(__cdecl*)(int))v2 [3])(a1))
            return 0;
        v4 = *v2;
        v3 = v2 [1];
        v1 = a1;
    }
    LOBYTE(v5) = 0;
    HIBYTE(v5) = *v4;
    v6 = v3 - 1;
    v7 = v4 + 1;
    v14 = v5;
    if(!v6) {
        if(!((unsigned __int8(__cdecl*)(int))v2 [3])(v1))
            return 0;
        v7 = *v2;
        v6 = v2 [1];
        v1 = a1;
    }
    v15 = *v7 + v14;
    v8 = v6 - 1;
    v9 = v7 + 1;
    if(v15 != 4) {
        *(_DWORD*) (*(_DWORD*) v1 + 20) = 9;
        (**(void(__cdecl***)(int))v1)(v1);
        v1 = a1;
    }
    if(!v8) {
        if(!((unsigned __int8(__cdecl*)(int))v2 [3])(v1))
            return 0;
        v9 = *v2;
        v8 = v2 [1];
        v1 = a1;
    }
    LOBYTE(v10) = 0;
    HIBYTE(v10) = *v9;
    v11 = v8 - 1;
    v12 = v9 + 1;
    v16 = v10;
    if(v11) {
        LABEL_15:
        v17 = *v12 + v16;
        *(_DWORD*) (*(_DWORD*) v1 + 20) = 81;
        *(_DWORD*) (*(_DWORD*) v1 + 24) = v17;
        (*(void(__cdecl**)(int, int))(*(_DWORD*) v1 + 4))(v1, 1);
        *(_DWORD*) (a1 + 252) = v17;
        *v2 = v12 + 1;
        v2 [1] = v11 - 1;
        return 1;
    }
    if(((unsigned __int8(__cdecl*)(int))v2 [3])(v1)) {
        v12 = *v2;
        v11 = v2 [1];
        v1 = a1;
        goto LABEL_15;
    }
    return 0;
}

//----- (0044B45B) --------------------------------------------------------
char __cdecl sub_44B45B(_DWORD* a1) {
    unsigned __int8** v2; // edi
    unsigned __int8* v3; // ebx
    unsigned __int16 v4; // ax
    unsigned __int8* v5; // ebx
    int v7; // [esp+Ch] [ebp-4h]
    int v8; // [esp+Ch] [ebp-4h]
    unsigned __int8* v9; // [esp+18h] [ebp+8h]
    unsigned __int8* v10; // [esp+18h] [ebp+8h]

    v2 = (unsigned __int8**) a1 [5];
    v3 = *v2;
    v9 = v2 [1];
    if(!v9) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1))
            return 0;
        v3 = *v2;
        v9 = v2 [1];
    }
    v10 = v9 - 1;
    LOBYTE(v4) = 0;
    HIBYTE(v4) = *v3;
    v5 = v3 + 1;
    v7 = v4;
    if(v10) {
        LABEL_7:
        v8 = *v5 + v7;
        *(_DWORD*) (*a1 + 20) = 90;
        *(_DWORD*) (*a1 + 24) = a1 [94];
        *(_DWORD*) (*a1 + 28) = v8;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        *v2 = v5 + 1;
        v2 [1] = v10 - 1;
        (*(void(__cdecl**)(_DWORD*, int))(a1 [5] + 16))(a1, v8 - 2);
        return 1;
    }
    if(((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(a1)) {
        v5 = *v2;
        v10 = v2 [1];
        goto LABEL_7;
    }
    return 0;
}

//----- (0044B4F7) --------------------------------------------------------
char __cdecl sub_44B4F7(_DWORD* a1) {
    _DWORD* v1; // eax
    unsigned __int8** v2; // esi
    unsigned __int8* v3; // ebx
    unsigned __int8* v4; // edi
    int v5; // ecx
    int v6; // ecx
    int v8; // [esp+Ch] [ebp-4h]

    v1 = a1;
    v2 = (unsigned __int8**) a1 [5];
    v3 = v2 [1];
    v4 = *v2;
    while(1) {
        if(!v3) {
            if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(v1))
                return 0;
            v1 = a1;
            v4 = *v2;
            v3 = v2 [1];
        }
        v5 = *v4;
        --v3;
        ++v4;
        if(v5 != 255) {
            ++* (_DWORD*) (v1 [100] + 88);
            goto LABEL_3;
        }
        do {
            if(!v3) {
                if(!((unsigned __int8(__cdecl*)(_DWORD*))v2 [3])(v1))
                    return 0;
                v4 = *v2;
                v3 = v2 [1];
                v1 = a1;
            }
            v6 = *v4;
            --v3;
            ++v4;
            v8 = v6;
        }
        while(v6 == 255);
        if(v6)
            break;
        *(_DWORD*) (v1 [100] + 88) += 2;
        LABEL_3:
        *v2 = v4;
        v2 [1] = v3;
    }
    if(*(_DWORD*) (v1 [100] + 88)) {
        *(_DWORD*) (*v1 + 20) = 112;
        *(_DWORD*) (*v1 + 24) = *(_DWORD*) (v1 [100] + 88);
        *(_DWORD*) (*v1 + 28) = v6;
        (*(void(__cdecl**)(_DWORD*, int))(*v1 + 4))(v1, -1);
        *(_DWORD*) (a1 [100] + 88) = 0;
        v1 = a1;
        v6 = v8;
    }
    v1 [94] = v6;
    *v2 = v4;
    v2 [1] = v3;
    return 1;
}

//----- (0044B5CE) --------------------------------------------------------
char __usercall sub_44B5CE(_DWORD* a1) {
    unsigned __int8** v1; // esi
    unsigned __int8* v2; // edi
    int v3; // ecx
    unsigned __int8* v4; // edi
    int v5; // eax
    unsigned __int8* v6; // edi
    int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+8h] [ebp-8h]
    unsigned __int8* v10; // [esp+Ch] [ebp-4h]
    unsigned __int8* v11; // [esp+Ch] [ebp-4h]
    unsigned __int8* v12; // [esp+Ch] [ebp-4h]

    v1 = (unsigned __int8**) a1 [5];
    v2 = *v1;
    v10 = v1 [1];
    if(!v10) {
        if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
            return 0;
        v2 = *v1;
        v10 = v1 [1];
    }
    v3 = *v2;
    v11 = v10 - 1;
    v4 = v2 + 1;
    v8 = v3;
    if(v11)
        goto LABEL_7;
    if(!((unsigned __int8(__cdecl*)(_DWORD*))v1 [3])(a1))
        return 0;
    v4 = *v1;
    v3 = v8;
    v11 = v1 [1];
    LABEL_7:
    v5 = *v4;
    v12 = v11 - 1;
    v6 = v4 + 1;
    v9 = v5;
    if(v3 != 255 || v5 != 216) {
        *(_DWORD*) (*a1 + 20) = 52;
        *(_DWORD*) (*a1 + 24) = v3;
        *(_DWORD*) (*a1 + 28) = v5;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        v5 = v9;
    }
    a1 [94] = v5;
    v1 [1] = v12;
    *v1 = v6;
    return 1;
}

//----- (0044B666) --------------------------------------------------------
int __cdecl sub_44B666(_DWORD* a1) {
    int v2; // eax
    char v3; // al
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int result; // eax
    char v8; // [esp-4h] [ebp-14h]

    while(1) {
        if(!a1 [94] && !(*(_BYTE*) (a1 [100] + 80) ? sub_44B4F7(a1) : sub_44B5CE(a1)))
            return 0;
        v2 = a1 [94];
        if(v2 > 207)
            break;
        if(v2 >= 205)
            goto LABEL_26;
        if(v2 > 200) {
            v4 = v2 - 201;
            if(v4) {
                v5 = v4 - 1;
                if(v5) {
                    v6 = v5 - 1;
                    if(!v6) {
                        LABEL_26:
                        *(_DWORD*) (*a1 + 20) = 59;
                        LABEL_34:
                        *(_DWORD*) (*a1 + 24) = a1 [94];
                        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                        goto LABEL_48;
                    }
                    if(v6 != 1)
                        goto LABEL_33;
                    v3 = sub_44AD47(a1);
                }
                else {
                    v3 = sub_44A3AD(1, (int) a1, 1);
                }
                goto LABEL_47;
            }
            v8 = 1;
        }
        else {
            if(v2 >= 197)
                goto LABEL_26;
            if(v2 == 1) {
                LABEL_36:
                *(_DWORD*) (*a1 + 20) = 91;
                *(_DWORD*) (*a1 + 24) = a1 [94];
                (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
                goto LABEL_48;
            }
            if(v2 <= 191)
                goto LABEL_33;
            if(v2 > 193) {
                if(v2 == 194) {
                    v3 = sub_44A3AD(1, (int) a1, 0);
                }
                else {
                    if(v2 == 195)
                        goto LABEL_26;
                    v3 = sub_44AE9E(a1);
                }
                goto LABEL_47;
            }
            v8 = 0;
        }
        v3 = sub_44A3AD(0, (int) a1, v8);
        LABEL_47:
        if(!v3)
            return 0;
        LABEL_48:
        a1 [94] = 0;
    }
    if(v2 > 219) {
        if(v2 == 220) {
            v3 = sub_44B45B(a1);
        }
        else if(v2 == 221) {
            v3 = sub_44B37C((int) a1);
        }
        else {
            if(v2 <= 223)
                goto LABEL_33;
            if(v2 <= 239) {
                v3 = (*(int(__cdecl**)(_DWORD*))(a1 [100] + 4 * v2 - 880))(a1);
            }
            else {
                if(v2 != 254) {
                    LABEL_33:
                    *(_DWORD*) (*a1 + 20) = 67;
                    goto LABEL_34;
                }
                v3 = (*(int(__cdecl**)(_DWORD*))(a1 [100] + 12))(a1);
            }
        }
        goto LABEL_47;
    }
    if(v2 == 219) {
        v3 = sub_44B132(a1);
        goto LABEL_47;
    }
    if(v2 <= 215)
        goto LABEL_36;
    if(v2 == 216) {
        v3 = sub_44A31F((int) a1);
        goto LABEL_47;
    }
    if(v2 == 217) {
        *(_DWORD*) (*a1 + 20) = 84;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
        result = 2;
        goto LABEL_51;
    }
    if(sub_44A6A8(a1)) {
        result = 1;
        LABEL_51:
        a1 [94] = 0;
        return result;
    }
    return 0;
}
// 44B6FA: conditional instruction was optimized away because eax.4==C4
// 44B754: conditional instruction was optimized away because eax.4 is in (D0..DA)
// 44B774: conditional instruction was optimized away because eax.4==DA

//----- (0044B85A) --------------------------------------------------------
char __cdecl sub_44B85A(_DWORD* a1) {
    if(a1 [94] || sub_44B4F7(a1)) {
        if(a1 [94] == *(_DWORD*) (a1 [100] + 84) + 208) {
            *(_DWORD*) (*a1 + 20) = 97;
            *(_DWORD*) (*a1 + 24) = *(_DWORD*) (a1 [100] + 84);
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 3);
            a1 [94] = 0;
            LABEL_5:
            *(_DWORD*) (a1 [100] + 84) = ((unsigned __int8) *(_DWORD*) (a1 [100] + 84) + 1) & 7;
            return 1;
        }
        if((*(unsigned __int8(__cdecl**)(_DWORD*, _DWORD))(a1 [5] + 20))(a1, *(_DWORD*) (a1 [100] + 84)))
            goto LABEL_5;
    }
    return 0;
}

//----- (0044B8D8) --------------------------------------------------------
char __cdecl sub_44B8D8(_DWORD* a1, int a2) {
    int v3; // edi
    int v5; // [esp+14h] [ebp+4h]

    v3 = a1 [94];
    *(_DWORD*) (*a1 + 20) = 117;
    *(_DWORD*) (*a1 + 24) = v3;
    *(_DWORD*) (*a1 + 28) = a2;
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
    while(1) {
        if(v3 < 192) {
            LABEL_3:
            v5 = 2;
            goto LABEL_12;
        }
        if(v3 < 208 || v3 > 215 || v3 == ((a2 + 1) & 7) + 208 || v3 == ((a2 + 2) & 7) + 208) {
            v5 = 3;
        }
        else {
            if(v3 == ((a2 - 1) & 7) + 208 || v3 == ((a2 - 2) & 7) + 208)
                goto LABEL_3;
            v5 = 1;
        }
        LABEL_12:
        *(_DWORD*) (*a1 + 20) = 96;
        *(_DWORD*) (*a1 + 24) = v3;
        *(_DWORD*) (*a1 + 28) = v5;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 4);
        if(v5 == 1)
            break;
        if(v5 != 2)
            return 1;
        if(!sub_44B4F7(a1))
            return 0;
        v3 = a1 [94];
    }
    a1 [94] = 0;
    return 1;
}
// 44B997: conditional instruction was optimized away because %arg_0.4==3

//----- (0044B9C7) --------------------------------------------------------
int __cdecl sub_44B9C7(_DWORD* a1) {
    _DWORD* v1; // eax
    int result; // eax

    a1 [49] = 0;
    a1 [31] = 0;
    a1 [94] = 0;
    v1 = a1 + 100;
    *(_BYTE*) (*v1 + 80) = 0;
    *(_BYTE*) (*v1 + 81) = 0;
    result = a1 [100];
    *(_DWORD*) (result + 88) = 0;
    return result;
}

//----- (0044B9F1) --------------------------------------------------------
int __cdecl sub_44B9F1(int a1) {
    _DWORD* v1; // eax
    int i; // eax

    v1 = (_DWORD*) (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
    *(_DWORD*) (a1 + 400) = v1;
    *v1 = sub_44B9C7;
    *(_DWORD*) (*(_DWORD*) (a1 + 400) + 4) = sub_44B666;
    *(_DWORD*) (*(_DWORD*) (a1 + 400) + 8) = sub_44B85A;
    *(_DWORD*) (*(_DWORD*) (a1 + 400) + 12) = sub_44B45B;
    for(i = 16; i < 80; i += 4)
        *(_DWORD*) (i + *(_DWORD*) (a1 + 400)) = sub_44B45B;
    *(_DWORD*) (*(_DWORD*) (a1 + 400) + 16) = sub_44A991;
    *(_DWORD*) (*(_DWORD*) (a1 + 400) + 72) = sub_44ABCD;
    return sub_44B9C7((_DWORD*) a1);
}

//----- (0044BA6E) --------------------------------------------------------
void __cdecl __noreturn sub_44BA6E(int a1) {
    (*(void(__cdecl**)(int))(*(_DWORD*) a1 + 8))(a1);
    sub_44FE4E(a1);
    exit(1);
}

//----- (0044BABA) --------------------------------------------------------
int __cdecl sub_44BABA(int a1, char* Buffer) {
    _DWORD* v2; // eax
    int v3; // edx
    const char* v4; // ecx
    int v5; // ecx
    int v6; // esi
    const char** v7; // ecx
    char v8; // dl
    char* i; // esi

    v2 = *(_DWORD**) a1;
    v3 = *(_DWORD*) (*(_DWORD*) a1 + 20);
    if(v3 <= 0 || v3 > v2 [29]) {
        v5 = v2 [30];
        if(!v5)
            goto LABEL_9;
        v6 = v2 [31];
        if(v3 < v6 || v3 > v2 [32])
            goto LABEL_9;
        v4 = *(const char**) (v5 + 4 * (v3 - v6));
    }
    else {
        v4 = *(const char**) (v2 [28] + 4 * v3);
    }
    if(!v4) {
        LABEL_9:
        v7 = (const char**) v2 [28];
        v2 [6] = v3;
        v4 = *v7;
    }
    v8 = *v4;
    for(i = (char*) v4; ; v8 = *i) {
        if(!v8)
            return sprintf(Buffer, v4, v2 [6], v2 [7], v2 [8], v2 [9], v2 [10], v2 [11], v2 [12], v2 [13]);
        ++i;
        if(v8 == 37)
            break;
    }
    if(*i != 115)
        return sprintf(Buffer, v4, v2 [6], v2 [7], v2 [8], v2 [9], v2 [10], v2 [11], v2 [12], v2 [13]);
    return sprintf(Buffer, v4, v2 + 6);
}

//----- (0044BB51) --------------------------------------------------------
int __cdecl sub_44BB51(int* a1) {
    int result; // eax

    *(_DWORD*) (*a1 + 108) = 0;
    result = *a1;
    *(_DWORD*) (*a1 + 20) = 0;
    return result;
}

//----- (0044BB62) --------------------------------------------------------
void(__cdecl __noreturn** __cdecl sub_44BB62(void(__cdecl __noreturn** a1)(int a1)))(int a1)
{
    void(__cdecl __noreturn** result)(int); // eax

    result = a1;
    *a1 = sub_44BA6E;
    a1 [1] = (void(__cdecl __noreturn*)(int))sub_44BA89;
    a1 [2] = (void(__cdecl __noreturn*)(int))sub_4448F5;
    a1 [3] = (void(__cdecl __noreturn*)(int))sub_44BABA;
    a1 [4] = (void(__cdecl __noreturn*)(int))sub_44BB51;
    a1 [26] = 0;
    a1 [27] = 0;
    a1 [5] = 0;
    a1 [28] = (void(__cdecl __noreturn*)(int))off_46D2A0;
    a1 [29] = (void(__cdecl __noreturn*)(int))119;
    a1 [30] = 0;
    a1 [31] = 0;
    a1 [32] = 0;
    return result;
}
// 44BA89: using guessed type int sub_44BA89();
// 46D2A0: using guessed type char *off_46D2A0[120];

//----- (0044BBAE) --------------------------------------------------------
_BYTE* __cdecl sub_44BBAE(int a1, const void* a2) {
    int v2; // ecx
    _BYTE* result; // eax
    int i; // esi
    int v5; // edx
    _BYTE* v6; // eax
    _BYTE* v7; // eax

    result = 0;
    for(i = 0; i < 4; ++i) {
        v5 = *(unsigned __int8*) (a1 + i + 268);
        if(v5 < 41 || v5 > 122 || v5 > 90 && v5 < 97) {
            result [v2] = 91;
            v6 = result + 1;
            v6 [v2] = byte_46E618 [(v5 >> 4) & 0xF];
            (++v6) [v2] = byte_46E618 [v5 & 0xF];
            result = v6 + 1;
            result [v2] = 93;
        }
        else {
            result [v2] = v5;
        }
        ++result;
    }
    if(a2) {
        result [v2] = 58;
        v7 = result + 1;
        v7 [v2] = 32;
        result = &v7 [v2 + 1];
        qmemcpy(result, a2, 0x40u);
        result [63] = 0;
    }
    else {
        result [v2] = 0;
    }
    return result;
}
// 44BBD6: variable 'v2' is possibly undefined

//----- (0044BC35) --------------------------------------------------------
void __cdecl __noreturn sub_44BC35(jmp_buf Buf) {
    longjmp(Buf, 1);
}

//----- (0044BC40) --------------------------------------------------------
_DWORD* __cdecl sub_44BC40(_DWORD* a1, int a2, int a3, int a4) {
    _DWORD* result; // eax

    result = a1;
    a1 [18] = a2;
    a1 [16] = a3;
    a1 [17] = a4;
    return result;
}

//----- (0044BC5A) --------------------------------------------------------
void __cdecl __noreturn sub_44BC5A(jmp_buf Buf, int a2) {
    void(__cdecl * v2)(int* __attribute__((__org_typedef(jmp_buf))), int); // eax

    v2 = (void(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int))Buf [16];
    if(v2)
        v2(Buf, a2);
    sub_44BC35(Buf);
}

//----- (0044BC7D) --------------------------------------------------------
int(__cdecl* __cdecl sub_44BC7D(int a1, int a2))(int, int) {
    int(__cdecl * result)(int, int); // eax

    result = *(int(__cdecl**)(int, int))(a1 + 68);
    if(result)
        return (int(__cdecl*)(int, int))result(a1, a2);
    return result;
}

//----- (0044BC92) --------------------------------------------------------
void __cdecl __noreturn sub_44BC92(jmp_buf Buf, const void* a2) {
    int v2 [20]; // [esp+0h] [ebp-50h] BYREF

    sub_44BBAE((int) Buf, a2);
    sub_44BC5A(Buf, (int) v2);
}
// 44BC92: using guessed type int var_50[20];

//----- (0044BCB7) --------------------------------------------------------
int(__cdecl* __cdecl sub_44BCB7(int a1, const void* a2))(int, int) {
    char v3 [80]; // [esp+0h] [ebp-50h] BYREF

    sub_44BBAE(a1, a2);
    return sub_44BC7D(a1, (int) v3);
}
// 44BCB7: using guessed type char var_50[80];

//----- (0044BCDC) --------------------------------------------------------
jmp_buf __cdecl sub_44BCDC(_BYTE* a1, int a2, int a3, int a4) {
    int* v4; // eax
    int v6; // eax
    int v7; // [esp+0h] [ebp-8h]
    int* __attribute__((__org_typedef(jmp_buf))) Buf; // [esp+4h] [ebp-4h]

    v4 = (int*) sub_450975(1);
    Buf = v4;
    if(!v4)
        return 0;
    if(_setjmp3(v4, 0, v7)) {
        sub_4509FA((int) Buf, (void*) Buf [39]);
        sub_4509B7(Buf);
        return 0;
    }
    sub_44BC40(Buf, a2, a3, a4);
    if(!a1 || *a1 != 49)
        sub_44BC5A(Buf, (int) "Incompatible libpng version in application and library");
    Buf [40] = 0x2000;
    Buf [39] = (int) sub_4509C4(Buf, 0x2000u);
    Buf [33] = (int) sub_44E044;
    Buf [34] = (int) sub_44E097;
    Buf [35] = (int) Buf;
    v6 = sub_4505FD(Buf + 25, "1.1.3", 56);
    if(v6 == -6)
        sub_44BC5A(Buf, (int) "zlib version error");
    if(v6 == -4 || v6 == -2)
        sub_44BC5A(Buf, (int) "zlib memory error");
    if(v6)
        sub_44BC5A(Buf, (int) "Unknown zlib error");
    Buf [28] = Buf [39];
    Buf [29] = Buf [40];
    sub_44DFBD(Buf, 0, 0);
    return Buf;
}
// 44BCF3: variable 'v7' is possibly undefined

//----- (0044BDDF) --------------------------------------------------------
int __cdecl sub_44BDDF(jmp_buf Buf, int a2) {
    int* __attribute__((__org_typedef(jmp_buf))) v2; // esi
    unsigned __int8 v3; // al
    unsigned int v4; // ebx
    int v5; // edi
    _DWORD* v6; // ebx
    int v7; // edi
    int result; // eax
    int v9; // [esp-18h] [ebp-24h]

    v2 = Buf;
    v3 = *((_BYTE*) Buf + 284);
    if(v3 < 8u) {
        v4 = v3;
        v5 = 8 - v3;
        sub_44DF95(Buf, v3 + a2 + 32, v5);
        v9 = a2 + 32;
        *((_BYTE*) v2 + 284) = 8;
        if(sub_44DFFC(v9, v4, v5)) {
            if(v4 < 4) {
                if(sub_44DFFC(a2 + 32, v4, v5 - 4))
                    sub_44BC5A(v2, (int) "Not a PNG file");
            }
            sub_44BC5A(v2, (int) "PNG file corrupted by ASCII conversion");
        }
    }
    v6 = v2 + 67;
    while(1) {
        while(1) {
            while(1) {
                while(1) {
                    sub_44DF95(v2, (int) &Buf, 4);
                    v7 = sub_450A69((unsigned __int8*) &Buf);
                    sub_44E09C((int) v2);
                    sub_450A9F(v2, (_BYTE*) v2 + 268, 4);
                    if(*v6 != *(_DWORD*) "IHDR")
                        break;
                    sub_451401(v2, a2, v7);
                }
                if(*v6 != *(_DWORD*) "PLTE")
                    break;
                sub_4515F8(v2, a2, v7);
            }
            if(*v6 != *(_DWORD*) "IEND")
                break;
            sub_451721(v2, a2, v7);
        }
        if(*v6 == *(_DWORD*) "IDAT")
            break;
        if(*v6 == *(_DWORD*) "gAMA") {
            sub_45176B(v2, a2, v7);
        }
        else if(*v6 == *(_DWORD*) "sRGB") {
            sub_45186B(v2, a2, v7);
        }
        else if(*v6 == *(_DWORD*) "tRNS") {
            sub_45195A(v2, a2, v7);
        }
        else {
            sub_451AF3(v2, a2, v7);
        }
    }
    result = v2 [22];
    if((result & 1) == 0)
        sub_44BC5A(v2, (int) "Missing IHDR before IDAT");
    if(*((_BYTE*) v2 + 278) == 3 && (result & 2) == 0)
        sub_44BC5A(v2, (int) "Missing PLTE before IDAT");
    v2 [22] |= 4u;
    v2 [63] = v7;
    return result;
}

//----- (0044BF53) --------------------------------------------------------
unsigned int __cdecl sub_44BF53(jmp_buf Buf, int a2) {
    if((Buf [23] & 0x40) == 0)
        sub_4511D9(Buf);
    return sub_44C8A0((int) Buf, a2);
}

//----- (0044BF73) --------------------------------------------------------
int(__cdecl* __usercall sub_44BF73(int a1, jmp_buf Buf, char* a3, char* a4))(jmp_buf, int, _DWORD) {
    int* __attribute__((__org_typedef(jmp_buf))) v4; // esi
    int(__cdecl * result)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
    bool v6; // zf
    unsigned int v7; // eax
    unsigned int v8; // edx
    _BYTE* v9; // ecx
    int v10; // eax
    const char* v11; // eax
    char v12; // al
    unsigned __int8 v13; // cl
    int v14; // eax
    unsigned int v15; // ecx
    unsigned __int8* v16; // eax
    unsigned __int8 v17; // cl

    v4 = Buf;
    if((Buf [23] & 0x40) == 0)
        sub_4511D9(Buf);
    if(!*((_BYTE*) v4 + 275) || (v4 [24] & 2) == 0)
        goto LABEL_36;
    switch(*((_BYTE*) v4 + 276)) {
        case 0:
            if((v4 [53] & 7) == 0)
                break;
            v6 = a4 == 0;
            goto LABEL_34;
        case 1:
            if((v4 [53] & 7) != 0 || (unsigned int) v4 [46] < 5) {
                if(a4)
                    sub_450B83((int) v4, a4, 15);
                return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
            }
            break;
        case 2:
            if((v4 [53] & 7) == 4)
                break;
            if(!a4)
                return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
            v6 = (v4 [53] & 4) == 0;
            LABEL_34:
            if(!v6)
                sub_450B83((int) v4, a4, 255);
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
        case 3:
            if((v4 [53] & 3) != 0 || (unsigned int) v4 [46] < 3) {
                if(a4)
                    sub_450B83((int) v4, a4, 51);
                return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
            }
            break;
        case 4:
            if((v4 [53] & 3) == 2)
                break;
            if(a4) {
                v6 = (v4 [53] & 2) == 0;
                goto LABEL_34;
            }
            return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
        case 5:
            if((v4 [53] & 1) != 0 || (unsigned int) v4 [46] < 2) {
                if(a4)
                    sub_450B83((int) v4, a4, 85);
                return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
            }
            break;
        default:
            if(*((_BYTE*) v4 + 276) == 6 && (v4 [53] & 1) == 0)
                return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_451B3D(a1, v4);
            break;
    }
    LABEL_36:
    if((v4 [22] & 4) == 0)
        sub_44BC5A(v4, (int) "Invalid attempt to read row data");
    v4 [28] = v4 [55];
    v4 [29] = v4 [51];
    while(1) {
        if(!v4 [26]) {
            while(!v4 [63]) {
                sub_451375(v4, 0);
                sub_44DF95(v4, (int) &Buf, 4);
                v4 [63] = sub_450A69((unsigned __int8*) &Buf);
                sub_44E09C((int) v4);
                sub_450A9F(v4, (_BYTE*) v4 + 268, 4);
                if(v4 [67] != *(_DWORD*) "IDAT")
                    sub_44BC5A(v4, (int) "Not enough image data");
            }
            v7 = v4 [40];
            v8 = v4 [63];
            v9 = (_BYTE*) v4 [39];
            v4 [26] = v7;
            v4 [25] = (int) v9;
            if(v7 > v8)
                v4 [26] = v8;
            sub_450A9F(v4, v9, v4 [26]);
            v4 [63] -= v4 [26];
        }
        v10 = sub_450614((unsigned __int8**) v4 + 25, 1);
        if(v10 == 1)
            break;
        if(v10) {
            v11 = (const char*) v4 [31];
            if(!v11)
                v11 = "Decompression error";
            sub_44BC5A(v4, (int) v11);
        }
        if(!v4 [29])
            goto LABEL_59;
    }
    if(v4 [29] || v4 [26] || v4 [63])
        sub_44BC5A(v4, (int) "Extra compressed data");
    v4 [22] |= 8u;
    v4 [23] |= 0x20u;
    LABEL_59:
    v12 = *((_BYTE*) v4 + 278);
    *((_BYTE*) v4 + 250) = *((_BYTE*) v4 + 282);
    *((_BYTE*) v4 + 249) = *((_BYTE*) v4 + 279);
    v13 = *((_BYTE*) v4 + 281);
    *((_BYTE*) v4 + 251) = v13;
    *((_BYTE*) v4 + 248) = v12;
    v14 = v4 [52];
    v15 = v14 * v13 + 7;
    v4 [60] = v14;
    v16 = (unsigned __int8*) v4 [55];
    v4 [61] = v15 >> 3;
    sub_451060((int) v4, (int) (v4 + 60), v16 + 1, (unsigned __int8*) (v4 [54] + 1), *v16);
    sub_450A13((int) v4, (void*) v4 [54], (const void*) v4 [55], v4 [50] + 1);
    if(v4 [24])
        sub_44DC7D(v4);
    if(*((_BYTE*) v4 + 275) && (v4 [24] & 2) != 0) {
        v17 = *((_BYTE*) v4 + 276);
        if(v17 < 6u)
            sub_450D97(v4 + 60, v4 [55] + 1, v17);
        if(a4)
            sub_450B83((int) v4, a4, dword_46E650 [*((unsigned __int8*) v4 + 276)]);
        if(a3)
            sub_450B83((int) v4, a3, dword_46E634 [*((unsigned __int8*) v4 + 276)]);
    }
    else {
        if(a3)
            sub_450B83((int) v4, a3, 255);
        if(a4)
            sub_450B83((int) v4, a4, 255);
    }
    sub_451B3D(0, v4);
    result = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))v4 [91];
    if(result)
        return (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))result(
            v4,
            v4 [53],
            *((unsigned __int8*) v4 + 276));
    return result;
}
// 46E634: using guessed type int dword_46E634[7];
// 46E650: using guessed type int dword_46E650[7];

//----- (0044C31B) --------------------------------------------------------
int(__cdecl* __cdecl sub_44C31B(jmp_buf Buf, char** a2))(jmp_buf, int, _DWORD) {
    int(__cdecl * result)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
    int v4; // edi
    char** v5; // ebx
    int(__cdecl * v6)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD); // [esp+8h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+14h] [ebp+8h]

    result = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_44C733((int) Buf);
    v4 = Buf [47];
    Buf [48] = v4;
    if((int) result > 0) {
        v6 = result;
        do {
            v5 = a2;
            if(v4) {
                Bufa = (int*) v4;
                do {
                    result = sub_44BF73((int) v5, Buf, *v5, 0);
                    ++v5;
                    Bufa = (int*) ((char*) Bufa - 1);
                }
                while(Bufa);
            }
            v6 = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, _DWORD))((char*) v6 - 1);
        }
        while(v6);
    }
    return result;
}

//----- (0044C368) --------------------------------------------------------
int __cdecl sub_44C368(int a1, void* a2, void* a3) {
    int v3; // edi
    int v4; // esi
    int result; // eax
    int v6; // edx
    int v7; // esi
    char v8 [64]; // [esp+Ch] [ebp-40h] BYREF

    v3 = 0;
    if(a2)
        sub_44E101(a1, a2);
    if(a3)
        sub_44E101(a1, a3);
    sub_4509FA(a1, *(void**) (a1 + 156));
    sub_4509FA(a1, *(void**) (a1 + 220));
    sub_4509FA(a1, *(void**) (a1 + 216));
    sub_4509FA(a1, *(void**) (a1 + 372));
    sub_4509FA(a1, *(void**) (a1 + 376));
    sub_4509FA(a1, *(void**) (a1 + 312));
    if((*(_BYTE*) (a1 + 93) & 0x10) != 0)
        sub_44E097(a1, *(void**) (a1 + 260));
    if((*(_BYTE*) (a1 + 93) & 0x20) != 0)
        sub_4509FA(a1, *(void**) (a1 + 348));
    if(*(_DWORD*) (a1 + 324)) {
        v4 = 1 << (8 - *(_BYTE*) (a1 + 300));
        if(v4 > 0) {
            do
                sub_4509FA(a1, *(void**) (*(_DWORD*) (a1 + 324) + 4 * v3++));
            while(v3 < v4);
        }
        sub_4509FA(a1, *(void**) (a1 + 324));
    }
    sub_4504DA((_DWORD*) (a1 + 100));
    result = *(_DWORD*) (a1 + 72);
    v6 = *(_DWORD*) (a1 + 64);
    qmemcpy(v8, (const void*) a1, sizeof(v8));
    v7 = *(_DWORD*) (a1 + 68);
    memset((void*) a1, 0, 0x19Cu);
    *(_DWORD*) (a1 + 68) = v7;
    qmemcpy((void*) a1, v8, 0x40u);
    *(_DWORD*) (a1 + 64) = v6;
    *(_DWORD*) (a1 + 72) = result;
    return result;
}

//----- (0044C48B) --------------------------------------------------------
void __cdecl sub_44C48B(void** a1, void** a2, void** a3) {
    void* v3; // esi
    void* v4; // [esp+Ch] [ebp-8h]
    void* v5; // [esp+10h] [ebp-4h]

    v3 = 0;
    v5 = 0;
    v4 = 0;
    if(a1)
        v5 = *a1;
    if(a2)
        v3 = *a2;
    if(a3)
        v4 = *a3;
    if(v5)
        sub_44C368((int) v5, v3, v4);
    if(v3) {
        sub_4509B7(v3);
        *a2 = 0;
    }
    if(v4) {
        sub_4509B7(v4);
        *a3 = 0;
    }
    if(v5) {
        sub_4509B7(v5);
        *a1 = 0;
    }
}

//----- (0044C50C) --------------------------------------------------------
int __cdecl sub_44C50C(int a1, int a2, int a3) {
    if(a1 && a2)
        return a3 & *(_DWORD*) (a2 + 8);
    else
        return 0;
}

//----- (0044C526) --------------------------------------------------------
int __cdecl sub_44C526(int a1, int a2) {
    if(a1 && a2)
        return *(_DWORD*) (a2 + 12);
    else
        return 0;
}

//----- (0044C53C) --------------------------------------------------------
char __cdecl sub_44C53C(int a1, int a2) {
    if(a1 && a2)
        return *(_BYTE*) (a2 + 29);
    else
        return 0;
}

//----- (0044C552) --------------------------------------------------------
int __cdecl sub_44C552(int a1, int a2, double* a3) {
    if(!a1 || !a2 || (*(_BYTE*) (a2 + 8) & 1) == 0 || !a3)
        return 0;
    *a3 = *(float*) (a2 + 40);
    return 1;
}

//----- (0044C57B) --------------------------------------------------------
int __cdecl sub_44C57B(int a1, int a2, _DWORD* a3) {
    int result; // eax

    if(!a1)
        return 0;
    if(!a2)
        return 0;
    result = 2048;
    if((*(_DWORD*) (a2 + 8) & 0x800) == 0 || !a3)
        return 0;
    *a3 = *(unsigned __int8*) (a2 + 44);
    return result;
}

//----- (0044C5A6) --------------------------------------------------------
int __cdecl sub_44C5A6(
    int a1,
    int a2,
    unsigned int* a3,
    _DWORD* a4,
    _DWORD* a5,
    _DWORD* a6,
    _DWORD* a7,
    _DWORD* a8,
    _DWORD* a9) {
    int v9; // eax

    if(!a1 || !a2 || !a3 || !a4 || !a5 || !a6)
        return 0;
    *a3 = *(_DWORD*) a2;
    *a4 = *(_DWORD*) (a2 + 4);
    *a5 = *(unsigned __int8*) (a2 + 24);
    *a6 = *(unsigned __int8*) (a2 + 25);
    if(a8)
        *a8 = *(unsigned __int8*) (a2 + 26);
    if(a9)
        *a9 = *(unsigned __int8*) (a2 + 27);
    if(a7)
        *a7 = *(unsigned __int8*) (a2 + 28);
    if(*a6 == 3)
        v9 = 1;
    else
        v9 = *a6 & 2 | 1;
    if((*a6 & 4) != 0)
        ++v9;
    if(*a3 > 0x7FFFFFFFu / ((v9 * *a5 + 7) >> 3))
        sub_44BC7D(a1, (int) "Width too large for libpng to process image data.");
    return 1;
}

//----- (0044C677) --------------------------------------------------------
int __cdecl sub_44C677(int a1, int a2, _DWORD* a3, _DWORD* a4) {
    if(!a1 || !a2 || (*(_BYTE*) (a2 + 8) & 8) == 0 || !a3)
        return 0;
    *a3 = *(_DWORD*) (a2 + 16);
    *a4 = *(unsigned __int16*) (a2 + 20);
    return 8;
}

//----- (0044C6AA) --------------------------------------------------------
int __cdecl sub_44C6AA(int a1, int a2, _DWORD* a3, _DWORD* a4, _DWORD* a5) {
    int result; // eax

    result = 0;
    if(a1 && a2 && (*(_BYTE*) (a2 + 8) & 0x10) != 0) {
        if(*(_BYTE*) (a2 + 25) == 3) {
            if(a3) {
                *a3 = *(_DWORD*) (a2 + 48);
                result = 16;
            }
            if(a5)
                *a5 = a2 + 52;
        }
        else {
            if(a5) {
                *a5 = a2 + 52;
                result = 16;
            }
            if(a3)
                *a3 = 0;
        }
        if(a4) {
            *a4 = *(unsigned __int16*) (a2 + 22);
            return result | 0x10;
        }
    }
    return result;
}

//----- (0044C711) --------------------------------------------------------
int __cdecl sub_44C711(int a1) {
    int result; // eax

    result = a1;
    *(_DWORD*) (a1 + 96) |= 1u;
    return result;
}

//----- (0044C71A) --------------------------------------------------------
int __cdecl sub_44C71A(int a1) {
    int result; // eax

    result = a1;
    if(*(_BYTE*) (a1 + 279) < 8u) {
        *(_DWORD*) (a1 + 96) |= 4u;
        *(_BYTE*) (a1 + 280) = 8;
    }
    return result;
}

//----- (0044C733) --------------------------------------------------------
int __cdecl sub_44C733(int a1) {
    if(!*(_BYTE*) (a1 + 275))
        return 1;
    *(_DWORD*) (a1 + 96) |= 2u;
    return 7;
}

//----- (0044C74C) --------------------------------------------------------
int __cdecl sub_44C74C(int a1, unsigned __int8 a2, int a3) {
    int result; // eax
    char v4; // cl

    result = a1;
    *(_BYTE*) (a1 + 97) |= 0x80u;
    *(_WORD*) (a1 + 286) = a2;
    if(a3 == 1)
        *(_BYTE*) (a1 + 92) |= 0x80u;
    else
        *(_BYTE*) (a1 + 92) &= ~0x80u;
    v4 = *(_BYTE*) (a1 + 278);
    if(v4 == 2)
        *(_BYTE*) (a1 + 283) = 4;
    if(!v4 && *(_BYTE*) (a1 + 279) >= 8u)
        *(_BYTE*) (a1 + 283) = 2;
    return result;
}

//----- (0044C799) --------------------------------------------------------
char __cdecl sub_44C799(int* a1, char* a2) {
    char* v2; // eax
    char v3; // dl
    int v4; // ecx
    int v5; // esi
    char v6; // dl
    int v7; // esi
    char v8; // dl
    int v9; // esi
    char v10; // cl
    char v11; // dl
    char v12; // cl
    int v13; // esi
    char v14; // cl
    char v15; // dl
    char v16; // cl

    LOBYTE(v2) = (_BYTE) a1;
    v3 = *((_BYTE*) a1 + 8);
    if((v3 & 2) != 0) {
        v4 = *a1;
        LOBYTE(v2) = *((_BYTE*) a1 + 9);
        if((_BYTE) v2 == 8) {
            if(v3 == 2) {
                v2 = a2;
                if(v4) {
                    v5 = *a1;
                    do {
                        v6 = *v2;
                        *v2 = v2 [2];
                        v2 [2] = v6;
                        v2 += 3;
                        --v5;
                    }
                    while(v5);
                }
            }
            else if(v3 == 6) {
                v2 = a2;
                if(v4) {
                    v7 = *a1;
                    do {
                        v8 = *v2;
                        *v2 = v2 [2];
                        v2 [2] = v8;
                        v2 += 4;
                        --v7;
                    }
                    while(v7);
                }
            }
        }
        else if((_BYTE) v2 == 16) {
            if(v3 == 2) {
                if(v4) {
                    v2 = a2 + 1;
                    v9 = *a1;
                    do {
                        v10 = *(v2 - 1);
                        *(v2 - 1) = v2 [3];
                        v11 = v2 [4];
                        v2 [3] = v10;
                        v12 = *v2;
                        *v2 = v11;
                        v2 [4] = v12;
                        v2 += 6;
                        --v9;
                    }
                    while(v9);
                }
            }
            else if(v3 == 6 && v4) {
                v2 = a2 + 1;
                v13 = *a1;
                do {
                    v14 = *(v2 - 1);
                    *(v2 - 1) = v2 [3];
                    v15 = v2 [4];
                    v2 [3] = v14;
                    v16 = *v2;
                    *v2 = v15;
                    v2 [4] = v16;
                    v2 += 8;
                    --v13;
                }
                while(v13);
            }
        }
    }
    return (char) v2;
}

//----- (0044C858) --------------------------------------------------------
int __cdecl sub_44C858(int a1) {
    int result; // eax

    result = a1;
    *(_BYTE*) (a1 + 97) |= 4u;
    return result;
}

//----- (0044C861) --------------------------------------------------------
int __cdecl sub_44C861(int a1, double a2, double a3) {
    int result; // eax

    result = a1;
    if(fabs(a2 * a3 - 1.0) > 0.05)
        *(_BYTE*) (a1 + 97) |= 0x20u;
    *(float*) (a1 + 304) = a3;
    *(float*) (a1 + 308) = a2;
    return result;
}

//----- (0044C897) --------------------------------------------------------
int __cdecl sub_44C897(int a1) {
    int result; // eax

    result = a1;
    *(_BYTE*) (a1 + 97) |= 0x10u;
    return result;
}

//----- (0044C8A0) --------------------------------------------------------
unsigned int __cdecl sub_44C8A0(int a1, int a2) {
    char v2; // dl
    char v3; // dl
    char v4; // dl
    unsigned __int8 v5; // al
    unsigned int result; // eax

    if((*(_BYTE*) (a1 + 97) & 0x10) != 0) {
        v2 = *(_BYTE*) (a2 + 25);
        if(v2 == 3) {
            *(_BYTE*) (a2 + 25) = 4 * (*(_WORD*) (a1 + 266) != 0) + 2;
        }
        else {
            if(*(_WORD*) (a1 + 266))
                *(_BYTE*) (a2 + 25) = v2 | 4;
            if(*(_BYTE*) (a2 + 24) >= 8u)
                goto LABEL_8;
        }
        *(_BYTE*) (a2 + 24) = 8;
        LABEL_8:
        *(_WORD*) (a2 + 22) = 0;
    }
    if((*(_BYTE*) (a1 + 97) & 0x20) != 0)
        *(_DWORD*) (a2 + 40) = *(_DWORD*) (a1 + 304);
    if((*(_BYTE*) (a1 + 97) & 4) != 0 && *(_BYTE*) (a2 + 24) == 16)
        *(_BYTE*) (a2 + 24) = 8;
    if((*(_BYTE*) (a1 + 96) & 0x40) != 0) {
        v3 = *(_BYTE*) (a2 + 25);
        if((v3 == 2 || v3 == 6) && *(_DWORD*) (a1 + 372) && *(_BYTE*) (a2 + 24) == 8)
            *(_BYTE*) (a2 + 25) = 3;
    }
    if((*(_BYTE*) (a1 + 96) & 4) != 0 && *(_BYTE*) (a2 + 24) < 8u)
        *(_BYTE*) (a2 + 24) = 8;
    v4 = *(_BYTE*) (a2 + 25);
    if(v4 == 3 || (v4 & 2) == 0)
        *(_BYTE*) (a2 + 29) = 1;
    else
        *(_BYTE*) (a2 + 29) = 3;
    if((v4 & 4) != 0)
        ++* (_BYTE*) (a2 + 29);
    if(*(char*) (a1 + 97) < 0 && (v4 == 2 || !v4))
        ++* (_BYTE*) (a2 + 29);
    v5 = *(_BYTE*) (a2 + 29) * *(_BYTE*) (a2 + 24);
    *(_BYTE*) (a2 + 30) = v5;
    result = (*(_DWORD*) a2 * (unsigned int) v5 + 7) >> 3;
    *(_DWORD*) (a2 + 12) = result;
    return result;
}

//----- (0044C98B) --------------------------------------------------------
void __cdecl sub_44C98B(int* a1, int a2) {
    int* v2; // ebx
    unsigned __int8 v3; // cl
    int v4; // eax
    int v5; // ecx
    int v6; // ecx
    _BYTE* v7; // esi
    _BYTE* v8; // edi
    int v9; // edx
    _BYTE* v10; // esi
    _BYTE* v11; // edi
    int v12; // edx
    _BYTE* v13; // esi
    _BYTE* v14; // edi
    int v15; // edx
    unsigned __int8 v16; // dl
    int v17; // [esp+10h] [ebp+Ch]
    int v18; // [esp+10h] [ebp+Ch]
    int v19; // [esp+10h] [ebp+Ch]

    v2 = a1;
    v3 = *((_BYTE*) a1 + 9);
    if(v3 < 8u) {
        v4 = *a1;
        v5 = v3 - 1;
        if(v5) {
            v6 = v5 - 1;
            if(v6) {
                if(v6 != 2)
                    goto LABEL_26;
                v7 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 1));
                v8 = (_BYTE*) (v4 + a2 - 1);
                v9 = 4 - 4 * ((v4 - 1) & 1);
                if(!v4)
                    goto LABEL_26;
                v17 = *a1;
                do {
                    *v8 = (*v7 >> v9) & 0xF;
                    if(v9 == 4) {
                        v9 = 0;
                        --v7;
                    }
                    else {
                        v9 = 4;
                    }
                    --v8;
                    --v17;
                }
                while(v17);
                goto LABEL_25;
            }
            v10 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 2));
            v11 = (_BYTE*) (v4 + a2 - 1);
            v12 = 6 - 2 * ((v4 - 1) & 3);
            if(v4) {
                v18 = *a1;
                do {
                    *v11 = (*v10 >> v12) & 3;
                    if(v12 == 6) {
                        v12 = 0;
                        --v10;
                    }
                    else {
                        v12 += 2;
                    }
                    --v11;
                    --v18;
                }
                while(v18);
                LABEL_25:
                v2 = a1;
            }
        }
        else {
            v13 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 3));
            v14 = (_BYTE*) (v4 + a2 - 1);
            v15 = 7 - ((v4 - 1) & 7);
            if(v4) {
                v19 = *a1;
                do {
                    *v14 = (*v13 >> v15) & 1;
                    if(v15 == 7) {
                        v15 = 0;
                        --v13;
                    }
                    else {
                        ++v15;
                    }
                    --v14;
                    --v19;
                }
                while(v19);
                goto LABEL_25;
            }
        }
        LABEL_26:
        v16 = *((_BYTE*) v2 + 10);
        *((_BYTE*) v2 + 9) = 8;
        *((_BYTE*) v2 + 11) = 8 * v16;
        v2 [1] = v4 * v16;
    }
}

//----- (0044CA9A) --------------------------------------------------------
char __cdecl sub_44CA9A(int* a1, _BYTE* a2, unsigned __int8* a3) {
    int i; // eax
    int v5; // edi
    bool v6; // zf
    int v7; // edx
    int v8; // ebx
    int v9; // ebx
    int v10; // ecx
    unsigned __int8* v11; // esi
    _BYTE* v12; // esi
    _BYTE* v13; // esi
    unsigned int j; // edi
    int v15; // esi
    _BYTE* v16; // edi
    int v17; // esi
    int v19 [4]; // [esp+Ch] [ebp-10h] BYREF
    __int16 v20; // [esp+24h] [ebp+8h]
    unsigned int k; // [esp+28h] [ebp+Ch]
    unsigned int v22; // [esp+28h] [ebp+Ch]

    LOBYTE(i) = *((_BYTE*) a1 + 8);
    if((_BYTE) i != 3) {
        v20 = 0;
        v5 = *a1;
        v6 = (i & 2) == 0;
        LOBYTE(i) = (_BYTE) a3;
        if(v6) {
            v7 = *((unsigned __int8*) a1 + 9) - a3 [3];
            v9 = 1;
        }
        else {
            v7 = *((unsigned __int8*) a1 + 9) - *a3;
            v8 = a3 [2];
            v19 [1] = *((unsigned __int8*) a1 + 9) - a3 [1];
            v19 [2] = *((unsigned __int8*) a1 + 9) - v8;
            v9 = 3;
        }
        v6 = (a1 [2] & 4) == 0;
        v19 [0] = v7;
        if(!v6) {
            i = *((unsigned __int8*) a1 + 9) - a3 [4];
            v19 [v9] = i;
            LOBYTE(v7) = v19 [0];
            ++v9;
        }
        v10 = 0;
        if(v9 > 0) {
            do {
                i = (int) &v19 [v10];
                if(*(int*) i > 0) {
                    v20 = 1;
                }
                else {
                    *(_DWORD*) i = 0;
                    LOBYTE(v7) = v19 [0];
                }
                ++v10;
            }
            while(v10 < v9);
            if(v20) {
                if(*((_BYTE*) a1 + 9) == 2) {
                    v17 = a1 [1];
                    for(i = (int) a2; v17; --v17) {
                        *(_BYTE*) i = (*(_BYTE*) i >> 1) & 0x55;
                        ++i;
                    }
                }
                else if(*((_BYTE*) a1 + 9) == 4) {
                    v15 = a1 [1];
                    v16 = a2;
                    for(LOBYTE(i) = (15 >> v7) | (240 >> v7) & 0xF0; v15; --v15) {
                        *v16 = i & (*v16 >> v7);
                        ++v16;
                    }
                }
                else {
                    LOBYTE(i) = *((_BYTE*) a1 + 9) - 8;
                    if(*((_BYTE*) a1 + 9) == 8) {
                        v13 = a2;
                        v22 = v9 * v5;
                        for(j = 0; j < v22; ++j) {
                            i = j / v9;
                            *v13++ >>= LOBYTE(v19 [j % v9]);
                        }
                    }
                    else {
                        LOBYTE(i) = *((_BYTE*) a1 + 9) - 16;
                        if(*((_BYTE*) a1 + 9) == 16) {
                            v11 = a2;
                            for(k = 0; k < v9 * v5; LOBYTE(i) = k) {
                                LOWORD(i) = (unsigned __int16) (v11 [1] + (*v11 << 8)) >> LOWORD(v19 [k % v9]);
                                *v11 = BYTE1(i);
                                v12 = v11 + 1;
                                *v12 = i;
                                v11 = v12 + 1;
                                ++k;
                            }
                        }
                    }
                }
            }
        }
    }
    return i;
}

//----- (0044CC15) --------------------------------------------------------
int __cdecl sub_44CC15(int a1, _BYTE* a2) {
    int result; // eax
    _BYTE* v3; // esi
    char* v4; // edx
    int v5; // edi
    char v6; // cl
    unsigned __int8 v7; // dl
    int v8; // ecx

    result = a1;
    if(*(_BYTE*) (a1 + 9) == 16) {
        v3 = a2;
        v4 = a2;
        if(*(_DWORD*) a1 * *(unsigned __int8*) (a1 + 10)) {
            v5 = *(_DWORD*) a1 * *(unsigned __int8*) (a1 + 10);
            do {
                v6 = *v4;
                v4 += 2;
                *v3++ = v6;
                --v5;
            }
            while(v5);
        }
        v7 = *(_BYTE*) (a1 + 10);
        v8 = *(_DWORD*) a1 * v7;
        *(_BYTE*) (a1 + 9) = 8;
        *(_BYTE*) (a1 + 11) = 8 * v7;
        *(_DWORD*) (a1 + 4) = v8;
    }
    return result;
}

//----- (0044CC59) --------------------------------------------------------
unsigned int __cdecl sub_44CC59(int a1, int a2, unsigned int a3, char a4) {
    char v4; // cl
    unsigned int result; // eax
    unsigned int v6; // ebx
    char v7; // cl
    _BYTE* v8; // ecx
    _BYTE* v9; // edi
    _BYTE* v10; // edi
    bool v11; // zf
    _BYTE* v12; // edi
    _BYTE* v14; // ecx
    _BYTE* v15; // edi
    _BYTE* v16; // ecx
    _BYTE* v17; // edi
    _BYTE* v18; // ecx
    char* v19; // edi
    char v20; // cl
    char* v21; // edi
    char v22; // cl
    _BYTE* v23; // ecx
    _BYTE* v24; // edi
    _BYTE* v25; // edi
    _BYTE* v26; // ecx
    char v27; // bl
    _BYTE* v28; // edi
    _BYTE* v29; // ecx
    _BYTE* v30; // edi
    _BYTE* v31; // ecx
    _BYTE* v32; // edi
    _BYTE* v33; // ecx
    _BYTE* v34; // ecx
    _BYTE* v35; // edi
    char v36; // bl
    _BYTE* v37; // ecx
    _BYTE* v38; // edi
    _BYTE* v39; // ecx
    unsigned int v40; // [esp+18h] [ebp+Ch]
    unsigned int v41; // [esp+18h] [ebp+Ch]
    unsigned int v42; // [esp+18h] [ebp+Ch]
    char* v43; // [esp+18h] [ebp+Ch]
    char* v44; // [esp+18h] [ebp+Ch]
    unsigned int v45; // [esp+18h] [ebp+Ch]
    unsigned int v46; // [esp+18h] [ebp+Ch]
    unsigned int v47; // [esp+18h] [ebp+Ch]
    unsigned int v48; // [esp+18h] [ebp+Ch]
    _BYTE* v49; // [esp+20h] [ebp+14h]
    unsigned int v50; // [esp+20h] [ebp+14h]

    v4 = *(_BYTE*) (a1 + 8);
    result = *(_DWORD*) a1;
    v6 = a3 >> 8;
    if(v4) {
        if(v4 != 2)
            return result;
        v22 = *(_BYTE*) (a1 + 9);
        if(v22 == 8) {
            if(a4 >= 0) {
                v28 = (_BYTE*) (a2 + 2 * result + result);
                v29 = &v28 [result];
                if(result) {
                    v46 = *(_DWORD*) a1;
                    do {
                        v30 = v28 - 1;
                        v31 = v29 - 1;
                        *v31 = *v30--;
                        *--v31 = *v30;
                        v28 = v30 - 1;
                        *--v31 = *v28;
                        v29 = v31 - 1;
                        v11 = v46-- == 1;
                        *v29 = a3;
                    }
                    while(!v11);
                }
            }
            else {
                v23 = (_BYTE*) (a2 + 2 * result + result);
                v24 = &v23 [result];
                if(result > 1) {
                    v45 = result - 1;
                    do {
                        v25 = v24 - 1;
                        *v25 = a3;
                        v26 = v23 - 1;
                        *--v25 = *v26;
                        v27 = *--v26;
                        --v25;
                        v23 = v26 - 1;
                        *v25 = v27;
                        v24 = v25 - 1;
                        v11 = v45-- == 1;
                        *v24 = *v23;
                    }
                    while(!v11);
                }
                *(v24 - 1) = a3;
            }
            *(_BYTE*) (a1 + 11) = 32;
            result *= 4;
        }
        else {
            if(v22 != 16)
                return result;
            v32 = (_BYTE*) (a2 + 2 * result + result);
            v33 = &v32 [result];
            if(a4 >= 0) {
                if(result) {
                    v48 = *(_DWORD*) a1;
                    do {
                        v38 = v32 - 1;
                        v39 = v33 - 1;
                        *v39 = *v38--;
                        *--v39 = *v38--;
                        *--v39 = *v38--;
                        *--v39 = *v38--;
                        *--v39 = *v38;
                        v32 = v38 - 1;
                        *--v39 = *v32;
                        *--v39 = BYTE1(a3);
                        v33 = v39 - 1;
                        v11 = v48-- == 1;
                        *v33 = a3;
                    }
                    while(!v11);
                }
            }
            else {
                if(result > 1) {
                    v47 = result - 1;
                    do {
                        v34 = v33 - 1;
                        *v34-- = BYTE1(a3);
                        *v34 = a3;
                        v35 = v32 - 1;
                        *--v34 = *v35--;
                        *--v34 = *v35--;
                        *--v34 = *v35--;
                        *--v34 = *v35;
                        v36 = *--v35;
                        --v34;
                        v32 = v35 - 1;
                        *v34 = v36;
                        v33 = v34 - 1;
                        v11 = v47-- == 1;
                        *v33 = *v32;
                    }
                    while(!v11);
                    LOBYTE(v6) = BYTE1(a3);
                }
                v37 = v33 - 1;
                *v37 = v6;
                *(v37 - 1) = a3;
            }
            *(_BYTE*) (a1 + 11) = 64;
            result *= 8;
        }
        *(_BYTE*) (a1 + 10) = 4;
    }
    else {
        v7 = *(_BYTE*) (a1 + 9);
        if(v7 == 8) {
            v8 = (_BYTE*) (result + a2);
            v9 = (_BYTE*) (result + a2 + result);
            if(a4 >= 0) {
                if(result) {
                    v41 = *(_DWORD*) a1;
                    do {
                        --v8;
                        v12 = v9 - 1;
                        *v12 = *v8;
                        v9 = v12 - 1;
                        v11 = v41-- == 1;
                        *v9 = a3;
                    }
                    while(!v11);
                }
            }
            else {
                if(result > 1) {
                    v40 = result - 1;
                    do {
                        v10 = v9 - 1;
                        --v8;
                        *v10 = a3;
                        v9 = v10 - 1;
                        v11 = v40-- == 1;
                        *v9 = *v8;
                    }
                    while(!v11);
                }
                *(v9 - 1) = a3;
            }
            *(_BYTE*) (a1 + 10) = 2;
            *(_BYTE*) (a1 + 11) = 16;
            result *= 2;
        }
        else {
            if(v7 != 16)
                return result;
            if(a4 >= 0) {
                v43 = (char*) (result + a2);
                v19 = (char*) (result + result + a2);
                if(result) {
                    v50 = *(_DWORD*) a1;
                    do {
                        v44 = v43 - 1;
                        v20 = *v44;
                        v21 = v19 - 1;
                        v43 = v44 - 1;
                        *v21-- = v20;
                        *v21-- = *v43;
                        *v21 = BYTE1(a3);
                        v19 = v21 - 1;
                        v11 = v50-- == 1;
                        *v19 = a3;
                    }
                    while(!v11);
                }
            }
            else {
                v49 = (_BYTE*) (result + a2);
                v14 = (_BYTE*) (result + result + a2);
                if(result > 1) {
                    v42 = result - 1;
                    v15 = v49;
                    do {
                        v16 = v14 - 1;
                        *v16-- = v6;
                        *v16 = a3;
                        v17 = v15 - 1;
                        *--v16 = *v17;
                        v15 = v17 - 1;
                        v14 = v16 - 1;
                        v11 = v42-- == 1;
                        *v14 = *v15;
                        LOBYTE(v6) = BYTE1(a3);
                    }
                    while(!v11);
                }
                v18 = v14 - 1;
                *v18 = v6;
                *(v18 - 1) = a3;
            }
            *(_BYTE*) (a1 + 10) = 2;
            *(_BYTE*) (a1 + 11) = 32;
            result *= 4;
        }
    }
    *(_DWORD*) (a1 + 4) = result;
    return result;
}

//----- (0044CE90) --------------------------------------------------------
unsigned __int8* __cdecl sub_44CE90(int* a1, _BYTE* a2, unsigned __int8* a3, int a4, char a5) {
    unsigned __int8* result; // eax
    int* v7; // edi
    unsigned __int8 v8; // cl
    int v9; // edx
    _BYTE* v10; // ecx
    int v11; // esi
    _BYTE* v12; // ecx
    __int16 v13; // cx
    unsigned __int8* v14; // eax
    __int16 v15; // cx
    __int16 v16; // cx
    _BYTE* v17; // ecx
    int v18; // esi
    int v19; // edi
    __int16 v20; // cx
    _BYTE* v21; // ecx
    int v22; // esi
    _BYTE* v23; // ecx
    __int16 v24; // cx
    unsigned __int8* v25; // eax
    __int16 v26; // cx
    __int16 v27; // cx
    char v28; // cl
    int v29; // edx
    int v30; // edi
    char* v31; // ecx
    bool v32; // zf
    char v33; // cl
    _BYTE* v34; // esi
    unsigned int v35; // edi
    _BYTE* v36; // ecx
    int v37; // esi
    int v38; // edi
    __int16 v39; // cx
    int v40; // [esp+Ch] [ebp-Ch]
    int v41; // [esp+24h] [ebp+Ch]
    int v42; // [esp+24h] [ebp+Ch]
    unsigned int v43; // [esp+28h] [ebp+10h]
    char* v44; // [esp+2Ch] [ebp+14h]

    result = a3;
    v7 = a1;
    v8 = *((_BYTE*) a1 + 9);
    v9 = *a1;
    v40 = *a1;
    if(v8 <= 8u && a3 || v8 == 16 && a4) {
        if(*((_BYTE*) a1 + 8)) {
            switch(*((_BYTE*) a1 + 8)) {
                case 2:
                    if(v8 == 8) {
                        v21 = a2;
                        if(v9) {
                            v22 = *a1;
                            do {
                                *v21 = a3 [(unsigned __int8) *v21];
                                v23 = v21 + 1;
                                *v23 = a3 [(unsigned __int8) *v23];
                                ++v23;
                                *v23 = a3 [(unsigned __int8) *v23];
                                v21 = v23 + 1;
                                --v22;
                            }
                            while(v22);
                        }
                    }
                    else {
                        result = a2;
                        if(v9) {
                            v42 = *a1;
                            do {
                                v24 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (result [1] >> a5)) + 2 * *result);
                                result [1] = v24;
                                *result = HIBYTE(v24);
                                v25 = result + 2;
                                v26 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (v25 [1] >> a5)) + 2 * *v25);
                                *v25 = HIBYTE(v26);
                                v25 [1] = v26;
                                v25 += 2;
                                v27 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (v25 [1] >> a5)) + 2 * *v25);
                                *v25 = HIBYTE(v27);
                                v25 [1] = v27;
                                result = v25 + 2;
                                --v42;
                            }
                            while(v42);
                        }
                    }
                    break;
                case 4:
                    if(v8 == 8) {
                        v17 = a2;
                        if(v9) {
                            v18 = *a1;
                            do {
                                *v17 = a3 [(unsigned __int8) *v17];
                                v17 += 2;
                                --v18;
                            }
                            while(v18);
                        }
                    }
                    else {
                        result = a2;
                        if(v9) {
                            v19 = *a1;
                            do {
                                v20 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (result [1] >> a5)) + 2 * *result);
                                *result = HIBYTE(v20);
                                result [1] = v20;
                                result += 4;
                                --v19;
                            }
                            while(v19);
                        }
                    }
                    break;
                case 6:
                    if(v8 == 8) {
                        v10 = a2;
                        if(v9) {
                            v11 = *a1;
                            do {
                                *v10 = a3 [(unsigned __int8) *v10];
                                v12 = v10 + 1;
                                *v12 = a3 [(unsigned __int8) *v12];
                                ++v12;
                                *v12 = a3 [(unsigned __int8) *v12];
                                v10 = v12 + 2;
                                --v11;
                            }
                            while(v11);
                        }
                    }
                    else {
                        result = a2;
                        if(v9) {
                            v41 = *a1;
                            do {
                                v13 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (result [1] >> a5)) + 2 * *result);
                                result [1] = v13;
                                *result = HIBYTE(v13);
                                v14 = result + 2;
                                v15 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (v14 [1] >> a5)) + 2 * *v14);
                                *v14 = HIBYTE(v15);
                                v14 [1] = v15;
                                v14 += 2;
                                v16 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (v14 [1] >> a5)) + 2 * *v14);
                                *v14 = HIBYTE(v16);
                                v14 [1] = v16;
                                result = v14 + 4;
                                --v41;
                            }
                            while(v41);
                        }
                    }
                    break;
            }
        }
        else {
            if(v8 == 2) {
                v44 = a2;
                if(v9) {
                    v43 = ((unsigned int) (v9 - 1) >> 2) + 1;
                    do {
                        v28 = *v44;
                        v29 = *v44 & 0xC;
                        v30 = *v44 & 0x30;
                        LOBYTE(v29) = result [*v44 & 0xC0 | ((*v44 & 0xC0 | ((*v44 & 0xC0 | ((*v44 & 0xC0) >> 2)) >> 2)) >> 2)] & 0xC0 | ((unsigned __int8) (result [v30 | (4 * v30) | ((v30 | (v30 >> 2)) >> 2)] & 0xC3 | ((unsigned __int8) ((result [v28 & 3 | (4 * (v28 & 3 | (4 * (v28 & 3 | (4 * (v28 & 3))))))] >> 2) | result [v29 | (v29 >> 2) | (4 * (v29 | (4 * (v28 & 0xC))))] & 0xCF) >> 2)) >> 2);
                        v31 = v44++;
                        v32 = v43-- == 1;
                        *v31 = v29;
                    }
                    while(!v32);
                    v9 = v40;
                    v7 = a1;
                }
            }
            v33 = *((_BYTE*) v7 + 9);
            switch(v33) {
                case 4:
                    v34 = a2;
                    if(v9) {
                        v35 = ((unsigned int) (v9 - 1) >> 1) + 1;
                        do {
                            *v34 = (result [*v34 & 0xF | (16 * (*v34 & 0xF))] >> 4) | result [*v34 & 0xF0 | ((*v34 & 0xF0) >> 4)] & 0xF0;
                            ++v34;
                            --v35;
                        }
                        while(v35);
                    }
                    break;
                case 8:
                    v36 = a2;
                    if(v9) {
                        v37 = v9;
                        do {
                            *v36 = result [(unsigned __int8) *v36];
                            ++v36;
                            --v37;
                        }
                        while(v37);
                    }
                    break;
                case 16:
                    result = a2;
                    if(v9) {
                        v38 = v9;
                        do {
                            v39 = *(_WORD*) (*(_DWORD*) (a4 + 4 * (result [1] >> a5)) + 2 * *result);
                            *result = HIBYTE(v39);
                            result [1] = v39;
                            result += 2;
                            --v38;
                        }
                        while(v38);
                    }
                    break;
            }
        }
    }
    return result;
}

//----- (0044D202) --------------------------------------------------------
int __cdecl sub_44D202(int* a1, int a2, int a3, int a4, int a5) {
    int result; // eax
    unsigned __int8 v7; // cl
    int v9; // ecx
    int v10; // ecx
    int v11; // ecx
    _BYTE* v12; // edx
    bool v13; // zf
    int v14; // ecx
    _BYTE* v15; // edx
    int v16; // ecx
    _BYTE* v17; // edx
    unsigned __int8* v18; // edx
    int v19; // ebx
    _BYTE* v20; // ecx
    _BYTE* v21; // ecx
    _BYTE* v22; // ecx
    _BYTE* v23; // ecx
    int v24; // [esp+Ch] [ebp-4h]
    int v25; // [esp+Ch] [ebp-4h]
    int v26; // [esp+Ch] [ebp-4h]
    int v27; // [esp+18h] [ebp+8h]
    int v28; // [esp+18h] [ebp+8h]
    int v29; // [esp+18h] [ebp+8h]
    int v30; // [esp+18h] [ebp+8h]
    int v31; // [esp+18h] [ebp+8h]
    _BYTE* v32; // [esp+1Ch] [ebp+Ch]
    _BYTE* v33; // [esp+1Ch] [ebp+Ch]
    _BYTE* v34; // [esp+1Ch] [ebp+Ch]
    int v35; // [esp+1Ch] [ebp+Ch]
    int v36; // [esp+24h] [ebp+14h]

    result = *a1;
    if(*((_BYTE*) a1 + 8) == 3) {
        v7 = *((_BYTE*) a1 + 9);
        if(v7 < 8u) {
            v9 = v7 - 1;
            if(v9) {
                v10 = v9 - 1;
                if(v10) {
                    if(v10 == 2) {
                        v32 = (_BYTE*) (result + a2 - 1);
                        LOBYTE(v11) = 4 * (result & 1);
                        v12 = (_BYTE*) (a2 + ((unsigned int) (result - 1) >> 1));
                        v27 = 4 * (*a1 & 1);
                        if(result) {
                            v24 = result;
                            do {
                                *v32 = (*v12 >> v11) & 0xF;
                                if(v27 == 4) {
                                    v11 = 0;
                                    --v12;
                                }
                                else {
                                    v11 = v27 + 4;
                                }
                                --v32;
                                v13 = v24-- == 1;
                                v27 = v11;
                            }
                            while(!v13);
                        }
                    }
                }
                else {
                    v33 = (_BYTE*) (result + a2 - 1);
                    LOBYTE(v14) = 2 * (3 - ((result - 1) & 3));
                    v15 = (_BYTE*) (a2 + ((unsigned int) (result - 1) >> 2));
                    v28 = 2 * (3 - (((_BYTE) result - 1) & 3));
                    if(result) {
                        v25 = result;
                        do {
                            *v33 = (*v15 >> v14) & 3;
                            if(v28 == 6) {
                                v14 = 0;
                                --v15;
                            }
                            else {
                                v14 = v28 + 2;
                            }
                            --v33;
                            v13 = v25-- == 1;
                            v28 = v14;
                        }
                        while(!v13);
                    }
                }
            }
            else {
                v34 = (_BYTE*) (result + a2 - 1);
                LOBYTE(v16) = 7 - ((result - 1) & 7);
                v17 = (_BYTE*) (a2 + ((unsigned int) (result - 1) >> 3));
                v29 = 7 - (((_BYTE) result - 1) & 7);
                if(result) {
                    v26 = result;
                    do {
                        *v34 = (*v17 >> v16) & 1;
                        if(v29 == 7) {
                            v16 = 0;
                            --v17;
                        }
                        else {
                            v16 = v29 + 1;
                        }
                        --v34;
                        v13 = v26-- == 1;
                        v29 = v16;
                    }
                    while(!v13);
                }
            }
            *((_BYTE*) a1 + 9) = 8;
            *((_BYTE*) a1 + 11) = 8;
            a1 [1] = result;
        }
        if(*((_BYTE*) a1 + 9) == 8) {
            v18 = (unsigned __int8*) (result + a2 - 1);
            if(a4) {
                v19 = 4 * result;
                v35 = 4 * result;
                v20 = (_BYTE*) (4 * result + a2 - 1);
                if(result) {
                    v30 = result;
                    result = a3;
                    do {
                        if(*v18 < a5)
                            *v20 = *(_BYTE*) (*v18 + a4);
                        else
                            *v20 = -1;
                        v21 = v20 - 1;
                        *v21-- = *(_BYTE*) (*v18 + a3 + 2 * *v18 + 2);
                        *v21-- = *(_BYTE*) (*v18 + a3 + 2 * *v18 + 1);
                        *v21 = *(_BYTE*) (*v18 + a3 + 2 * *v18);
                        v20 = v21 - 1;
                        --v18;
                        --v30;
                    }
                    while(v30);
                    v19 = v35;
                }
                *((_BYTE*) a1 + 11) = 32;
                *((_BYTE*) a1 + 8) = 6;
                *((_BYTE*) a1 + 10) = 4;
            }
            else {
                v19 = 3 * result;
                v31 = 3 * result;
                v22 = (_BYTE*) (3 * result + a2 - 1);
                if(result) {
                    v36 = result;
                    result = a3;
                    do {
                        *v22 = *(_BYTE*) (*v18 + a3 + 2 * *v18 + 2);
                        v23 = v22 - 1;
                        *v23-- = *(_BYTE*) (*v18 + a3 + 2 * *v18 + 1);
                        *v23 = *(_BYTE*) (*v18 + a3 + 2 * *v18);
                        v22 = v23 - 1;
                        --v18;
                        --v36;
                    }
                    while(v36);
                    v19 = v31;
                }
                *((_BYTE*) a1 + 11) = 24;
                *((_BYTE*) a1 + 8) = 2;
                *((_BYTE*) a1 + 10) = 3;
            }
            *((_BYTE*) a1 + 9) = 8;
            a1 [1] = v19;
        }
    }
    return result;
}

//----- (0044D409) --------------------------------------------------------
int __cdecl sub_44D409(int* a1, int a2, _WORD* a3) {
    char v4; // cl
    int result; // eax
    unsigned __int16 v6; // bx
    unsigned __int8 v7; // cl
    int v9; // ecx
    int v10; // ecx
    int v11; // ecx
    unsigned __int8* v12; // edx
    bool v13; // zf
    int v14; // ecx
    unsigned __int8* v15; // edx
    char v16; // bl
    int v17; // ecx
    _BYTE* v18; // edx
    char v19; // cl
    _BYTE* v20; // ecx
    _BYTE* v21; // edi
    int v22; // edx
    _BYTE* v23; // edi
    int v24; // edx
    _BYTE* v25; // ecx
    _BYTE* v26; // edi
    unsigned __int16 v27; // bx
    _BYTE* v28; // edi
    _BYTE* v29; // edi
    char v30; // cl
    unsigned __int8 v31; // cl
    _WORD* v32; // edx
    char v33; // cl
    _BYTE* v34; // ecx
    _BYTE* v35; // edi
    _BYTE* v36; // edi
    _BYTE* v37; // ecx
    _BYTE* v38; // ecx
    _BYTE* v39; // edi
    __int16 v40; // bx
    __int16 v41; // dx
    __int16 v42; // dx
    _BYTE* v43; // edi
    _BYTE* v44; // edi
    _BYTE* v45; // ecx
    char v46; // cl
    int v47; // [esp+Ch] [ebp-8h]
    int v48; // [esp+Ch] [ebp-8h]
    int v49; // [esp+Ch] [ebp-8h]
    unsigned __int16 v50; // [esp+10h] [ebp-4h]
    _BYTE* v51; // [esp+1Ch] [ebp+8h]
    _BYTE* v52; // [esp+1Ch] [ebp+8h]
    _BYTE* v53; // [esp+1Ch] [ebp+8h]
    int v54; // [esp+20h] [ebp+Ch]
    int v55; // [esp+20h] [ebp+Ch]
    int v56; // [esp+20h] [ebp+Ch]
    int v57; // [esp+20h] [ebp+Ch]
    int v58; // [esp+20h] [ebp+Ch]
    int v59; // [esp+24h] [ebp+10h]
    int v60; // [esp+24h] [ebp+10h]

    v4 = *((_BYTE*) a1 + 8);
    result = *a1;
    if(v4) {
        if(v4 == 2) {
            v32 = a3;
            if(a3) {
                v33 = *((_BYTE*) a1 + 9);
                if(v33 == 8) {
                    v34 = (_BYTE*) (a1 [1] + a2 - 1);
                    v35 = (_BYTE*) (a2 + 4 * result - 1);
                    if(result) {
                        v60 = *a1;
                        do {
                            if((unsigned __int8) *(v34 - 2) == v32 [1]
                               && (unsigned __int8) *(v34 - 1) == v32 [2]
                               && (unsigned __int8) *v34 == v32 [3]) {
                                *v35 = 0;
                            }
                            else {
                                *v35 = -1;
                            }
                            v36 = v35 - 1;
                            *v36-- = *v34;
                            v37 = v34 - 1;
                            *v36-- = *v37;
                            *v36 = *--v37;
                            v35 = v36 - 1;
                            v34 = v37 - 1;
                            --v60;
                        }
                        while(v60);
                    }
                }
                else if(v33 == 16) {
                    v38 = (_BYTE*) (a1 [1] + a2 - 1);
                    v39 = (_BYTE*) (a2 + 8 * result - 1);
                    if(result) {
                        v58 = *a1;
                        while(1) {
                            HIBYTE(v40) = *(v38 - 5);
                            LOBYTE(v40) = *(v38 - 4);
                            if(v40 == v32 [1]
                               && (HIBYTE(v41) = *(v38 - 3), LOBYTE(v41) = *(v38 - 2), v41 == a3 [2])
                               && (HIBYTE(v42) = *(v38 - 1), LOBYTE(v42) = *v38, v42 == a3 [3])) {
                                *v39 = 0;
                                v43 = v39 - 1;
                                *v43 = 0;
                            }
                            else {
                                *v39 = -1;
                                v43 = v39 - 1;
                                *v43 = -1;
                            }
                            v44 = v43 - 1;
                            *v44-- = *v38;
                            v45 = v38 - 1;
                            *v44-- = *v45;
                            *v44-- = *--v45;
                            *v44-- = *--v45;
                            *v44-- = *--v45;
                            *v44 = *--v45;
                            v39 = v44 - 1;
                            v38 = v45 - 1;
                            if(!--v58)
                                break;
                            v32 = a3;
                        }
                    }
                }
                v46 = *((_BYTE*) a1 + 9);
                *((_BYTE*) a1 + 8) = 6;
                *((_BYTE*) a1 + 10) = 4;
                v31 = 4 * v46;
                goto LABEL_68;
            }
        }
    }
    else {
        v6 = 0;
        if(a3)
            v6 = a3 [4];
        v7 = *((_BYTE*) a1 + 9);
        v50 = v6;
        if(v7 < 8u) {
            v9 = v7 - 1;
            if(v9) {
                v10 = v9 - 1;
                if(v10) {
                    if(v10 == 2) {
                        v51 = (_BYTE*) (result + a2 - 1);
                        v50 = 17 * v6;
                        LOBYTE(v11) = 4 - 4 * ((result - 1) & 1);
                        v12 = (unsigned __int8*) (a2 + ((unsigned int) (result - 1) >> 1));
                        v54 = 4 - 4 * (((_BYTE) result - 1) & 1);
                        if(result) {
                            v47 = result;
                            do {
                                *v51 = (*v12 >> v11) & 0xF | (16 * ((*v12 >> v11) & 0xF));
                                v11 = 4;
                                if(v54 == 4) {
                                    v11 = 0;
                                    --v12;
                                }
                                --v51;
                                v13 = v47-- == 1;
                                v54 = v11;
                            }
                            while(!v13);
                        }
                    }
                }
                else {
                    v50 = 85 * v6;
                    v52 = (_BYTE*) (result + a2 - 1);
                    v14 = (unsigned __int8) (2 * (3 - ((result - 1) & 3)));
                    v15 = (unsigned __int8*) (a2 + ((unsigned int) (result - 1) >> 2));
                    v55 = 2 * (3 - (((_BYTE) result - 1) & 3));
                    if(result) {
                        v48 = result;
                        do {
                            v16 = (*v15 >> v14) & 3;
                            *v52 = v16 | (4 * (v16 | (4 * (v16 | (4 * v16)))));
                            if(v55 == 6) {
                                v14 = 0;
                                --v15;
                            }
                            else {
                                v14 = v55 + 2;
                            }
                            --v52;
                            v13 = v48-- == 1;
                            v55 = v14;
                        }
                        while(!v13);
                    }
                }
            }
            else {
                v50 = 255 * v6;
                v53 = (_BYTE*) (result + a2 - 1);
                v17 = (unsigned __int8) (7 - ((result - 1) & 7));
                v18 = (_BYTE*) (a2 + ((unsigned int) (result - 1) >> 3));
                v56 = 7 - (((_BYTE) result - 1) & 7);
                if(result) {
                    v49 = result;
                    do {
                        *v53 = -(((*v18 >> v17) & 1) != 0);
                        if(v56 == 7) {
                            v17 = 0;
                            --v18;
                        }
                        else {
                            v17 = v56 + 1;
                        }
                        --v53;
                        v13 = v49-- == 1;
                        v56 = v17;
                    }
                    while(!v13);
                }
            }
            v6 = v50;
            *((_BYTE*) a1 + 9) = 8;
            *((_BYTE*) a1 + 11) = 8;
            a1 [1] = result;
        }
        if(a3) {
            v19 = *((_BYTE*) a1 + 9);
            if(v19 == 8) {
                v20 = (_BYTE*) (result + a2 - 1);
                v21 = (_BYTE*) (a2 + 2 * result - 1);
                if(result) {
                    v22 = result;
                    do {
                        if((unsigned __int8) *v20 == v50)
                            *v21 = 0;
                        else
                            *v21 = -1;
                        v23 = v21 - 1;
                        *v23 = *v20;
                        v21 = v23 - 1;
                        --v20;
                        --v22;
                    }
                    while(v22);
                }
            }
            else if(v19 == 16) {
                v24 = a1 [1];
                v25 = (_BYTE*) (v24 + a2 - 1);
                v26 = (_BYTE*) (a2 + 2 * v24 - 1);
                if(result) {
                    v59 = result;
                    v57 = v6;
                    do {
                        HIBYTE(v27) = *(v25 - 1);
                        LOBYTE(v27) = *v25;
                        if(v27 == v57) {
                            *v26 = 0;
                            v28 = v26 - 1;
                            *v28 = 0;
                        }
                        else {
                            *v26 = -1;
                            v28 = v26 - 1;
                            *v28 = -1;
                        }
                        v29 = v28 - 1;
                        *v29-- = *v25;
                        *v29 = *(v25 - 1);
                        v26 = v29 - 1;
                        v25 -= 2;
                        --v59;
                    }
                    while(v59);
                }
            }
            v30 = *((_BYTE*) a1 + 9);
            *((_BYTE*) a1 + 8) = 4;
            *((_BYTE*) a1 + 10) = 2;
            v31 = 2 * v30;
            LABEL_68:
            *((_BYTE*) a1 + 11) = v31;
            a1 [1] = (result * (unsigned int) v31) >> 3;
        }
    }
    return result;
}

//----- (0044D75C) --------------------------------------------------------
int __cdecl sub_44D75C(int* a1, char* a2, int a3, int a4) {
    char v5; // cl
    int result; // eax
    char* v7; // edx
    char v8; // al
    char* v9; // edx
    char v10; // bl
    char v11; // al
    char* v12; // esi
    bool v13; // zf
    unsigned __int8 v14; // cl
    char* v15; // edx
    char v16; // al
    char* v17; // edx
    char v18; // bl
    char v19; // al
    char* v20; // esi
    char* i; // ecx
    int v22; // [esp+Ch] [ebp-4h]
    int v23; // [esp+18h] [ebp+8h]
    int v24; // [esp+18h] [ebp+8h]

    v5 = *((_BYTE*) a1 + 8);
    result = *a1;
    v22 = *a1;
    if(v5 == 2 && a3 && *((_BYTE*) a1 + 9) == 8) {
        v7 = a2;
        if(!result) {
            LABEL_8:
            v14 = *((_BYTE*) a1 + 9);
            *((_BYTE*) a1 + 11) = v14;
            *((_BYTE*) a1 + 8) = 3;
            *((_BYTE*) a1 + 10) = 1;
            a1 [1] = (result * (unsigned int) v14 + 7) >> 3;
            return result;
        }
        v23 = *a1;
        do {
            v8 = *v7;
            v9 = v7 + 1;
            v10 = *v9++;
            v11 = *(_BYTE*) ((((int) (unsigned __int8) *v9 >> 3) & 0x1F | (4 * (v10 & 0xF8 | (32 * (v8 & 0xF8))))) + a3);
            v12 = a2;
            v7 = v9 + 1;
            ++a2;
            v13 = v23-- == 1;
            *v12 = v11;
        }
        while(!v13);
        LABEL_7:
        result = v22;
        goto LABEL_8;
    }
    if(v5 == 6 && a3 && *((_BYTE*) a1 + 9) == 8) {
        v15 = a2;
        if(!result)
            goto LABEL_8;
        v24 = *a1;
        do {
            v16 = *v15;
            v17 = v15 + 1;
            v18 = *v17++;
            v19 = *(_BYTE*) ((((int) (unsigned __int8) *v17 >> 3) & 0x1F | (4 * (v18 & 0xF8 | (32 * (v16 & 0xF8))))) + a3);
            v20 = a2;
            v15 = v17 + 2;
            ++a2;
            v13 = v24-- == 1;
            *v20 = v19;
        }
        while(!v13);
        goto LABEL_7;
    }
    if(v5 == 3) {
        if(a4) {
            if(*((_BYTE*) a1 + 9) == 8) {
                for(i = a2; result; --result) {
                    *i = *(_BYTE*) ((unsigned __int8) *i + a4);
                    ++i;
                }
            }
        }
    }
    return result;
}

//----- (0044D869) --------------------------------------------------------
void __cdecl sub_44D869(jmp_buf Buf) {
    long double v2; // st7
    void* v3; // eax
    __int64 v4; // rax
    int v5; // eax
    unsigned int v6; // edi
    int v7; // ebx
    long double v8; // st7
    void* v9; // eax
    bool v10; // zf
    void* v11; // eax
    int* __attribute__((__org_typedef(jmp_buf))) v12; // edx
    __int16 v13; // cx
    unsigned int v14; // ebx
    int v15; // eax
    int v16; // ebx
    __int64 v17; // rax
    double v18; // [esp+Ch] [ebp-30h]
    unsigned int v19; // [esp+20h] [ebp-1Ch]
    unsigned int v20; // [esp+24h] [ebp-18h]
    char v21; // [esp+2Ch] [ebp-10h]
    unsigned int v22; // [esp+30h] [ebp-Ch]
    int v23; // [esp+38h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+44h] [ebp+8h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufb; // [esp+44h] [ebp+8h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufc; // [esp+44h] [ebp+8h]

    if(*((float*) Buf + 76) != 0.0) {
        if(*((_BYTE*) Buf + 279) > 8u) {
            if((*((_BYTE*) Buf + 278) & 2) != 0) {
                v5 = *((unsigned __int8*) Buf + 336);
                if(*((unsigned __int8*) Buf + 337) > v5)
                    v5 = *((unsigned __int8*) Buf + 337);
                if(*((unsigned __int8*) Buf + 338) > v5)
                    v5 = *((unsigned __int8*) Buf + 338);
            }
            else {
                v5 = *((unsigned __int8*) Buf + 339);
            }
            v6 = 0;
            if(v5 <= 0)
                v23 = 0;
            else
                v23 = 16 - v5;
            if((*((_BYTE*) Buf + 97) & 4) != 0 && v23 < 5)
                v23 = 5;
            if(v23 > 8)
                v23 = 8;
            if(v23 < 0)
                v23 = 0;
            v7 = 1 << (8 - v23);
            v21 = 8 - v23;
            Buf [75] = (unsigned __int8) v23;
            if(*((float*) Buf + 77) <= 0.000001)
                v8 = 1.0;
            else
                v8 = 1.0 / (*((float*) Buf + 77) * *((float*) Buf + 76));
            v9 = sub_4509C4(Buf, 4 * v7);
            v10 = (Buf [24] & 0x480) == 0;
            Buf [81] = (int) v9;
            Bufb = 0;
            if(v10) {
                if(v7 > 0) {
                    do {
                        *(_DWORD*) (Buf [81] + 4 * (_DWORD) Bufb) = sub_4509C4(Buf, 0x200u);
                        v16 = 0;
                        v22 = (unsigned int) ((_DWORD) Bufb * dword_479428 [v23]) >> 4;
                        do {
                            v17 = (__int64) (pow((double) v22 * 0.00001525902189669642, v8) * 65535.0 + 0.5);
                            v22 += 256;
                            *(_WORD*) (v16 + *(_DWORD*) (Buf [81] + 4 * (_DWORD) Bufb)) = v17;
                            v16 += 2;
                        }
                        while(v16 < 512);
                        Bufb = (int*) ((char*) Bufb + 1);
                    }
                    while((int) Bufb < 1 << (8 - v23));
                }
            }
            else {
                if(v7 > 0) {
                    do {
                        v11 = sub_4509C4(Buf, 0x200u);
                        v12 = Bufb;
                        Bufb = (int*) ((char*) Bufb + 1);
                        *(_DWORD*) (Buf [81] + 4 * (_DWORD) v12) = v11;
                    }
                    while((int) Bufb < v7);
                    v6 = 0;
                }
                Bufc = 0;
                v20 = v7 << 8;
                v18 = (double) (unsigned int) (v7 << 8);
                do {
                    v19 = (__int64) (pow(((double) (int) Bufc + 0.5) * 0.00390625, 1.0 / v8) * v18);
                    if(v6 <= v19) {
                        LOBYTE(v13) = 0;
                        HIBYTE(v13) = (_BYTE) Bufc;
                        do {
                            v14 = v6 >> v21;
                            v15 = *(_DWORD*) (Buf [81] + 4 * (v6++ & (255 >> v23)));
                            *(_WORD*) (v15 + 2 * v14) = (unsigned __int16) Bufc | v13;
                        }
                        while(v6 <= v19);
                    }
                    Bufc = (int*) ((char*) Bufc + 1);
                }
                while((int) Bufc < 256);
                for(; v6 < v20; ++v6)
                    *(_WORD*) (*(_DWORD*) (Buf [81] + 4 * (v6 & (255 >> v23))) + 2 * (v6 >> v21)) = -1;
            }
        }
        else {
            if(*((float*) Buf + 77) <= 0.000001)
                v2 = 1.0;
            else
                v2 = 1.0 / (*((float*) Buf + 77) * *((float*) Buf + 76));
            v3 = sub_4509C4(Buf, 0x100u);
            Bufa = 0;
            Buf [78] = (int) v3;
            do {
                v4 = (__int64) (pow((double) (int) Bufa * 0.00392156862745098, v2) * 255.0 + 0.5);
                HIDWORD(v4) = Bufa;
                Bufa = (int*) ((char*) Bufa + 1);
                *(_BYTE*) (HIDWORD(v4) + Buf [78]) = v4;
            }
            while((int) Bufa < 256);
        }
    }
}
// 479428: using guessed type _DWORD[8];

//----- (0044DB68) --------------------------------------------------------
void __cdecl sub_44DB68(jmp_buf Buf) {
    int v2; // edi
    int v3; // ecx
    _BYTE* v4; // eax
    unsigned int v5; // ebx
    unsigned int v6; // eax
    unsigned int v7; // ecx
    int v8; // eax
    int v9; // edi
    char v10; // [esp+Ch] [ebp-4h]
    char Bufa; // [esp+18h] [ebp+8h]

    v2 = *((unsigned __int8*) Buf + 278);
    if(((unsigned int) &unk_602000 & Buf [24]) != 0) {
        sub_44D869(Buf);
        if(v2 == 3) {
            v3 = *((unsigned __int16*) Buf + 132);
            if(*((_WORD*) Buf + 132)) {
                v4 = (_BYTE*) (Buf [65] + 2);
                do {
                    *(v4 - 2) = *(_BYTE*) ((unsigned __int8) *(v4 - 2) + Buf [78]);
                    *(v4 - 1) = *(_BYTE*) ((unsigned __int8) *(v4 - 1) + Buf [78]);
                    *v4 = *(_BYTE*) ((unsigned __int8) *v4 + Buf [78]);
                    v4 += 3;
                    --v3;
                }
                while(v3);
            }
        }
    }
    if((Buf [24] & 8) != 0 && v2 == 3) {
        v5 = 8 - *((unsigned __int8*) Buf + 336);
        v6 = 8 - *((unsigned __int8*) Buf + 337);
        v7 = 8 - *((unsigned __int8*) Buf + 338);
        Bufa = 8 - *((_BYTE*) Buf + 337);
        v10 = 8 - *((_BYTE*) Buf + 338);
        if(v5 >= 9)
            LOBYTE(v5) = 0;
        if(v6 >= 9)
            Bufa = 0;
        if(v7 >= 9)
            v10 = 0;
        if(*((_WORD*) Buf + 132)) {
            v8 = 0;
            v9 = *((unsigned __int16*) Buf + 132);
            do {
                *(_BYTE*) (v8 + Buf [65]) >>= v5;
                *(_BYTE*) (v8 + Buf [65] + 1) >>= Bufa;
                *(_BYTE*) (v8 + Buf [65] + 2) >>= v10;
                v8 += 3;
                --v9;
            }
            while(v9);
        }
    }
}

//----- (0044DC7D) --------------------------------------------------------
void __cdecl sub_44DC7D(jmp_buf Buf) {
    if(!Buf [55])
        sub_44BC5A(Buf, (int) "NULL row buffer");
    if((*((_BYTE*) Buf + 97) & 0x10) != 0) {
        if(*((_BYTE*) Buf + 248) == 3) {
            sub_44D202(Buf + 60, Buf [55] + 1, Buf [65], Buf [87], *((unsigned __int16*) Buf + 133));
        }
        else if(*((_WORD*) Buf + 133)) {
            sub_44D409(Buf + 60, Buf [55] + 1, (_WORD*) Buf + 176);
        }
        else {
            sub_44D409(Buf + 60, Buf [55] + 1, 0);
        }
    }
    if((*((_BYTE*) Buf + 97) & 0x20) != 0 && *((_BYTE*) Buf + 278) != 3)
        sub_44CE90(Buf + 60, (_BYTE*) (Buf [55] + 1), (unsigned __int8*) Buf [78], Buf [81], Buf [75]);
    if((*((_BYTE*) Buf + 97) & 4) != 0)
        sub_44CC15((int) (Buf + 60), (_BYTE*) (Buf [55] + 1));
    if((Buf [24] & 0x40) != 0) {
        sub_44D75C(Buf + 60, (char*) (Buf [55] + 1), Buf [93], Buf [94]);
        if(!Buf [61])
            sub_44BC5A(Buf, (int) "png_do_dither returned rowbytes=0");
    }
    if((Buf [24] & 8) != 0)
        sub_44CA9A(Buf + 60, (_BYTE*) (Buf [55] + 1), (unsigned __int8*) Buf + 341);
    if((Buf [24] & 4) != 0)
        sub_44C98B(Buf + 60, Buf [55] + 1);
    if((Buf [24] & 1) != 0)
        sub_44C799(Buf + 60, (char*) (Buf [55] + 1));
    if(*((char*) Buf + 97) < 0)
        sub_44CC59((int) (Buf + 60), Buf [55] + 1, *((unsigned __int16*) Buf + 143), Buf [23]);
}

//----- (0044DE19) --------------------------------------------------------
void __cdecl sub_44DE19(int a1, int a2, double a3) {
    if(a1) {
        if(a2) {
            *(_DWORD*) (a2 + 8) |= 1u;
            *(float*) (a2 + 40) = a3;
        }
    }
}

//----- (0044DE34) --------------------------------------------------------
void __cdecl sub_44DE34(int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7, char a8, char a9) {
    unsigned __int8 v9; // al

    if(a1 && a2) {
        *(_BYTE*) (a2 + 26) = a8;
        *(_DWORD*) (a2 + 4) = a4;
        *(_BYTE*) (a2 + 27) = a9;
        *(_DWORD*) a2 = a3;
        *(_BYTE*) (a2 + 24) = a5;
        *(_BYTE*) (a2 + 25) = a6;
        *(_BYTE*) (a2 + 28) = a7;
        if(a6 == 3 || (a6 & 2) == 0)
            *(_BYTE*) (a2 + 29) = 1;
        else
            *(_BYTE*) (a2 + 29) = 3;
        if((a6 & 4) != 0)
            ++* (_BYTE*) (a2 + 29);
        v9 = a5 * *(_BYTE*) (a2 + 29);
        *(_BYTE*) (a2 + 30) = v9;
        if(a3 <= 0x7FFFFFFFu / ((v9 + 7) >> 3)) {
            *(_DWORD*) (a2 + 12) = (a3 * v9 + 7) >> 3;
        }
        else {
            sub_44BC7D(a1, (int) "Width too large to process image data; rowbytes will overflow.");
            *(_DWORD*) (a2 + 12) = 0;
        }
    }
}

//----- (0044DED6) --------------------------------------------------------
void __cdecl sub_44DED6(int a1, int a2, int a3, __int16 a4) {
    if(a1) {
        if(a2) {
            *(_DWORD*) (a2 + 8) |= 8u;
            *(_DWORD*) (a2 + 16) = a3;
            *(_WORD*) (a2 + 20) = a4;
        }
    }
}

//----- (0044DEFA) --------------------------------------------------------
void __cdecl sub_44DEFA(int a1, int a2, char a3) {
    if(a1) {
        if(a2) {
            *(_BYTE*) (a2 + 9) |= 8u;
            *(_BYTE*) (a2 + 44) = a3;
        }
    }
}

//----- (0044DF15) --------------------------------------------------------
void __cdecl sub_44DF15(int a1, __int64 a2) {
    if(a1) {
        if((_DWORD) a2) {
            sub_44DEFA(a1, a2, SBYTE4(a2));
            sub_44DE19(a1, a2, 0.4545499980449677);
        }
    }
}

//----- (0044DF4E) --------------------------------------------------------
void __cdecl sub_44DF4E(int a1, int a2, int a3, int a4, int a5) {
    if(a1 && a2) {
        if(a3)
            *(_DWORD*) (a2 + 48) = a3;
        if(a5) {
            *(_DWORD*) (a2 + 52) = *(_DWORD*) a5;
            *(_DWORD*) (a2 + 56) = *(_DWORD*) (a5 + 4);
            *(_WORD*) (a2 + 60) = *(_WORD*) (a5 + 8);
            if(!a4)
                LOWORD(a4) = 1;
        }
        *(_DWORD*) (a2 + 8) |= 0x10u;
        *(_WORD*) (a2 + 22) = a4;
    }
}

//----- (0044DF95) --------------------------------------------------------
int __cdecl sub_44DF95(jmp_buf Buf, int a2, int a3) {
    int(__cdecl * v3)(int* __attribute__((__org_typedef(jmp_buf))), int, int); // eax

    v3 = (int(__cdecl*)(int* __attribute__((__org_typedef(jmp_buf))), int, int))Buf [20];
    if(!v3)
        sub_44BC5A(Buf, (int) "Call to NULL read function");
    return v3(Buf, a2, a3);
}

//----- (0044DFBD) --------------------------------------------------------
int(__cdecl* __cdecl sub_44DFBD(_DWORD* a1, int a2, int(__cdecl* a3)(int, int)))(int, int)
{
    bool v3; // zf
    int(__cdecl* result)(int, int); // eax

    v3 = a1 [19] == 0;
    a1 [21] = a2;
    result = a3;
    a1 [20] = a3;
    if(!v3) {
        a1 [19] = 0;
        sub_44BC7D((int) a1, (int) "It's an error to set both read_data_fn and write_data_fn in the ");
        result = sub_44BC7D((int) a1, (int) "same structure.  Resetting write_data_fn to NULL.");
    }
    a1 [72] = 0;
    return result;
}

//----- (0044DFFC) --------------------------------------------------------
int __cdecl sub_44DFFC(int a1, unsigned int a2, unsigned int a3) {
    int v3; // ecx

    v3 = a3;
    if(a3 <= 8) {
        if(!a3)
            return 0;
    }
    else {
        v3 = 8;
    }
    if(a2 > 7)
        return 0;
    if(a2 + v3 > 8)
        v3 = 8 - a2;
    return memcmp((const char*) (a1 + a2), &byte_46E964 [a2], v3);
}

//----- (0044E044) --------------------------------------------------------
char* __cdecl sub_44E044(jmp_buf Buf, int a2, int a3) {
    unsigned int v3; // esi
    char* v4; // edx
    char* result; // eax
    void* v6; // edi
    unsigned int v7; // ecx

    v3 = a3 * a2;
    v4 = (char*) sub_4509C4(Buf, a3 * a2);
    result = 0;
    if(v4) {
        v6 = v4;
        if(v3 <= 0x8000) {
            v7 = a3 * a2;
        }
        else {
            memset(v4, 0, 0x8000u);
            v7 = v3 - 0x8000;
            v6 = v4 + 0x8000;
        }
        memset(v6, 0, v7);
        return v4;
    }
    return result;
}

//----- (0044E09C) --------------------------------------------------------
int __cdecl sub_44E09C(int a1) {
    int result; // eax

    result = sub_451D62(0, 0, 0);
    *(_DWORD*) (a1 + 256) = result;
    return result;
}

//----- (0044E0B4) --------------------------------------------------------
int __cdecl sub_44E0B4(int a1, _BYTE* a2, unsigned int a3) {
    int result; // eax

    result = a1;
    if((*(_BYTE*) (a1 + 268) & 0x20) == 0) {
        if((*(_BYTE*) (a1 + 93) & 8) != 0)
            return result;
        goto LABEL_5;
    }
    if((*(_DWORD*) (a1 + 92) & 0x300) != 768) {
        LABEL_5:
        result = sub_451D62(*(_DWORD*) (a1 + 256), a2, a3);
        *(_DWORD*) (a1 + 256) = result;
    }
    return result;
}

//----- (0044E0F3) --------------------------------------------------------
int __cdecl sub_44E0F3(void* a1) {
    int result; // eax

    result = 0;
    memset(a1, 0, 0x40u);
    return result;
}

//----- (0044E101) --------------------------------------------------------
int __cdecl sub_44E101(int a1, void* a2) {
    return sub_44E0F3(a2);
}

//----- (0044E10C) --------------------------------------------------------
void* __cdecl sub_44E10C(int a1) {
    void* v2; // eax
    void* v3; // edx

    if(!a1)
        return 0;
    v2 = sub_450975(2);
    v3 = v2;
    if(v2)
        sub_44E0F3(v2);
    return v3;
}
// 44E12B: variable 'v3' is possibly undefined

//----- (0044E12E) --------------------------------------------------------
__int16 __cdecl sub_44E12E(_BYTE* a1, int a2) {
    int i; // eax
    int j; // esi
    int k; // ecx
    int v6; // eax
    int m; // eax

    for(i = 0; i < 16; ++i) {
        if(*(int*) &a1 [4 * i] >= 0)
            break;
    }
    if(i == 16)
        return sub_44EC2C(a1, a2);
    for(j = 0; ; ++j) {
        for(k = 0; k < 16; ++k) {
            v6 = *(_DWORD*) &a1 [4 * k];
            if(v6 < 0 && (v6 & 0xFFFFFF) == j)
                break;
        }
        if(k == 16)
            break;
    }
    for(m = 0; m < 16; ++m) {
        if(*(int*) &a1 [4 * m] >= 0)
            *(_DWORD*) &a1 [4 * m] = j;
    }
    return sub_44E55E(a1, a2, j, j);
}

//----- (0044E197) --------------------------------------------------------
int __cdecl sub_44E197(unsigned __int16* a1, char* a2) {
    int result; // eax

    sub_44E9F5(a1, a2);
    for(result = 0; result < 16; ++result) {
        if(!a2 [4 * result + 3])
            *(_DWORD*) &a2 [4 * result] = 0;
    }
    return result;
}

//----- (0044E1BD) --------------------------------------------------------
float* __usercall sub_44E1BD(float* result, int a2) {
    int v2; // ecx
    int v3; // edx
    int v4; // [esp+4h] [ebp-4h]

    v2 = 0;
    v3 = (char*) flt_479448 - (char*) result;
    do {
        v4 = *(unsigned __int8*) (v2 + a2);
        ++v2;
        *result = (double) v4 * *(float*) ((char*) result + v3) * 0.0039215689;
        ++result;
    }
    while(v2 < 3);
    return result;
}
// 479448: using guessed type float flt_479448[3];

//----- (0044E1EF) --------------------------------------------------------
__int64 __usercall sub_44E1EF(int a1, int a2) {
    int v2; // esi
    int v3; // edi
    __int64 result; // rax

    v2 = 0;
    v3 = a1 - (_DWORD) flt_479448;
    do {
        result = (__int64) (*(float*) (v3 + 4 * v2 + 4691016) / flt_479448 [v2] * 255.0);
        *(_BYTE*) (v2 + a2) = result;
        ++v2;
    }
    while(v2 < 3);
    return result;
}
// 479448: using guessed type float flt_479448[3];

//----- (0044E224) --------------------------------------------------------
_WORD* __usercall sub_44E224(_BYTE* a1, _WORD* a2) {
    __int16 v2; // cx
    _WORD* result; // eax

    v2 = (*a1 >> 3) | (32 * ((a1 [1] >> 2) | (a1 [2] >> 3 << 6)));
    result = a2;
    *a2 = v2;
    return result;
}

//----- (0044E254) --------------------------------------------------------
unsigned int __usercall sub_44E254(unsigned __int16* a1, unsigned int* a2) {
    int v2; // eax
    unsigned __int8 v3; // dl
    char v4; // cl
    unsigned int v5; // eax
    unsigned int result; // eax
    unsigned int v7; // [esp+4h] [ebp-4h]

    v2 = *a1;
    v3 = 8 * v2;
    HIWORD(v7) = HIWORD(v2);
    LOWORD(v7) = (unsigned __int16) v2 >> 5;
    v4 = (unsigned __int16) v2 >> 5;
    v5 = v7;
    LOBYTE(v7) = (v3 >> 5) | v3;
    BYTE1(v7) = ((unsigned __int8) (4 * v4) >> 6) | (4 * v4);
    BYTE2(v7) = ((unsigned __int8) (8 * (v5 >> 6)) >> 5) | (8 * (v5 >> 6));
    result = v7;
    *a2 = v7;
    return result;
}

//----- (0044E2A1) --------------------------------------------------------
float* __usercall sub_44E2A1(float* result, float* a2) {
    *a2 = *result * *result + result [1] * result [1] + result [2] * result [2];
    a2 [1] = (result [4] + *result) * result [1] + result [5] * result [2];
    a2 [2] = (result [8] + *result) * result [2] + result [5] * result [1];
    a2 [4] = result [5] * result [5] + result [4] * result [4] + result [1] * result [1];
    a2 [5] = (result [8] + result [4]) * result [5] + result [2] * result [1];
    a2 [8] = result [8] * result [8] + result [5] * result [5] + result [2] * result [2];
    return result;
}

//----- (0044E340) --------------------------------------------------------
float* __usercall sub_44E340(unsigned __int16* a1, float* a2, float* a3, int a4) {
    unsigned __int16 v4; // ax
    unsigned int v6; // [esp+8h] [ebp-4h] BYREF

    sub_44E1EF((int) a2, (int) &v6);
    sub_44E224(&v6, a1);
    sub_44E1EF((int) a3, (int) &v6);
    sub_44E224(&v6, a1 + 1);
    v4 = *a1;
    if((a4 == 16) != a1 [1] < *a1) {
        *a1 = a1 [1];
        a1 [1] = v4;
    }
    sub_44E254(a1, &v6);
    sub_44E1BD(a2, (int) &v6);
    sub_44E254(a1 + 1, &v6);
    return sub_44E1BD(a3, (int) &v6);
}

//----- (0044E3CB) --------------------------------------------------------
float* __usercall sub_44E3CB(float* a1, float* a2) {
    int v2; // ebx
    float* v3; // ecx
    double v4; // st5
    float* v5; // eax
    float* v6; // esi
    float* result; // eax
    double v8; // st5
    int v9; // [esp+8h] [ebp-10h]
    char* v10; // [esp+14h] [ebp-4h]

    v2 = (char*) a2 - (char*) a1;
    v10 = (char*) ((char*) flt_479448 - (char*) a1);
    v3 = a1;
    v9 = 3;
    do {
        if(*v3 < 0.0 != *(float*) ((char*) v3 + v2) < 0.0) {
            v4 = -(*v3 / (*(float*) ((char*) v3 + v2) - *v3));
            if(*v3 >= 0.0) {
                v5 = a2;
                v4 = v4 - 1.0;
            }
            else {
                v5 = a1;
            }
            v5 [2] = (a2 [2] - a1 [2]) * v4 + v5 [2];
            v5 [1] = (a2 [1] - a1 [1]) * v4 + v5 [1];
            *v5 = (*a2 - *a1) * v4 + *v5;
        }
        v6 = (float*) ((int) v3 + (_DWORD) v10);
        result = (float*) ((*v3 > (double) *(float*) ((char*) v3 + (_DWORD) v10)) ^ (*(float*) ((char*) v3 + v2) > (double) *(float*) ((char*) v3 + (_DWORD) v10)));
        v2 = (char*) a2 - (char*) a1;
        if(result) {
            v8 = (*v6 - *v3) / (*(float*) ((char*) v3 + (char*) a2 - (char*) a1) - *v3);
            if(*v3 <= (double) *v6) {
                result = a2;
                v8 = v8 - 1.0;
            }
            else {
                result = a1;
            }
            result [2] = (a2 [2] - a1 [2]) * v8 + result [2];
            result [1] = (a2 [1] - a1 [1]) * v8 + result [1];
            *result = (*a2 - *a1) * v8 + *result;
        }
        ++v3;
        --v9;
    }
    while(v9);
    return result;
}
// 479448: using guessed type float flt_479448[3];

//----- (0044E4FD) --------------------------------------------------------
__int16 __usercall sub_44E4FD(_BYTE* a1, int a2, unsigned __int16 a3) {
    int v3; // eax
    int v4; // ecx
    __int16 v5; // dx
    _WORD* v7; // [esp+0h] [ebp-8h]
    int v8; // [esp+4h] [ebp-4h] BYREF

    v8 = *(_DWORD*) a1;
    sub_44E224(a1, v7);
    *(_WORD*) (a2 + 2) = *(_WORD*) a2;
    v3 = 0;
    *(_DWORD*) (a2 + 4) = 0;
    if(a3 != 0xFFFF) {
        v4 = 3;
        v5 = 1;
        do {
            if((a3 & (unsigned __int16) v5) != 0)
                v8 = *(_DWORD*) &a1 [4 * v3];
            else
                *(_DWORD*) (a2 + 4) |= v4;
            ++v3;
            v5 *= 2;
            v4 *= 4;
        }
        while(v3 < 16);
        sub_44E224(&v8, (_WORD*) a2);
        LOWORD(v3) = *(_WORD*) a2;
        *(_WORD*) (a2 + 2) = *(_WORD*) a2;
    }
    return v3;
}
// 44E509: variable 'v7' is possibly undefined

//----- (0044E55E) --------------------------------------------------------
__int16 __cdecl sub_44E55E(_BYTE* a1, int a2, int a3, int a4) {
    int v4; // eax
    _BYTE* v5; // edi
    _BYTE* v6; // eax
    int v7; // edx
    int v8; // esi
    unsigned __int8 v9; // cl
    unsigned __int8 v10; // cl
    int v11; // ecx
    _BYTE* v12; // eax
    int v13; // esi
    int v14; // esi
    float* v15; // edi
    int v16; // ebx
    int v17; // ecx
    double v18; // st7
    float* v19; // eax
    __int16 v20; // si
    float* v21; // edx
    int v22; // edi
    int i; // ecx
    double v24; // st7
    float* v25; // eax
    int v26; // edx
    char* v27; // esi
    float* v28; // eax
    int v29; // ecx
    float* v30; // edx
    float* v31; // edi
    int j; // ebx
    double v33; // st7
    double v34; // st7
    int v35; // edx
    float* v36; // esi
    float* v37; // ecx
    int v38; // eax
    long double v39; // st7
    int v40; // esi
    int v41; // edx
    float* v42; // ecx
    int v43; // ecx
    float* v44; // eax
    long double v45; // st7
    long double v46; // st6
    int v47; // eax
    double v48; // st7
    double v49; // st6
    __int16 v50; // si
    char* v51; // edx
    int v52; // ebx
    double v53; // st6
    int v54; // eax
    float* v55; // ecx
    double v56; // st5
    double v57; // st5
    double v58; // st6
    int k; // eax
    float* v60; // ecx
    double v61; // st7
    float* v62; // edx
    double v63; // st7
    int m; // eax
    double v65; // st6
    __int16 v66; // ax
    char* v67; // ebx
    double v68; // st3
    float* v69; // edx
    int n; // eax
    float* v71; // ecx
    double v72; // st2
    double v73; // st3
    double v74; // st3
    int v75; // edi
    int v76; // eax
    double v77; // st3
    bool v78; // zf
    char v80 [240]; // [esp+Ch] [ebp-134h] BYREF
    char v81; // [esp+FCh] [ebp-44h] BYREF
    float v82 [17]; // [esp+10Ch] [ebp-34h] BYREF
    float v83 [4]; // [esp+150h] [ebp+10h] BYREF
    float v84 [4]; // [esp+160h] [ebp+20h] BYREF
    float v85 [9]; // [esp+170h] [ebp+30h] BYREF
    int v86; // [esp+194h] [ebp+54h]
    float* v87; // [esp+198h] [ebp+58h]
    float* v88; // [esp+19Ch] [ebp+5Ch]
    int v89; // [esp+1A0h] [ebp+60h]
    int v90; // [esp+1A4h] [ebp+64h]
    int v91; // [esp+1B0h] [ebp+70h]
    int v92; // [esp+1B8h] [ebp+78h]
    float v93; // [esp+1B8h] [ebp+78h]
    unsigned __int16 v94; // [esp+1B8h] [ebp+78h]
    int v95; // [esp+1BCh] [ebp+7Ch]
    float v96; // [esp+1BCh] [ebp+7Ch]

    LOWORD(v4) = 0;
    v90 = 0;
    if(!a2)
        return v4;
    v5 = a1;
    v89 = 0;
    v6 = a1 + 61;
    v7 = 16;
    v8 = 1;
    do {
        v9 = v6 [1];
        v90 *= 2;
        if(BYTE2(a3) > v9
           || v9 > BYTE2(a4)
           || BYTE1(a3) > *v6
           || *v6 > BYTE1(a4)
           || (v10 = *(v6 - 1), (unsigned __int8) a3 > v10)
           || v10 > (unsigned __int8) a4) {
            v90 |= 1u;
            ++v89;
        }
        else {
            v90 &= 0xFFFEu;
        }
        v6 -= 4;
        --v7;
    }
    while(v7);
    if(!v89) {
        LOWORD(v4) = a2;
        *(_WORD*) a2 = 0;
        *(_WORD*) (a2 + 2) = -1;
        *(_DWORD*) (a2 + 4) = -1;
        return v4;
    }
    v11 = 0;
    v12 = a1 + 2;
    do {
        if(v8 && v11 > 0 && (*v12 != *(v12 - 4) || *(v12 - 1) != *(v12 - 5) || *(v12 - 2) != *(v12 - 6)))
            v8 = 0;
        ++v11;
        v12 += 4;
    }
    while(v11 < 16);
    if(!v8) {
        v14 = (int) a1;
        v15 = (float*) v80;
        v16 = 16;
        do {
            sub_44E1BD(v15, v14);
            v15 += 4;
            v14 += 4;
            --v16;
        }
        while(v16);
        v17 = 0;
        v18 = 1.0 / (double) v89;
        do {
            v19 = &v82 [v17 + 9];
            v82 [v17 + 9] = 0.0;
            v20 = 1;
            v21 = (float*) &v80 [v17 * 4];
            v22 = 16;
            do {
                if(((unsigned __int16) v90 & (unsigned __int16) v20) != 0)
                    *v19 = *v21 + *v19;
                v20 *= 2;
                v21 += 4;
                --v22;
            }
            while(v22);
            ++v17;
            *v19 = v18 * *v19;
        }
        while(v17 < 3);
        for(i = 0; i < 3; ++i) {
            v24 = v82 [i + 9];
            v25 = (float*) &v80 [i * 4];
            v26 = 16;
            do {
                *v25 = *v25 - v24;
                v25 += 4;
                --v26;
            }
            while(v26);
        }
        v95 = 0;
        v87 = v85;
        v27 = v80;
        do {
            v28 = v87;
            v29 = 3 - v95;
            v88 = (float*) v27;
            do {
                v30 = v88;
                *v28 = 0.0;
                v92 = 1;
                v31 = (float*) v27;
                v86 = 16;
                do {
                    if(((unsigned __int16) v90 & (unsigned __int16) v92) != 0)
                        *v28 = *v30 * *v31 + *v28;
                    v92 *= 2;
                    v30 += 4;
                    v31 += 4;
                    --v86;
                }
                while(v86);
                ++v88;
                ++v28;
                --v29;
            }
            while(v29);
            ++v95;
            v87 += 4;
            v27 += 4;
        }
        while(v95 < 3);
        for(j = 0; j < 9; ++j) {
            sub_44E2A1(v85, v82);
            sub_44E2A1(v82, v85);
            v33 = v85 [8] + v85 [4] + v85 [0];
            if(v33 == 0.0)
                goto LABEL_60;
            v34 = 3.0 / v33;
            v35 = 0;
            v36 = v85;
            do {
                v37 = v36;
                v38 = 3 - v35;
                do {
                    *v37 = v34 * *v37;
                    ++v37;
                    --v38;
                }
                while(v38);
                ++v35;
                v36 += 4;
            }
            while(v35 < 3);
        }
        v39 = 0.0;
        v40 = a2;
        v85 [3] = v85 [1];
        v85 [6] = v85 [2];
        v85 [7] = v85 [5];
        v41 = 0;
        v42 = v85;
        do {
            if(v39 < *v42) {
                v40 = v41;
                v39 = *v42;
            }
            ++v41;
            v42 += 4;
        }
        while(v41 < 3);
        v43 = 0;
        v44 = &v85 [v40];
        v45 = 1.0 / sqrt(v39);
        do {
            ++v43;
            v46 = v45 * *v44;
            v44 += 3;
            v82 [v43 + 12] = v46;
        }
        while(v43 < 3);
        v47 = 0;
        v48 = 0.0;
        do {
            v49 = v82 [v47++ + 13];
            v48 = v48 + v49 * v49;
        }
        while(v47 < 3);
        if(v48 == 0.0) {
            LABEL_60:
            v13 = a2;
        }
        else {
            v50 = 1;
            v96 = -99999.0;
            v93 = 99999.0;
            v51 = v80;
            v52 = 16;
            do {
                if(((unsigned __int16) v90 & (unsigned __int16) v50) != 0) {
                    v53 = 0.0;
                    v54 = 0;
                    v55 = (float*) v51;
                    do {
                        v56 = v82 [v54++ + 13];
                        v57 = v56 * *v55++;
                        v53 = v53 + v57;
                    }
                    while(v54 < 3);
                    v58 = v53 / v48;
                    if(v58 < v93)
                        v93 = v58;
                    if(v58 > v96)
                        v96 = v58;
                }
                v50 *= 2;
                v51 += 16;
                --v52;
            }
            while(v52);
            for(k = 0; k < 3; v82 [k + 16] = v96 * *v60 + *v62) {
                v60 = &v82 [k + 13];
                v61 = v93 * v82 [k + 13];
                v62 = &v82 [k + 9];
                v83 [++k + 3] = v61 + *v62;
            }
            sub_44E3CB(v84, v83);
            v13 = a2;
            sub_44E340((unsigned __int16*) a2, v84, v83, v89);
            v63 = 0.0;
            for(m = 0; m < 3; v63 = v63 + (v65 - v83 [m + 3]) * (v65 - v83 [m + 3]))
                v65 = v83 [m++];
            if(v63 != 0.0 || v89 != 16) {
                v66 = 0x8000;
                v94 = 0x8000;
                v67 = &v81;
                v91 = 16;
                while(1) {
                    if(((unsigned __int16) v90 & (unsigned __int16) v66) != 0) {
                        v68 = 0.0;
                        v69 = (float*) v67;
                        for(n = 0; n < 3; v68 = v68 + (v82 [n + 16] - *v71) * (v72 - *v71)) {
                            v71 = &v84 [n];
                            v72 = v82 [n + 9] + *v69;
                            ++n;
                            *v69++ = v72;
                        }
                        v73 = v68 / v63;
                        if(v89 == 16) {
                            v74 = v73 * 4.0;
                            if(v74 >= 0.0) {
                                if(v74 >= 4.0)
                                    v74 = 3.0;
                            }
                            else {
                                v74 = 0.0;
                            }
                            *(_DWORD*) (a2 + 4) *= 4;
                            v75 = *(_DWORD*) (a2 + 4);
                            v76 = dword_479454 [(unsigned int) (__int64) v74];
                        }
                        else {
                            v77 = v73 * 3.0;
                            if(v77 >= 0.0) {
                                if(v77 >= 3.0)
                                    v77 = 2.0;
                            }
                            else {
                                v77 = 0.0;
                            }
                            *(_DWORD*) (a2 + 4) *= 4;
                            v75 = *(_DWORD*) (a2 + 4);
                            v76 = dword_479464 [(unsigned int) (__int64) v77];
                        }
                        v4 = v75 | v76;
                    }
                    else {
                        v4 = (4 * *(_DWORD*) (a2 + 4)) | 3;
                    }
                    v94 >>= 1;
                    v67 -= 16;
                    v78 = v91-- == 1;
                    *(_DWORD*) (a2 + 4) = v4;
                    if(v78)
                        break;
                    v66 = v94;
                }
                return v4;
            }
        }
        v5 = a1;
        goto LABEL_77;
    }
    v13 = a2;
    LABEL_77:
    LOWORD(v4) = sub_44E4FD(v5, v13, v90);
    return v4;
}
// 479454: using guessed type int dword_479454[4];
// 479464: using guessed type int dword_479464[4];
// 44E55E: using guessed type float var_48[4];

//----- (0044E9F5) --------------------------------------------------------
char __cdecl sub_44E9F5(unsigned __int16* a1, char* a2) {
    unsigned __int16* v2; // esi
    char result; // al
    unsigned __int16 v4; // ax
    unsigned __int8* v5; // ecx
    unsigned __int16 v6; // si
    unsigned __int16 v7; // di
    bool v8; // cc
    int i; // edi
    unsigned __int8* v10; // ecx
    unsigned int v11; // edx
    char* v12; // ecx
    int v13; // ebx
    unsigned int* v14; // esi
    unsigned int v15; // [esp+Ch] [ebp-14h] BYREF
    unsigned int v16; // [esp+10h] [ebp-10h] BYREF
    char v17; // [esp+17h] [ebp-9h]
    char v18; // [esp+1Bh] [ebp-5h]
    int v19; // [esp+1Ch] [ebp-4h]

    v2 = a1;
    if(a1) {
        sub_44E254(a1, &v15);
        sub_44E254(a1 + 1, &v16);
        v4 = *a1;
        v17 = -1;
        HIBYTE(v16) = -1;
        HIBYTE(v15) = -1;
        if(v4 <= a1 [1]) {
            for(i = 0; i < 3; ++i) {
                v10 = (unsigned __int8*) &v15 + i;
                v10 [8] = (*v10 + v10 [4]) / 2;
                v10 [12] = 0;
            }
            v18 = 0;
        }
        else {
            v19 = 0;
            do {
                v5 = (unsigned __int8*) &v16 + v19;
                v6 = *((unsigned __int8*) &v15 + v19);
                v7 = *((unsigned __int8*) &v16 + v19);
                v5 [4] = (*v5 + 2 * *(v5 - 4) + 1) / 3;
                v8 = ++v19 < 3;
                v5 [8] = (v6 + 2 * v7 + 1) / 3;
            }
            while(v8);
            v18 = -1;
            v2 = a1;
        }
        v11 = *((_DWORD*) v2 + 1);
        v12 = a2;
        v13 = 16;
        do {
            v14 = &v15 + (v11 & 3);
            result = *((_BYTE*) &v15 + 4 * (v11 & 3) + 3);
            *(_WORD*) v12 = *(_WORD*) v14;
            v12 [2] = *((_BYTE*) v14 + 2);
            v12 [3] = result;
            v11 >>= 2;
            v12 += 4;
            --v13;
        }
        while(v13);
    }
    else {
        result = 0;
        memset(a2, 0, 0x40u);
    }
    return result;
}

//----- (0044EADE) --------------------------------------------------------
int __cdecl sub_44EADE(int a1, char* a2) {
    int v2; // esi
    _BYTE* v3; // ecx
    int result; // eax
    int v5; // edx
    char v6; // al
    char v7; // bl
    unsigned __int16 v8; // [esp+18h] [ebp+Ch]

    sub_44E9F5((unsigned __int16*) (a1 + 8), a2);
    v2 = 0;
    v3 = a2 + 3;
    do {
        result = *(unsigned __int16*) (a1 + 2 * v2);
        v5 = 4;
        v8 = *(_WORD*) (a1 + 2 * v2);
        do {
            v6 = v8;
            v8 >>= 4;
            v7 = v6 & 0xF;
            LOBYTE(result) = 16 * v6;
            *v3 = result | v7;
            v3 += 4;
            --v5;
        }
        while(v5);
        ++v2;
    }
    while(v2 < 4);
    return result;
}

//----- (0044EB2C) --------------------------------------------------------
int __cdecl sub_44EB2C(unsigned __int16* a1, char* a2) {
    int v2; // esi
    int v3; // ecx
    unsigned int v4; // ecx
    int result; // eax
    int v6; // ecx
    int v7; // edx
    char v8; // dl
    int v9 [2]; // [esp+Ch] [ebp-24h]
    int v10; // [esp+14h] [ebp-1Ch]
    int v11; // [esp+18h] [ebp-18h]
    int v12; // [esp+1Ch] [ebp-14h]
    int v13; // [esp+20h] [ebp-10h]
    int v14; // [esp+24h] [ebp-Ch]
    int v15; // [esp+28h] [ebp-8h]
    unsigned int v16; // [esp+2Ch] [ebp-4h]

    v16 = 0;
    sub_44E9F5(a1 + 4, a2);
    v2 = *((unsigned __int8*) a1 + 1);
    v3 = *(unsigned __int8*) a1;
    v9 [0] = v3;
    v9 [1] = v2;
    if(v3 <= v2) {
        v15 = 255;
        v10 = (v2 + 4 * v3) / 5;
        v11 = (3 * v3 + 2 * v2) / 5;
        v12 = (3 * v2 + 2 * v3) / 5;
        v14 = 0;
        v13 = (v3 + 4 * v2) / 5;
    }
    else {
        v10 = (v2 + 6 * v3) / 7;
        v11 = (5 * v3 + 2 * v2) / 7;
        v12 = (3 * v2 + 4 * v3) / 7;
        v13 = (3 * v3 + 4 * v2) / 7;
        v14 = (5 * v2 + 2 * v3) / 7;
        v15 = (v3 + 6 * v2) / 7;
    }
    v4 = v16;
    for(result = 0; result < 16; ++result) {
        if((result & 7) == 0) {
            HIWORD(v6) = 0;
            if(result) {
                BYTE1(v6) = *((_BYTE*) a1 + 7);
                v7 = *((unsigned __int8*) a1 + 5);
                LOBYTE(v6) = *((_BYTE*) a1 + 6);
            }
            else {
                BYTE1(v6) = *((_BYTE*) a1 + 4);
                v7 = *((unsigned __int8*) a1 + 2);
                LOBYTE(v6) = *((_BYTE*) a1 + 3);
            }
            v4 = v7 | (v6 << 8);
        }
        v8 = v9 [v4 & 7];
        v4 >>= 3;
        a2 [4 * result + 3] = v8;
    }
    return result;
}

//----- (0044EC2C) --------------------------------------------------------
__int16 __cdecl sub_44EC2C(_BYTE* a1, int a2) {
    int v3; // [esp+0h] [ebp-8h]
    int v4; // [esp+4h] [ebp-4h]

    LOWORD(v3) = -1;
    BYTE2(v3) = -1;
    LOWORD(v4) = 0;
    BYTE2(v4) = 0;
    return sub_44E55E(a1, a2, v3, v4);
}
// 44EC54: variable 'v3' is possibly undefined
// 44EC54: variable 'v4' is possibly undefined

//----- (0044EC5E) --------------------------------------------------------
__int16 __cdecl sub_44EC5E(_BYTE* a1, _WORD* a2) {
    _WORD* v2; // eax
    _BYTE* v3; // esi
    _BYTE* v4; // ecx
    int v5; // edx
    __int16 v6; // bx
    int v8; // [esp+Ch] [ebp-4h]

    v2 = a2;
    v3 = a1 + 15;
    v8 = 4;
    do {
        v4 = v3;
        v5 = 4;
        do {
            *v2 *= 16;
            v6 = *v4 >> 4;
            v4 -= 4;
            --v5;
            *v2 |= v6;
        }
        while(v5);
        ++v2;
        v3 += 16;
        --v8;
    }
    while(v8);
    return sub_44EC2C(a1, (int) (a2 + 4));
}

//----- (0044ECB7) --------------------------------------------------------
__int16 __cdecl sub_44ECB7(_BYTE* a1, int a2) {
    _BYTE* v2; // edx
    unsigned __int8* v3; // esi
    unsigned __int8 v4; // al
    unsigned __int8 v5; // cl
    unsigned __int8* v6; // edi
    int v7; // edi
    unsigned __int8 v8; // bl
    int v10; // ecx
    int v11; // ebx
    char v12; // al
    int v13; // eax
    unsigned int v14; // eax
    int v16; // [esp+Ch] [ebp-Ch]
    int v17; // [esp+10h] [ebp-8h]
    int v18; // [esp+10h] [ebp-8h]
    unsigned int v19; // [esp+14h] [ebp-4h]
    int v20; // [esp+24h] [ebp+Ch]

    v2 = a1;
    v19 = 0;
    v3 = a1 + 3;
    v4 = a1 [3];
    v5 = v4;
    v6 = a1 + 7;
    v17 = 15;
    do {
        if(*v6 > v5)
            v5 = *v6;
        if(*v6 < v4)
            v4 = *v6;
        v6 += 4;
        --v17;
    }
    while(v17);
    if(v5 != 0xFF || v4) {
        v18 = 0;
    }
    else {
        v7 = 16;
        do {
            v8 = *v3;
            if(*v3 < v5 && v8)
                v5 = *v3;
            if(v8 > v4 && v8 != 0xFF)
                v4 = *v3;
            v3 += 4;
            --v7;
        }
        while(v7);
        if(v5 >= v4) {
            v18 = 0;
            v5 = -1;
            v4 = 0;
        }
        else {
            v18 = 1;
        }
    }
    *(_BYTE*) a2 = v5;
    *(_BYTE*) (a2 + 1) = v4;
    if(v5 != v4) {
        v16 = v5;
        v10 = v5 - v4;
        v11 = 15;
        v20 = 2 * (v18 == 0) + 5;
        while(1) {
            v19 *= 8;
            if(!v18)
                break;
            v12 = v2 [4 * v11 + 3];
            if(v12) {
                if(v12 != -1)
                    break;
                v19 |= 7u;
            }
            else {
                v19 |= 6u;
            }
            LABEL_33:
            if((v11 & 7) == 0) {
                if(v11 == 8) {
                    *(_WORD*) (a2 + 5) = v19;
                    v14 = HIWORD(v19);
                    *(_BYTE*) (a2 + 7) = BYTE2(v19);
                }
                else {
                    *(_WORD*) (a2 + 2) = v19;
                    v14 = HIWORD(v19);
                    *(_BYTE*) (a2 + 4) = BYTE2(v19);
                }
                v19 = v14;
            }
            if(--v11 < 0)
                return sub_44EC2C(v2, a2 + 8);
        }
        v13 = ((v10 >> 1) + v20 * (v16 - (unsigned __int8) v2 [4 * v11 + 3])) / v10;
        if(v13 < v20) {
            if(v13 > 0)
                v19 |= v13 + 1;
        }
        else {
            v19 |= 1u;
        }
        v2 = a1;
        goto LABEL_33;
    }
    *(_BYTE*) (a2 + 7) = 0;
    *(_BYTE*) (a2 + 6) = 0;
    *(_BYTE*) (a2 + 5) = 0;
    *(_BYTE*) (a2 + 4) = 0;
    *(_BYTE*) (a2 + 3) = 0;
    *(_BYTE*) (a2 + 2) = 0;
    return sub_44EC2C(v2, a2 + 8);
}

//----- (0044EE0D) --------------------------------------------------------
int __cdecl sub_44EE0D(int a1, int a2) {
    return (a1 + a2 - 1) / a2;
}

//----- (0044EE1D) --------------------------------------------------------
int __cdecl sub_44EE1D(int a1, int a2) {
    return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

//----- (0044EE35) --------------------------------------------------------
const void** __cdecl sub_44EE35(int a1, int a2, int a3, int a4, int a5, unsigned int a6) {
    const void** result; // eax
    void** v7; // edx
    int v8; // [esp+Ch] [ebp+Ch]

    result = (const void**) (a1 + 4 * a2);
    v7 = (void**) (a3 + 4 * a4);
    if(a5 > 0) {
        v8 = a5;
        do {
            qmemcpy(*v7++, *result++, a6);
            --v8;
        }
        while(v8);
    }
    return result;
}

//----- (0044EE7C) --------------------------------------------------------
int __cdecl sub_44EE7C(const void* a1, void* a2, int a3) {
    int result; // eax

    result = a3 << 7;
    qmemcpy(a2, a1, 4 * ((unsigned int) (a3 << 7) >> 2));
    return result;
}

//----- (0044EE9E) --------------------------------------------------------
int __cdecl sub_44EE9E(void* a1, unsigned int a2) {
    int result; // eax

    result = 0;
    memset(a1, 0, a2);
    return result;
}

//----- (0044EEB9) --------------------------------------------------------
unsigned int sub_44EEB9() {
    unsigned int v0; // kr00_4
    unsigned int v1; // kr04_4
    int v2; // edx

    v0 = __readeflags();
    __writeeflags(v0 ^ 0x200000);
    v1 = __readeflags();
    v2 = v0 ^ v1;
    if(v0 != v1) {
        _EAX = 1;
        __asm { cpuid }
        return (_EDX & 0x800000u) >> 23;
    }
    return v2;
}

//----- (0044EEEA) --------------------------------------------------------
int __usercall sub_44EEEA(int a1) {
    int v1; // ebx
    bool v2; // cc
    int v3; // edi
    int* v4; // edi
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // ebx
    int v10; // edi
    int v11; // eax
    int result; // eax

    if(*(int*) (a1 + 28) > 65500 || *(int*) (a1 + 24) > 65500) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 40;
        *(_DWORD*) (*(_DWORD*) a1 + 24) = 65500;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if(*(_DWORD*) (a1 + 192) != 8) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 13;
        *(_DWORD*) (*(_DWORD*) a1 + 24) = *(_DWORD*) (a1 + 192);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if(*(int*) (a1 + 32) > 10) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 24;
        *(_DWORD*) (*(_DWORD*) a1 + 24) = *(_DWORD*) (a1 + 32);
        *(_DWORD*) (*(_DWORD*) a1 + 28) = 10;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v1 = 0;
    v2 = *(_DWORD*) (a1 + 32) <= 0;
    v3 = *(_DWORD*) (a1 + 196);
    *(_DWORD*) (a1 + 268) = 1;
    *(_DWORD*) (a1 + 272) = 1;
    if(!v2) {
        v4 = (int*) (v3 + 12);
        do {
            v5 = *(v4 - 1);
            if(v5 <= 0 || v5 > 4 || *v4 <= 0 || *v4 > 4) {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 16;
                (**(void(__cdecl***)(int))a1)(a1);
            }
            v6 = *(_DWORD*) (a1 + 268);
            if(v6 <= *(v4 - 1))
                v6 = *(v4 - 1);
            *(_DWORD*) (a1 + 268) = v6;
            v7 = *(_DWORD*) (a1 + 272);
            if(v7 <= *v4)
                v7 = *v4;
            ++v1;
            v4 += 21;
            v2 = v1 < *(_DWORD*) (a1 + 32);
            *(_DWORD*) (a1 + 272) = v7;
        }
        while(v2);
    }
    v8 = *(_DWORD*) (a1 + 196);
    v9 = 0;
    v2 = *(_DWORD*) (a1 + 32) <= 0;
    *(_DWORD*) (a1 + 276) = 8;
    if(!v2) {
        v10 = v8 + 28;
        do {
            *(_DWORD*) (v10 + 8) = 8;
            *(_DWORD*) v10 = sub_44EE0D(*(_DWORD*) (a1 + 24) * *(_DWORD*) (v10 - 20), 8 * *(_DWORD*) (a1 + 268));
            *(_DWORD*) (v10 + 4) = sub_44EE0D(*(_DWORD*) (a1 + 28) * *(_DWORD*) (v10 - 16), 8 * *(_DWORD*) (a1 + 272));
            *(_DWORD*) (v10 + 12) = sub_44EE0D(*(_DWORD*) (a1 + 24) * *(_DWORD*) (v10 - 20), *(_DWORD*) (a1 + 268));
            v11 = sub_44EE0D(*(_DWORD*) (a1 + 28) * *(_DWORD*) (v10 - 16), *(_DWORD*) (a1 + 272));
            *(_DWORD*) (v10 + 48) = 0;
            *(_DWORD*) (v10 + 16) = v11;
            *(_BYTE*) (v10 + 20) = 1;
            ++v9;
            v10 += 84;
        }
        while(v9 < *(_DWORD*) (a1 + 32));
    }
    *(_DWORD*) (a1 + 280) = sub_44EE0D(*(_DWORD*) (a1 + 28), 8 * *(_DWORD*) (a1 + 272));
    if(*(_DWORD*) (a1 + 288) < *(_DWORD*) (a1 + 32) || *(_BYTE*) (a1 + 200)) {
        result = *(_DWORD*) (a1 + 396);
        *(_BYTE*) (result + 16) = 1;
    }
    else {
        result = *(_DWORD*) (a1 + 396);
        *(_BYTE*) (result + 16) = 0;
    }
    return result;
}

//----- (0044F0A5) --------------------------------------------------------
int __usercall sub_44F0A5(int* a1) {
    int v1; // eax
    _DWORD* v2; // ecx
    unsigned int v3; // ebx
    int result; // eax
    int v5; // edx
    bool v6; // cc
    _DWORD* v7; // ecx
    unsigned int v8; // ebx
    int v9; // edi
    int v10; // edx
    int v11; // edi
    unsigned int v12; // eax
    unsigned int v13; // ebx
    int v14; // edx
    int* v15; // [esp+8h] [ebp-8h]
    int v16; // [esp+Ch] [ebp-4h]

    v1 = a1 [72];
    if(v1 == 1) {
        v2 = (_DWORD*) a1 [73];
        a1 [77] = v2 [7];
        a1 [78] = v2 [8];
        v3 = v2 [3];
        v2 [16] = v2 [9];
        result = v2 [8] / v3;
        v5 = v2 [8] % v3;
        v2 [13] = 1;
        v2 [14] = 1;
        v2 [15] = 1;
        v2 [17] = 1;
        if(!v5)
            v5 = v3;
        v2 [18] = v5;
        a1 [80] = 0;
        a1 [79] = 1;
    }
    else {
        if(v1 <= 0 || v1 > 4) {
            *(_DWORD*) (*a1 + 20) = 24;
            *(_DWORD*) (*a1 + 24) = a1 [72];
            *(_DWORD*) (*a1 + 28) = 4;
            (*(void(__cdecl**)(int*)) * a1)(a1);
        }
        a1 [77] = sub_44EE0D(a1 [6], 8 * a1 [67]);
        result = sub_44EE0D(a1 [7], 8 * a1 [68]);
        v6 = a1 [72] <= 0;
        a1 [78] = result;
        a1 [79] = 0;
        v16 = 0;
        if(!v6) {
            v15 = a1 + 73;
            do {
                v7 = (_DWORD*) *v15;
                v8 = *(_DWORD*) (*v15 + 8);
                v9 = *(_DWORD*) (*v15 + 12);
                v7 [16] = v8 * *(_DWORD*) (*v15 + 36);
                v10 = v7 [7] % v8;
                v7 [14] = v9;
                v11 = v8 * v9;
                v7 [13] = v8;
                v7 [15] = v11;
                if(!v10)
                    v10 = v8;
                v12 = v7 [8];
                v13 = v7 [3];
                v7 [17] = v10;
                v14 = v12 % v13;
                if(!(v12 % v13))
                    v14 = v13;
                v7 [18] = v14;
                if(v11 + a1 [79] > 10) {
                    *(_DWORD*) (*a1 + 20) = 11;
                    (*(void(__cdecl**)(int*)) * a1)(a1);
                }
                if(v11 > 0) {
                    do {
                        a1 [a1 [79]++ + 80] = v16;
                        --v11;
                    }
                    while(v11);
                }
                result = ++v16;
                ++v15;
            }
            while(v16 < a1 [72]);
        }
    }
    return result;
}

//----- (0044F21B) --------------------------------------------------------
void __usercall sub_44F21B(int a1) {
    unsigned int v1; // esi
    void* v2; // eax
    int v3; // [esp+0h] [ebp-Ch]
    int v4; // [esp+4h] [ebp-8h]
    int* v5; // [esp+8h] [ebp-4h]

    v4 = 0;
    if(*(int*) (a1 + 288) > 0) {
        v5 = (int*) (a1 + 292);
        do {
            v3 = *v5;
            if(!*(_DWORD*) (*v5 + 76)) {
                v1 = *(_DWORD*) (*v5 + 16);
                if(v1 > 3 || !*(_DWORD*) (a1 + 4 * v1 + 144)) {
                    *(_DWORD*) (*(_DWORD*) a1 + 20) = 51;
                    *(_DWORD*) (*(_DWORD*) a1 + 24) = v1;
                    (**(void(__cdecl***)(int))a1)(a1);
                }
                v2 = (void*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 130);
                qmemcpy(v2, *(const void**) (a1 + 4 * v1 + 144), 0x82u);
                *(_DWORD*) (v3 + 76) = v2;
            }
            ++v4;
            ++v5;
        }
        while(v4 < *(_DWORD*) (a1 + 288));
    }
}

//----- (0044F2AD) --------------------------------------------------------
int __cdecl sub_44F2AD(int a1) {
    int result; // eax

    sub_44F0A5((int*) a1);
    sub_44F21B(a1);
    (**(void(__cdecl***)(int))(a1 + 404))(a1);
    (**(void(__cdecl***)(int))(a1 + 388))(a1);
    result = *(_DWORD*) (*(_DWORD*) (a1 + 388) + 4);
    **(_DWORD**) (a1 + 396) = result;
    return result;
}

//----- (0044F2E7) --------------------------------------------------------
int __cdecl sub_44F2E7(_DWORD* a1) {
    _BYTE* v1; // edi
    int v3; // ebp
    bool v4; // zf
    int v5; // esi

    v1 = (_BYTE*) a1 [99];
    if(v1 [17])
        return 2;
    v3 = (*(int(__cdecl**)(_DWORD*))(a1 [100] + 4))(a1);
    if(v3 == 1) {
        if(v1 [20]) {
            sub_44EEEA((int) a1);
            v1 [20] = 0;
        }
        else {
            if(!v1 [16]) {
                *(_DWORD*) (*a1 + 20) = 34;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
            sub_44F2AD((int) a1);
        }
    }
    else if(v3 == 2) {
        v4 = v1 [20] == 0;
        v1 [17] = 1;
        if(v4) {
            v5 = a1 [31];
            if(a1 [33] > v5)
                a1 [33] = v5;
        }
        else if(*(_BYTE*) (a1 [100] + 81)) {
            *(_DWORD*) (*a1 + 20) = 58;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
    }
    return v3;
}

//----- (0044F37A) --------------------------------------------------------
int __cdecl sub_44F37A(int a1) {
    int v1; // eax
    int result; // eax

    v1 = *(_DWORD*) (a1 + 396);
    *(_BYTE*) (v1 + 16) = 0;
    *(_BYTE*) (v1 + 17) = 0;
    *(_DWORD*) v1 = sub_44F2E7;
    *(_BYTE*) (v1 + 20) = 1;
    (*(void(__cdecl**)(int))(*(_DWORD*) a1 + 16))(a1);
    result = (**(int(__cdecl***)(int))(a1 + 400))(a1);
    *(_DWORD*) (a1 + 140) = 0;
    return result;
}

//----- (0044F3B1) --------------------------------------------------------
_DWORD* __cdecl sub_44F3B1(int a1) {
    _DWORD* result; // eax

    result = *(_DWORD**) (a1 + 396);
    *result = sub_44F2E7;
    return result;
}

//----- (0044F3C2) --------------------------------------------------------
int __cdecl sub_44F3C2(int a1) {
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
    *(_DWORD*) (a1 + 396) = result;
    *(_BYTE*) (result + 16) = 0;
    *(_BYTE*) (result + 17) = 0;
    *(_DWORD*) result = sub_44F2E7;
    *(_DWORD*) (result + 4) = sub_44F37A;
    *(_DWORD*) (result + 8) = sub_44F2AD;
    *(_DWORD*) (result + 12) = sub_44F3B1;
    *(_BYTE*) (result + 20) = 1;
    return result;
}

//----- (0044F403) --------------------------------------------------------
int __usercall sub_44F403(int a1, int a2) {
    *(_DWORD*) (*(_DWORD*) a1 + 20) = 53;
    *(_DWORD*) (*(_DWORD*) a1 + 24) = a2;
    return (**(int(__cdecl***)(int))a1)(a1);
}

//----- (0044F418) --------------------------------------------------------
int __cdecl sub_44F418(_DWORD* a1, unsigned int a2, unsigned int a3) {
    unsigned int v3; // ebx
    _DWORD* v5; // eax
    unsigned int v6; // edi
    unsigned int v7; // esi
    _DWORD* v8; // ecx
    int v9; // ecx
    int v11; // [esp+Ch] [ebp-4h]
    _DWORD* v12; // [esp+1Ch] [ebp+Ch]
    _DWORD* v13; // [esp+20h] [ebp+10h]

    v3 = a3;
    v11 = a1 [1];
    if(a3 > 0x3B9AC9F0)
        sub_44F403((int) a1, 1);
    if((a3 & 7) != 0)
        v3 = 8 - (a3 & 7) + a3;
    if(a2 >= 2) {
        *(_DWORD*) (*a1 + 20) = 12;
        *(_DWORD*) (*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v13 = 0;
    v12 = (_DWORD*) (v11 + 4 * a2 + 48);
    v5 = (_DWORD*) *v12;
    if(!*v12)
        goto LABEL_11;
    do {
        if(v5 [2] >= v3)
            break;
        v13 = v5;
        v5 = (_DWORD*) *v5;
    }
    while(v5);
    if(!v5) {
        LABEL_11:
        v6 = v3 + 16;
        if(v13)
            v7 = dword_46EBB8 [a2];
        else
            v7 = dword_46EBB0 [a2];
        if(v7 > 1000000000 - v6)
            v7 = 1000000000 - v6;
        while(1) {
            v5 = sub_451E6B((int) a1, v7 + v6);
            if(v5)
                break;
            v7 >>= 1;
            if(v7 < 0x32)
                sub_44F403((int) a1, 2);
        }
        *(_DWORD*) (v11 + 72) += v7 + v6;
        v8 = v13;
        *v5 = 0;
        v5 [1] = 0;
        v5 [2] = v3 + v7;
        if(!v13)
            v8 = v12;
        *v8 = v5;
    }
    v9 = v5 [1];
    v5 [2] -= v3;
    v5 [1] = v3 + v9;
    return (int) v5 + v9 + 16;
}
// 46EBB0: using guessed type int dword_46EBB0[];
// 46EBB8: using guessed type int dword_46EBB8[];

//----- (0044F514) --------------------------------------------------------
_DWORD* __cdecl sub_44F514(_DWORD* a1, unsigned int a2, unsigned int a3) {
    int v3; // ebx
    unsigned int v4; // edi
    _DWORD* v5; // esi
    int* v6; // eax
    int v7; // ecx

    v3 = a1 [1];
    v4 = a3;
    if(a3 > 0x3B9AC9F0)
        sub_44F403((int) a1, 3);
    if((a3 & 7) != 0)
        v4 = 8 - (a3 & 7) + a3;
    if(a2 >= 2) {
        *(_DWORD*) (*a1 + 20) = 12;
        *(_DWORD*) (*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v5 = sub_451E6B((int) a1, v4 + 16);
    if(!v5)
        sub_44F403((int) a1, 4);
    *(_DWORD*) (v3 + 72) += v4 + 16;
    v6 = (int*) (v3 + 4 * a2 + 56);
    v7 = *v6;
    v5 [2] = 0;
    v5 [1] = v4;
    *v5 = v7;
    *v6 = (int) v5;
    return v5 + 4;
}

//----- (0044F5A2) --------------------------------------------------------
int __cdecl sub_44F5A2(_DWORD* a1, unsigned int a2, unsigned int a3, unsigned int a4) {
    int v4; // edi
    unsigned int v5; // esi
    unsigned int v7; // edi
    _DWORD* v8; // eax
    unsigned int v9; // ecx
    int v11; // [esp+20h] [ebp+14h]

    v4 = a1 [1];
    v5 = 0x3B9AC9F0 / a3;
    if((int) (0x3B9AC9F0 / a3) <= 0) {
        *(_DWORD*) (*a1 + 20) = 69;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if((int) v5 >= (int) a4)
        v5 = a4;
    *(_DWORD*) (v4 + 76) = v5;
    v7 = 0;
    v11 = sub_44F418(a1, a2, 4 * a4);
    while(v7 < a4) {
        if(v5 >= a4 - v7)
            v5 = a4 - v7;
        v8 = sub_44F514(a1, a2, a3 * v5);
        if(v5) {
            v9 = v5;
            do {
                *(_DWORD*) (v11 + 4 * v7) = v8;
                v8 = (_DWORD*) ((char*) v8 + a3);
                ++v7;
                --v9;
            }
            while(v9);
        }
    }
    return v11;
}

//----- (0044F634) --------------------------------------------------------
int __cdecl sub_44F634(_DWORD* a1, unsigned int a2, int a3, signed int a4) {
    int v4; // edi
    signed int v5; // esi
    unsigned int v7; // edi
    _DWORD* v8; // eax
    signed int v9; // ecx
    int v11; // [esp+24h] [ebp+14h]

    v4 = a1 [1];
    v5 = 0x3B9AC9F0u / (a3 << 7);
    if(v5 <= 0) {
        *(_DWORD*) (*a1 + 20) = 69;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if(v5 >= a4)
        v5 = a4;
    *(_DWORD*) (v4 + 76) = v5;
    v7 = 0;
    v11 = sub_44F418(a1, a2, 4 * a4);
    while(v7 < a4) {
        if(v5 >= a4 - v7)
            v5 = a4 - v7;
        v8 = sub_44F514(a1, a2, (a3 * v5) << 7);
        if(v5) {
            v9 = v5;
            do {
                *(_DWORD*) (v11 + 4 * v7) = v8;
                v8 += 32 * a3;
                ++v7;
                --v9;
            }
            while(v9);
        }
    }
    return v11;
}

//----- (0044F6D2) --------------------------------------------------------
int __cdecl sub_44F6D2(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6) {
    int v6; // esi
    int result; // eax

    v6 = a1 [1];
    if(a2 != 1) {
        *(_DWORD*) (*a1 + 20) = 12;
        *(_DWORD*) (*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_44F418(a1, a2, 0x78u);
    *(_DWORD*) result = 0;
    *(_DWORD*) (result + 4) = a5;
    *(_DWORD*) (result + 8) = a4;
    *(_DWORD*) (result + 12) = a6;
    *(_BYTE*) (result + 34) = 0;
    *(_BYTE*) (result + 32) = a3;
    *(_DWORD*) (result + 36) = *(_DWORD*) (v6 + 64);
    *(_DWORD*) (v6 + 64) = result;
    return result;
}

//----- (0044F733) --------------------------------------------------------
int __cdecl sub_44F733(_DWORD* a1, unsigned int a2, char a3, int a4, int a5, int a6) {
    int v6; // esi
    int result; // eax

    v6 = a1 [1];
    if(a2 != 1) {
        *(_DWORD*) (*a1 + 20) = 12;
        *(_DWORD*) (*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    result = sub_44F418(a1, a2, 0x78u);
    *(_DWORD*) result = 0;
    *(_DWORD*) (result + 4) = a5;
    *(_DWORD*) (result + 8) = a4;
    *(_DWORD*) (result + 12) = a6;
    *(_BYTE*) (result + 34) = 0;
    *(_BYTE*) (result + 32) = a3;
    *(_DWORD*) (result + 36) = *(_DWORD*) (v6 + 68);
    *(_DWORD*) (v6 + 68) = result;
    return result;
}

//----- (0044F794) --------------------------------------------------------
int __cdecl sub_44F794(_DWORD* a1) {
    _DWORD* v1; // edi
    _DWORD* v2; // eax
    int v3; // esi
    int v4; // ebx
    int v5; // ecx
    int result; // eax
    int v7; // ecx
    int i; // esi
    int v9; // ebx
    unsigned int v10; // ecx
    int j; // esi
    int v12; // ebx
    unsigned int v13; // ecx
    signed int v14; // [esp+Ch] [ebp-4h]

    v1 = (_DWORD*) a1 [1];
    v2 = (_DWORD*) v1 [16];
    v3 = 0;
    v4 = 0;
    while(v2) {
        if(!*v2) {
            v5 = v2 [2];
            v3 += v5 * v2 [3];
            v4 += v5 * v2 [1];
        }
        v2 = (_DWORD*) v2 [9];
    }
    for(result = v1 [17]; result; result = *(_DWORD*) (result + 36)) {
        if(!*(_DWORD*) result) {
            v7 = *(_DWORD*) (result + 8);
            v3 += (v7 * *(_DWORD*) (result + 12)) << 7;
            v4 += (v7 * *(_DWORD*) (result + 4)) << 7;
        }
    }
    if(v3 > 0) {
        result = sub_451E81((int) a1, v3, v4);
        if(result < v4) {
            result /= v3;
            v14 = result;
            if(result <= 0)
                v14 = 1;
        }
        else {
            v14 = 1000000000;
        }
        for(i = v1 [16]; i; i = *(_DWORD*) (i + 36)) {
            if(!*(_DWORD*) i) {
                v9 = *(_DWORD*) (i + 4);
                v10 = *(_DWORD*) (i + 12);
                if((int) ((v9 - 1) / v10 + 1) > v14) {
                    *(_DWORD*) (i + 16) = v14 * v10;
                    sub_451E86((int) a1);
                    *(_BYTE*) (i + 34) = 1;
                }
                else {
                    *(_DWORD*) (i + 16) = v9;
                }
                *(_DWORD*) i = sub_44F5A2(a1, 1u, *(_DWORD*) (i + 8), *(_DWORD*) (i + 16));
                result = v1 [19];
                *(_DWORD*) (i + 24) = 0;
                *(_DWORD*) (i + 28) = 0;
                *(_BYTE*) (i + 33) = 0;
                *(_DWORD*) (i + 20) = result;
            }
        }
        for(j = v1 [17]; j; j = *(_DWORD*) (j + 36)) {
            if(!*(_DWORD*) j) {
                v12 = *(_DWORD*) (j + 4);
                v13 = *(_DWORD*) (j + 12);
                if((int) ((v12 - 1) / v13 + 1) > v14) {
                    *(_DWORD*) (j + 16) = v14 * v13;
                    sub_451E86((int) a1);
                    *(_BYTE*) (j + 34) = 1;
                }
                else {
                    *(_DWORD*) (j + 16) = v12;
                }
                *(_DWORD*) j = sub_44F634(a1, 1u, *(_DWORD*) (j + 8), *(_DWORD*) (j + 16));
                result = v1 [19];
                *(_DWORD*) (j + 24) = 0;
                *(_DWORD*) (j + 28) = 0;
                *(_BYTE*) (j + 33) = 0;
                *(_DWORD*) (j + 20) = result;
            }
        }
    }
    return result;
}

//----- (0044F913) --------------------------------------------------------
int __usercall sub_44F913(int a1, int a2, char a3) {
    int v3; // ebx
    int result; // eax
    int i; // edi
    int v6; // ecx
    int v7; // [esp-4h] [ebp-14h]
    int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v3 = *(_DWORD*) (a1 + 8) * *(_DWORD*) (a1 + 24);
    v8 = *(_DWORD*) (a1 + 8);
    result = *(_DWORD*) (a1 + 16);
    for(i = 0; i < result; v3 += v9) {
        result -= i;
        if(*(_DWORD*) (a1 + 20) < result)
            result = *(_DWORD*) (a1 + 20);
        v6 = i + *(_DWORD*) (a1 + 24);
        if(result >= *(_DWORD*) (a1 + 28) - v6)
            result = *(_DWORD*) (a1 + 28) - v6;
        if(result >= *(_DWORD*) (a1 + 4) - v6)
            result = *(_DWORD*) (a1 + 4) - v6;
        if(result <= 0)
            break;
        v7 = v8 * result;
        v9 = v8 * result;
        if(a3)
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 44))(
                a2,
                a1 + 40,
                *(_DWORD*) (*(_DWORD*) a1 + 4 * i),
                v3,
                v7);
        else
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 40))(
                a2,
                a1 + 40,
                *(_DWORD*) (*(_DWORD*) a1 + 4 * i),
                v3,
                v7);
        i += *(_DWORD*) (a1 + 20);
        result = *(_DWORD*) (a1 + 16);
    }
    return result;
}

//----- (0044F99B) --------------------------------------------------------
int __usercall sub_44F99B(int a1, int a2, char a3) {
    int v3; // ebx
    int result; // eax
    int i; // edi
    int v6; // ecx
    int v7; // [esp-4h] [ebp-14h]
    int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v3 = (*(_DWORD*) (a1 + 8) << 7) * *(_DWORD*) (a1 + 24);
    v8 = *(_DWORD*) (a1 + 8) << 7;
    result = *(_DWORD*) (a1 + 16);
    for(i = 0; i < result; v3 += v9) {
        result -= i;
        if(*(_DWORD*) (a1 + 20) < result)
            result = *(_DWORD*) (a1 + 20);
        v6 = i + *(_DWORD*) (a1 + 24);
        if(result >= *(_DWORD*) (a1 + 28) - v6)
            result = *(_DWORD*) (a1 + 28) - v6;
        if(result >= *(_DWORD*) (a1 + 4) - v6)
            result = *(_DWORD*) (a1 + 4) - v6;
        if(result <= 0)
            break;
        v7 = v8 * result;
        v9 = v8 * result;
        if(a3)
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 44))(
                a2,
                a1 + 40,
                *(_DWORD*) (*(_DWORD*) a1 + 4 * i),
                v3,
                v7);
        else
            (*(void(__cdecl**)(int, int, _DWORD, int, int))(a1 + 40))(
                a2,
                a1 + 40,
                *(_DWORD*) (*(_DWORD*) a1 + 4 * i),
                v3,
                v7);
        i += *(_DWORD*) (a1 + 20);
        result = *(_DWORD*) (a1 + 16);
    }
    return result;
}

//----- (0044FA26) --------------------------------------------------------
int __cdecl sub_44FA26(int a1, int a2, unsigned int a3, unsigned int a4, char a5) {
    unsigned int v5; // ebx
    int v6; // edi
    unsigned int v7; // eax
    int v8; // eax
    unsigned int v9; // eax
    unsigned int v10; // edi
    int v11; // eax
    unsigned int v12; // edi
    unsigned int v13; // ebx
    unsigned int v15; // [esp+14h] [ebp+8h]

    v5 = a3 + a4;
    if(a3 + a4 <= *(_DWORD*) (a2 + 4) && a4 <= *(_DWORD*) (a2 + 12) && *(_DWORD*) a2) {
        v6 = a1;
    }
    else {
        v6 = a1;
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 20;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v7 = *(_DWORD*) (a2 + 24);
    if(a3 < v7 || v5 > v7 + *(_DWORD*) (a2 + 16)) {
        if(!*(_BYTE*) (a2 + 34)) {
            *(_DWORD*) (*(_DWORD*) v6 + 20) = 68;
            (**(void(__cdecl***)(int))v6)(v6);
        }
        if(*(_BYTE*) (a2 + 33)) {
            sub_44F913(a2, v6, 1);
            *(_BYTE*) (a2 + 33) = 0;
        }
        v8 = a3;
        if(a3 <= *(_DWORD*) (a2 + 24)) {
            v8 = v5 - *(_DWORD*) (a2 + 16);
            if(v8 < 0)
                v8 = 0;
        }
        *(_DWORD*) (a2 + 24) = v8;
        sub_44F913(a2, v6, 0);
    }
    v9 = *(_DWORD*) (a2 + 28);
    if(v9 < v5) {
        if(v9 >= a3) {
            v10 = *(_DWORD*) (a2 + 28);
        }
        else {
            if(a5) {
                *(_DWORD*) (*(_DWORD*) v6 + 20) = 20;
                (**(void(__cdecl***)(int))v6)(v6);
            }
            v10 = a3;
        }
        if(a5)
            *(_DWORD*) (a2 + 28) = v5;
        if(*(_BYTE*) (a2 + 32)) {
            v15 = *(_DWORD*) (a2 + 8);
            v11 = *(_DWORD*) (a2 + 24);
            v12 = v10 - v11;
            v13 = v5 - v11;
            while(v12 < v13)
                sub_44EE9E(*(void**) (*(_DWORD*) a2 + 4 * v12++), v15);
        }
        else {
            if(a5) {
                LABEL_32:
                *(_BYTE*) (a2 + 33) = 1;
                return *(_DWORD*) a2 + 4 * (a3 - *(_DWORD*) (a2 + 24));
            }
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 20;
            (**(void(__cdecl***)(int))a1)(a1);
        }
    }
    if(a5)
        goto LABEL_32;
    return *(_DWORD*) a2 + 4 * (a3 - *(_DWORD*) (a2 + 24));
}

//----- (0044FB44) --------------------------------------------------------
int __cdecl sub_44FB44(int a1, int a2, unsigned int a3, unsigned int a4, char a5) {
    unsigned int v6; // edi
    unsigned int v7; // eax
    int v8; // eax
    unsigned int v9; // ebx
    int v10; // eax
    unsigned int v11; // edi
    unsigned int v12; // ebx
    unsigned int v14; // [esp+20h] [ebp+14h]
    unsigned int v15; // [esp+20h] [ebp+14h]

    v6 = a3 + a4;
    v14 = a3 + a4;
    if(v14 > *(_DWORD*) (a2 + 4) || a4 > *(_DWORD*) (a2 + 12) || !*(_DWORD*) a2) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 20;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v7 = *(_DWORD*) (a2 + 24);
    if(a3 < v7 || v6 > v7 + *(_DWORD*) (a2 + 16)) {
        if(!*(_BYTE*) (a2 + 34)) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 68;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if(*(_BYTE*) (a2 + 33)) {
            sub_44F99B(a2, a1, 1);
            *(_BYTE*) (a2 + 33) = 0;
        }
        if(a3 <= *(_DWORD*) (a2 + 24)) {
            v8 = v6 - *(_DWORD*) (a2 + 16);
            if(v8 < 0)
                v8 = 0;
            *(_DWORD*) (a2 + 24) = v8;
        }
        else {
            *(_DWORD*) (a2 + 24) = a3;
        }
        sub_44F99B(a2, a1, 0);
    }
    v9 = *(_DWORD*) (a2 + 28);
    if(v9 < v6) {
        if(v9 < a3) {
            if(a5) {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 20;
                (**(void(__cdecl***)(int))a1)(a1);
            }
            v9 = a3;
        }
        if(a5)
            *(_DWORD*) (a2 + 28) = v6;
        if(*(_BYTE*) (a2 + 32)) {
            v10 = *(_DWORD*) (a2 + 24);
            v11 = *(_DWORD*) (a2 + 8) << 7;
            v12 = v9 - v10;
            v15 = v14 - v10;
            while(v12 < v15)
                sub_44EE9E(*(void**) (*(_DWORD*) a2 + 4 * v12++), v11);
        }
        else {
            if(a5) {
                LABEL_32:
                *(_BYTE*) (a2 + 33) = 1;
                return *(_DWORD*) a2 + 4 * (a3 - *(_DWORD*) (a2 + 24));
            }
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 20;
            (**(void(__cdecl***)(int))a1)(a1);
        }
    }
    if(a5)
        goto LABEL_32;
    return *(_DWORD*) a2 + 4 * (a3 - *(_DWORD*) (a2 + 24));
}

//----- (0044FC67) --------------------------------------------------------
_DWORD* __cdecl sub_44FC67(_DWORD* a1, unsigned int a2) {
    unsigned int v2; // ebx
    _DWORD* v3; // esi
    int i; // edi
    int j; // edi
    _DWORD* v6; // eax
    _DWORD* v7; // ebx
    int v8; // edi
    _DWORD** v9; // ecx
    _DWORD* result; // eax
    _DWORD* v11; // ebx
    int v12; // edi

    v2 = a2;
    v3 = (_DWORD*) a1 [1];
    if(a2 >= 2) {
        *(_DWORD*) (*a1 + 20) = 12;
        *(_DWORD*) (*a1 + 24) = a2;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if(a2 == 1) {
        for(i = v3 [16]; i; i = *(_DWORD*) (i + 36)) {
            if(*(_BYTE*) (i + 34)) {
                *(_BYTE*) (i + 34) = 0;
                (*(void(__cdecl**)(_DWORD*, int))(i + 48))(a1, i + 40);
            }
        }
        v3 [16] = 0;
        for(j = v3 [17]; j; j = *(_DWORD*) (j + 36)) {
            if(*(_BYTE*) (j + 34)) {
                *(_BYTE*) (j + 34) = 0;
                (*(void(__cdecl**)(_DWORD*, int))(j + 48))(a1, j + 40);
            }
        }
        v3 [17] = 0;
    }
    v6 = (_DWORD*) v3 [a2 + 14];
    v3 [a2 + 14] = 0;
    if(v6) {
        do {
            v7 = (_DWORD*) *v6;
            v8 = v6 [2] + v6 [1] + 16;
            sub_451E76((int) a1, v6);
            v3 [18] -= v8;
            v6 = v7;
        }
        while(v7);
        v2 = a2;
    }
    v9 = (_DWORD**) &v3 [v2 + 12];
    result = *v9;
    *v9 = 0;
    if(result) {
        do {
            v11 = (_DWORD*) *result;
            v12 = result [2] + result [1] + 16;
            sub_451E76((int) a1, result);
            v3 [18] -= v12;
            result = v11;
        }
        while(v11);
    }
    return result;
}

//----- (0044FD48) --------------------------------------------------------
int __cdecl sub_44FD48(int a1) {
    signed int i; // edi

    for(i = 1; i >= 0; --i)
        sub_44FC67((_DWORD*) a1, i);
    sub_451E76(a1, *(void**) (a1 + 4));
    *(_DWORD*) (a1 + 4) = 0;
    return nullsub_1(a1);
}
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);

//----- (0044FD78) --------------------------------------------------------
_DWORD* __cdecl sub_44FD78(_DWORD* a1) {
    int v1; // edi
    _DWORD* result; // eax
    _DWORD* v3; // ecx
    int v4; // edx

    a1 [1] = 0;
    v1 = sub_4671A5();
    result = sub_451E6B((int) a1, 0x50u);
    if(result) {
        *result = sub_44F418;
        result [1] = sub_44F514;
        result [2] = sub_44F5A2;
        result [3] = sub_44F634;
        result [4] = sub_44F6D2;
        result [5] = sub_44F733;
        result [6] = sub_44F794;
        result [7] = sub_44FA26;
        result [8] = sub_44FB44;
        result [9] = sub_44FC67;
        result [10] = sub_44FD48;
        result [11] = v1;
        v3 = result + 15;
        v4 = 2;
        do {
            *(v3 - 2) = 0;
            *v3-- = 0;
            --v4;
        }
        while(v4);
        result [16] = 0;
        result [17] = 0;
        result [18] = 80;
        a1 [1] = result;
    }
    else {
        nullsub_1(a1);
        *(_DWORD*) (*a1 + 20) = 53;
        *(_DWORD*) (*a1 + 24) = 0;
        return (_DWORD*) (*(int(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    return result;
}
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);

//----- (0044FE2C) --------------------------------------------------------
int __cdecl sub_44FE2C(int a1) {
    int result; // eax

    (*(void(__cdecl**)(int, int))(*(_DWORD*) (a1 + 4) + 36))(a1, 1);
    result = *(_BYTE*) (a1 + 12) != 0 ? 200 : 100;
    *(_DWORD*) (a1 + 16) = result;
    return result;
}

//----- (0044FE4E) --------------------------------------------------------
int __cdecl sub_44FE4E(int a1) {
    int result; // eax

    result = *(_DWORD*) (a1 + 4);
    if(result)
        result = (*(int(__cdecl**)(int))(result + 40))(a1);
    *(_DWORD*) (a1 + 4) = 0;
    *(_DWORD*) (a1 + 16) = 0;
    return result;
}

//----- (0044FE69) --------------------------------------------------------
int __cdecl sub_44FE69(int a1) {
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
    *(_BYTE*) (result + 128) = 0;
    return result;
}

//----- (0044FE85) --------------------------------------------------------
int __cdecl sub_44FE85(int a1) {
    int result; // eax

    result = (**(int(__cdecl***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
    *(_BYTE*) (result + 273) = 0;
    return result;
}

//----- (0044FEA1) --------------------------------------------------------
char __fastcall sub_44FEA1(int a1, int a2) {
    _DWORD* v2; // ecx
    char result; // al
    int v4; // edx

    if(*(_BYTE*) (a2 + 72))
        return 0;
    if(*(_BYTE*) (a2 + 264))
        return 0;
    if(*(_DWORD*) (a2 + 36) != 3)
        return 0;
    if(*(_DWORD*) (a2 + 32) != 3)
        return 0;
    if(*(_DWORD*) (a2 + 40) != 2)
        return 0;
    if(*(_DWORD*) (a2 + 100) != 3)
        return 0;
    v2 = *(_DWORD**) (a2 + 196);
    if(v2 [2] != 2)
        return 0;
    result = 1;
    if(v2 [23] != 1)
        return 0;
    if(v2 [44] != 1)
        return 0;
    if((int) v2 [3] > 2)
        return 0;
    if(v2 [24] != 1)
        return 0;
    if(v2 [45] != 1)
        return 0;
    v4 = *(_DWORD*) (a2 + 276);
    if(v2 [9] != v4 || v2 [30] != v4 || v2 [51] != v4)
        return 0;
    return result;
}

//----- (0044FF12) --------------------------------------------------------
char __cdecl sub_44FF12(int a1) {
    int v2; // eax
    unsigned int v3; // ecx
    int v4; // eax
    int v5; // eax
    int v6; // eax
    int v7; // eax
    bool v8; // cc
    _DWORD* v9; // eax
    int v10; // edx
    int v11; // ebx
    _DWORD* v12; // edi
    int v13; // eax
    int v14; // ecx
    int v15; // eax
    int v16; // eax
    int v18; // [esp-18h] [ebp-20h]
    int v19; // [esp-18h] [ebp-20h]
    int v20; // [esp-18h] [ebp-20h]
    int v21; // [esp+4h] [ebp-4h]
    int i; // [esp+10h] [ebp+8h]

    if(*(_DWORD*) (a1 + 16) != 202) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 18;
        *(_DWORD*) (*(_DWORD*) a1 + 24) = *(_DWORD*) (a1 + 16);
        (**(void(__cdecl***)(int))a1)(a1);
    }
    v2 = *(_DWORD*) (a1 + 44);
    v3 = *(_DWORD*) (a1 + 48);
    if(8 * v2 > v3) {
        if(4 * v2 > v3) {
            if(2 * v2 > v3) {
                *(_DWORD*) (a1 + 92) = *(_DWORD*) (a1 + 24);
                v5 = *(_DWORD*) (a1 + 28);
                *(_DWORD*) (a1 + 276) = 8;
            }
            else {
                v7 = sub_44EE0D(*(_DWORD*) (a1 + 24), 2);
                v20 = *(_DWORD*) (a1 + 28);
                *(_DWORD*) (a1 + 92) = v7;
                v5 = sub_44EE0D(v20, 2);
                *(_DWORD*) (a1 + 276) = 4;
            }
        }
        else {
            v6 = sub_44EE0D(*(_DWORD*) (a1 + 24), 4);
            v19 = *(_DWORD*) (a1 + 28);
            *(_DWORD*) (a1 + 92) = v6;
            v5 = sub_44EE0D(v19, 4);
            *(_DWORD*) (a1 + 276) = 2;
        }
    }
    else {
        v4 = sub_44EE0D(*(_DWORD*) (a1 + 24), 8);
        v18 = *(_DWORD*) (a1 + 28);
        *(_DWORD*) (a1 + 92) = v4;
        v5 = sub_44EE0D(v18, 8);
        *(_DWORD*) (a1 + 276) = 1;
    }
    v21 = 0;
    v8 = *(_DWORD*) (a1 + 32) <= 0;
    *(_DWORD*) (a1 + 96) = v5;
    if(!v8) {
        v9 = (_DWORD*) (*(_DWORD*) (a1 + 196) + 12);
        do {
            v10 = *(_DWORD*) (a1 + 276);
            for(i = v10; i < 8; i *= 2) {
                if(2 * i * *(v9 - 1) > v10 * *(_DWORD*) (a1 + 268))
                    break;
                if(2 * i * *v9 > v10 * *(_DWORD*) (a1 + 272))
                    break;
            }
            ++v21;
            v9 [6] = i;
            v9 += 21;
        }
        while(v21 < *(_DWORD*) (a1 + 32));
    }
    v11 = 0;
    if(*(int*) (a1 + 32) > 0) {
        v12 = (_DWORD*) (*(_DWORD*) (a1 + 196) + 36);
        do {
            v12 [1] = sub_44EE0D(*(_DWORD*) (a1 + 24) * *v12 * *(v12 - 7), 8 * *(_DWORD*) (a1 + 268));
            v12 [2] = sub_44EE0D(*v12 * *(_DWORD*) (a1 + 28) * *(v12 - 6), 8 * *(_DWORD*) (a1 + 272));
            ++v11;
            v12 += 21;
        }
        while(v11 < *(_DWORD*) (a1 + 32));
    }
    v13 = *(_DWORD*) (a1 + 40);
    v14 = 1;
    if(v13 != 1) {
        if(v13 <= 1) {
            LABEL_25:
            *(_DWORD*) (a1 + 100) = *(_DWORD*) (a1 + 32);
            goto LABEL_27;
        }
        v14 = 3;
        if(v13 > 3) {
            if(v13 <= 5) {
                *(_DWORD*) (a1 + 100) = 4;
                goto LABEL_27;
            }
            goto LABEL_25;
        }
    }
    *(_DWORD*) (a1 + 100) = v14;
    LABEL_27:
    if(*(_BYTE*) (a1 + 74))
        v15 = 1;
    else
        v15 = *(_DWORD*) (a1 + 100);
    *(_DWORD*) (a1 + 104) = v15;
    LOBYTE(v16) = sub_44FEA1(v14, a1);
    if((_BYTE) v16) {
        v16 = *(_DWORD*) (a1 + 272);
        *(_DWORD*) (a1 + 108) = v16;
    }
    else {
        *(_DWORD*) (a1 + 108) = 1;
    }
    return v16;
}

//----- (00450101) --------------------------------------------------------
int __usercall sub_450101(int a1) {
    int v2; // edx
    int v3; // eax
    int v4; // edx
    int result; // eax

    v2 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1408) + 256;
    v3 = 0;
    *(_DWORD*) (a1 + 284) = v2;
    memset((void*) (v2 - 256), 0, 0x100u);
    do {
        *(_BYTE*) (v3 + v2) = v3;
        ++v3;
    }
    while(v3 <= 255);
    v4 = v2 + 128;
    memset((void*) (v4 + 128), 0xFFu, 0x180u);
    result = 0;
    memset((void*) (v4 + 512), 0, 0x180u);
    qmemcpy((void*) (v4 + 896), *(const void**) (a1 + 284), 0x80u);
    return result;
}

//----- (00450170) --------------------------------------------------------
int __usercall sub_450170(int a1) {
    int v1; // edi
    int v2; // ecx
    char v3; // al
    int result; // eax
    int v5; // ecx
    int v6; // eax
    int v7; // [esp+0h] [ebp-10h]
    char v8; // [esp+Ch] [ebp-4h]

    v1 = *(_DWORD*) (a1 + 380);
    sub_44FF12(v7);
    sub_450101(a1);
    *(_DWORD*) (v1 + 12) = 0;
    *(_BYTE*) (v1 + 16) = sub_44FEA1(v2, a1);
    *(_DWORD*) (v1 + 20) = 0;
    *(_DWORD*) (v1 + 24) = 0;
    v3 = *(_BYTE*) (a1 + 74);
    if(!v3 || !*(_BYTE*) (a1 + 64)) {
        *(_BYTE*) (a1 + 88) = 0;
        *(_BYTE*) (a1 + 89) = 0;
        *(_BYTE*) (a1 + 90) = 0;
    }
    if(v3) {
        if(*(_BYTE*) (a1 + 65)) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 46;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if(*(_DWORD*) (a1 + 100) == 3) {
            if(*(_DWORD*) (a1 + 116)) {
                *(_BYTE*) (a1 + 89) = 1;
                goto LABEL_10;
            }
            if(*(_BYTE*) (a1 + 80)) {
                *(_BYTE*) (a1 + 90) = 1;
                goto LABEL_10;
            }
        }
        else {
            *(_BYTE*) (a1 + 89) = 0;
            *(_BYTE*) (a1 + 90) = 0;
            *(_DWORD*) (a1 + 116) = 0;
        }
        *(_BYTE*) (a1 + 88) = 1;
        LABEL_10:
        if(*(_BYTE*) (a1 + 88)) {
            sub_45769D((_DWORD*) a1);
            *(_DWORD*) (v1 + 20) = *(_DWORD*) (a1 + 420);
        }
        if(*(_BYTE*) (a1 + 90) || *(_BYTE*) (a1 + 89)) {
            sub_456C05(a1);
            *(_DWORD*) (v1 + 24) = *(_DWORD*) (a1 + 420);
        }
    }
    if(!*(_BYTE*) (a1 + 65)) {
        if(*(_BYTE*) (v1 + 16)) {
            sub_455C7D(a1);
        }
        else {
            sub_455684(a1);
            sub_454EF9(a1);
        }
        sub_454A39(a1, *(_BYTE*) (a1 + 90));
    }
    sub_45479E(a1);
    if(*(_BYTE*) (a1 + 201)) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 1;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    else if(*(_BYTE*) (a1 + 200)) {
        sub_454586(a1);
    }
    else {
        sub_4539D4(a1);
    }
    if(*(_BYTE*) (*(_DWORD*) (a1 + 396) + 16) || (v8 = 0, *(_BYTE*) (a1 + 64)))
        v8 = 1;
    sub_45300F(a1, v8);
    if(!*(_BYTE*) (a1 + 65))
        sub_4523D8(a1, 0);
    (*(void(__cdecl**)(int))(*(_DWORD*) (a1 + 4) + 24))(a1);
    result = (*(int(__cdecl**)(int))(*(_DWORD*) (a1 + 396) + 8))(a1);
    v5 = *(_DWORD*) (a1 + 8);
    if(v5) {
        if(!*(_BYTE*) (a1 + 64)) {
            result = *(_DWORD*) (a1 + 396);
            if(*(_BYTE*) (result + 16)) {
                v6 = *(_DWORD*) (a1 + 32);
                if(*(_BYTE*) (a1 + 200))
                    v6 = 3 * v6 + 2;
                *(_DWORD*) (v5 + 4) = 0;
                *(_DWORD*) (*(_DWORD*) (a1 + 8) + 8) = v6 * *(_DWORD*) (a1 + 280);
                *(_DWORD*) (*(_DWORD*) (a1 + 8) + 12) = 0;
                result = (*(_BYTE*) (a1 + 90) != 0) + 2;
                *(_DWORD*) (*(_DWORD*) (a1 + 8) + 16) = result;
                ++* (_DWORD*) (v1 + 12);
            }
        }
    }
    return result;
}
// 45017D: variable 'v7' is possibly undefined
// 450191: variable 'v2' is possibly undefined

//----- (0045031D) --------------------------------------------------------
int __cdecl sub_45031D(int a1) {
    int v1; // edi
    int result; // eax

    v1 = *(_DWORD*) (a1 + 380);
    if(*(_BYTE*) (v1 + 8)) {
        *(_BYTE*) (v1 + 8) = 0;
        (**(void(__cdecl***)(int, _DWORD))(a1 + 420))(a1, 0);
        (**(void(__cdecl***)(int, int))(a1 + 392))(a1, 2);
        (**(void(__cdecl***)(int, int))(a1 + 384))(a1, 2);
    }
    else {
        if(*(_BYTE*) (a1 + 74) && !*(_DWORD*) (a1 + 116)) {
            if(*(_BYTE*) (a1 + 80) && *(_BYTE*) (a1 + 90)) {
                *(_DWORD*) (a1 + 420) = *(_DWORD*) (v1 + 24);
                *(_BYTE*) (v1 + 8) = 1;
            }
            else if(*(_BYTE*) (a1 + 88)) {
                *(_DWORD*) (a1 + 420) = *(_DWORD*) (v1 + 20);
            }
            else {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 45;
                (**(void(__cdecl***)(int))a1)(a1);
            }
        }
        (**(void(__cdecl***)(int))(a1 + 408))(a1);
        (*(void(__cdecl**)(int))(*(_DWORD*) (a1 + 388) + 8))(a1);
        if(!*(_BYTE*) (a1 + 65)) {
            if(!*(_BYTE*) (v1 + 16))
                (**(void(__cdecl***)(int))(a1 + 416))(a1);
            (**(void(__cdecl***)(int))(a1 + 412))(a1);
            if(*(_BYTE*) (a1 + 74))
                (**(void(__cdecl***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8*) (v1 + 8));
            (**(void(__cdecl***)(int, int))(a1 + 392))(a1, *(_BYTE*) (v1 + 8) != 0 ? 3 : 0);
            (**(void(__cdecl***)(int, _DWORD))(a1 + 384))(a1, 0);
        }
    }
    result = *(_DWORD*) (a1 + 8);
    if(result) {
        *(_DWORD*) (result + 12) = *(_DWORD*) (v1 + 12);
        result = *(_DWORD*) (v1 + 12) + (*(_BYTE*) (v1 + 8) != 0) + 1;
        *(_DWORD*) (*(_DWORD*) (a1 + 8) + 16) = result;
        if(*(_BYTE*) (a1 + 64)) {
            result = *(_DWORD*) (a1 + 396);
            if(!*(_BYTE*) (result + 17)) {
                result = *(_DWORD*) (a1 + 8);
                *(_DWORD*) (result + 16) += (*(_BYTE*) (a1 + 90) != 0) + 1;
            }
        }
    }
    return result;
}

//----- (0045044A) --------------------------------------------------------
int __cdecl sub_45044A(int a1) {
    int result; // eax
    int v2; // esi

    result = a1;
    v2 = *(_DWORD*) (a1 + 380);
    if(*(_BYTE*) (a1 + 74))
        result = (*(int(__cdecl**)(int))(*(_DWORD*) (a1 + 420) + 8))(a1);
    ++* (_DWORD*) (v2 + 12);
    return result;
}

//----- (0045046B) --------------------------------------------------------
int __cdecl sub_45046B(int a1) {
    int v1; // eax

    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 28);
    *(_DWORD*) (a1 + 380) = v1;
    *(_BYTE*) (v1 + 8) = 0;
    *(_DWORD*) v1 = sub_45031D;
    *(_DWORD*) (v1 + 4) = sub_45044A;
    return sub_450170(a1);
}

//----- (0045049B) --------------------------------------------------------
int __cdecl sub_45049B(_DWORD* a1) {
    _DWORD* v1; // ecx

    if(!a1)
        return -2;
    v1 = (_DWORD*) a1 [7];
    if(!v1)
        return -2;
    a1 [5] = 0;
    a1 [2] = 0;
    a1 [6] = 0;
    *v1 = v1 [3] != 0 ? 7 : 0;
    sub_457726(*(_DWORD**) (a1 [7] + 20), (int) a1, 0);
    return 0;
}

//----- (004504DA) --------------------------------------------------------
int __cdecl sub_4504DA(_DWORD* a1) {
    int v1; // eax
    _DWORD* v2; // eax

    if(!a1)
        return -2;
    v1 = a1 [7];
    if(!v1 || !a1 [9])
        return -2;
    v2 = *(_DWORD**) (v1 + 20);
    if(v2)
        sub_458135(v2, (int) a1);
    ((void(__cdecl*)(_DWORD, _DWORD))a1 [9])(a1 [10], a1 [7]);
    a1 [7] = 0;
    return 0;
}

//----- (00450518) --------------------------------------------------------
int __cdecl sub_450518(_DWORD* a1, int a2, _BYTE* a3, int a4) {
    bool v4; // zf
    int v5; // eax
    int v6; // ecx
    int v7; // edi
    int v10; // [esp-4h] [ebp-10h]

    if(!a3 || *a3 != 49 || a4 != 56)
        return -6;
    if(!a1)
        return -2;
    v4 = a1 [8] == 0;
    a1 [6] = 0;
    if(v4) {
        a1 [8] = sub_458282;
        a1 [10] = 0;
    }
    if(!a1 [9])
        a1 [9] = sub_451E76;
    v5 = ((int(__cdecl*)(_DWORD, int, int))a1 [8])(a1 [10], 1, 24);
    a1 [7] = v5;
    if(v5) {
        v6 = a2;
        *(_DWORD*) (v5 + 20) = 0;
        *(_DWORD*) (a1 [7] + 12) = 0;
        if(a2 < 0) {
            v6 = -a2;
            *(_DWORD*) (a1 [7] + 12) = 1;
        }
        if(v6 < 8 || v6 > 15) {
            v10 = -2;
        }
        else {
            *(_DWORD*) (a1 [7] + 16) = v6;
            *(_DWORD*) (a1 [7] + 20) = sub_457791(
                (int) a1,
                *(_DWORD*) (a1 [7] + 12) == 0 ? (unsigned int) sub_458169 : 0,
                1 << v6);
            if(*(_DWORD*) (a1 [7] + 20)) {
                sub_45049B(a1);
                return 0;
            }
            v10 = -4;
        }
        v7 = v10;
        sub_4504DA(a1);
        return v7;
    }
    return -4;
}

//----- (004505FD) --------------------------------------------------------
int __cdecl sub_4505FD(_DWORD* a1, _BYTE* a2, int a3) {
    return sub_450518(a1, 15, a2, a3);
}

//----- (00450614) --------------------------------------------------------
int __cdecl sub_450614(unsigned __int8** a1, int a2) {
    bool v2; // zf
    int v3; // ebx
    unsigned __int8* v4; // eax
    unsigned __int8* v5; // ecx
    unsigned __int8* v6; // eax
    int v7; // ecx
    unsigned __int8* v8; // eax
    int v9; // ebx
    unsigned __int8* v10; // ecx
    unsigned __int8* v11; // eax
    int v12; // eax
    unsigned __int8* v13; // eax
    unsigned __int8* v14; // eax
    unsigned __int8* v15; // ecx
    unsigned __int8* v16; // eax
    unsigned __int8* v17; // eax
    unsigned __int8* v18; // ecx
    unsigned __int8* v19; // eax
    unsigned __int8* v20; // eax
    unsigned __int8* v21; // ecx
    unsigned __int8* v22; // eax
    unsigned __int8* v23; // eax
    unsigned __int8* v24; // ecx
    unsigned __int8* v25; // eax
    unsigned __int8* v27; // eax
    unsigned __int8* v28; // ecx
    unsigned __int8* v29; // eax
    unsigned __int8* v30; // eax
    unsigned __int8* v31; // ecx
    unsigned __int8* v32; // eax
    unsigned __int8* v33; // eax
    unsigned __int8* v34; // ecx
    unsigned __int8* v35; // eax
    unsigned __int8* v36; // eax
    unsigned __int8* v37; // ecx
    unsigned __int8* v38; // eax
    unsigned __int8* v39; // eax
    int v41; // [esp+18h] [ebp+Ch]

    if(!a1 || !a1 [7] || !*a1)
        return -2;
    v2 = a2 == 4;
    v3 = -5;
    v41 = -5;
    if(!v2)
        v41 = 0;
    while(2) {
        v4 = a1 [7];
        switch(*(_DWORD*) v4) {
            case 0:
                v5 = a1 [1];
                if(!v5)
                    return v3;
                v3 = v41;
                ++a1 [2];
                a1 [1] = v5 - 1;
                *((_DWORD*) v4 + 1) = **a1;
                v6 = a1 [7];
                v7 = *((_DWORD*) v6 + 1) & 0xF;
                ++* a1;
                if((_BYTE) v7 != 8) {
                    *(_DWORD*) v6 = 13;
                    a1 [6] = "unknown compression method";
                    goto LABEL_10;
                }
                if((unsigned int) ((*((_DWORD*) v6 + 1) >> 4) + 8) > *((_DWORD*) v6 + 4)) {
                    *(_DWORD*) v6 = 13;
                    a1 [6] = "invalid window size";
                    goto LABEL_10;
                }
                *(_DWORD*) v6 = 1;
                LABEL_14:
                v8 = a1 [1];
                if(!v8)
                    return v3;
                ++a1 [2];
                a1 [1] = v8 - 1;
                v9 = *(*a1)++;
                v10 = a1 [7];
                if((v9 + (*((_DWORD*) v10 + 1) << 8)) % 0x1Fu) {
                    v3 = v41;
                    *(_DWORD*) v10 = 13;
                    v11 = a1 [7];
                    a1 [6] = "incorrect header check";
                    *((_DWORD*) v11 + 1) = 5;
                }
                else {
                    v2 = (v9 & 0x20) == 0;
                    v3 = v41;
                    if(!v2) {
                        *(_DWORD*) a1 [7] = 2;
                        LABEL_38:
                        v27 = a1 [1];
                        if(!v27)
                            return v3;
                        v28 = a1 [7];
                        v3 = v41;
                        ++a1 [2];
                        a1 [1] = v27 - 1;
                        *((_DWORD*) v28 + 2) = **a1 << 24;
                        v29 = a1 [7];
                        ++* a1;
                        *(_DWORD*) v29 = 3;
                        LABEL_40:
                        v30 = a1 [1];
                        if(!v30)
                            return v3;
                        v31 = *a1;
                        v3 = v41;
                        ++a1 [2];
                        a1 [1] = v30 - 1;
                        *((_DWORD*) a1 [7] + 2) += *v31 << 16;
                        v32 = a1 [7];
                        ++* a1;
                        *(_DWORD*) v32 = 4;
                        LABEL_42:
                        v33 = a1 [1];
                        if(!v33)
                            return v3;
                        v34 = *a1;
                        v3 = v41;
                        ++a1 [2];
                        a1 [1] = v33 - 1;
                        *((_DWORD*) a1 [7] + 2) += *v34 << 8;
                        v35 = a1 [7];
                        ++* a1;
                        *(_DWORD*) v35 = 5;
                        LABEL_44:
                        v36 = a1 [1];
                        if(!v36)
                            return v3;
                        v37 = *a1;
                        ++a1 [2];
                        a1 [1] = v36 - 1;
                        *((_DWORD*) a1 [7] + 2) += *v37;
                        v38 = a1 [7];
                        ++* a1;
                        a1 [12] = (unsigned __int8*) *((_DWORD*) v38 + 2);
                        *(_DWORD*) v38 = 6;
                        return 2;
                    }
                    *(_DWORD*) v10 = 7;
                }
                continue;
            case 1:
                goto LABEL_14;
            case 2:
                goto LABEL_38;
            case 3:
                goto LABEL_40;
            case 4:
                goto LABEL_42;
            case 5:
                goto LABEL_44;
            case 6:
                *(_DWORD*) a1 [7] = 13;
                v39 = a1 [7];
                a1 [6] = "need dictionary";
                *((_DWORD*) v39 + 1) = 0;
                return -2;
            case 7:
                v12 = sub_45781C(*((int**) v4 + 5), (int) a1, v3);
                v3 = v12;
                if(v12 == -3) {
                    *(_DWORD*) a1 [7] = 13;
                    *((_DWORD*) a1 [7] + 1) = 0;
                    continue;
                }
                if(!v12)
                    v3 = v41;
                if(v3 != 1)
                    return v3;
                v3 = v41;
                sub_457726(*((_DWORD**) a1 [7] + 5), (int) a1, (_DWORD*) a1 [7] + 1);
                v13 = a1 [7];
                if(*((_DWORD*) v13 + 3)) {
                    *(_DWORD*) v13 = 12;
                    continue;
                }
                *(_DWORD*) v13 = 8;
                LABEL_27:
                v14 = a1 [1];
                if(!v14)
                    return v3;
                v15 = a1 [7];
                v3 = v41;
                ++a1 [2];
                a1 [1] = v14 - 1;
                *((_DWORD*) v15 + 2) = **a1 << 24;
                v16 = a1 [7];
                ++* a1;
                *(_DWORD*) v16 = 9;
                LABEL_29:
                v17 = a1 [1];
                if(!v17)
                    return v3;
                v18 = *a1;
                v3 = v41;
                ++a1 [2];
                a1 [1] = v17 - 1;
                *((_DWORD*) a1 [7] + 2) += *v18 << 16;
                v19 = a1 [7];
                ++* a1;
                *(_DWORD*) v19 = 10;
                LABEL_31:
                v20 = a1 [1];
                if(!v20)
                    return v3;
                v21 = *a1;
                v3 = v41;
                ++a1 [2];
                a1 [1] = v20 - 1;
                *((_DWORD*) a1 [7] + 2) += *v21 << 8;
                v22 = a1 [7];
                ++* a1;
                *(_DWORD*) v22 = 11;
                LABEL_33:
                v23 = a1 [1];
                if(!v23)
                    return v3;
                v24 = *a1;
                v3 = v41;
                ++a1 [2];
                a1 [1] = v23 - 1;
                *((_DWORD*) a1 [7] + 2) += *v24;
                v25 = a1 [7];
                ++* a1;
                if(*((_DWORD*) v25 + 1) != *((_DWORD*) v25 + 2)) {
                    *(_DWORD*) v25 = 13;
                    a1 [6] = "incorrect data check";
                    LABEL_10:
                    *((_DWORD*) a1 [7] + 1) = 5;
                    continue;
                }
                *(_DWORD*) a1 [7] = 12;
                return 1;
            case 8:
                goto LABEL_27;
            case 9:
                goto LABEL_29;
            case 0xA:
                goto LABEL_31;
            case 0xB:
                goto LABEL_33;
            case 0xC:
                return 1;
            case 0xD:
                return -3;
            default:
                return -2;
        }
    }
}

//----- (00450975) --------------------------------------------------------
void* __cdecl sub_450975(int a1) {
    size_t v1; // esi
    void* v2; // edx

    if(a1 == 2) {
        v1 = 64;
    }
    else {
        if(a1 != 1)
            return 0;
        v1 = 412;
    }
    v2 = malloc(v1);
    if(v2)
        memset(v2, 0, v1);
    return v2;
}

//----- (004509B7) --------------------------------------------------------
void __cdecl sub_4509B7(void* Block) {
    if(Block)
        free(Block);
}

//----- (004509C4) --------------------------------------------------------
void* __cdecl sub_4509C4(jmp_buf Buf, size_t Size) {
    void* result; // eax

    if(!Buf || !Size)
        return 0;
    result = malloc(Size);
    if(!result)
        sub_44BC5A(Buf, (int) "Out of Memory");
    return result;
}

//----- (004509FA) --------------------------------------------------------
void __cdecl sub_4509FA(int a1, void* Block) {
    if(a1) {
        if(Block)
            free(Block);
    }
}

//----- (00450A13) --------------------------------------------------------
void* __cdecl sub_450A13(int a1, void* a2, const void* a3, unsigned int a4) {
    qmemcpy(a2, a3, a4);
    return a2;
}

//----- (00450A36) --------------------------------------------------------
char* __usercall sub_450A36(int a1, int a2, char* a3, char a4, unsigned int a5) {
    int v5; // eax

    LOBYTE(a1) = a4;
    BYTE1(a1) = a4;
    v5 = a1 << 16;
    LOWORD(v5) = a1;
    memset32(a3, v5, a5 >> 2);
    memset(&a3 [4 * (a5 >> 2)], a4, a5 & 3);
    return a3;
}

//----- (00450A69) --------------------------------------------------------
int __cdecl sub_450A69(unsigned __int8* a1) {
    return a1 [3] + ((a1 [2] + ((a1 [1] + (*a1 << 8)) << 8)) << 8);
}

//----- (00450A8C) --------------------------------------------------------
int __usercall sub_450A8C(int a1, unsigned __int8* a2) {
    int v2; // ecx

    HIWORD(v2) = HIWORD(a2);
    LOWORD(a1) = *a2;
    LOWORD(v2) = a2 [1];
    return v2 + (a1 << 8);
}

//----- (00450A9F) --------------------------------------------------------
int __cdecl sub_450A9F(jmp_buf Buf, _BYTE* a2, int a3) {
    sub_44DF95(Buf, (int) a2, a3);
    return sub_44E0B4((int) Buf, a2, a3);
}

//----- (00450AC3) --------------------------------------------------------
BOOL __cdecl sub_450AC3(jmp_buf Buf) {
    int* __attribute__((__org_typedef(jmp_buf))) v1; // esi
    int v2; // edi

    v1 = Buf;
    v2 = 1;
    if((Buf [67] & 0x20) != 0) {
        if((Buf [23] & 0x300) != 768)
            goto LABEL_6;
    }
    else if((*((_BYTE*) Buf + 93) & 8) == 0) {
        goto LABEL_6;
    }
    v2 = 0;
    LABEL_6:
    sub_44DF95(Buf, (int) &Buf, 4);
    return v2 && sub_450A69((unsigned __int8*) &Buf) != v1 [64];
}

//----- (00450B21) --------------------------------------------------------
unsigned __int8 __cdecl sub_450B21(jmp_buf Buf, unsigned __int8* a2) {
    unsigned __int8 v2; // al
    unsigned __int8 v3; // al
    unsigned __int8 v4; // al
    unsigned __int8 result; // al

    v2 = *a2;
    if(*a2 < 0x29u
       || v2 > 0x7Au
       || v2 > 0x5Au && v2 < 0x61u
       || (v3 = a2 [1], v3 < 0x29u)
       || v3 > 0x7Au
       || v3 > 0x5Au && v3 < 0x61u
       || (v4 = a2 [2], v4 < 0x29u)
       || v4 > 0x7Au
       || v4 > 0x5Au && v4 < 0x61u
       || (result = a2 [3], result < 0x29u)
       || result > 0x7Au
       || result > 0x5Au && result < 0x61u) {
        sub_44BC92(Buf, "invalid chunk type");
    }
    return result;
}

//----- (00450B83) --------------------------------------------------------
char __cdecl sub_450B83(int a1, char* a2, int a3) {
    unsigned int v3; // ecx
    unsigned int v4; // eax
    char* v5; // ebx
    char* v6; // edx
    _BYTE* v7; // edi
    unsigned __int8* v8; // esi
    int v9; // edx
    _BYTE* v10; // edi
    unsigned __int8* v11; // esi
    int v12; // edx
    _BYTE* v13; // edi
    unsigned __int8* v14; // esi
    int v15; // edx
    unsigned int v17; // [esp+Ch] [ebp-4h]
    unsigned int v18; // [esp+18h] [ebp+8h]
    int v19; // [esp+18h] [ebp+8h]
    int v20; // [esp+18h] [ebp+8h]
    int v21; // [esp+18h] [ebp+8h]
    int v22; // [esp+1Ch] [ebp+Ch]
    int v23; // [esp+1Ch] [ebp+Ch]
    int v24; // [esp+1Ch] [ebp+Ch]
    unsigned __int8 v25; // [esp+1Fh] [ebp+Fh]

    v3 = *(unsigned __int8*) (a1 + 251);
    if(a3 == 255) {
        v4 = (*(_DWORD*) (a1 + 184) * v3 + 7) >> 3;
        qmemcpy(a2, (const void*) (*(_DWORD*) (a1 + 220) + 1), 4 * ((*(_DWORD*) (a1 + 184) * v3 + 7) >> 5) + (v4 & 3));
    }
    else {
        switch(v3) {
            case 1u:
                v4 = *(_DWORD*) (a1 + 184);
                v13 = a2;
                v14 = (unsigned __int8*) (*(_DWORD*) (a1 + 220) + 1);
                v24 = 128;
                v15 = 7;
                if(v4) {
                    v21 = *(_DWORD*) (a1 + 184);
                    do {
                        LOBYTE(v4) = a3;
                        if((a3 & v24) != 0) {
                            LOBYTE(v4) = ((*v14 >> v15) & 1) << v15;
                            *v13 = v4 | *v13 & (32639 >> (7 - v15));
                        }
                        if(v15) {
                            --v15;
                        }
                        else {
                            ++v14;
                            v15 = 7;
                            ++v13;
                        }
                        if(v24 == 1)
                            v24 = 128;
                        else
                            v24 >>= 1;
                        --v21;
                    }
                    while(v21);
                }
                break;
            case 2u:
                v4 = *(_DWORD*) (a1 + 184);
                v10 = a2;
                v11 = (unsigned __int8*) (*(_DWORD*) (a1 + 220) + 1);
                v23 = 128;
                v12 = 6;
                if(v4) {
                    v20 = *(_DWORD*) (a1 + 184);
                    do {
                        LOBYTE(v4) = a3;
                        if((a3 & v23) != 0) {
                            LOBYTE(v4) = ((*v11 >> v12) & 3) << v12;
                            *v10 = v4 | *v10 & (16191 >> (6 - v12));
                        }
                        if(v12) {
                            v12 -= 2;
                        }
                        else {
                            ++v11;
                            v12 = 6;
                            ++v10;
                        }
                        if(v23 == 1)
                            v23 = 128;
                        else
                            v23 >>= 1;
                        --v20;
                    }
                    while(v20);
                }
                break;
            case 4u:
                v4 = *(_DWORD*) (a1 + 184);
                v7 = a2;
                v8 = (unsigned __int8*) (*(_DWORD*) (a1 + 220) + 1);
                v22 = 128;
                v9 = 4;
                if(v4) {
                    v19 = *(_DWORD*) (a1 + 184);
                    do {
                        LOBYTE(v4) = a3;
                        if((a3 & v22) != 0) {
                            LOBYTE(v4) = ((*v8 >> v9) & 0xF) << v9;
                            *v7 = v4 | *v7 & (3855 >> (4 - v9));
                        }
                        if(v9) {
                            v9 -= 4;
                        }
                        else {
                            ++v8;
                            v9 = 4;
                            ++v7;
                        }
                        if(v22 == 1)
                            v22 = 128;
                        else
                            v22 >>= 1;
                        --v19;
                    }
                    while(v19);
                }
                break;
            default:
                v4 = *(_DWORD*) (a1 + 184);
                v5 = a2;
                v6 = (char*) (*(_DWORD*) (a1 + 220) + 1);
                v18 = v3 >> 3;
                v25 = 0x80;
                if(v4) {
                    v17 = v4;
                    do {
                        LOBYTE(v4) = a3;
                        if(((unsigned __int8) a3 & v25) != 0) {
                            v4 = v3 >> 3;
                            qmemcpy(v5, v6, v18);
                        }
                        v6 += v18;
                        v5 += v18;
                        if(v25 == 1)
                            v25 = 0x80;
                        else
                            v25 >>= 1;
                        --v17;
                    }
                    while(v17);
                }
                break;
        }
    }
    return v4;
}

//----- (00450D97) --------------------------------------------------------
void __cdecl sub_450D97(int* a1, int a2, int a3) {
    int v3; // eax
    int v4; // edx
    unsigned int v5; // esi
    unsigned int v6; // esi
    char* v7; // ebx
    char* v8; // edi
    _BYTE* v9; // edi
    _BYTE* v10; // esi
    char v11; // al
    _BYTE* v12; // edi
    _BYTE* v13; // esi
    char v14; // al
    _BYTE* v15; // edi
    _BYTE* v16; // esi
    char v17; // al
    unsigned int v18; // ecx
    char v19 [4]; // [esp+4h] [ebp-14h] BYREF
    int v20; // [esp+8h] [ebp-10h]
    unsigned int v21; // [esp+Ch] [ebp-Ch]
    int v22; // [esp+10h] [ebp-8h]
    unsigned int v23; // [esp+14h] [ebp-4h]
    char* v24; // [esp+24h] [ebp+Ch]
    char v25; // [esp+27h] [ebp+Fh]
    char v26; // [esp+27h] [ebp+Fh]
    char v27; // [esp+27h] [ebp+Fh]
    int v28; // [esp+28h] [ebp+10h]
    int v29; // [esp+28h] [ebp+10h]
    int v30; // [esp+28h] [ebp+10h]

    if(a2 && a1) {
        v3 = *a1;
        v4 = dword_46EC5C [a3] * *a1;
        v22 = dword_46EC5C [a3];
        v5 = *((unsigned __int8*) a1 + 11);
        if(v5 == 1) {
            v21 = 0;
            v15 = (_BYTE*) (a2 + ((unsigned int) (v3 - 1) >> 3));
            v16 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 3));
            v23 = 7 - (((_BYTE) v3 - 1) & 7);
            v30 = 7 - (((_BYTE) v4 - 1) & 7);
            if(v3) {
                do {
                    v17 = (*v15 >> v23) & 1;
                    v27 = v17;
                    if(v22 > 0) {
                        v20 = v22;
                        while(1) {
                            *v16 = (v17 << v30) | *v16 & (32639 >> (7 - v30));
                            if(v30 == 7) {
                                v30 = 0;
                                --v16;
                            }
                            else {
                                ++v30;
                            }
                            if(!--v20)
                                break;
                            v17 = v27;
                        }
                    }
                    if(v23 == 7) {
                        v23 = 0;
                        --v15;
                    }
                    else {
                        ++v23;
                    }
                    ++v21;
                }
                while(v21 < *a1);
            }
        }
        else if(*((_BYTE*) a1 + 11) == 2) {
            v21 = 0;
            v12 = (_BYTE*) (a2 + ((unsigned int) (v3 - 1) >> 2));
            v13 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 2));
            v23 = 2 * (3 - (((_BYTE) v3 - 1) & 3));
            v29 = 2 * (3 - (((_BYTE) v4 - 1) & 3));
            if(v3) {
                do {
                    v14 = (*v12 >> v23) & 3;
                    v26 = v14;
                    if(v22 > 0) {
                        v20 = v22;
                        while(1) {
                            *v13 = (v14 << v29) | *v13 & (16191 >> (6 - v29));
                            if(v29 == 6) {
                                v29 = 0;
                                --v13;
                            }
                            else {
                                v29 += 2;
                            }
                            if(!--v20)
                                break;
                            v14 = v26;
                        }
                    }
                    if(v23 == 6) {
                        v23 = 0;
                        --v12;
                    }
                    else {
                        v23 += 2;
                    }
                    ++v21;
                }
                while(v21 < *a1);
            }
        }
        else if(*((_BYTE*) a1 + 11) == 4) {
            v21 = 0;
            v9 = (_BYTE*) (a2 + ((unsigned int) (v3 - 1) >> 1));
            v10 = (_BYTE*) (a2 + ((unsigned int) (v4 - 1) >> 1));
            v23 = 4 - 4 * (((_BYTE) v3 - 1) & 1);
            v28 = 4 - 4 * (((_BYTE) v4 - 1) & 1);
            if(v3) {
                do {
                    v11 = (*v9 >> v23) & 0xF;
                    v25 = v11;
                    if(v22 > 0) {
                        v20 = v22;
                        while(1) {
                            *v10 = (v11 << v28) | *v10 & (3855 >> (4 - v28));
                            if(v28 == 4) {
                                v28 = 0;
                                --v10;
                            }
                            else {
                                v28 += 4;
                            }
                            if(!--v20)
                                break;
                            v11 = v25;
                        }
                    }
                    if(v23 == 4) {
                        v23 = 0;
                        --v9;
                    }
                    else {
                        v23 += 4;
                    }
                    ++v21;
                }
                while(v21 < *a1);
            }
        }
        else {
            v23 = 0;
            v6 = v5 >> 3;
            v7 = (char*) (a2 + v6 * (v3 - 1));
            v24 = (char*) (a2 + v6 * (v4 - 1));
            if(v3) {
                do {
                    qmemcpy(v19, v7, v6);
                    if(v22 > 0) {
                        v21 = v22;
                        do {
                            v8 = v24;
                            v24 -= v6;
                            qmemcpy(v8, v19, v6);
                            --v21;
                        }
                        while(v21);
                    }
                    v7 -= v6;
                    ++v23;
                }
                while(v23 < *a1);
            }
        }
        v18 = (v4 * (unsigned int) *((unsigned __int8*) a1 + 11) + 7) >> 3;
        *a1 = v4;
        a1 [1] = v18;
    }
}
// 46EC5C: using guessed type int dword_46EC5C[7];
// 450D97: using guessed type char var_14[4];

//----- (00451060) --------------------------------------------------------
char __cdecl sub_451060(int a1, int a2, _BYTE* a3, unsigned __int8* a4, int a5) {
    unsigned int v5; // eax
    _BYTE* v6; // edx
    _BYTE* v7; // edi
    unsigned int v8; // ecx
    int v9; // esi
    int v10; // ecx
    int v11; // esi
    int v12; // edx
    int v13; // ebx
    int v14; // eax
    bool v15; // zf
    _BYTE* v16; // esi
    unsigned __int8* v17; // edi
    unsigned int v18; // ecx
    unsigned __int8* j; // ebx
    unsigned int v20; // esi
    unsigned int i; // ecx
    unsigned int v22; // ecx
    _BYTE* v23; // esi
    _BYTE* v24; // edx
    unsigned int v25; // ecx
    int v27; // [esp+Ch] [ebp-4h]
    unsigned int v28; // [esp+18h] [ebp+8h]
    int v29; // [esp+1Ch] [ebp+Ch]
    _BYTE* v30; // [esp+28h] [ebp+18h]

    LOBYTE(v5) = a5;
    if(a5) {
        switch(a5) {
            case 1:
                v22 = *(_DWORD*) (a2 + 4);
                v5 = (*(unsigned __int8*) (a2 + 11) + 7) >> 3;
                v23 = &a3 [v5];
                if(v5 < v22) {
                    v24 = a3;
                    v25 = v22 - v5;
                    do {
                        LOBYTE(v5) = *v24;
                        *v23++ += *v24++;
                        --v25;
                    }
                    while(v25);
                }
                break;
            case 2:
                v20 = *(_DWORD*) (a2 + 4);
                v5 = (unsigned int) a3;
                for(i = 0; i < v20; ++i)
                    *(_BYTE*) v5++ += a4 [i];
                break;
            case 3:
                v16 = a3;
                v17 = a4;
                v5 = (*(unsigned __int8*) (a2 + 11) + 7) >> 3;
                v18 = *(_DWORD*) (a2 + 4) - v5;
                for(j = a3; v5; --v5)
                    *v16++ += *v17++ >> 1;
                for(; v18; --v18) {
                    v5 = (*v17 + *j) / 2;
                    *v16 += v5;
                    ++j;
                    ++v17;
                    ++v16;
                }
                break;
            case 4:
                v6 = a3;
                v7 = a4;
                v5 = (*(unsigned __int8*) (a2 + 11) + 7) >> 3;
                v8 = *(_DWORD*) (a2 + 4) - v5;
                v30 = a3;
                if(v5) {
                    v9 = (*(unsigned __int8*) (a2 + 11) + 7) >> 3;
                    do {
                        LOBYTE(v5) = *v7;
                        *v6++ += *v7++;
                        --v9;
                    }
                    while(v9);
                    v30 = v6;
                }
                if(v8) {
                    v28 = v8;
                    do {
                        v10 = (unsigned __int8) *a3;
                        v11 = *a4;
                        ++a3;
                        v27 = (unsigned __int8) *v7++;
                        ++a4;
                        v12 = v10 - v11;
                        if(v27 - v11 >= 0)
                            v29 = v27 - v11;
                        else
                            v29 = v11 - v27;
                        v13 = v10 - v11;
                        if(v12 < 0)
                            v13 = v11 - v10;
                        v14 = v12 + v27 - v11;
                        if(v14 < 0)
                            v14 = -v14;
                        if(v29 > v13 || v29 > v14) {
                            LOBYTE(v10) = v27;
                            if(v13 > v14)
                                LOBYTE(v10) = v11;
                        }
                        *v30 += v10;
                        LOBYTE(v5) = (_BYTE) v30 + 1;
                        v15 = v28-- == 1;
                        ++v30;
                    }
                    while(!v15);
                }
                break;
            default:
                sub_44BC7D(a1, (int) "Ignoring bad adaptive filter type");
                LOBYTE(v5) = (_BYTE) a3;
                *a3 = 0;
                break;
        }
    }
    return v5;
}

//----- (004511D9) --------------------------------------------------------
char* __cdecl sub_4511D9(jmp_buf Buf) {
    unsigned int v1; // eax
    int v2; // edi
    unsigned int v3; // eax
    unsigned int v4; // ecx
    int v5; // eax
    int v6; // eax
    int v7; // ebx
    char v8; // cl
    char v9; // cl
    int v10; // ecx
    char* v11; // eax
    char* result; // eax
    unsigned int v13; // [esp-14h] [ebp-1Ch]

    Buf [26] = 0;
    sub_44DB68(Buf);
    v1 = Buf [47];
    if(*((_BYTE*) Buf + 275)) {
        if((Buf [24] & 2) == 0)
            v1 = (v1 + 7) >> 3;
        v2 = Buf [46];
        Buf [48] = v1;
        v3 = (v2 - dword_46EC40 [*((unsigned __int8*) Buf + 276)] + dword_46EC5C [*((unsigned __int8*) Buf + 276)] - 1)
            / (unsigned int) dword_46EC5C [*((unsigned __int8*) Buf + 276)];
        v4 = ((v3 * *((unsigned __int8*) Buf + 281) + 7) >> 3) + 1;
        Buf [52] = v3;
        Buf [51] = v4;
    }
    else {
        v2 = Buf [46];
        Buf [48] = v1;
        v5 = Buf [50] + 1;
        Buf [52] = v2;
        Buf [51] = v5;
    }
    v6 = *((unsigned __int8*) Buf + 281);
    v7 = Buf [24];
    if((v7 & 4) != 0 && *((_BYTE*) Buf + 279) < 8u)
        v6 = 8;
    if((v7 & 0x1000) != 0) {
        v8 = *((_BYTE*) Buf + 278);
        if(v8 == 3) {
            v6 = 8 * (*((_WORD*) Buf + 133) != 0) + 24;
        }
        else if(v8) {
            if(v8 == 2 && *((_WORD*) Buf + 133))
                v6 = 4 * v6 / 3;
        }
        else {
            if(v6 < 8)
                v6 = 8;
            if(*((_WORD*) Buf + 133))
                v6 *= 2;
        }
    }
    if((v7 & 0x8000) != 0) {
        v9 = *((_BYTE*) Buf + 278);
        if(v9 != 3) {
            if(v9) {
                if(v9 != 2)
                    goto LABEL_28;
                v10 = v6 > 32 ? 64 : 32;
            }
            else {
                v10 = v6 > 8 ? 32 : 16;
            }
            v6 = v10;
            goto LABEL_28;
        }
        v6 = 32;
    }
    LABEL_28:
    Buf [55] = (int) sub_4509C4(Buf, ((v6 * ((v2 + 7) & 0xFFFFFFF8) + 7) >> 3) + ((v6 + 7) >> 3) + 1);
    v11 = (char*) sub_4509C4(Buf, Buf [50] + 1);
    v13 = Buf [50] + 1;
    Buf [54] = (int) v11;
    result = sub_450A36(v7, (int) Buf, v11, 0, v13);
    Buf [23] |= 0x40u;
    return result;
}
// 46EC40: using guessed type int dword_46EC40[7];
// 46EC5C: using guessed type int dword_46EC5C[7];

//----- (00451375) --------------------------------------------------------
int __cdecl sub_451375(jmp_buf Buf, unsigned int a2) {
    unsigned int i; // edi

    for(i = Buf [40]; a2 > i; a2 -= i)
        sub_450A9F(Buf, (_BYTE*) Buf [39], Buf [40]);
    if(a2)
        sub_450A9F(Buf, (_BYTE*) Buf [39], a2);
    if(!sub_450AC3(Buf))
        return 0;
    if(((Buf [67] & 0x20) == 0 || (*((_BYTE*) Buf + 93) & 2) != 0)
       && ((Buf [67] & 0x20) != 0 || (*((_BYTE*) Buf + 93) & 4) == 0)) {
        sub_44BC92(Buf, "CRC error");
    }
    sub_44BCB7((int) Buf, "CRC error");
    return 1;
}

//----- (00451401) --------------------------------------------------------
void __cdecl sub_451401(jmp_buf Buf, int a2, int a3) {
    int v4; // edi
    int v5; // eax
    char v6; // bl
    unsigned __int8 v7; // al
    char v8; // [esp-Ch] [ebp-34h]
    char v9; // [esp-8h] [ebp-30h]
    char v10; // [esp-4h] [ebp-2Ch]
    int v11; // [esp+Ch] [ebp-1Ch] BYREF
    unsigned __int8 v12 [4]; // [esp+10h] [ebp-18h] BYREF
    unsigned __int8 v13; // [esp+14h] [ebp-14h]
    unsigned __int8 v14; // [esp+15h] [ebp-13h]
    unsigned __int8 v15; // [esp+16h] [ebp-12h]
    unsigned __int8 v16; // [esp+17h] [ebp-11h]
    unsigned __int8 v17; // [esp+18h] [ebp-10h]
    int v18; // [esp+1Ch] [ebp-Ch]
    int v19; // [esp+20h] [ebp-8h]
    int v20; // [esp+24h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+30h] [ebp+8h]
    char v22; // [esp+38h] [ebp+10h]

    if(Buf [22])
        sub_44BC5A(Buf, (int) "Out of place IHDR");
    if(a3 != 13)
        sub_44BC5A(Buf, (int) "Invalid IHDR chunk");
    Buf [22] |= 1u;
    sub_450A9F(Buf, &v11, 13);
    sub_451375(Buf, 0);
    v4 = sub_450A69((unsigned __int8*) &v11);
    v5 = sub_450A69(v12);
    v6 = v13;
    Bufa = (int*) v5;
    v22 = v14;
    v18 = v15;
    v19 = v16;
    v20 = v17;
    if(v4 <= 0 || v5 <= 0)
        sub_44BC5A(Buf, (int) "Invalid image size in IHDR");
    if(v13 != 1 && v13 != 2 && v13 != 4 && v13 != 8 && v13 != 16)
        sub_44BC5A(Buf, (int) "Invalid bit depth in IHDR");
    if(v14 == 1 || v14 == 5 || v14 > 6u)
        sub_44BC5A(Buf, (int) "Invalid color type in IHDR");
    if(v14 == 3 && v13 > 8u || (v14 == 2 || v14 == 4 || v14 == 6) && v13 < 8u)
        sub_44BC5A(Buf, (int) "Invalid color type/bit depth combination in IHDR");
    if(v20 >= 2)
        sub_44BC5A(Buf, (int) "Unknown interlace method in IHDR");
    if(v18)
        sub_44BC5A(Buf, (int) "Unknown compression method in IHDR");
    if(v19)
        sub_44BC5A(Buf, (int) "Unknown filter method in IHDR");
    *((_BYTE*) Buf + 275) = v20;
    Buf [46] = v4;
    Buf [47] = v5;
    *((_BYTE*) Buf + 279) = v6;
    *((_BYTE*) Buf + 278) = v22;
    switch(v22) {
        case 0:
            goto LABEL_39;
        case 2:
            *((_BYTE*) Buf + 282) = 3;
            break;
        case 3:
            LABEL_39:
            *((_BYTE*) Buf + 282) = 1;
            break;
        case 4:
            *((_BYTE*) Buf + 282) = 2;
            break;
        case 6:
            *((_BYTE*) Buf + 282) = 4;
            break;
    }
    v10 = v19;
    v7 = v6 * *((_BYTE*) Buf + 282);
    v9 = v18;
    *((_BYTE*) Buf + 281) = v7;
    v8 = v20;
    Buf [50] = (v4 * (unsigned int) v7 + 7) >> 3;
    sub_44DE34((int) Buf, a2, v4, (int) Bufa, v6, v22, v8, v9, v10);
}
// 4514D5: conditional instruction was optimized away because %arg_8.4<100u
// 451401: using guessed type unsigned __int8 var_18[4];

//----- (004515F8) --------------------------------------------------------
void __cdecl sub_4515F8(jmp_buf Buf, int a2, int a3) {
    int v4; // eax
    unsigned int v5; // edx
    int v6; // ebx
    char* v7; // eax
    _BYTE* v8; // edi
    int v9; // [esp+8h] [ebp-4h]
    int* __attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+14h] [ebp+8h]

    v4 = Buf [22];
    if((v4 & 1) == 0)
        sub_44BC5A(Buf, (int) "Missing IHDR before PLTE");
    if((v4 & 4) != 0) {
        sub_44BC7D((int) Buf, (int) "Invalid PLTE after IDAT");
        LABEL_10:
        sub_451375(Buf, a3);
        return;
    }
    if((v4 & 2) != 0)
        sub_44BC5A(Buf, (int) "Duplicate PLTE chunk");
    v5 = a3 % 3u;
    Buf [22] |= 2u;
    if(v5) {
        if(*((_BYTE*) Buf + 278) == 3)
            sub_44BC5A(Buf, (int) "Invalid palette chunk");
        sub_44BC7D((int) Buf, (int) "Invalid palette chunk");
        goto LABEL_10;
    }
    v6 = a3 / 3;
    v7 = sub_44E044(Buf, a3 / 3, 3);
    *((_BYTE*) Buf + 93) |= 0x10u;
    v9 = (int) v7;
    if(v6 > 0) {
        v8 = v7 + 2;
        Bufa = (int*) v6;
        do {
            sub_450A9F(Buf, &a3, 3);
            *((_WORD*) v8 - 1) = a3;
            *v8 = BYTE2(a3);
            v8 += 3;
            Bufa = (int*) ((char*) Bufa - 1);
        }
        while(Bufa);
    }
    sub_451375(Buf, 0);
    Buf [65] = v9;
    *((_WORD*) Buf + 132) = v6;
    sub_44DED6((int) Buf, a2, v9, v6);
    if(*((_BYTE*) Buf + 278) == 3
       && a2
       && (*(_BYTE*) (a2 + 8) & 0x10) != 0
       && *((_WORD*) Buf + 133) > *((_WORD*) Buf + 132)) {
        sub_44BC7D((int) Buf, (int) "Truncating incorrect tRNS chunk length");
        *((_WORD*) Buf + 133) = *((_WORD*) Buf + 132);
    }
}

//----- (00451721) --------------------------------------------------------
int __cdecl sub_451721(jmp_buf Buf, int a2, int a3) {
    int v3; // eax

    v3 = Buf [22];
    if((v3 & 1) == 0 || (v3 & 4) == 0)
        sub_44BC5A(Buf, (int) "No image in file");
    Buf [22] |= 0x18u;
    if(a3)
        sub_44BC7D((int) Buf, (int) "Incorrect IEND chunk length");
    return sub_451375(Buf, a3);
}

//----- (0045176B) --------------------------------------------------------
void __cdecl sub_45176B(jmp_buf Buf, int a2, int a3) {
    int* __attribute__((__org_typedef(jmp_buf))) v3; // esi
    int v4; // eax
    int v5; // edi
    int v6; // eax
    int v7; // eax
    double v8; // st7

    v3 = Buf;
    v4 = Buf [22];
    v5 = a2;
    if((v4 & 1) == 0)
        sub_44BC5A(Buf, (int) "Missing IHDR before gAMA");
    if((v4 & 4) != 0) {
        sub_44BC7D((int) Buf, (int) "Invalid gAMA after IDAT");
        goto LABEL_5;
    }
    if((v4 & 2) != 0) {
        sub_44BC7D((int) Buf, (int) "Out of place gAMA chunk");
    }
    else if(a2) {
        v6 = *(_DWORD*) (a2 + 8);
        if((v6 & 1) != 0 && (v6 & 0x800) == 0) {
            sub_44BC7D((int) Buf, (int) "Duplicate gAMA chunk");
            goto LABEL_5;
        }
    }
    if(a3 != 4) {
        sub_44BC7D((int) v3, (int) "Incorrect gAMA chunk length");
        LABEL_5:
        sub_451375(v3, a3);
        return;
    }
    sub_450A9F(v3, &Buf, 4);
    if(!sub_451375(v3, 0)) {
        v7 = sub_450A69((unsigned __int8*) &Buf);
        if(v7) {
            if((*(_DWORD*) (v5 + 8) & 0x800) != 0 && fabs((double) (unsigned int) v7 - 45455.0) > 500.0) {
                sub_44BC7D((int) v3, (int) "Ignoring incorrect gAMA value when sRGB is also present");
            }
            else {
                v8 = (double) (unsigned int) v7 * 0.0000099999997;
                *((float*) v3 + 76) = v8;
                sub_44DE19((int) v3, v5, v8);
            }
        }
    }
}

//----- (0045186B) --------------------------------------------------------
void __cdecl sub_45186B(jmp_buf Buf, int a2, int a3) {
    int* __attribute__((__org_typedef(jmp_buf))) v3; // esi
    int v4; // eax
    unsigned int v5; // edi

    v3 = Buf;
    v4 = Buf [22];
    if((v4 & 1) == 0)
        sub_44BC5A(Buf, (int) "Missing IHDR before sRGB");
    if((v4 & 4) != 0) {
        sub_44BC7D((int) Buf, (int) "Invalid sRGB after IDAT");
        goto LABEL_5;
    }
    if((v4 & 2) != 0) {
        sub_44BC7D((int) Buf, (int) "Out of place sRGB chunk");
    }
    else if(a2 && (*(_BYTE*) (a2 + 9) & 8) != 0) {
        sub_44BC7D((int) Buf, (int) "Duplicate sRGB chunk");
        goto LABEL_5;
    }
    if(a3 != 1) {
        sub_44BC7D((int) v3, (int) "Incorrect sRGB chunk length");
        LABEL_5:
        sub_451375(v3, a3);
        return;
    }
    sub_450A9F(v3, (_BYTE*) &Buf + 3, 1);
    if(!sub_451375(v3, 0)) {
        v5 = HIBYTE(Buf);
        if(HIBYTE(Buf) < 4u) {
            if((*(_BYTE*) (a2 + 8) & 1) != 0 && fabs(*((float*) v3 + 76) * 100000.0 + 0.5 - 45455.0) > 500.0)
                sub_44BC7D((int) v3, (int) "Ignoring incorrect gAMA value when sRGB is also present");
            sub_44DF15((int) v3, __SPAIR64__(v5, a2));
        }
        else {
            sub_44BC7D((int) v3, (int) "Unknown sRGB intent");
        }
    }
}

//----- (0045195A) --------------------------------------------------------
void __cdecl sub_45195A(jmp_buf Buf, int a2, size_t Size) {
    int v3; // eax
    char v4; // al
    _BYTE* v5; // eax
    unsigned __int8 v6 [2]; // [esp+Ch] [ebp-8h] BYREF
    unsigned __int8 v7 [2]; // [esp+Eh] [ebp-6h] BYREF
    unsigned __int8 v8 [4]; // [esp+10h] [ebp-4h] BYREF

    v3 = Buf [22];
    if((v3 & 1) == 0)
        sub_44BC5A(Buf, (int) "Missing IHDR before tRNS");
    if((v3 & 4) != 0) {
        sub_44BC7D((int) Buf, (int) "Invalid tRNS after IDAT");
        LABEL_26:
        sub_451375(Buf, Size);
        return;
    }
    if(a2 && (*(_BYTE*) (a2 + 8) & 0x10) != 0) {
        sub_44BC7D((int) Buf, (int) "Duplicate tRNS chunk");
        goto LABEL_26;
    }
    v4 = *((_BYTE*) Buf + 278);
    if(v4 == 3) {
        if((Buf [22] & 2) != 0) {
            if(Size > *((unsigned __int16*) Buf + 132)) {
                sub_44BC7D((int) Buf, (int) "Incorrect tRNS chunk length");
                sub_451375(Buf, Size);
                return;
            }
        }
        else {
            sub_44BC7D((int) Buf, (int) "Missing PLTE before tRNS");
        }
        if(!Size) {
            sub_44BC7D((int) Buf, (int) "Zero length tRNS chunk");
            sub_451375(Buf, 0);
            return;
        }
        v5 = sub_4509C4(Buf, Size);
        *((_BYTE*) Buf + 93) |= 0x20u;
        Buf [87] = (int) v5;
        sub_450A9F(Buf, v5, Size);
        *((_WORD*) Buf + 133) = Size;
        goto LABEL_23;
    }
    if(v4 == 2) {
        if(Size == 6) {
            sub_450A9F(Buf, v6, 6);
            *((_WORD*) Buf + 133) = 1;
            *((_WORD*) Buf + 177) = sub_450A8C((int) v6, v6);
            *((_WORD*) Buf + 178) = sub_450A8C((int) v7, v7);
            *((_WORD*) Buf + 179) = sub_450A8C((int) v8, v8);
            goto LABEL_23;
        }
        LABEL_21:
        sub_44BC7D((int) Buf, (int) "Incorrect tRNS chunk length");
        goto LABEL_26;
    }
    if(v4) {
        sub_44BC7D((int) Buf, (int) "tRNS chunk not allowed with alpha channel");
        goto LABEL_26;
    }
    if(Size != 2)
        goto LABEL_21;
    sub_450A9F(Buf, v6, 2);
    *((_WORD*) Buf + 133) = 1;
    *((_WORD*) Buf + 180) = sub_450A8C((int) v6, v6);
    LABEL_23:
    if(!sub_451375(Buf, 0))
        sub_44DF4E((int) Buf, a2, Buf [87], *((unsigned __int16*) Buf + 133), (int) (Buf + 88));
}
// 45195A: using guessed type unsigned __int8 var_4[4];

//----- (00451AF3) --------------------------------------------------------
int __cdecl sub_451AF3(jmp_buf Buf, int a2, int a3) {
    int v3; // eax

    sub_450B21(Buf, (unsigned __int8*) Buf + 268);
    if((Buf [67] & 0x20) == 0)
        sub_44BC92(Buf, "unknown critical chunk");
    v3 = Buf [22];
    if((v3 & 4) != 0)
        Buf [22] = v3 | 8;
    return sub_451375(Buf, a3);
}

//----- (00451B3D) --------------------------------------------------------
int __usercall sub_451B3D(int a1, jmp_buf Buf) {
    int* __attribute__((__org_typedef(jmp_buf))) v2; // esi
    int result; // eax
    unsigned __int8 v4; // bl
    unsigned int v5; // edx
    bool v6; // zf
    unsigned int v7; // eax
    unsigned int v8; // edx
    _BYTE* v9; // ecx
    int v10; // eax
    const char* v11; // eax
    int v12; // [esp+10h] [ebp-4h] BYREF

    v2 = Buf;
    result = (int) (Buf + 53);
    ++Buf [53];
    if(*(_DWORD*) result >= (unsigned int) v2 [48]) {
        if(*((_BYTE*) v2 + 275)) {
            *(_DWORD*) result = 0;
            sub_450A36(a1, (int) v2, (char*) v2 [54], 0, v2 [50] + 1);
            while(1) {
                v4 = ++ * ((_BYTE*) v2 + 276);
                if(v4 >= 7u)
                    break;
                result = (v2 [46] - dword_46EC40 [v4] + dword_46EC5C [v4] - 1) / (unsigned int) dword_46EC5C [v4];
                v5 = ((result * (unsigned int) *((unsigned __int8*) v2 + 281) + 7) >> 3) + 1;
                v6 = (v2 [24] & 2) == 0;
                v2 [52] = result;
                v2 [51] = v5;
                if(v6) {
                    result = (v2 [47] - dword_46EC78 [v4] + dword_46EC94 [v4] - 1) / (unsigned int) dword_46EC94 [v4];
                    v6 = v2 [52] == 0;
                    v2 [48] = result;
                    if(v6)
                        continue;
                }
                return result;
            }
        }
        if((v2 [23] & 0x20) == 0) {
            v2 [28] = (int) &Buf;
            v2 [29] = 1;
            while(1) {
                if(!v2 [26]) {
                    while(!v2 [63]) {
                        sub_451375(v2, 0);
                        sub_44DF95(v2, (int) &v12, 4);
                        v2 [63] = sub_450A69((unsigned __int8*) &v12);
                        sub_44E09C((int) v2);
                        sub_450A9F(v2, (_BYTE*) v2 + 268, 4);
                        if(v2 [67] != *(_DWORD*) "IDAT")
                            sub_44BC5A(v2, (int) "Not enough image data");
                    }
                    v7 = v2 [40];
                    v8 = v2 [63];
                    v9 = (_BYTE*) v2 [39];
                    v2 [26] = v7;
                    v2 [25] = (int) v9;
                    if(v7 > v8)
                        v2 [26] = v8;
                    sub_450A9F(v2, v9, v2 [26]);
                    v2 [63] -= v2 [26];
                }
                v10 = sub_450614((unsigned __int8**) v2 + 25, 1);
                if(v10 == 1)
                    break;
                if(v10) {
                    v11 = (const char*) v2 [31];
                    if(!v11)
                        v11 = "Decompression Error";
                    sub_44BC5A(v2, (int) v11);
                }
                if(!v2 [29])
                    sub_44BC5A(v2, (int) "Extra compressed data");
            }
            if(!v2 [29] || v2 [26] || v2 [63])
                sub_44BC5A(v2, (int) "Extra compressed data");
            v2 [22] |= 8u;
            v2 [23] |= 0x20u;
            v2 [29] = 0;
        }
        if(v2 [63] || v2 [26])
            sub_44BC5A(v2, (int) "Extra compression data");
        result = sub_45049B(v2 + 25);
        v2 [22] |= 8u;
    }
    return result;
}
// 451C05: conditional instruction was optimized away because bl.1<7u
// 46EC40: using guessed type int dword_46EC40[7];
// 46EC5C: using guessed type int dword_46EC5C[7];
// 46EC78: using guessed type int dword_46EC78[];
// 46EC94: using guessed type int dword_46EC94[7];

//----- (00451D62) --------------------------------------------------------
int __cdecl sub_451D62(int a1, _BYTE* a2, unsigned int a3) {
    _BYTE* v3; // edx
    unsigned int v5; // esi
    unsigned int v6; // eax
    unsigned int v7; // esi
    _BYTE* v8; // edx
    unsigned int v9; // edi
    unsigned int v10; // esi
    unsigned int v11; // edi
    unsigned int v12; // esi
    unsigned int v13; // edi
    unsigned int v14; // esi

    v3 = a2;
    if(!a2)
        return 0;
    v5 = ~a1;
    if(a3 >= 8) {
        v6 = a3 >> 3;
        do {
            a3 -= 8;
            v7 = (v5 >> 8) ^ dword_46F140 [(unsigned __int8) (v5 ^ *v3)];
            v8 = v3 + 1;
            v9 = (v7 >> 8) ^ dword_46F140 [(unsigned __int8) (v7 ^ *v8++)];
            v10 = (v9 >> 8) ^ dword_46F140 [(unsigned __int8) (v9 ^ *v8++)];
            v11 = (v10 >> 8) ^ dword_46F140 [(unsigned __int8) (v10 ^ *v8++)];
            v12 = (v11 >> 8) ^ dword_46F140 [(unsigned __int8) (v11 ^ *v8++)];
            v13 = (v12 >> 8) ^ dword_46F140 [(unsigned __int8) (v12 ^ *v8++)];
            v14 = (v13 >> 8) ^ dword_46F140 [(unsigned __int8) (v13 ^ *v8++)];
            v5 = dword_46F140 [(unsigned __int8) (v14 ^ *v8)] ^ (v14 >> 8);
            v3 = v8 + 1;
            --v6;
        }
        while(v6);
    }
    for(; a3; --a3)
        v5 = dword_46F140 [(unsigned __int8) (v5 ^ *v3++)] ^ (v5 >> 8);
    return ~v5;
}
// 46F140: using guessed type int dword_46F140[256];

//----- (00451E6B) --------------------------------------------------------
void* __cdecl sub_451E6B(int a1, size_t Size) {
    return malloc(Size);
}

//----- (00451E76) --------------------------------------------------------
void __cdecl sub_451E76(int a1, void* Block) {
    free(Block);
}

//----- (00451E81) --------------------------------------------------------
int __cdecl sub_451E81(int a1, int a2, int a3) {
    return a3;
}

//----- (00451E86) --------------------------------------------------------
int __cdecl sub_451E86(int a1) {
    *(_DWORD*) (*(_DWORD*) a1 + 20) = 48;
    return (**(int(__cdecl***)(int))a1)(a1);
}

//----- (00451E9A) --------------------------------------------------------
int __usercall sub_451E9A(int a1) {
    int v1; // ebx
    int v2; // edi
    int v3; // eax
    int result; // eax
    _DWORD* v5; // ecx
    int v6; // edi
    int v7; // eax
    int v8; // ecx
    int v9; // [esp+8h] [ebp-10h]
    int v10; // [esp+Ch] [ebp-Ch]
    _DWORD* i; // [esp+10h] [ebp-8h]
    int v12; // [esp+14h] [ebp-4h]

    v1 = *(_DWORD*) (a1 + 384);
    v2 = *(_DWORD*) (a1 + 276);
    v3 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD*) (a1 + 32));
    v12 = 0;
    *(_DWORD*) (v1 + 56) = v3;
    *(_DWORD*) (v1 + 60) = v3 + 4 * *(_DWORD*) (a1 + 32);
    result = *(_DWORD*) (a1 + 196);
    if(*(int*) (a1 + 32) > 0) {
        v5 = (_DWORD*) (result + 12);
        v10 = v2 + 4;
        for(i = (_DWORD*) (result + 12); ; v5 = i) {
            v6 = *v5 * v5 [6] / *(_DWORD*) (a1 + 276) * v10;
            v9 = *v5 * v5 [6] / *(_DWORD*) (a1 + 276);
            i += 21;
            v7 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 8 * v6) + 4 * v9;
            v8 = 4 * v12;
            *(_DWORD*) (v8 + *(_DWORD*) (v1 + 56)) = v7;
            ++v12;
            *(_DWORD*) (v8 + *(_DWORD*) (v1 + 60)) = v7 + 4 * v6;
            result = v12;
            if(v12 >= *(_DWORD*) (a1 + 32))
                break;
        }
    }
    return result;
}

//----- (00451F42) --------------------------------------------------------
int __usercall sub_451F42(_DWORD* a1) {
    _DWORD* v1; // ebx
    int result; // eax
    _DWORD* v3; // ecx
    int v4; // eax
    int v5; // edx
    int v6; // esi
    int v7; // ecx
    _DWORD* v8; // eax
    int v9; // ecx
    int* v10; // ecx
    int v11; // edx
    _DWORD* v12; // esi
    bool v13; // zf
    _DWORD* v14; // ecx
    int* v15; // [esp+4h] [ebp-2Ch]
    _DWORD* v16; // [esp+8h] [ebp-28h]
    _DWORD* v17; // [esp+Ch] [ebp-24h]
    int v18; // [esp+10h] [ebp-20h]
    int v19; // [esp+10h] [ebp-20h]
    int v20; // [esp+14h] [ebp-1Ch]
    _DWORD* v21; // [esp+18h] [ebp-18h]
    int* v22; // [esp+1Ch] [ebp-14h]
    int v23; // [esp+20h] [ebp-10h]
    int v24; // [esp+20h] [ebp-10h]
    int v25; // [esp+24h] [ebp-Ch]
    _DWORD* v26; // [esp+28h] [ebp-8h]
    int v27; // [esp+2Ch] [ebp-4h]

    v25 = 0;
    v1 = (_DWORD*) a1 [96];
    v20 = a1 [69];
    result = a1 [49];
    v16 = v1;
    if((int) a1 [8] > 0) {
        v3 = (_DWORD*) (result + 12);
        v21 = (_DWORD*) (result + 12);
        v22 = v1 + 2;
        while(1) {
            v4 = *v3 * v3 [6] / a1 [69];
            v17 = *(_DWORD**) (4 * v25 + v1 [14]);
            v5 = *(_DWORD*) (4 * v25 + v1 [15]);
            v6 = *v22;
            v7 = v4 * (v20 + 2);
            v18 = v4;
            if(v7 > 0) {
                v8 = *(_DWORD**) (4 * v25 + v1 [15]);
                v23 = v7;
                do {
                    v9 = *(_DWORD*) ((char*) v8 + v6 - v5);
                    *v8 = v9;
                    *(_DWORD*) ((char*) v8++ + (_DWORD) v17 - v5) = v9;
                    --v23;
                }
                while(v23);
                v1 = v16;
                v4 = v18;
            }
            if(2 * v4 > 0) {
                v26 = (_DWORD*) (v5 + 4 * v20 * v4);
                v4 = v18;
                v15 = (int*) (v6 + 4 * v18 * (v20 - 2));
                v27 = v6 - v5;
                v24 = v5 - v6;
                v19 = 2 * v18;
                v10 = v15;
                do {
                    *(int*) ((char*) v10 + v24) = *(_DWORD*) ((char*) v26 + v27);
                    v11 = *v10;
                    v12 = v26++;
                    ++v10;
                    v13 = v19-- == 1;
                    *v12 = v11;
                }
                while(!v13);
            }
            if(v4 > 0) {
                v14 = &v17 [-v4];
                do {
                    *v14++ = *v17;
                    --v4;
                }
                while(v4);
            }
            result = ++v25;
            ++v22;
            v21 += 21;
            if(v25 >= a1 [8])
                break;
            v3 = v21;
        }
    }
    return result;
}

//----- (00452073) --------------------------------------------------------
int __usercall sub_452073(_DWORD* a1) {
    int v1; // ecx
    int result; // eax
    int v3; // esi
    _DWORD* v4; // ebx
    int* v5; // edx
    int* v6; // ebx
    int* v7; // ecx
    int* v8; // eax
    int v9; // esi
    int v10; // edx
    int v11; // [esp+4h] [ebp-1Ch]
    int v12; // [esp+8h] [ebp-18h]
    int v13; // [esp+Ch] [ebp-14h]
    _DWORD* v14; // [esp+10h] [ebp-10h]
    int v15; // [esp+14h] [ebp-Ch]
    int v16; // [esp+18h] [ebp-8h]
    int* v17; // [esp+1Ch] [ebp-4h]

    v1 = a1 [96];
    v16 = 0;
    result = a1 [49];
    v3 = a1 [69];
    v11 = v1;
    v12 = v3;
    if((int) a1 [8] > 0) {
        v4 = (_DWORD*) (result + 12);
        v14 = (_DWORD*) (result + 12);
        do {
            v15 = *v4 * v4 [6] / a1 [69];
            v13 = *(_DWORD*) (4 * v16 + *(_DWORD*) (v1 + 56));
            v5 = *(int**) (4 * v16 + *(_DWORD*) (v1 + 60));
            if(v15 > 0) {
                v6 = &v5 [v15 * (v3 + 2)];
                v7 = &v5 [-v15];
                v8 = &v5 [v15 * (v3 + 1)];
                v17 = v5;
                v9 = v13 - (_DWORD) v5;
                do {
                    *(int*) ((char*) v7 + v9) = *(int*) ((char*) v8 + v9);
                    *v7 = *v8;
                    *(int*) ((char*) v6 + v9) = *(int*) ((char*) v17 + v9);
                    v10 = *v17++;
                    *v6 = v10;
                    ++v8;
                    ++v7;
                    ++v6;
                    --v15;
                }
                while(v15);
                v3 = v12;
                v1 = v11;
                v4 = v14;
            }
            result = ++v16;
            v4 += 21;
            v14 = v4;
        }
        while(v16 < a1 [8]);
    }
    return result;
}

//----- (00452147) --------------------------------------------------------
int __usercall sub_452147(_DWORD* a1) {
    int result; // eax
    int v2; // ebx
    _DWORD* v3; // edi
    int v4; // eax
    _DWORD* v5; // edx
    int v6; // [esp+4h] [ebp-Ch]
    int v7; // [esp+4h] [ebp-Ch]
    unsigned int v8; // [esp+8h] [ebp-8h]
    int v9; // [esp+Ch] [ebp-4h]

    v9 = 0;
    result = a1 [49];
    v2 = a1 [96];
    if((int) a1 [8] > 0) {
        v3 = (_DWORD*) (result + 12);
        do {
            v6 = *v3 * v3 [6] / a1 [69];
            v8 = v3 [8] % (unsigned int) (*v3 * v3 [6]);
            if(!v8)
                v8 = *v3 * v3 [6];
            if(!v9)
                *(_DWORD*) (v2 + 72) = (int) (v8 - 1) / v6 + 1;
            if(2 * v6 > 0) {
                v4 = *(_DWORD*) (*(_DWORD*) (v2 + 4 * *(_DWORD*) (v2 + 64) + 56) + 4 * v9) + 4 * v8;
                v5 = (_DWORD*) v4;
                v7 = 2 * v6;
                do {
                    *v5++ = *(_DWORD*) (v4 - 4);
                    --v7;
                }
                while(v7);
            }
            result = ++v9;
            v3 += 21;
        }
        while(v9 < a1 [8]);
    }
    return result;
}

//----- (004521DD) --------------------------------------------------------
int __cdecl sub_4521DD(_DWORD* a1, int a2, int a3, int a4) {
    int v5; // esi
    int result; // eax
    unsigned int v7; // [esp+14h] [ebp+8h]

    v5 = a1 [96];
    if(!*(_BYTE*) (v5 + 48)) {
        result = (*(int(__cdecl**)(_DWORD*, int))(a1 [97] + 12))(a1, v5 + 8);
        if(!result)
            return result;
        *(_BYTE*) (v5 + 48) = 1;
    }
    v7 = a1 [69];
    (*(void(__cdecl**)(_DWORD*, int, int, _DWORD, int, int, int))(a1 [98] + 4))(a1, v5 + 8, v5 + 52, a1 [69], a2, a3, a4);
    result = v7;
    if(*(_DWORD*) (v5 + 52) >= v7) {
        *(_BYTE*) (v5 + 48) = 0;
        *(_DWORD*) (v5 + 52) = 0;
    }
    return result;
}

//----- (00452245) --------------------------------------------------------
unsigned int __cdecl sub_452245(_DWORD* a1, int a2, unsigned int* a3, unsigned int a4) {
    int v4; // ebx
    unsigned int result; // eax
    int v6; // eax
    int v7; // eax

    v4 = a1 [96];
    if(!*(_BYTE*) (v4 + 48)) {
        result = (*(int(__cdecl**)(_DWORD*, _DWORD))(a1 [97] + 12))(a1, *(_DWORD*) (v4 + 4 * *(_DWORD*) (v4 + 64) + 56));
        if(!result)
            return result;
        ++* (_DWORD*) (v4 + 76);
        *(_BYTE*) (v4 + 48) = 1;
    }
    v6 = *(_DWORD*) (v4 + 68);
    if(!v6) {
        LABEL_9:
        *(_DWORD*) (v4 + 52) = 0;
        *(_DWORD*) (v4 + 72) = a1 [69] - 1;
        if(*(_DWORD*) (v4 + 76) == a1 [70])
            sub_452147(a1);
        *(_DWORD*) (v4 + 68) = 1;
        goto LABEL_12;
    }
    v7 = v6 - 1;
    if(v7) {
        result = v7 - 1;
        if(result)
            return result;
        (*(void(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int, unsigned int*, unsigned int))(a1 [98] + 4))(
            a1,
            *(_DWORD*) (v4 + 4 * *(_DWORD*) (v4 + 64) + 56),
            v4 + 52,
            *(_DWORD*) (v4 + 72),
            a2,
            a3,
            a4);
        result = *(_DWORD*) (v4 + 52);
        if(result < *(_DWORD*) (v4 + 72))
            return result;
        result = a4;
        *(_DWORD*) (v4 + 68) = 0;
        if(*a3 >= a4)
            return result;
        goto LABEL_9;
    }
    LABEL_12:
    (*(void(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int, unsigned int*, unsigned int))(a1 [98] + 4))(
        a1,
        *(_DWORD*) (v4 + 4 * *(_DWORD*) (v4 + 64) + 56),
        v4 + 52,
        *(_DWORD*) (v4 + 72),
        a2,
        a3,
        a4);
    result = *(_DWORD*) (v4 + 52);
    if(result >= *(_DWORD*) (v4 + 72)) {
        if(*(_DWORD*) (v4 + 76) == 1)
            sub_452073(a1);
        *(_DWORD*) (v4 + 64) ^= 1u;
        *(_BYTE*) (v4 + 48) = 0;
        *(_DWORD*) (v4 + 52) = a1 [69] + 1;
        result = 2;
        *(_DWORD*) (v4 + 72) = a1 [69] + 2;
        *(_DWORD*) (v4 + 68) = 2;
    }
    return result;
}

//----- (0045234D) --------------------------------------------------------
int __cdecl sub_45234D(int a1, int a2, int a3, int a4) {
    return (*(int(__cdecl**)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD*) (a1 + 392) + 4))(
        a1,
        0,
        0,
        0,
        a2,
        a3,
        a4);
}

//----- (004523D8) --------------------------------------------------------
int __cdecl sub_4523D8(int a1, char a2) {
    _DWORD* v3; // ebx
    int result; // eax
    int v5; // ecx
    _DWORD* v6; // edi
    _DWORD* v7; // ebx
    int v8; // [esp+14h] [ebp+8h]
    int v9; // [esp+18h] [ebp+Ch]

    v3 = (_DWORD*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 80);
    *(_DWORD*) (a1 + 384) = v3;
    *v3 = sub_452370;
    if(a2) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 4;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    if(*(_BYTE*) (*(_DWORD*) (a1 + 412) + 8)) {
        if(*(int*) (a1 + 276) < 2) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 46;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        result = sub_451E9A(a1);
        v5 = *(_DWORD*) (a1 + 276) + 2;
        v9 = v5;
    }
    else {
        result = *(_DWORD*) (a1 + 276);
        v9 = result;
        v5 = result;
    }
    v8 = 0;
    if(*(int*) (a1 + 32) > 0) {
        v6 = (_DWORD*) (*(_DWORD*) (a1 + 196) + 36);
        v7 = v3 + 2;
        while(1) {
            ++v8;
            *v7 = (*(int(__cdecl**)(int, int, int, int))(*(_DWORD*) (a1 + 4) + 8))(
                a1,
                1,
                *v6 * *(v6 - 2),
                v5 * (*v6 * *(v6 - 6) / *(_DWORD*) (a1 + 276)));
            result = v8;
            ++v7;
            v6 += 21;
            if(v8 >= *(_DWORD*) (a1 + 32))
                break;
            v5 = v9;
        }
    }
    return result;
}
// 452370: using guessed type int sub_452370();

//----- (004524AB) --------------------------------------------------------
_DWORD* __thiscall sub_4524AB(_DWORD* this) {
    _DWORD* result; // eax
    bool v2; // cf
    int v3; // ecx
    int v4; // ecx

    result = (_DWORD*) this [97];
    if((int) this [72] <= 1) {
        v2 = this [32] < (unsigned int) (this [70] - 1);
        v3 = this [73];
        if(v2)
            v4 = *(_DWORD*) (v3 + 12);
        else
            v4 = *(_DWORD*) (v3 + 72);
        result [7] = v4;
    }
    else {
        result [7] = 1;
    }
    result [5] = 0;
    result [6] = 0;
    return result;
}

//----- (004524EA) --------------------------------------------------------
_DWORD* __cdecl sub_4524EA(_DWORD* a1) {
    a1 [32] = 0;
    return sub_4524AB(a1);
}

//----- (004524FA) --------------------------------------------------------
int __cdecl sub_4524FA(_DWORD* a1, int a2) {
    int v3; // ebx
    unsigned int v4; // esi
    int v5; // eax
    int v6; // eax
    _DWORD* v7; // esi
    int v8; // ecx
    int v9; // ebx
    void(__cdecl * v12)(_DWORD*, _DWORD*, _DWORD, int, int); // [esp+Ch] [ebp-38h]
    unsigned int v13; // [esp+10h] [ebp-34h]
    unsigned int v14; // [esp+14h] [ebp-30h]
    int v15; // [esp+18h] [ebp-2Ch]
    int v16; // [esp+1Ch] [ebp-28h]
    _DWORD* v17; // [esp+20h] [ebp-24h]
    int v18; // [esp+24h] [ebp-20h]
    int i; // [esp+28h] [ebp-1Ch]
    int v20; // [esp+2Ch] [ebp-18h]
    _DWORD* v21; // [esp+30h] [ebp-14h]
    int v22; // [esp+34h] [ebp-10h]
    int v23; // [esp+38h] [ebp-Ch]
    int v24; // [esp+3Ch] [ebp-8h]
    int v25; // [esp+40h] [ebp-4h]
    unsigned int v26; // [esp+4Ch] [ebp+8h]

    v3 = a1 [97];
    v4 = a1 [77] - 1;
    v13 = a1 [70] - 1;
    v5 = *(_DWORD*) (v3 + 24);
    v18 = v3;
    v14 = v4;
    while(1) {
        v25 = v5;
        if(v5 >= *(_DWORD*) (v3 + 28)) {
            ++a1 [34];
            if(++a1 [32] >= a1 [70]) {
                (*(void(__cdecl**)(_DWORD*))(a1 [99] + 12))(a1);
                return 4;
            }
            else {
                sub_4524AB(a1);
                return 3;
            }
        }
        v26 = *(_DWORD*) (v3 + 20);
        if(v26 <= v4)
            break;
        LABEL_24:
        *(_DWORD*) (v3 + 20) = 0;
        ++v5;
    }
    while(1) {
        sub_44EE9E(*(void**) (v3 + 32), a1 [79] << 7);
        if(!(*(unsigned __int8(__cdecl**)(_DWORD*, int))(a1 [101] + 4))(a1, v3 + 32))
            break;
        v6 = 0;
        v20 = 0;
        v23 = 0;
        if((int) a1 [72] > 0) {
            v17 = a1 + 73;
            do {
                v7 = (_DWORD*) *v17;
                if(*(_BYTE*) (*v17 + 48)) {
                    v12 = *(void(__cdecl**)(_DWORD*, _DWORD*, _DWORD, int, int))(a1 [102] + 4 * v7 [1] + 4);
                    if(v26 >= v14)
                        v8 = v7 [17];
                    else
                        v8 = v7 [13];
                    v9 = v26 * v7 [16];
                    v24 = 0;
                    v16 = v8;
                    for(i = *(_DWORD*) (a2 + 4 * v23) + 4 * v25 * v7 [9]; v24 < v7 [14]; v20 = v6) {
                        if(a1 [32] < v13 || v25 + v24 < v7 [18]) {
                            v22 = v9;
                            if(v16 > 0) {
                                v21 = (_DWORD*) (v18 + 4 * v6 + 32);
                                v15 = v16;
                                do {
                                    v12(a1, v7, *v21, i, v22);
                                    v22 += v7 [9];
                                    ++v21;
                                    --v15;
                                }
                                while(v15);
                                v6 = v20;
                            }
                        }
                        v6 += v7 [13];
                        ++v24;
                        i += 4 * v7 [9];
                    }
                    v3 = v18;
                }
                else {
                    v6 += v7 [15];
                    v20 = v6;
                }
                ++v23;
                ++v17;
            }
            while(v23 < a1 [72]);
            v4 = v14;
        }
        if(++v26 > v4) {
            v5 = v25;
            goto LABEL_24;
        }
    }
    *(_DWORD*) (v3 + 24) = v25;
    *(_DWORD*) (v3 + 20) = v26;
    return 0;
}

//----- (004526D4) --------------------------------------------------------
int __cdecl sub_4526D4(_DWORD* a1) {
    _DWORD* v2; // edi
    int v3; // eax
    int i; // eax
    unsigned int v5; // ebx
    bool v6; // cf
    bool v7; // cc
    int v8; // ecx
    int v9; // ebx
    unsigned int v10; // edx
    unsigned int* j; // ebx
    int v14 [4]; // [esp+Ch] [ebp-34h]
    unsigned int* v15; // [esp+1Ch] [ebp-24h]
    unsigned int v16; // [esp+20h] [ebp-20h]
    unsigned int v17; // [esp+24h] [ebp-1Ch]
    _DWORD* v18; // [esp+28h] [ebp-18h]
    int v19; // [esp+2Ch] [ebp-14h]
    _DWORD* v20; // [esp+30h] [ebp-10h]
    int v21; // [esp+34h] [ebp-Ch]
    int v22; // [esp+38h] [ebp-8h]
    int v23; // [esp+3Ch] [ebp-4h]
    int v24; // [esp+48h] [ebp+8h]
    int v25; // [esp+48h] [ebp+8h]

    v24 = 0;
    v2 = (_DWORD*) a1 [97];
    if((int) a1 [72] > 0) {
        v23 = (int) (a1 + 73);
        do {
            v3 = (*(int(__cdecl**)(_DWORD*, _DWORD, int, _DWORD, int))(a1 [1] + 32))(
                a1,
                v2 [*(_DWORD*) (*(_DWORD*) v23 + 4) + 18],
                *(_DWORD*) (*(_DWORD*) v23 + 12) * a1 [32],
                *(_DWORD*) (*(_DWORD*) v23 + 12),
                1);
            v23 += 4;
            v14 [v24++] = v3;
        }
        while(v24 < a1 [72]);
    }
    for(i = v2 [6]; ; ++i) {
        v7 = i < v2 [7];
        v23 = i;
        if(!v7) {
            if(++a1 [32] >= a1 [70]) {
                (*(void(__cdecl**)(_DWORD*))(a1 [99] + 12))(a1);
                return 4;
            }
            else {
                sub_4524AB(a1);
                return 3;
            }
        }
        v5 = v2 [5];
        v6 = v5 < a1 [77];
        v17 = v5;
        if(v6)
            break;
        LABEL_20:
        v2 [5] = 0;
    }
    while(1) {
        v7 = a1 [72] <= 0;
        v22 = 0;
        v25 = 0;
        if(!v7) {
            v18 = a1 + 73;
            do {
                v8 = *v18;
                v9 = *(_DWORD*) (*v18 + 52);
                v19 = 0;
                if(*(int*) (v8 + 56) > 0) {
                    v16 = (v17 * v9) << 7;
                    v20 = (_DWORD*) (v14 [v25] + 4 * v23);
                    do {
                        v10 = v16 + *v20;
                        v21 = 0;
                        if(v9 > 0) {
                            for(j = &v2 [v22 + 8]; ; j = v15) {
                                ++v22;
                                *j = v10;
                                v10 += 128;
                                ++v21;
                                v15 = j + 1;
                                v9 = *(_DWORD*) (v8 + 52);
                                if(v21 >= v9)
                                    break;
                            }
                        }
                        ++v19;
                        ++v20;
                    }
                    while(v19 < *(_DWORD*) (v8 + 56));
                }
                ++v25;
                ++v18;
            }
            while(v25 < a1 [72]);
            v5 = v17;
        }
        if(!(*(unsigned __int8(__cdecl**)(_DWORD*, _DWORD*))(a1 [101] + 4))(a1, v2 + 8))
            break;
        v6 = ++v5 < a1 [77];
        v17 = v5;
        if(!v6) {
            i = v23;
            goto LABEL_20;
        }
    }
    v2 [6] = v23;
    v2 [5] = v5;
    return 0;
}
// 4526D4: using guessed type int var_34[4];

//----- (00452873) --------------------------------------------------------
int __cdecl sub_452873(int a1, int a2) {
    unsigned int v3; // ebx
    int v4; // eax
    int v5; // ecx
    int result; // eax
    int v7; // edi
    int v8; // ecx
    unsigned int v9; // eax
    int v10; // ebx
    unsigned int v11; // [esp+8h] [ebp-24h]
    void(__cdecl * v12)(int, int, int, int, int); // [esp+Ch] [ebp-20h]
    int v13; // [esp+10h] [ebp-1Ch]
    int v14; // [esp+14h] [ebp-18h]
    _DWORD* v15; // [esp+18h] [ebp-14h]
    int v16; // [esp+1Ch] [ebp-10h]
    unsigned int v17; // [esp+20h] [ebp-Ch]
    int i; // [esp+24h] [ebp-8h]
    int v19; // [esp+28h] [ebp-4h]
    int v20; // [esp+34h] [ebp+8h]
    int v21; // [esp+34h] [ebp+8h]

    v3 = *(_DWORD*) (a1 + 280) - 1;
    v20 = *(_DWORD*) (a1 + 388);
    v11 = v3;
    while(1) {
        v4 = *(_DWORD*) (a1 + 124);
        v5 = *(_DWORD*) (a1 + 132);
        if(v4 >= v5 && (v4 != v5 || *(_DWORD*) (a1 + 128) > *(_DWORD*) (a1 + 136)))
            break;
        result = (**(int(__cdecl***)(int))(a1 + 396))(a1);
        if(!result)
            return result;
    }
    v19 = 0;
    v7 = *(_DWORD*) (a1 + 196);
    if(*(int*) (a1 + 32) > 0) {
        v15 = (_DWORD*) (v20 + 72);
        do {
            if(*(_BYTE*) (v7 + 48)) {
                v13 = (*(int(__cdecl**)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD*) (a1 + 4) + 32))(
                    a1,
                    *v15,
                    *(_DWORD*) (v7 + 12) * *(_DWORD*) (a1 + 136),
                    *(_DWORD*) (v7 + 12),
                    0);
                if(*(_DWORD*) (a1 + 136) >= v3) {
                    v21 = *(_DWORD*) (v7 + 32) % *(_DWORD*) (v7 + 12);
                    if(!v21)
                        v21 = *(_DWORD*) (v7 + 12);
                }
                else {
                    v21 = *(_DWORD*) (v7 + 12);
                }
                v12 = *(void(__cdecl**)(int, int, int, int, int))(*(_DWORD*) (a1 + 408) + 4 * v19 + 4);
                v8 = 0;
                v16 = *(_DWORD*) (4 * v19 + a2);
                v14 = 0;
                if(v21 > 0) {
                    v9 = *(_DWORD*) (v7 + 28);
                    do {
                        v10 = 0;
                        v17 = 0;
                        for(i = *(_DWORD*) (v13 + 4 * v8); v17 < v9; ++v17) {
                            v12(a1, v7, i, v16, v10);
                            i += 128;
                            v10 += *(_DWORD*) (v7 + 36);
                            v9 = *(_DWORD*) (v7 + 28);
                        }
                        v16 += 4 * *(_DWORD*) (v7 + 36);
                        v8 = ++v14;
                    }
                    while(v14 < v21);
                    v3 = v11;
                }
            }
            ++v19;
            ++v15;
            v7 += 84;
        }
        while(v19 < *(_DWORD*) (a1 + 32));
    }
    return 4 - (++ * (_DWORD*) (a1 + 136) < *(_DWORD*) (a1 + 280));
}

//----- (004529D9) --------------------------------------------------------
char __usercall sub_4529D9(int a1) {
    int v1; // edi
    _WORD** v2; // eax
    _WORD* v3; // eax
    int* v4; // eax
    _DWORD* v5; // ecx
    int v6; // edx
    int v7; // eax
    _WORD** i; // [esp+8h] [ebp-14h]
    int v10; // [esp+Ch] [ebp-10h]
    int v11; // [esp+10h] [ebp-Ch]
    int v12; // [esp+14h] [ebp-8h]
    char v13; // [esp+1Bh] [ebp-1h]

    v1 = *(_DWORD*) (a1 + 388);
    v13 = 0;
    if(*(_BYTE*) (a1 + 200) && *(_DWORD*) (a1 + 140)) {
        if(!*(_DWORD*) (v1 + 112))
            *(_DWORD*) (v1 + 112) = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD*) (a1 + 32));
        v12 = *(_DWORD*) (v1 + 112);
        v10 = 0;
        if(*(int*) (a1 + 32) <= 0)
            return v13;
        v2 = (_WORD**) (*(_DWORD*) (a1 + 196) + 76);
        v11 = 0;
        for(i = v2; ; i += 21) {
            v3 = *v2;
            if(!v3)
                break;
            if(!*v3)
                break;
            if(!v3 [1])
                break;
            if(!v3 [8])
                break;
            if(!v3 [16])
                break;
            if(!v3 [9])
                break;
            if(!v3 [2])
                break;
            v4 = (int*) (v11 + *(_DWORD*) (a1 + 140));
            if(*v4 < 0)
                break;
            v5 = v4 + 1;
            v6 = v12 - (_DWORD) v4;
            v7 = 5;
            do {
                *(_DWORD*) ((char*) v5 + v6) = *v5;
                if(*v5)
                    v13 = 1;
                ++v5;
                --v7;
            }
            while(v7);
            v12 += 24;
            ++v10;
            v11 += 256;
            v2 = i + 21;
            if(v10 >= *(_DWORD*) (a1 + 32))
                return v13;
        }
    }
    return 0;
}

//----- (00452ABC) --------------------------------------------------------
int __cdecl sub_452ABC(_DWORD* a1, int a2) {
    int v3; // edx
    int v4; // eax
    int v5; // ecx
    bool v6; // cc
    int v7; // edi
    unsigned int v8; // ebx
    unsigned int v9; // ecx
    int v10; // eax
    int v12; // eax
    _DWORD* v13; // eax
    unsigned __int16* v14; // eax
    int v15; // ecx
    int v16; // eax
    __int16** v17; // edx
    __int16* v18; // ecx
    __int16* v19; // eax
    int v20; // edx
    int v21; // ecx
    int v22; // eax
    int v23; // edx
    int v24; // eax
    int v25; // ecx
    int v26; // eax
    int v27; // ecx
    int v28; // ecx
    int v29; // ebx
    int v30; // eax
    int v31; // edx
    int v32; // eax
    int v33; // eax
    int v34; // edx
    int v35; // ecx
    int v36; // eax
    int v37; // eax
    int v38; // ecx
    int v39; // eax
    int v40; // ecx
    int v41; // edx
    int v42; // ecx
    int v43; // eax
    int v44; // eax
    int v45; // ecx
    int v46; // eax
    int v47; // ecx
    int v48; // edx
    int v49; // ecx
    int v50; // eax
    int v51; // eax
    int v52; // ecx
    int v53; // eax
    int v54; // ecx
    int v55; // eax
    char v56 [2]; // [esp+8h] [ebp-98h] BYREF
    __int16 v57; // [esp+Ah] [ebp-96h]
    __int16 v58; // [esp+Ch] [ebp-94h]
    __int16 v59; // [esp+18h] [ebp-88h]
    __int16 v60; // [esp+1Ah] [ebp-86h]
    __int16 v61; // [esp+28h] [ebp-78h]
    void(__cdecl * v62)(_DWORD*, int, char*, int, int); // [esp+88h] [ebp-18h]
    unsigned int v63; // [esp+8Ch] [ebp-14h]
    int v64; // [esp+90h] [ebp-10h]
    int v65; // [esp+94h] [ebp-Ch]
    int v66; // [esp+98h] [ebp-8h]
    unsigned int v67; // [esp+9Ch] [ebp-4h]
    int v68; // [esp+A0h] [ebp+0h]
    int v69; // [esp+A4h] [ebp+4h]
    int v70; // [esp+A8h] [ebp+8h]
    int i; // [esp+ACh] [ebp+Ch]
    __int16* v72; // [esp+B0h] [ebp+10h]
    int v73; // [esp+B4h] [ebp+14h]
    __int16* v74; // [esp+B8h] [ebp+18h]
    int v75; // [esp+BCh] [ebp+1Ch]
    int v76; // [esp+C0h] [ebp+20h]
    int v77; // [esp+C4h] [ebp+24h]
    unsigned int v78; // [esp+C8h] [ebp+28h]
    int v79; // [esp+CCh] [ebp+2Ch]
    int v80; // [esp+D0h] [ebp+30h]
    int v81; // [esp+D4h] [ebp+34h]
    int v82; // [esp+D8h] [ebp+38h]
    int v83; // [esp+DCh] [ebp+3Ch]
    int v84; // [esp+E0h] [ebp+40h]
    int v85; // [esp+E4h] [ebp+44h]
    int v86; // [esp+E8h] [ebp+48h]
    int v87; // [esp+ECh] [ebp+4Ch]
    _DWORD* v88; // [esp+F0h] [ebp+50h]
    int v89; // [esp+F4h] [ebp+54h]
    int v90; // [esp+F8h] [ebp+58h]
    int v91; // [esp+FCh] [ebp+5Ch]
    int v92; // [esp+100h] [ebp+60h]
    __int16* v93; // [esp+104h] [ebp+64h]
    char v94; // [esp+10Bh] [ebp+6Bh]
    _DWORD* v95; // [esp+10Ch] [ebp+6Ch]
    char v96; // [esp+11Bh] [ebp+7Bh]

    v68 = a1 [97];
    v63 = a1 [70] - 1;
    while(1) {
        v4 = a1 [31];
        v5 = a1 [33];
        if(v4 > v5)
            break;
        v3 = a1 [99];
        if(*(_BYTE*) (v3 + 17) || v4 == v5 && a1 [32] > a1 [34] + (unsigned int) (a1 [90] == 0))
            break;
        if(!(*(int(__cdecl**)(_DWORD*))v3)(a1))
            return 0;
    }
    v6 = a1 [8] <= 0;
    v7 = a1 [49];
    v76 = 0;
    if(!v6) {
        v69 = 0;
        v70 = -72 - v68;
        v88 = (_DWORD*) (v68 + 72);
        do {
            if(*(_BYTE*) (v7 + 48)) {
                v8 = a1 [34];
                v9 = *(_DWORD*) (v7 + 12);
                if(v8 >= v63) {
                    v92 = *(_DWORD*) (v7 + 32) % v9;
                    if(!v92)
                        v92 = v9;
                    v10 = v92;
                    v94 = 1;
                }
                else {
                    v92 = *(_DWORD*) (v7 + 12);
                    v10 = 2 * v9;
                    v94 = 0;
                }
                if(v8) {
                    v96 = 0;
                    v12 = (*(int(__cdecl**)(_DWORD*, _DWORD, unsigned int, unsigned int, _DWORD))(a1 [1] + 32))(
                        a1,
                        *v88,
                        v9 * (v8 - 1),
                        v9 + v10,
                        0)
                        + 4 * *(_DWORD*) (v7 + 12);
                }
                else {
                    v12 = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, int, _DWORD))(a1 [1] + 32))(a1, *v88, 0, v10, 0);
                    v96 = 1;
                }
                v66 = v12;
                v13 = (_DWORD*) (v69 + *(_DWORD*) (v68 + 112));
                v90 = 0;
                v95 = v13;
                v14 = *(unsigned __int16**) (v7 + 76);
                v89 = *v14;
                v80 = v14 [1];
                v85 = v14 [8];
                v77 = v14 [16];
                v15 = v14 [9];
                v79 = v14 [2];
                v16 = v70 + a1 [102];
                v83 = v15;
                v62 = *(void(__cdecl**)(_DWORD*, int, char*, int, int))((char*) v88 + v16 + 4);
                for(i = *(_DWORD*) (a2 + 4 * v76); v90 < v92; i += 4 * v55) {
                    v17 = (__int16**) (v66 + 4 * v90);
                    v18 = *v17;
                    v93 = *v17;
                    if(!v96 || v90)
                        v18 = *(v17 - 1);
                    if(!v94 || (v19 = v93, v90 != v92 - 1))
                        v19 = v17 [1];
                    v20 = *v18;
                    v73 = 0;
                    v78 = 0;
                    v81 = v20;
                    v86 = v20;
                    v64 = v20;
                    v91 = *v93;
                    v84 = v91;
                    v75 = v91;
                    v82 = *v19;
                    v87 = v82;
                    v65 = v82;
                    v67 = *(_DWORD*) (v7 + 28) - 1;
                    v74 = v19 + 64;
                    v72 = v18 + 64;
                    do {
                        sub_44EE7C(v93, v56, 1);
                        if(v78 < v67) {
                            v81 = *v72;
                            v91 = v93 [64];
                            v82 = *v74;
                        }
                        if(v95 [1] && !v57) {
                            v21 = v80 << 8;
                            v22 = v80 << 7;
                            v23 = 36 * v89 * (v75 - v91);
                            if(v23 < 0) {
                                v26 = (v22 - v23) / v21;
                                v27 = v95 [1];
                                if(v27 > 0 && v26 >= 1 << v27)
                                    v26 = (1 << v27) - 1;
                                v24 = -v26;
                            }
                            else {
                                v24 = (v23 + v22) / v21;
                                v25 = v95 [1];
                                if(v25 > 0 && v24 >= 1 << v25)
                                    LOWORD(v24) = (1 << v25) - 1;
                            }
                            v57 = v24;
                        }
                        v28 = v95 [2];
                        if(v28 && !v59) {
                            v29 = v85 << 8;
                            v30 = v85 << 7;
                            v31 = 36 * v89 * (v86 - v87);
                            if(v31 < 0) {
                                v33 = (v30 - v31) / v29;
                                if(v28 > 0 && v33 >= 1 << v28)
                                    v33 = (1 << v28) - 1;
                                v32 = -v33;
                            }
                            else {
                                v32 = (v31 + v30) / v29;
                                if(v28 > 0 && v32 >= 1 << v28)
                                    LOWORD(v32) = (1 << v28) - 1;
                            }
                            v59 = v32;
                        }
                        if(v95 [3] && !v61) {
                            v34 = 9 * v89 * (v86 + v87 - 2 * v84);
                            v35 = v77 << 8;
                            v36 = v77 << 7;
                            if(v34 < 0) {
                                v39 = (v36 - v34) / v35;
                                v40 = v95 [3];
                                if(v40 > 0 && v39 >= 1 << v40)
                                    v39 = (1 << v40) - 1;
                                v37 = -v39;
                            }
                            else {
                                v37 = (v34 + v36) / v35;
                                v38 = v95 [3];
                                if(v38 > 0 && v37 >= 1 << v38)
                                    LOWORD(v37) = (1 << v38) - 1;
                            }
                            v61 = v37;
                        }
                        if(v95 [4] && !v60) {
                            v41 = 5 * v89 * (v64 + v82 - v65 - v81);
                            v42 = v83 << 8;
                            v43 = v83 << 7;
                            if(v41 < 0) {
                                v46 = (v43 - v41) / v42;
                                v47 = v95 [4];
                                if(v47 > 0 && v46 >= 1 << v47)
                                    v46 = (1 << v47) - 1;
                                v44 = -v46;
                            }
                            else {
                                v44 = (v41 + v43) / v42;
                                v45 = v95 [4];
                                if(v45 > 0 && v44 >= 1 << v45)
                                    LOWORD(v44) = (1 << v45) - 1;
                            }
                            v60 = v44;
                        }
                        if(v95 [5] && !v58) {
                            v48 = 9 * v89 * (v75 + v91 - 2 * v84);
                            v49 = v79 << 8;
                            v50 = v79 << 7;
                            if(v48 < 0) {
                                v53 = (v50 - v48) / v49;
                                v54 = v95 [5];
                                if(v54 > 0 && v53 >= 1 << v54)
                                    v53 = (1 << v54) - 1;
                                v51 = -v53;
                            }
                            else {
                                v51 = (v48 + v50) / v49;
                                v52 = v95 [5];
                                if(v52 > 0 && v51 >= 1 << v52)
                                    LOWORD(v51) = (1 << v52) - 1;
                            }
                            v58 = v51;
                        }
                        v62(a1, v7, v56, i, v73);
                        v93 += 64;
                        v72 += 64;
                        v74 += 64;
                        v64 = v86;
                        v86 = v81;
                        v75 = v84;
                        v84 = v91;
                        v65 = v87;
                        v87 = v82;
                        v73 += *(_DWORD*) (v7 + 36);
                        ++v78;
                    }
                    while(v78 <= v67);
                    v55 = *(_DWORD*) (v7 + 36);
                    ++v90;
                }
            }
            ++v76;
            v69 += 24;
            ++v88;
            v7 += 84;
        }
        while(v76 < a1 [8]);
    }
    return 4 - (++a1 [34] < a1 [70]);
}

//----- (0045300F) --------------------------------------------------------
int __cdecl sub_45300F(int a1, char a2) {
    _DWORD* v3; // ebx
    int v4; // eax
    int* v5; // edi
    int v6; // ecx
    int v7; // ebx
    int v8; // eax
    int v9; // eax
    int* v10; // ecx
    int result; // eax
    int* v12; // ecx
    int v13; // edx
    int v14; // [esp-8h] [ebp-18h]
    int v15; // [esp-4h] [ebp-14h]
    _DWORD* v16; // [esp+Ch] [ebp-4h]
    int v17; // [esp+18h] [ebp+8h]
    int* v18; // [esp+1Ch] [ebp+Ch]

    v3 = (_DWORD*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 116);
    *(_DWORD*) (a1 + 388) = v3;
    v16 = v3;
    *v3 = sub_4524EA;
    v3 [2] = sub_452FD4;
    v3 [28] = 0;
    if(a2) {
        v4 = *(_DWORD*) (a1 + 196);
        v17 = 0;
        if(*(int*) (a1 + 32) > 0) {
            v5 = (int*) (v4 + 12);
            v18 = v3 + 18;
            do {
                v6 = *v5;
                if(*(_BYTE*) (a1 + 200))
                    v6 *= 3;
                v7 = *(_DWORD*) (a1 + 4);
                v15 = v6;
                v14 = sub_44EE1D(v5 [5], *v5);
                v8 = sub_44EE1D(v5 [4], *(v5 - 1));
                v9 = (*(int(__cdecl**)(int, int, int, int, int, int))(v7 + 20))(a1, 1, 1, v8, v14, v15);
                v10 = v18++;
                ++v17;
                *v10 = v9;
                v5 += 21;
            }
            while(v17 < *(_DWORD*) (a1 + 32));
            v3 = v16;
        }
        result = (int) (v3 + 18);
        v3 [1] = sub_4526D4;
        v3 [3] = sub_452873;
        v3 [4] = v3 + 18;
    }
    else {
        result = (*(int(__cdecl**)(int, int, int))(*(_DWORD*) (a1 + 4) + 4))(a1, 1, 1280);
        v12 = v3 + 8;
        v13 = 10;
        do {
            *v12++ = result;
            result += 128;
            --v13;
        }
        while(v13);
        v3 [1] = sub_4671A5;
        v3 [3] = sub_4524FA;
        v3 [4] = 0;
    }
    return result;
}
// 452FD4: using guessed type int sub_452FD4();

//----- (00453107) --------------------------------------------------------
int __cdecl sub_453107(int a1, int a2, int a3) {
    _DWORD* v3; // esi
    int v4; // ebx
    int v5; // eax
    int v6; // ecx
    char* v7; // edi
    int v8; // edx
    unsigned int v9; // ecx
    int v10; // eax
    int v11; // ecx
    int v12; // eax
    int v13; // edi
    int v14; // edx
    int v15; // ecx
    int v16; // edx
    _DWORD* v17; // eax
    int v18; // edi
    int result; // eax
    unsigned __int8* v20; // edi
    bool v21; // cf
    int v22; // edx
    _BYTE* v23; // ebx
    int v24; // eax
    _BYTE* v25; // edi
    int* v26; // eax
    int v27 [258]; // [esp+8h] [ebp-51Ch]
    char v28 [260]; // [esp+410h] [ebp-114h] BYREF
    unsigned __int8* v29; // [esp+514h] [ebp-10h]
    int v30; // [esp+518h] [ebp-Ch]
    int j; // [esp+51Ch] [ebp-8h]
    int v32; // [esp+520h] [ebp-4h]
    int v33; // [esp+52Ch] [ebp+8h]
    int v34; // [esp+52Ch] [ebp+8h]
    int i; // [esp+534h] [ebp+10h]
    int v36; // [esp+534h] [ebp+10h]

    if(!*(_DWORD*) a3)
        *(_DWORD*) a3 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1492);
    v3 = *(_DWORD**) a3;
    v4 = a2;
    v5 = 0;
    *(_DWORD*) (*(_DWORD*) a3 + 208) = a2;
    v33 = 0;
    for(i = 1; i <= 16; ++i) {
        v6 = *(unsigned __int8*) (i + v4);
        v32 = v6;
        if(v6 >= 1) {
            v7 = &v28 [v5];
            LOBYTE(v4) = i;
            BYTE1(v4) = i;
            v8 = v6;
            v9 = (unsigned int) v6 >> 2;
            v10 = v4 << 16;
            LOWORD(v10) = v4;
            v4 = a2;
            memset32(v7, v10, v9);
            memset(&v7 [4 * v9], v10, v8 & 3);
            v5 = v8 + v33;
            v33 += v8;
        }
    }
    v28 [v5] = 0;
    v11 = v28 [0];
    v12 = 0;
    v13 = 0;
    if(v28 [0]) {
        v14 = v28 [0];
        do {
            while(v14 == v11) {
                v14 = v28 [v12 + 1];
                v27 [++v12] = v13++;
            }
            v13 *= 2;
            ++v11;
        }
        while(v28 [v12]);
    }
    v15 = 0;
    v16 = 1;
    v17 = v3 + 18;
    do {
        if(*(_BYTE*) (v16 + v4)) {
            v18 = v27 [v15 + 1];
            v17 [18] = v15;
            *(v17 - 17) = v18;
            v15 += *(unsigned __int8*) (v16 + v4);
            *v17 = v27 [v15];
        }
        else {
            *v17 = -1;
        }
        ++v16;
        ++v17;
    }
    while(v16 <= 16);
    v34 = 0;
    v3 [34] = 0xFFFFF;
    memset(v3 + 53, 0, 0x400u);
    v36 = 1;
    for(j = 7; j >= 0; --j) {
        result = v36;
        v20 = (unsigned __int8*) (v36 + v4);
        v21 = *(_BYTE*) (v36 + v4) == 0;
        v30 = 1;
        v29 = (unsigned __int8*) (v36 + v4);
        if(!v21) {
            v22 = 1 << j;
            v23 = (_BYTE*) (v34 + v4 + 17);
            do {
                v24 = v27 [v34 + 1] << j;
                if(v22 > 0) {
                    v25 = (char*) v3 + v24 + 1236;
                    v26 = &v3 [v24 + 53];
                    v32 = v22;
                    do {
                        *v26++ = v36;
                        *v25++ = *v23;
                        --v32;
                    }
                    while(v32);
                    v20 = v29;
                }
                ++v30;
                result = *v20;
                ++v34;
                ++v23;
            }
            while(v30 <= result);
            v4 = a2;
        }
        ++v36;
    }
    return result;
}

//----- (004532AA) --------------------------------------------------------
char __cdecl sub_4532AA(unsigned __int8** a1, int a2, int a3, int a4) {
    unsigned __int8* v4; // ebx
    unsigned __int8* v5; // edi
    unsigned __int8** v6; // eax
    int v7; // ecx
    unsigned __int8** v8; // eax
    unsigned __int8* v9; // ecx

    v4 = a1 [1];
    v5 = *a1;
    while(1) {
        if(a3 >= 25) {
            LABEL_20:
            a1 [3] = (unsigned __int8*) a2;
            a1 [6] = (unsigned __int8*) a3;
            *a1 = v5;
            a1 [1] = v4;
            return 1;
        }
        if(a1 [2])
            goto LABEL_14;
        if(!v4)
            break;
        LABEL_6:
        v7 = *v5;
        --v4;
        ++v5;
        if(v7 != 255)
            goto LABEL_18;
        do {
            if(!v4) {
                if(!(*(unsigned __int8(__cdecl**)(unsigned __int8*))(*((_DWORD*) a1 [7] + 5) + 12))(a1 [7]))
                    return 0;
                v8 = (unsigned __int8**) *((_DWORD*) a1 [7] + 5);
                v5 = *v8;
                v4 = v8 [1];
            }
            v9 = (unsigned __int8*) *v5;
            --v4;
            ++v5;
        }
        while(v9 == (unsigned __int8*) 255);
        if(!v9) {
            v7 = 255;
            goto LABEL_18;
        }
        a1 [2] = v9;
        LABEL_14:
        if(a3 >= a4)
            goto LABEL_20;
        if(!*a1 [8]) {
            *(_DWORD*) (*(_DWORD*) a1 [7] + 20) = 113;
            (*(void(__cdecl**)(unsigned __int8*, int))(*(_DWORD*) a1 [7] + 4))(a1 [7], -1);
            *a1 [8] = 1;
        }
        v7 = 0;
        LABEL_18:
        a3 += 8;
        a2 = v7 | (a2 << 8);
    }
    if((*(unsigned __int8(__cdecl**)(unsigned __int8*))(*((_DWORD*) a1 [7] + 5) + 12))(a1 [7])) {
        v6 = (unsigned __int8**) *((_DWORD*) a1 [7] + 5);
        v5 = *v6;
        v4 = v6 [1];
        goto LABEL_6;
    }
    return 0;
}

//----- (00453394) --------------------------------------------------------
int __cdecl sub_453394(int a1, int a2, int a3, int a4, int a5) {
    int v5; // eax
    int v6; // edx
    int v7; // eax
    int v8; // esi
    int v9; // ebx
    int v10; // esi
    int v12; // [esp+Ch] [ebp-4h]
    int* v13; // [esp+1Ch] [ebp+Ch]

    v5 = a3;
    v12 = a5;
    if(a3 >= a5) {
        v6 = a2;
    }
    else {
        if(!sub_4532AA((unsigned __int8**) a1, a2, a3, a5))
            return -1;
        v6 = *(_DWORD*) (a1 + 12);
        v5 = *(_DWORD*) (a1 + 24);
    }
    v7 = v5 - a5;
    v8 = ((1 << a5) - 1) & (v6 >> v7);
    v9 = a4;
    if(v8 > *(_DWORD*) (a4 + 4 * a5 + 68)) {
        v13 = (int*) (a4 + 4 * a5 + 68);
        do {
            v10 = 2 * v8;
            if(v7 < 1) {
                if(!sub_4532AA((unsigned __int8**) a1, v6, v7, 1))
                    return -1;
                v6 = *(_DWORD*) (a1 + 12);
                v7 = *(_DWORD*) (a1 + 24);
            }
            ++v13;
            v8 = (v6 >> --v7) & 1 | v10;
            ++v12;
        }
        while(v8 > *v13);
        v9 = a4;
    }
    *(_DWORD*) (a1 + 24) = v7;
    *(_DWORD*) (a1 + 12) = v6;
    if(v12 <= 16)
        return *(unsigned __int8*) (*(_DWORD*) (v9 + 208)
                                    + *(_DWORD*) (v9 + 4 * v12 + 140)
                                    - *(_DWORD*) (v9 + 4 * v12)
                                    + v8
                                    + 17);
    *(_DWORD*) (**(_DWORD**) (a1 + 28) + 20) = 114;
    (*(void(__cdecl**)(_DWORD, int))(**(_DWORD**) (a1 + 28) + 4))(*(_DWORD*) (a1 + 28), -1);
    return 0;
}

//----- (0045347A) --------------------------------------------------------
char __cdecl sub_45347A(_DWORD* a1) {
    int v1; // esi
    char result; // al
    int v3; // edx
    _DWORD* v4; // ecx

    v1 = a1 [101];
    *(_DWORD*) (a1 [100] + 88) += *(_DWORD*) (v1 + 20) / 8;
    *(_DWORD*) (v1 + 20) = 0;
    result = (*(int(__cdecl**)(_DWORD*))(a1 [100] + 8))(a1);
    if(result) {
        v3 = 0;
        if((int) a1 [72] > 0) {
            v4 = (_DWORD*) (v1 + 32);
            do {
                *v4 = 0;
                ++v3;
                ++v4;
            }
            while(v3 < a1 [72]);
        }
        *(_DWORD*) (v1 + 48) = a1 [63];
        *(_BYTE*) (v1 + 24) = 0;
        return 1;
    }
    return result;
}

//----- (004534D8) --------------------------------------------------------
char __cdecl sub_4534D8(_DWORD* a1, int a2) {
    _DWORD* v2; // ecx
    _DWORD* v3; // ebx
    int v4; // eax
    unsigned __int8* v5; // edx
    int v6; // eax
    bool v7; // cc
    int v8; // eax
    int v9; // edx
    int v10; // eax
    int v11; // esi
    int v12; // edi
    int v13; // ecx
    int v14; // ecx
    int v15; // esi
    int v16; // ecx
    int v17; // esi
    int v18; // esi
    int v19; // ecx
    int* v20; // ecx
    int v21; // ecx
    int v22; // esi
    int v23; // esi
    int v24; // edi
    int v25; // edi
    int v26; // ecx
    int v27; // edi
    int v28; // esi
    __int16 v29; // cx
    int v30; // ecx
    int v31; // esi
    int v32; // esi
    int v33; // edi
    int v34; // esi
    int v35; // ecx
    int v36; // esi
    unsigned __int8* v38; // [esp+Ch] [ebp-54h] BYREF
    int v39; // [esp+10h] [ebp-50h]
    int v40; // [esp+14h] [ebp-4Ch]
    int v41; // [esp+18h] [ebp-48h]
    int v42; // [esp+24h] [ebp-3Ch]
    _DWORD* v43; // [esp+28h] [ebp-38h]
    _DWORD* v44; // [esp+2Ch] [ebp-34h]
    int v45; // [esp+34h] [ebp-2Ch] BYREF
    int v46; // [esp+38h] [ebp-28h]
    int v47; // [esp+3Ch] [ebp-24h]
    int v48; // [esp+40h] [ebp-20h]
    int v49; // [esp+44h] [ebp-1Ch]
    _WORD* v50; // [esp+48h] [ebp-18h]
    int v51; // [esp+4Ch] [ebp-14h]
    int* v52; // [esp+50h] [ebp-10h]
    int v53; // [esp+54h] [ebp-Ch]
    int v54; // [esp+58h] [ebp-8h]
    int v55; // [esp+5Ch] [ebp-4h]

    v2 = a1;
    v3 = (_DWORD*) a1 [101];
    if(a1 [63] && !v3 [12]) {
        if(!sub_45347A(a1))
            return 0;
        v2 = a1;
    }
    v4 = v2 [5];
    v5 = *(unsigned __int8**) v4;
    v6 = *(_DWORD*) (v4 + 4);
    v53 = 0;
    v7 = v2 [79] <= 0;
    v44 = v3 + 6;
    v45 = v3 [8];
    v46 = v3 [9];
    v39 = v6;
    v8 = v2 [94];
    v47 = v3 [10];
    v38 = v5;
    v9 = v3 [4];
    v40 = v8;
    v10 = v3 [5];
    v43 = v2;
    v48 = v3 [11];
    if(v7)
        goto LABEL_66;
    v52 = v2 + 80;
    LABEL_7:
    v50 = *(_WORD**) (a2 + 4 * v53);
    v11 = *v52;
    v12 = v2 [*v52 + 73];
    v55 = v3 [*(_DWORD*) (v12 + 20) + 13];
    v13 = v3 [*(_DWORD*) (v12 + 24) + 17];
    v49 = v11;
    v51 = v12;
    v54 = v13;
    if(v10 < 8) {
        if(!sub_4532AA(&v38, v9, v10, 0))
            return 0;
        v10 = v42;
        v9 = v41;
        if(v42 < 8) {
            v14 = 1;
            LABEL_14:
            v17 = sub_453394((int) &v38, v9, v10, v55, v14);
            if(v17 < 0)
                return 0;
            v9 = v41;
            v10 = v42;
            goto LABEL_16;
        }
    }
    v15 = (unsigned __int8) (v9 >> (v10 - 8));
    v16 = *(_DWORD*) (v55 + 4 * v15 + 212);
    if(!v16) {
        v14 = 9;
        goto LABEL_14;
    }
    v10 -= v16;
    v17 = *(unsigned __int8*) (v15 + v55 + 1236);
    LABEL_16:
    if(!v17) {
        LABEL_23:
        if(*(_BYTE*) (v12 + 48)) {
            v20 = &v45 + v49;
            *v20 += v17;
            *v50 = *v20;
            if(*(int*) (v12 + 36) > 1) {
                v55 = 1;
                while(1) {
                    if(v10 < 8) {
                        if(!sub_4532AA(&v38, v9, v10, 0))
                            return 0;
                        v10 = v42;
                        v9 = v41;
                        if(v42 < 8)
                            break;
                    }
                    v21 = v54;
                    v23 = (unsigned __int8) (v9 >> (v10 - 8));
                    v24 = *(_DWORD*) (v54 + 4 * v23 + 212);
                    if(!v24) {
                        v22 = 9;
                        goto LABEL_33;
                    }
                    v10 -= v24;
                    v25 = *(unsigned __int8*) (v23 + v54 + 1236);
                    LABEL_35:
                    v26 = v25 >> 4;
                    v27 = v25 & 0xF;
                    v49 = v27;
                    if(v27) {
                        v55 += v26;
                        if(v10 < v27) {
                            if(!sub_4532AA(&v38, v9, v10, v27))
                                return 0;
                            v9 = v41;
                            v10 = v42;
                        }
                        v10 -= v27;
                        v28 = (v9 >> v10) & ((1 << v27) - 1);
                        if(v28 >= dword_46F540 [v49])
                            v29 = (v9 >> v10) & ((1 << v27) - 1);
                        else
                            v29 = v28 + dword_46F580 [v49];
                        v50 [dword_46EA70 [v55]] = v29;
                    }
                    else {
                        if(v26 != 15)
                            goto LABEL_65;
                        v55 += 15;
                    }
                    if(++v55 >= 64)
                        goto LABEL_65;
                }
                v21 = v54;
                v22 = 1;
                LABEL_33:
                v25 = sub_453394((int) &v38, v9, v10, v21, v22);
                if(v25 < 0)
                    return 0;
                v9 = v41;
                v10 = v42;
                goto LABEL_35;
            }
        }
        v55 = 1;
        while(1) {
            if(v10 < 8) {
                if(!sub_4532AA(&v38, v9, v10, 0))
                    return 0;
                v10 = v42;
                v9 = v41;
                if(v42 < 8)
                    break;
            }
            v30 = v54;
            v32 = (unsigned __int8) (v9 >> (v10 - 8));
            v33 = *(_DWORD*) (v54 + 4 * v32 + 212);
            if(!v33) {
                v31 = 9;
                goto LABEL_55;
            }
            v34 = *(unsigned __int8*) (v32 + v54 + 1236);
            v10 -= v33;
            LABEL_57:
            v35 = v34 >> 4;
            v36 = v34 & 0xF;
            if(v36) {
                v55 += v35;
                if(v10 < v36) {
                    if(!sub_4532AA(&v38, v9, v10, v36))
                        return 0;
                    v9 = v41;
                    v10 = v42;
                }
                v10 -= v36;
            }
            else {
                if(v35 != 15)
                    goto LABEL_65;
                v55 += 15;
            }
            if(++v55 >= 64) {
                LABEL_65:
                ++v53;
                v2 = a1;
                ++v52;
                if(v53 >= a1 [79]) {
                    LABEL_66:
                    *(_DWORD*) v2 [5] = v38;
                    *(_DWORD*) (v2 [5] + 4) = v39;
                    v2 [94] = v40;
                    --v3 [12];
                    v3 [8] = v45;
                    v3 [9] = v46;
                    v3 [10] = v47;
                    v3 [5] = v10;
                    v3 [4] = v9;
                    v3 [11] = v48;
                    return 1;
                }
                goto LABEL_7;
            }
        }
        v30 = v54;
        v31 = 1;
        LABEL_55:
        v34 = sub_453394((int) &v38, v9, v10, v30, v31);
        if(v34 < 0)
            return 0;
        v9 = v41;
        v10 = v42;
        goto LABEL_57;
    }
    if(v10 >= v17) {
        LABEL_20:
        v10 -= v17;
        v55 = (1 << v17) - 1;
        v18 = v17;
        v19 = (v9 >> v10) & v55;
        v12 = v51;
        if(v19 >= dword_46F540 [v18])
            v17 = (v9 >> v10) & v55;
        else
            v17 = v19 + dword_46F580 [v18];
        goto LABEL_23;
    }
    if(sub_4532AA(&v38, v9, v10, v17)) {
        v9 = v41;
        v10 = v42;
        goto LABEL_20;
    }
    return 0;
}
// 46EA70: using guessed type int dword_46EA70[64];
// 46F540: using guessed type int dword_46F540[16];
// 46F580: using guessed type int dword_46F580[42];

//----- (004538A5) --------------------------------------------------------
int __cdecl sub_4538A5(_DWORD* a1) {
    int v2; // edi
    unsigned int v3; // ebx
    unsigned int v4; // eax
    int result; // eax
    unsigned int v6; // [esp+Ch] [ebp-Ch]
    int v7; // [esp+10h] [ebp-8h]
    _DWORD* v8; // [esp+14h] [ebp-4h]
    _DWORD* v9; // [esp+20h] [ebp+8h]

    v2 = a1 [101];
    if(a1 [90] || a1 [91] != 63 || a1 [92] || a1 [93]) {
        *(_DWORD*) (*a1 + 20) = 118;
        (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
    }
    v7 = 0;
    if((int) a1 [72] > 0) {
        v8 = (_DWORD*) (v2 + 32);
        v9 = a1 + 73;
        do {
            v3 = *(_DWORD*) (*v9 + 20);
            v4 = *(_DWORD*) (*v9 + 24);
            v6 = v4;
            if(v3 > 3 || !a1 [v3 + 40]) {
                *(_DWORD*) (*a1 + 20) = 49;
                *(_DWORD*) (*a1 + 24) = v3;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                v4 = v6;
            }
            if(v4 > 3 || !a1 [v4 + 44]) {
                *(_DWORD*) (*a1 + 20) = 49;
                *(_DWORD*) (*a1 + 24) = v4;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
            sub_453107((int) a1, a1 [v3 + 40], v2 + 4 * v3 + 52);
            sub_453107((int) a1, a1 [v6 + 44], v2 + 4 * v6 + 68);
            *v8 = 0;
            ++v9;
            ++v8;
            ++v7;
        }
        while(v7 < a1 [72]);
    }
    *(_BYTE*) (v2 + 24) = 0;
    *(_DWORD*) (v2 + 20) = 0;
    *(_DWORD*) (v2 + 8) = 0;
    *(_DWORD*) (v2 + 12) = 0;
    *(_DWORD*) (v2 + 16) = 0;
    result = a1 [63];
    *(_DWORD*) (v2 + 48) = result;
    return result;
}

//----- (004539D4) --------------------------------------------------------
_DWORD* __cdecl sub_4539D4(int a1) {
    _DWORD* v1; // eax
    int v2; // ecx
    _DWORD* result; // eax

    v1 = (_DWORD*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 88);
    *(_DWORD*) (a1 + 404) = v1;
    v2 = 4;
    *v1 = sub_4538A5;
    v1 [1] = sub_4534D8;
    result = v1 + 13;
    do {
        result [4] = 0;
        *result++ = 0;
        --v2;
    }
    while(v2);
    return result;
}

//----- (00453A0E) --------------------------------------------------------
char __usercall sub_453A0E(_DWORD* a1) {
    int v1; // esi
    char result; // al
    int v3; // edx
    _DWORD* v4; // ecx

    v1 = a1 [101];
    *(_DWORD*) (a1 [100] + 88) += *(_DWORD*) (v1 + 20) / 8;
    *(_DWORD*) (v1 + 20) = 0;
    result = (*(int(__cdecl**)(_DWORD*))(a1 [100] + 8))(a1);
    if(result) {
        v3 = 0;
        if((int) a1 [72] > 0) {
            v4 = (_DWORD*) (v1 + 36);
            do {
                *v4 = 0;
                ++v3;
                ++v4;
            }
            while(v3 < a1 [72]);
        }
        *(_DWORD*) (v1 + 32) = 0;
        *(_DWORD*) (v1 + 52) = a1 [63];
        *(_BYTE*) (v1 + 24) = 0;
        return 1;
    }
    return result;
}

//----- (00453A69) --------------------------------------------------------
char __cdecl sub_453A69(_DWORD* a1, int a2) {
    bool v3; // zf
    _DWORD* v4; // eax
    int v5; // ecx
    int v6; // ecx
    bool v7; // cc
    int v8; // edx
    int v9; // edi
    int v10; // eax
    int v11; // esi
    int v12; // ecx
    int v13; // esi
    int v14; // esi
    int v15; // ecx
    _DWORD* v16; // ecx
    int v17; // esi
    unsigned __int8* v19; // [esp+Ch] [ebp-58h] BYREF
    int v20; // [esp+10h] [ebp-54h]
    int v21; // [esp+14h] [ebp-50h]
    int v22; // [esp+18h] [ebp-4Ch]
    int v23; // [esp+24h] [ebp-40h]
    _DWORD* v24; // [esp+28h] [ebp-3Ch]
    _DWORD* v25; // [esp+2Ch] [ebp-38h]
    _DWORD v26 [5]; // [esp+34h] [ebp-30h] BYREF
    _WORD* v27; // [esp+48h] [ebp-1Ch]
    int v28; // [esp+4Ch] [ebp-18h]
    int v29; // [esp+50h] [ebp-14h]
    int* v30; // [esp+54h] [ebp-10h]
    int v31; // [esp+58h] [ebp-Ch]
    _DWORD* v32; // [esp+5Ch] [ebp-8h]
    int v33; // [esp+60h] [ebp-4h]
    int v34; // [esp+6Ch] [ebp+8h]

    v3 = a1 [63] == 0;
    v4 = (_DWORD*) a1 [101];
    v5 = a1 [93];
    v32 = v4;
    v28 = v5;
    if(!v3 && !v4 [13]) {
        if(!sub_453A0E(a1))
            return 0;
        v4 = v32;
    }
    v6 = a1 [5];
    v31 = 0;
    v7 = a1 [79] <= 0;
    v24 = a1;
    v19 = *(unsigned __int8**) v6;
    v20 = *(_DWORD*) (v6 + 4);
    v21 = a1 [94];
    v8 = v4 [5];
    v34 = v4 [4];
    v25 = v4 + 6;
    qmemcpy(v26, v4 + 8, sizeof(v26));
    if(!v7) {
        v30 = a1 + 80;
        do {
            v27 = *(_WORD**) (a2 + 4 * v31);
            v29 = *v30;
            v9 = v4 [*(_DWORD*) (a1 [v29 + 73] + 20) + 14];
            if(v8 < 8) {
                if(!sub_4532AA(&v19, v34, v8, 0))
                    return 0;
                v8 = v23;
                v34 = v22;
                if(v23 < 8) {
                    v10 = 1;
                    LABEL_15:
                    v13 = sub_453394((int) &v19, v34, v8, v9, v10);
                    if(v13 < 0)
                        return 0;
                    v8 = v23;
                    v34 = v22;
                    v4 = v32;
                    goto LABEL_17;
                }
                v4 = v32;
            }
            v11 = (unsigned __int8) (v34 >> (v8 - 8));
            v12 = *(_DWORD*) (v9 + 4 * v11 + 212);
            if(!v12) {
                v10 = 9;
                goto LABEL_15;
            }
            v13 = *(unsigned __int8*) (v11 + v9 + 1236);
            v8 -= v12;
            LABEL_17:
            if(v13) {
                if(v8 < v13) {
                    if(!sub_4532AA(&v19, v34, v8, v13))
                        return 0;
                    v8 = v23;
                    v34 = v22;
                    v4 = v32;
                }
                v8 -= v13;
                v33 = (1 << v13) - 1;
                v14 = v13;
                v15 = (v34 >> v8) & v33;
                if(v15 >= dword_46F628 [v14])
                    v13 = (v34 >> v8) & v33;
                else
                    v13 = v15 + dword_46F668 [v14];
            }
            ++v30;
            v16 = &v26 [v29 + 1];
            *v16 += v13;
            v17 = *v16 << v28;
            ++v31;
            *v27 = v17;
        }
        while(v31 < a1 [79]);
    }
    *(_DWORD*) a1 [5] = v19;
    *(_DWORD*) (a1 [5] + 4) = v20;
    a1 [94] = v21;
    --v4 [13];
    v4 [4] = v34;
    v4 [5] = v8;
    qmemcpy(v4 + 8, v26, 0x14u);
    return 1;
}
// 46F628: using guessed type int dword_46F628[16];
// 46F668: using guessed type int dword_46F668[16];

//----- (00453C66) --------------------------------------------------------
char __cdecl sub_453C66(_DWORD* a1, int* a2) {
    bool v3; // zf
    _DWORD* v4; // esi
    int v5; // eax
    int v6; // eax
    int v7; // ebx
    int v8; // eax
    int v9; // ecx
    int v10; // ecx
    int v11; // edx
    int v12; // ecx
    int v13; // ecx
    int v14; // edx
    int v15; // ebx
    unsigned __int8* v17; // [esp+Ch] [ebp-44h] BYREF
    int v18; // [esp+10h] [ebp-40h]
    int v19; // [esp+14h] [ebp-3Ch]
    int v20; // [esp+18h] [ebp-38h]
    int v21; // [esp+24h] [ebp-2Ch]
    _DWORD* v22; // [esp+28h] [ebp-28h]
    _DWORD* v23; // [esp+2Ch] [ebp-24h]
    int v24; // [esp+34h] [ebp-1Ch]
    int v25; // [esp+38h] [ebp-18h]
    int v26; // [esp+3Ch] [ebp-14h]
    int v27; // [esp+40h] [ebp-10h]
    int v28; // [esp+44h] [ebp-Ch]
    int v29; // [esp+48h] [ebp-8h]
    int v30; // [esp+4Ch] [ebp-4h]
    int v31; // [esp+58h] [ebp+8h]
    int v32; // [esp+58h] [ebp+8h]
    int v33; // [esp+58h] [ebp+8h]
    int v34; // [esp+5Ch] [ebp+Ch]
    int v35; // [esp+5Ch] [ebp+Ch]

    v3 = a1 [63] == 0;
    v4 = (_DWORD*) a1 [101];
    v26 = a1 [91];
    v25 = a1 [93];
    if(!v3 && !v4 [13] && !sub_453A0E(a1))
        return 0;
    v30 = v4 [8];
    if(v30) {
        v5 = v30 - 1;
        goto LABEL_37;
    }
    v6 = a1 [5];
    v22 = a1;
    v17 = *(unsigned __int8**) v6;
    v18 = *(_DWORD*) (v6 + 4);
    v19 = a1 [94];
    v7 = v4 [4];
    v8 = v4 [5];
    v23 = v4 + 6;
    v24 = *a2;
    v27 = v4 [18];
    v9 = a1 [90];
    v29 = v7;
    v34 = v9;
    while(v9 <= v26) {
        if(v8 >= 8)
            goto LABEL_11;
        if(!sub_4532AA(&v17, v7, v8, 0))
            return 0;
        v8 = v21;
        v7 = v20;
        v29 = v20;
        if(v21 >= 8) {
            LABEL_11:
            v11 = (unsigned __int8) (v7 >> (v8 - 8));
            v12 = *(_DWORD*) (v27 + 4 * v11 + 212);
            if(v12) {
                v8 -= v12;
                v31 = *(unsigned __int8*) (v11 + v27 + 1236);
                goto LABEL_16;
            }
            v10 = 9;
        }
        else {
            v10 = 1;
        }
        v31 = sub_453394((int) &v17, v7, v8, v27, v10);
        if(v31 < 0)
            return 0;
        v7 = v20;
        v8 = v21;
        v29 = v20;
        LABEL_16:
        v13 = v31 >> 4;
        v3 = (v31 & 0xF) == 0;
        v32 = v31 & 0xF;
        v28 = v13;
        if(v3) {
            if(v13 != 15) {
                v33 = 1 << v13;
                v30 = 1 << v13;
                if(v28) {
                    if(v8 < v28) {
                        if(!sub_4532AA(&v17, v7, v8, v28))
                            return 0;
                        v7 = v20;
                        v8 = v21;
                    }
                    v8 -= v28;
                    v30 += (v33 - 1) & (v7 >> v8);
                }
                --v30;
                break;
            }
            v35 = v34 + 15;
        }
        else {
            v35 = v13 + v34;
            if(v8 < v32) {
                if(!sub_4532AA(&v17, v7, v8, v32))
                    return 0;
                v7 = v20;
                v8 = v21;
                v29 = v20;
            }
            v8 -= v32;
            v14 = (v7 >> v8) & ((1 << v32) - 1);
            if(v14 >= dword_46F628 [v32])
                v15 = (v7 >> v8) & ((1 << v32) - 1);
            else
                v15 = v14 + dword_46F668 [v32];
            *(_WORD*) (v24 + 2 * dword_46EA70 [v35]) = v15 << v25;
            v7 = v29;
        }
        v34 = v35 + 1;
        v9 = v34;
    }
    *(_DWORD*) a1 [5] = v17;
    *(_DWORD*) (a1 [5] + 4) = v18;
    a1 [94] = v19;
    v4 [5] = v8;
    v5 = v30;
    v4 [4] = v7;
    LABEL_37:
    --v4 [13];
    v4 [8] = v5;
    return 1;
}
// 46EA70: using guessed type int dword_46EA70[64];
// 46F628: using guessed type int dword_46F628[16];
// 46F668: using guessed type int dword_46F668[16];

//----- (00453E93) --------------------------------------------------------
char __cdecl sub_453E93(_DWORD* a1, int a2) {
    _DWORD* v3; // esi
    bool v4; // zf
    bool v5; // cc
    int v6; // eax
    int v7; // eax
    int v8; // ecx
    _WORD* v9; // ebx
    unsigned __int8* v11; // [esp+Ch] [ebp-2Ch] BYREF
    int v12; // [esp+10h] [ebp-28h]
    int v13; // [esp+14h] [ebp-24h]
    int v14; // [esp+18h] [ebp-20h]
    int v15; // [esp+24h] [ebp-14h]
    _DWORD* v16; // [esp+28h] [ebp-10h]
    _DWORD* v17; // [esp+2Ch] [ebp-Ch]
    int v18; // [esp+34h] [ebp-4h]
    int v19; // [esp+40h] [ebp+8h]

    v3 = (_DWORD*) a1 [101];
    v4 = a1 [63] == 0;
    v18 = 1 << a1 [93];
    if(!v4 && !v3 [13] && !sub_453A0E(a1))
        return 0;
    v5 = a1 [79] <= 0;
    v6 = a1 [5];
    v16 = a1;
    v11 = *(unsigned __int8**) v6;
    v12 = *(_DWORD*) (v6 + 4);
    v13 = a1 [94];
    v7 = v3 [4];
    v8 = v3 [5];
    v17 = v3 + 6;
    v19 = 0;
    if(!v5) {
        do {
            v9 = *(_WORD**) (a2 + 4 * v19);
            if(v8 < 1) {
                if(!sub_4532AA(&v11, v7, v8, 1))
                    return 0;
                v7 = v14;
                v8 = v15;
            }
            if(((v7 >> --v8) & 1) != 0)
                *v9 |= v18;
            ++v19;
        }
        while(v19 < a1 [79]);
    }
    *(_DWORD*) a1 [5] = v11;
    *(_DWORD*) (a1 [5] + 4) = v12;
    a1 [94] = v13;
    --v3 [13];
    v3 [4] = v7;
    v3 [5] = v8;
    return 1;
}

//----- (00453F75) --------------------------------------------------------
char __cdecl sub_453F75(_DWORD* a1, int* a2) {
    int v3; // ecx
    _DWORD* v4; // esi
    bool v5; // zf
    int v6; // eax
    int v7; // ebx
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    int v11; // eax
    int v12; // ecx
    int v13; // ecx
    int v14; // eax
    int v15; // ecx
    __int16* v16; // eax
    __int16 v17; // dx
    int v18; // eax
    int v19; // ecx
    int v20; // eax
    int i; // eax
    __int16* v22; // eax
    __int16 v23; // dx
    int j; // eax
    int v26; // ecx
    int v27 [65]; // [esp+8h] [ebp-154h]
    unsigned __int8* v28; // [esp+10Ch] [ebp-50h] BYREF
    int v29; // [esp+110h] [ebp-4Ch]
    int v30; // [esp+114h] [ebp-48h]
    int v31; // [esp+118h] [ebp-44h]
    int v32; // [esp+124h] [ebp-38h]
    _DWORD* v33; // [esp+128h] [ebp-34h]
    _DWORD* v34; // [esp+12Ch] [ebp-30h]
    int v35; // [esp+134h] [ebp-28h]
    int v36; // [esp+138h] [ebp-24h]
    __int16* v37; // [esp+13Ch] [ebp-20h]
    int v38; // [esp+140h] [ebp-1Ch]
    int v39; // [esp+144h] [ebp-18h]
    int v40; // [esp+148h] [ebp-14h]
    int v41; // [esp+14Ch] [ebp-10h]
    int v42; // [esp+150h] [ebp-Ch]
    int v43; // [esp+154h] [ebp-8h]
    int v44; // [esp+158h] [ebp-4h]
    int v45; // [esp+164h] [ebp+8h]
    int v46; // [esp+168h] [ebp+Ch]

    v3 = a1 [93];
    v4 = (_DWORD*) a1 [101];
    v42 = a1 [91];
    v36 = 1 << v3;
    v5 = a1 [63] == 0;
    v35 = -1 << v3;
    if(!v5 && !v4 [13] && !sub_453A0E(a1))
        return 0;
    v6 = a1 [5];
    v40 = 0;
    v33 = a1;
    v28 = *(unsigned __int8**) v6;
    v29 = *(_DWORD*) (v6 + 4);
    v30 = a1 [94];
    v7 = v4 [5];
    v45 = v4 [4];
    v34 = v4 + 6;
    v8 = v4 [8];
    v41 = *a2;
    v39 = v4 [18];
    v9 = a1 [90];
    v43 = v8;
    v46 = v9;
    if(v8) {
        LABEL_47:
        if(v43) {
            for(i = v46; i <= v42; i = ++v46) {
                v22 = (__int16*) (v41 + 2 * dword_46EA70 [i]);
                v5 = *v22 == 0;
                v37 = v22;
                if(!v5) {
                    if(v7 < 1) {
                        if(!sub_4532AA(&v28, v45, v7, 1))
                            goto LABEL_62;
                        v7 = v32;
                        v45 = v31;
                        v22 = v37;
                    }
                    if(((v45 >> --v7) & 1) != 0) {
                        v23 = v36;
                        if((*v22 & v36) == 0) {
                            if(*v22 < 0)
                                v23 = v35;
                            *v22 += v23;
                        }
                    }
                }
            }
            --v43;
        }
        LABEL_61:
        *(_DWORD*) a1 [5] = v28;
        *(_DWORD*) (a1 [5] + 4) = v29;
        a1 [94] = v30;
        --v4 [13];
        v4 [4] = v45;
        v4 [8] = v43;
        v4 [5] = v7;
        return 1;
    }
    while(1) {
        if(v9 > v42)
            goto LABEL_61;
        if(v7 >= 8)
            goto LABEL_10;
        if(!sub_4532AA(&v28, v45, v7, 0))
            goto LABEL_62;
        v7 = v32;
        v45 = v31;
        if(v32 >= 8) {
            LABEL_10:
            v11 = (unsigned __int8) (v45 >> (v7 - 8));
            v12 = *(_DWORD*) (v39 + 4 * v11 + 212);
            if(v12) {
                v7 -= v12;
                v44 = *(unsigned __int8*) (v11 + v39 + 1236);
                goto LABEL_15;
            }
            v10 = 9;
        }
        else {
            v10 = 1;
        }
        v44 = sub_453394((int) &v28, v45, v7, v39, v10);
        if(v44 < 0)
            goto LABEL_62;
        v7 = v32;
        v45 = v31;
        LABEL_15:
        v13 = v44 >> 4;
        v5 = (v44 & 0xF) == 0;
        v44 &= 0xFu;
        v38 = v13;
        if(v5)
            break;
        if(v44 != 1) {
            *(_DWORD*) (*a1 + 20) = 114;
            (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, -1);
        }
        if(v7 < 1) {
            if(!sub_4532AA(&v28, v45, v7, 1))
                goto LABEL_62;
            v7 = v32;
            v45 = v31;
        }
        --v7;
        v14 = v36;
        if(((v45 >> v7) & 1) == 0)
            v14 = v35;
        v44 = v14;
        LABEL_25:
        v15 = v46;
        do {
            v16 = (__int16*) (v41 + 2 * dword_46EA70 [v15]);
            v5 = *v16 == 0;
            v37 = v16;
            if(v5) {
                if(--v38 < 0)
                    break;
            }
            else {
                if(v7 < 1) {
                    if(!sub_4532AA(&v28, v45, v7, 1))
                        goto LABEL_62;
                    v7 = v32;
                    v45 = v31;
                    v16 = v37;
                }
                if(((v45 >> --v7) & 1) != 0) {
                    v17 = v36;
                    if((*v16 & v36) == 0) {
                        if(*v16 < 0)
                            v17 = v35;
                        *v16 += v17;
                    }
                }
            }
            v15 = ++v46;
        }
        while(v46 <= v42);
        if(v44) {
            v18 = dword_46EA70 [v15];
            *(_WORD*) (v41 + 2 * v18) = v44;
            v19 = v40++;
            v27 [v19 + 1] = v18;
        }
        v9 = ++v46;
    }
    if(v13 == 15)
        goto LABEL_25;
    v20 = 1 << v13;
    v39 = 1 << v13;
    v43 = 1 << v13;
    if(!v13)
        goto LABEL_47;
    if(v7 >= v13)
        goto LABEL_46;
    if(sub_4532AA(&v28, v45, v7, v13)) {
        v7 = v32;
        v45 = v31;
        v20 = v39;
        LABEL_46:
        v7 -= v38;
        v43 += (v20 - 1) & (v45 >> v7);
        goto LABEL_47;
    }
    LABEL_62:
    for(j = v40; j > 0; --j) {
        v26 = v27 [j];
        *(_WORD*) (v41 + 2 * v26) = 0;
    }
    return 0;
}
// 46EA70: using guessed type int dword_46EA70[64];

//----- (004542E3) --------------------------------------------------------
int __cdecl sub_4542E3(int* a1) {
    int v2; // eax
    int v3; // ebx
    char v4; // dl
    bool v5; // zf
    int v6; // ecx
    int v7; // eax
    int v8; // eax
    int* v9; // ebx
    int i; // edi
    int v11; // ecx
    int v12; // eax
    unsigned int v13; // edi
    unsigned int v14; // edi
    _DWORD* v15; // eax
    int result; // eax
    int v17; // [esp+10h] [ebp-10h]
    _DWORD* v18; // [esp+10h] [ebp-10h]
    _DWORD* v19; // [esp+14h] [ebp-Ch]
    int* v20; // [esp+14h] [ebp-Ch]
    int v21; // [esp+18h] [ebp-8h]
    int v22; // [esp+1Ch] [ebp-4h]
    int v23; // [esp+1Ch] [ebp-4h]
    bool v24; // [esp+2Bh] [ebp+Bh]

    v2 = a1 [90];
    v3 = a1 [101];
    v24 = v2 == 0;
    v4 = 0;
    v21 = v3;
    if(v2) {
        v6 = a1 [91];
        if(v2 > v6 || v6 >= 64)
            v4 = 1;
        v5 = a1 [72] == 1;
    }
    else {
        v5 = a1 [91] == 0;
    }
    if(!v5)
        v4 = 1;
    v7 = a1 [92];
    if(v7 && a1 [93] != v7 - 1)
        v4 = 1;
    if(a1 [93] > 13)
        v4 = 1;
    if(v4) {
        *(_DWORD*) (*a1 + 20) = 14;
        *(_DWORD*) (*a1 + 24) = a1 [90];
        *(_DWORD*) (*a1 + 28) = a1 [91];
        *(_DWORD*) (*a1 + 32) = a1 [92];
        *(_DWORD*) (*a1 + 36) = a1 [93];
        (*(void(__cdecl**)(int*)) * a1)(a1);
    }
    v22 = 0;
    if(a1 [72] > 0) {
        v19 = a1 + 73;
        do {
            v8 = *(_DWORD*) (*v19 + 4);
            v9 = (int*) (a1 [35] + (v8 << 8));
            v17 = v8;
            if(!v24 && *v9 < 0) {
                *(_DWORD*) (*a1 + 20) = 111;
                *(_DWORD*) (*a1 + 24) = v8;
                *(_DWORD*) (*a1 + 28) = 0;
                (*(void(__cdecl**)(int*, int))(*a1 + 4))(a1, -1);
                v8 = v17;
            }
            for(i = a1 [90]; i <= a1 [91]; ++i) {
                v11 = v9 [i];
                if(v11 < 0)
                    v11 = 0;
                if(a1 [92] != v11) {
                    *(_DWORD*) (*a1 + 20) = 111;
                    *(_DWORD*) (*a1 + 24) = v8;
                    *(_DWORD*) (*a1 + 28) = i;
                    (*(void(__cdecl**)(int*, int))(*a1 + 4))(a1, -1);
                    v8 = v17;
                }
                v9 [i] = a1 [93];
            }
            ++v22;
            ++v19;
        }
        while(v22 < a1 [72]);
        v3 = v21;
    }
    if(a1 [92]) {
        if(v24)
            *(_DWORD*) (v3 + 4) = sub_453E93;
        else
            *(_DWORD*) (v3 + 4) = sub_453F75;
    }
    else if(v24) {
        *(_DWORD*) (v3 + 4) = sub_453A69;
    }
    else {
        *(_DWORD*) (v3 + 4) = sub_453C66;
    }
    v23 = 0;
    if(a1 [72] > 0) {
        v18 = (_DWORD*) (v3 + 36);
        v20 = a1 + 73;
        while(1) {
            v12 = *v20;
            if(!v24)
                break;
            if(!a1 [92]) {
                v13 = *(_DWORD*) (v12 + 20);
                if(v13 > 3 || !a1 [v13 + 40]) {
                    *(_DWORD*) (*a1 + 20) = 49;
                    *(_DWORD*) (*a1 + 24) = v13;
                    (*(void(__cdecl**)(int*)) * a1)(a1);
                }
                sub_453107((int) a1, a1 [v13 + 40], v21 + 4 * v13 + 56);
                LABEL_49:
                v3 = v21;
            }
            v15 = v18;
            ++v23;
            ++v20;
            ++v18;
            *v15 = 0;
            if(v23 >= a1 [72])
                goto LABEL_51;
        }
        v14 = *(_DWORD*) (v12 + 24);
        if(v14 > 3 || !a1 [v14 + 44]) {
            *(_DWORD*) (*a1 + 20) = 49;
            *(_DWORD*) (*a1 + 24) = v14;
            (*(void(__cdecl**)(int*)) * a1)(a1);
        }
        sub_453107((int) a1, a1 [v14 + 44], v21 + 4 * v14 + 56);
        *(_DWORD*) (v21 + 72) = *(_DWORD*) (v21 + 4 * v14 + 56);
        goto LABEL_49;
    }
    LABEL_51:
    *(_BYTE*) (v3 + 24) = 0;
    *(_DWORD*) (v3 + 20) = 0;
    *(_DWORD*) (v3 + 16) = 0;
    *(_DWORD*) (v3 + 32) = 0;
    result = a1 [63];
    *(_DWORD*) (v3 + 52) = result;
    return result;
}

//----- (00454586) --------------------------------------------------------
int __cdecl sub_454586(int a1) {
    int(__cdecl * *v1)(int*); // eax
    int result; // eax
    int v3; // edx
    bool v4; // cc
    char* v5; // ebx
    void* v6; // edi

    v1 = (int(__cdecl**)(int*))(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 80);
    *(_DWORD*) (a1 + 404) = v1;
    *v1 = sub_4542E3;
    v1 [14] = 0;
    v1 [15] = 0;
    v1 [16] = 0;
    v1 [17] = 0;
    result = (**(int(__cdecl***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD*) (a1 + 32) << 8);
    v3 = 0;
    v4 = *(_DWORD*) (a1 + 32) <= 0;
    *(_DWORD*) (a1 + 140) = result;
    v5 = (char*) result;
    if(!v4) {
        do {
            result = -1;
            v6 = v5;
            v5 += 256;
            ++v3;
            memset(v6, 0xFFu, 0x100u);
        }
        while(v3 < *(_DWORD*) (a1 + 32));
    }
    return result;
}

//----- (004545E7) --------------------------------------------------------
int __cdecl sub_4545E7(_DWORD* a1) {
    bool v2; // cc
    int result; // eax
    int v4; // edi
    int* v5; // ebx
    int v6; // edi
    int v7; // eax
    int v8; // eax
    int v9; // edx
    int v10; // edx
    int v11; // eax
    double* v12; // ecx
    double v13; // st7
    __int16* v14; // eax
    int v15; // edx
    _WORD* v16; // eax
    int v17; // ecx
    int v18; // edx
    int v19; // [esp+Ch] [ebp-14h]
    int i; // [esp+10h] [ebp-10h]
    int v21; // [esp+14h] [ebp-Ch]
    double* v22; // [esp+18h] [ebp-8h]
    int v23; // [esp+18h] [ebp-8h]
    int v24; // [esp+1Ch] [ebp-4h]
    void* v25; // [esp+28h] [ebp+8h]

    v2 = a1 [8] <= 0;
    result = a1 [102];
    v4 = a1 [49];
    v24 = 0;
    v25 = 0;
    v21 = 0;
    if(!v2) {
        v5 = (int*) (result + 44);
        v6 = v4 + 36;
        for(i = result + 44; ; i += 4) {
            if(*(_DWORD*) v6 == 1) {
                v25 = sub_458765;
                goto LABEL_19;
            }
            if(*(_DWORD*) v6 == 2) {
                v25 = sub_4585A7;
                goto LABEL_19;
            }
            if(*(_DWORD*) v6 == 4)
                break;
            if(*(_DWORD*) v6 != 8) {
                *(_DWORD*) (*a1 + 20) = 6;
                *(_DWORD*) (*a1 + 24) = *(_DWORD*) v6;
                LABEL_12:
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
                goto LABEL_20;
            }
            v7 = a1 [17];
            if(!v7) {
                v25 = sub_4587A2;
                LABEL_19:
                v24 = 0;
                goto LABEL_20;
            }
            v8 = v7 - 1;
            if(v8) {
                if(v8 != 1) {
                    *(_DWORD*) (*a1 + 20) = 47;
                    goto LABEL_12;
                }
                v25 = sub_45883A;
                v24 = 2;
            }
            else {
                v25 = sub_4587EE;
                v24 = 1;
            }
            LABEL_20:
            *(v5 - 10) = (int) v25;
            if(*(_BYTE*) (v6 + 12)) {
                if(*v5 != v24) {
                    v9 = *(_DWORD*) (v6 + 40);
                    v19 = v9;
                    if(v9) {
                        *v5 = v24;
                        if(v24) {
                            if(v24 == 1) {
                                v14 = (__int16*) &unk_46F6A8;
                                v15 = v9 - (_DWORD) &unk_46F6A8;
                                v23 = *(_DWORD*) (v6 + 44) - (_DWORD) &unk_46F6A8;
                                do {
                                    *(__int16*) ((char*) v14 + v23) = (*v14 * *(__int16*) ((char*) v14 + v15) + 2048) >> 12;
                                    ++v14;
                                }
                                while((int) v14 < (int) &unk_46F728);
                            }
                            else {
                                v10 = *(_DWORD*) (v6 + 44);
                                v11 = 0;
                                v22 = (double*) &unk_46F728;
                                do {
                                    v12 = (double*) &unk_46F728;
                                    do {
                                        v13 = (double) *(unsigned __int16*) (v19 + 2 * v11) * *v12++;
                                        *(float*) (v10 + 4 * v11++) = v13 * *v22;
                                    }
                                    while((int) v12 < (int) &unk_46F768);
                                    ++v22;
                                }
                                while((int) v22 < (int) &unk_46F768);
                            }
                        }
                        else {
                            v16 = *(_WORD**) (v6 + 44);
                            v17 = v9 - (_DWORD) v16;
                            v18 = 64;
                            do {
                                *v16 = *(_WORD*) ((char*) v16 + v17);
                                ++v16;
                                --v18;
                            }
                            while(v18);
                        }
                    }
                }
            }
            result = ++v21;
            v5 = (int*) (i + 4);
            v6 += 84;
            if(v21 >= a1 [8])
                return result;
        }
        v25 = sub_458292;
        goto LABEL_19;
    }
    return result;
}
// 4546DD: conditional instruction was optimized away because %var_4.4==2

//----- (0045479E) --------------------------------------------------------
_DWORD* __cdecl sub_45479E(int a1) {
    _DWORD* result; // eax
    _DWORD* v3; // ebx
    void* v4; // edi
    _DWORD* v5; // eax
    int v6; // [esp+4h] [ebp-4h]
    int v7; // [esp+10h] [ebp+8h]

    result = (_DWORD*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 84);
    v6 = 0;
    *(_DWORD*) (a1 + 408) = result;
    *result = sub_4545E7;
    if(*(int*) (a1 + 32) > 0) {
        v7 = *(_DWORD*) (a1 + 196) + 80;
        v3 = result + 11;
        do {
            v4 = (void*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 256);
            v5 = (_DWORD*) v7;
            v7 += 84;
            *v5 = v4;
            memset(v4, 0, 0x100u);
            *v3 = -1;
            result = (_DWORD*)++v6;
            ++v3;
        }
        while(v6 < *(_DWORD*) (a1 + 32));
    }
    return result;
}

//----- (00454812) --------------------------------------------------------
int __cdecl sub_454812(int a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7) {
    int v7; // ebx
    int v8; // esi
    _DWORD* v9; // edi
    unsigned int v10; // eax
    int result; // eax

    v7 = a1;
    v8 = *(_DWORD*) (a1 + 392);
    v9 = a6;
    v10 = a7 - *a6;
    if(v10 > *(_DWORD*) (v8 + 16))
        v10 = *(_DWORD*) (v8 + 16);
    a1 = 0;
    (*(void(__cdecl**)(int, int, int, int, _DWORD, int*, unsigned int))(*(_DWORD*) (v7 + 412) + 4))(
        v7,
        a2,
        a3,
        a4,
        *(_DWORD*) (v8 + 12),
        &a1,
        v10);
    (*(void(__cdecl**)(int, _DWORD, int, int))(*(_DWORD*) (v7 + 420) + 4))(v7, *(_DWORD*) (v8 + 12), a5 + 4 * *v9, a1);
    result = a1;
    *v9 += a1;
    return result;
}

//----- (00454877) --------------------------------------------------------
unsigned int __cdecl sub_454877(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6) {
    _DWORD* v7; // esi
    unsigned int* v8; // edi
    unsigned int v9; // ecx
    unsigned int result; // eax
    unsigned int v11; // [esp+14h] [ebp+8h]
    unsigned int v12; // [esp+14h] [ebp+8h]

    v7 = (_DWORD*) a1 [98];
    v8 = v7 + 6;
    if(!v7 [6])
        v7 [3] = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, _DWORD, int))(a1 [1] + 28))(a1, v7 [2], v7 [5], v7 [4], 1);
    v11 = *v8;
    (*(void(__cdecl**)(_DWORD*, int, int, int, _DWORD, _DWORD*, _DWORD))(a1 [103] + 4))(
        a1,
        a2,
        a3,
        a4,
        v7 [3],
        v7 + 6,
        v7 [4]);
    v9 = v11;
    if(*v8 > v11) {
        v12 = *v8 - v11;
        (*(void(__cdecl**)(_DWORD*, unsigned int, _DWORD, unsigned int))(a1 [105] + 4))(a1, v7 [3] + 4 * v9, 0, v12);
        *a6 += v12;
    }
    result = v7 [4];
    if(*v8 >= result) {
        v7 [5] += result;
        *v8 = 0;
    }
    return result;
}

//----- (00454907) --------------------------------------------------------
unsigned int __cdecl sub_454907(_DWORD* a1, int a2, int a3, int a4, int a5, _DWORD* a6, int a7) {
    _DWORD* v7; // esi
    unsigned int v8; // edi
    unsigned int result; // eax

    v7 = (_DWORD*) a1 [98];
    if(!v7 [6])
        v7 [3] = (*(int(__cdecl**)(_DWORD*, _DWORD, _DWORD, _DWORD, _DWORD))(a1 [1] + 28))(a1, v7 [2], v7 [5], v7 [4], 0);
    v8 = v7 [4] - v7 [6];
    if(v8 > a7 - *a6)
        v8 = a7 - *a6;
    if(v8 > a1 [24] - v7 [5])
        v8 = a1 [24] - v7 [5];
    (*(void(__cdecl**)(_DWORD*, int, int, unsigned int))(a1 [105] + 4))(a1, v7 [3] + 4 * v7 [6], a5 + 4 * *a6, v8);
    *a6 += v8;
    v7 [6] += v8;
    result = v7 [4];
    if(v7 [6] >= result) {
        v7 [5] += result;
        v7 [6] = 0;
    }
    return result;
}

//----- (00454993) --------------------------------------------------------
int __cdecl sub_454993(int a1, int a2) {
    int result; // eax
    _DWORD* v3; // esi
    bool v4; // zf

    result = a1;
    v3 = *(_DWORD**) (a1 + 392);
    if(a2) {
        if(a2 == 2) {
            if(!v3 [2]) {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 4;
                result = (**(int(__cdecl***)(int))a1)(a1);
            }
            v3 [1] = sub_454907;
        }
        else if(a2 == 3) {
            if(!v3 [2]) {
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 4;
                result = (**(int(__cdecl***)(int))a1)(a1);
            }
            v3 [1] = sub_454877;
        }
        else {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 4;
            result = (**(int(__cdecl***)(int))a1)(a1);
        }
    }
    else if(*(_BYTE*) (a1 + 74)) {
        v4 = v3 [3] == 0;
        v3 [1] = sub_454812;
        if(v4) {
            result = (*(int(__cdecl**)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD*) (a1 + 4) + 28))(a1, v3 [2], 0, v3 [4], 1);
            v3 [3] = result;
        }
    }
    else {
        result = *(_DWORD*) (*(_DWORD*) (a1 + 412) + 4);
        v3 [1] = result;
    }
    v3 [6] = 0;
    v3 [5] = 0;
    return result;
}

//----- (00454A39) --------------------------------------------------------
int(__cdecl** __cdecl sub_454A39(int a1, char a2))(int a1, int a2) {
    int(__cdecl * *result)(int, int); // eax
    int(__cdecl * *v3)(int, int); // edi
    int v4; // eax
    int v5; // ebp
    int v6; // eax
    int v7; // [esp-8h] [ebp-14h]

    result = (int(__cdecl**)(int, int))(**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 28);
    v3 = result;
    *(_DWORD*) (a1 + 392) = result;
    *result = sub_454993;
    result [2] = 0;
    result [3] = 0;
    if(*(_BYTE*) (a1 + 74)) {
        v4 = *(_DWORD*) (a1 + 272);
        v3 [4] = (int(__cdecl*)(int, int))v4;
        if(a2) {
            v5 = *(_DWORD*) (a1 + 4);
            v7 = v4;
            v6 = sub_44EE1D(*(_DWORD*) (a1 + 96), v4);
            result = (int(__cdecl**)(int, int))(*(int(__cdecl**)(int, int, _DWORD, int, int, int))(v5 + 16))(
                a1,
                1,
                0,
                *(_DWORD*) (a1 + 92) * *(_DWORD*) (a1 + 100),
                v6,
                v7);
            v3 [2] = (int(__cdecl*)(int, int))result;
        }
        else {
            result = (int(__cdecl**)(int, int))(*(int(__cdecl**)(int, int, int, int))(*(_DWORD*) (a1 + 4) + 8))(
                a1,
                1,
                *(_DWORD*) (a1 + 92) * *(_DWORD*) (a1 + 100),
                v4);
            v3 [3] = (int(__cdecl*)(int, int))result;
        }
    }
    return result;
}

//----- (00454ABC) --------------------------------------------------------
int __cdecl sub_454ABC(_DWORD* a1) {
    int v1; // ecx
    int result; // eax

    v1 = a1 [103];
    *(_DWORD*) (v1 + 92) = a1 [68];
    result = a1 [24];
    *(_DWORD*) (v1 + 96) = result;
    return result;
}

//----- (00454AD6) --------------------------------------------------------
_DWORD* __cdecl sub_454AD6(_DWORD* a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6, int a7) {
    int v8; // esi
    int v9; // edi
    unsigned int v10; // edi
    _DWORD* result; // eax
    int v12; // [esp+Ch] [ebp-4h]
    int v13; // [esp+18h] [ebp+8h]
    unsigned int v14; // [esp+30h] [ebp+20h]

    v8 = a1 [103];
    if(*(_DWORD*) (v8 + 92) >= a1 [68]) {
        v13 = 0;
        v12 = a1 [49];
        if((int) a1 [8] > 0) {
            v9 = v8 + 12;
            do {
                (*(void(__cdecl**)(_DWORD*, int, int, int))(v9 + 40))(
                    a1,
                    v12,
                    *(_DWORD*) (a2 + 4 * v13) + 4 * *a3 * *(_DWORD*) (v9 + 88),
                    v9);
                v12 += 84;
                ++v13;
                v9 += 4;
            }
            while(v13 < a1 [8]);
        }
        *(_DWORD*) (v8 + 92) = 0;
    }
    v10 = a1 [68] - *(_DWORD*) (v8 + 92);
    if(v10 > *(_DWORD*) (v8 + 96))
        v10 = *(_DWORD*) (v8 + 96);
    v14 = a7 - *a6;
    if(v10 > v14)
        v10 = v14;
    (*(void(__cdecl**)(_DWORD*, int, _DWORD, int, unsigned int))(a1 [104] + 4))(
        a1,
        v8 + 12,
        *(_DWORD*) (v8 + 92),
        a5 + 4 * *a6,
        v10);
    result = a6;
    *a6 += v10;
    *(_DWORD*) (v8 + 96) -= v10;
    *(_DWORD*) (v8 + 92) += v10;
    if(*(_DWORD*) (v8 + 92) >= a1 [68]) {
        result = a3;
        ++* a3;
    }
    return result;
}

//----- (00454B9C) --------------------------------------------------------
_DWORD* __cdecl sub_454B9C(int a1, int a2, int a3, _DWORD* a4) {
    _DWORD* result; // eax

    result = a4;
    *a4 = a3;
    return result;
}

//----- (00454BA7) --------------------------------------------------------
_DWORD* __cdecl sub_454BA7(int a1, int a2, int a3, _DWORD* a4) {
    _DWORD* result; // eax

    result = a4;
    *a4 = 0;
    return result;
}

//----- (00454BAF) --------------------------------------------------------
const void** __cdecl sub_454BAF(unsigned int* a1, int a2, char** a3, int* a4) {
    int v4; // ebx
    int v6; // eax
    int v7; // ecx
    const void** result; // eax
    int v9; // edi
    char* v10; // edx
    char* v11; // eax
    unsigned int v12; // ecx
    char v13; // al
    int v14; // eax
    unsigned int v15; // [esp+Ch] [ebp-10h]
    int v16; // [esp+10h] [ebp-Ch]
    int i; // [esp+14h] [ebp-8h]
    int v18; // [esp+18h] [ebp-4h]
    char* v19; // [esp+24h] [ebp+8h]
    int v21; // [esp+30h] [ebp+14h]

    v4 = *a4;
    v6 = *(_DWORD*) (a2 + 4) + a1 [103];
    v7 = *(unsigned __int8*) (v6 + 140);
    result = (const void**) *(unsigned __int8*) (v6 + 150);
    v9 = 0;
    v16 = *a4;
    v21 = v7;
    v18 = (int) result;
    for(i = 0; v9 < (int) a1 [68]; i = v9) {
        v10 = *a3;
        v11 = *(char**) (v4 + 4 * v9);
        v12 = (unsigned int) &v11 [a1 [23]];
        v19 = v11;
        v15 = v12;
        while((unsigned int) v19 < v12) {
            v13 = *v10++;
            if(v21 > 0) {
                LOBYTE(v4) = v13;
                BYTE1(v4) = v13;
                v14 = v4 << 16;
                LOWORD(v14) = v4;
                v4 = v16;
                memset32(v19, v14, (unsigned int) v21 >> 2);
                memset(&v19 [4 * ((unsigned int) v21 >> 2)], v14, v21 & 3);
                v9 = i;
                v12 = v15;
                v19 += v21;
            }
        }
        result = (const void**) v18;
        if(v18 > 1)
            result = sub_44EE35(v4, v9, v4, v9 + 1, v18 - 1, a1 [23]);
        v9 += v18;
        ++a3;
    }
    return result;
}

//----- (00454C8E) --------------------------------------------------------
_BYTE*** __cdecl sub_454C8E(int a1, int a2, int a3, _BYTE*** a4) {
    _BYTE*** result; // eax
    _BYTE** v6; // esi
    int v7; // edx
    _BYTE* v8; // eax
    char* v9; // edi
    unsigned int v10; // ecx
    char v11; // dl
    _BYTE* v12; // eax
    int v13; // [esp+10h] [ebp+8h]
    int v14; // [esp+1Ch] [ebp+14h]

    result = a4;
    v14 = 0;
    v6 = *result;
    if(*(int*) (a1 + 272) > 0) {
        v7 = a3 - (_DWORD) v6;
        v13 = a3 - (_DWORD) v6;
        do {
            v8 = *v6;
            v9 = *(_BYTE**) ((char*) v6 + v7);
            v10 = (unsigned int) &(*v6) [*(_DWORD*) (a1 + 92)];
            if((unsigned int) *v6 < v10) {
                do {
                    v11 = *v9++;
                    *v8 = v11;
                    v12 = v8 + 1;
                    *v12 = v11;
                    v8 = v12 + 1;
                }
                while((unsigned int) v8 < v10);
                v7 = v13;
            }
            result = (_BYTE***)++v14;
            ++v6;
        }
        while(v14 < *(_DWORD*) (a1 + 272));
    }
    return result;
}

//----- (00454CE5) --------------------------------------------------------
const void** __cdecl sub_454CE5(int a1, int a2, char** a3, int* a4) {
    const void** result; // eax
    int v5; // ebx
    int v6; // esi
    char* v7; // edx
    _BYTE* v8; // ecx
    _BYTE* v9; // eax
    char v10; // bl
    _BYTE* v11; // ecx
    int i; // [esp+Ch] [ebp-4h]

    result = (const void**) a4;
    v5 = *a4;
    v6 = 0;
    for(i = *a4; v6 < *(_DWORD*) (a1 + 272); v6 += 2) {
        v7 = *a3;
        v8 = *(_BYTE**) (v5 + 4 * v6);
        v9 = &v8 [*(_DWORD*) (a1 + 92)];
        if(v8 < v9) {
            do {
                v10 = *v7++;
                *v8 = v10;
                v11 = v8 + 1;
                *v11 = v10;
                v8 = v11 + 1;
            }
            while(v8 < v9);
            v5 = i;
        }
        result = sub_44EE35(v5, v6, v5, v6 + 1, 1, *(_DWORD*) (a1 + 92));
        ++a3;
    }
    return result;
}

//----- (00454D4F) --------------------------------------------------------
int __cdecl sub_454D4F(int a1, int a2, int a3, _BYTE*** a4) {
    _BYTE** v5; // esi
    int result; // eax
    int v7; // ebx
    unsigned __int8* v8; // eax
    int v9; // edx
    _BYTE* v10; // ecx
    unsigned __int8* v11; // eax
    _BYTE* v12; // ecx
    int v13; // edi
    int v14; // edx
    _BYTE* v15; // ecx
    int v16; // edx
    int v17; // [esp+14h] [ebp+10h]
    int v18; // [esp+18h] [ebp+14h]

    v18 = 0;
    v5 = *a4;
    result = a1;
    if(*(int*) (a1 + 272) > 0) {
        v7 = a3 - (_DWORD) v5;
        do {
            v8 = *(_BYTE**) ((char*) v5 + v7);
            v9 = *v8;
            v10 = *v5;
            *v10 = v9;
            v11 = v8 + 1;
            *++v10 = (3 * v9 + *v11 + 2) >> 2;
            v12 = v10 + 1;
            if(*(_DWORD*) (a2 + 40) != 2) {
                v17 = *(_DWORD*) (a2 + 40) - 2;
                do {
                    v13 = *v11;
                    v14 = *(v11++ - 1);
                    v13 *= 3;
                    *v12 = (v14 + v13 + 1) >> 2;
                    v15 = v12 + 1;
                    *v15 = (*v11 + v13 + 2) >> 2;
                    v12 = v15 + 1;
                    --v17;
                }
                while(v17);
            }
            v16 = *v11;
            ++v18;
            *v12 = (*(v11 - 1) + 3 * v16 + 1) >> 2;
            result = a1;
            v12 [1] = v16;
            ++v5;
        }
        while(v18 < *(_DWORD*) (a1 + 272));
    }
    return result;
}

//----- (00454DF2) --------------------------------------------------------
unsigned __int8** __cdecl sub_454DF2(unsigned __int8** a1, int a2, unsigned __int8** a3, int* a4) {
    unsigned __int8** result; // eax
    unsigned __int8* v5; // edx
    unsigned __int8* v6; // edi
    _BYTE* v7; // esi
    int v8; // ecx
    unsigned __int8* v9; // edi
    unsigned __int8* v10; // edx
    int v11; // eax
    unsigned __int8* v12; // edi
    unsigned __int8* v13; // edx
    _BYTE* v14; // esi
    _BYTE* v15; // esi
    bool v16; // zf
    int v17; // [esp+0h] [ebp-10h]
    int v18; // [esp+4h] [ebp-Ch]
    unsigned __int8** v19; // [esp+8h] [ebp-8h]
    int v20; // [esp+Ch] [ebp-4h]
    int v21; // [esp+20h] [ebp+10h]
    int v22; // [esp+24h] [ebp+14h]

    v20 = 0;
    v17 = *a4;
    result = a1;
    if((int) a1 [68] > 0) {
        result = a3;
        v19 = a3;
        do {
            v22 = 0;
            do {
                v5 = *result;
                if(v22)
                    v6 = result [1];
                else
                    v6 = *(result - 1);
                v7 = *(_BYTE**) (v17 + 4 * v20++);
                v8 = *v6 + 3 * *v5;
                v9 = v6 + 1;
                v10 = v5 + 1;
                v11 = *v9 + 3 * *v10;
                *v7 = (4 * v8 + 8) >> 4;
                v12 = v9 + 1;
                v13 = v10 + 1;
                *++v7 = (v8 + v11 + 2 * v8 + 7) >> 4;
                v14 = v7 + 1;
                v21 = v11;
                if(*(_DWORD*) (a2 + 40) != 2) {
                    v18 = *(_DWORD*) (a2 + 40) - 2;
                    do {
                        v11 = *v12 + 3 * *v13;
                        *v14 = (3 * v21 + v8 + 8) >> 4;
                        ++v12;
                        ++v13;
                        v15 = v14 + 1;
                        *v15 = (3 * v21 + v11 + 7) >> 4;
                        v8 = v21;
                        v14 = v15 + 1;
                        v16 = v18-- == 1;
                        v21 = v11;
                    }
                    while(!v16);
                }
                ++v22;
                *v14 = (v11 + v8 + 2 * v11 + 8) >> 4;
                v14 [1] = (4 * v11 + 7) >> 4;
                result = v19;
            }
            while(v22 < 2);
            result = ++v19;
        }
        while(v20 < (int) a1 [68]);
    }
    return result;
}

//----- (00454EF9) --------------------------------------------------------
int __cdecl sub_454EF9(int a1) {
    int result; // eax
    int v3; // ebx
    _DWORD* v4; // ecx
    int v5; // edi
    int v6; // ebx
    int v7; // eax
    int v8; // edx
    int v9; // ebx
    int v10; // eax
    int v11; // eax
    int v12; // [esp-4h] [ebp-28h]
    _DWORD* v13; // [esp+10h] [ebp-14h]
    int v14; // [esp+14h] [ebp-10h]
    int v15; // [esp+18h] [ebp-Ch]
    int v16; // [esp+1Ch] [ebp-8h]
    int v17; // [esp+20h] [ebp-4h]
    bool v18; // [esp+2Fh] [ebp+Bh]

    result = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 160);
    v3 = result;
    *(_DWORD*) (a1 + 412) = result;
    *(_BYTE*) (result + 8) = 0;
    *(_DWORD*) result = sub_454ABC;
    *(_DWORD*) (result + 4) = sub_454AD6;
    v14 = result;
    if(*(_BYTE*) (a1 + 264)) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 23;
        result = (**(int(__cdecl***)(int))a1)(a1);
    }
    v18 = *(_BYTE*) (a1 + 72) && *(int*) (a1 + 276) > 1;
    v16 = 0;
    if(*(int*) (a1 + 32) > 0) {
        v4 = (_DWORD*) (v3 + 52);
        v5 = *(_DWORD*) (a1 + 196) + 36;
        v13 = (_DWORD*) (v3 + 52);
        do {
            v6 = *(_DWORD*) (a1 + 276);
            v15 = *(_DWORD*) v5 * *(_DWORD*) (v5 - 28) / v6;
            v7 = *(_DWORD*) v5 * *(_DWORD*) (v5 - 24) / v6;
            v8 = *(_DWORD*) (a1 + 268);
            v17 = *(_DWORD*) (a1 + 272);
            v4 [12] = v7;
            if(*(_BYTE*) (v5 + 12)) {
                if(v15 != v8 || v7 != v17) {
                    if(2 * v15 == v8) {
                        if(v7 == v17) {
                            if(v18 && *(_DWORD*) (v5 + 4) > 2u)
                                *v4 = sub_454D4F;
                            else
                                *v4 = sub_454C8E;
                            LABEL_30:
                            v12 = *(_DWORD*) (a1 + 272);
                            v9 = *(_DWORD*) (a1 + 4);
                            v10 = sub_44EE1D(*(_DWORD*) (a1 + 92), *(_DWORD*) (a1 + 268));
                            v11 = (*(int(__cdecl**)(int, int, int, int))(v9 + 8))(a1, 1, v10, v12);
                            v4 = v13;
                            *(v13 - 10) = v11;
                            goto LABEL_31;
                        }
                        if(2 * v15 == v8 && 2 * v7 == v17) {
                            if(v18 && *(_DWORD*) (v5 + 4) > 2u) {
                                *v4 = sub_454DF2;
                                *(_BYTE*) (v14 + 8) = 1;
                            }
                            else {
                                *v4 = sub_454CE5;
                            }
                            goto LABEL_30;
                        }
                    }
                    if(v8 % v15 || v17 % v7) {
                        *(_DWORD*) (*(_DWORD*) a1 + 20) = 37;
                        (**(void(__cdecl***)(int))a1)(a1);
                    }
                    else {
                        *v4 = sub_454BAF;
                        *(_BYTE*) (v16 + v14 + 140) = v8 / v15;
                        *(_BYTE*) (v16 + v14 + 150) = v17 / v7;
                    }
                    goto LABEL_30;
                }
                *v4 = sub_454B9C;
            }
            else {
                *v4 = sub_454BA7;
            }
            LABEL_31:
            result = ++v16;
            ++v4;
            v5 += 84;
            v13 = v4;
        }
        while(v16 < *(_DWORD*) (a1 + 32));
    }
    return result;
}

//----- (004550BA) --------------------------------------------------------
int __usercall sub_4550BA(int a1) {
    _DWORD* v2; // esi
    int result; // eax
    char* v4; // edx
    int i; // ecx
    int v6; // edi
    int v7; // edi
    int v8; // [esp+Ch] [ebp-8h]
    int v9; // [esp+10h] [ebp-4h]

    v2 = *(_DWORD**) (a1 + 416);
    v2 [2] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [3] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [4] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [5] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    result = 0;
    v4 = (char*) &unk_5B6900;
    v8 = -14831872;
    v9 = -11728000;
    for(i = 2919680; i >= -2831590; i -= 22554) {
        v6 = v9;
        v9 += 91881;
        *(_DWORD*) (result + v2 [2]) = v6 >> 16;
        v7 = v8;
        v8 += 116130;
        *(_DWORD*) (result + v2 [3]) = v7 >> 16;
        *(_DWORD*) (result + v2 [4]) = v4;
        *(_DWORD*) (result + v2 [5]) = i;
        v4 -= 46802;
        result += 4;
    }
    return result;
}

//----- (0045516A) --------------------------------------------------------
_BYTE* __cdecl sub_45516A(int a1, int a2, int a3, _DWORD* a4, _BYTE* a5) {
    int v5; // ebx
    _BYTE* result; // eax
    int v8; // edi
    int i; // esi
    _BYTE* v10; // ecx
    int v11; // [esp+4h] [ebp-4h]
    int v12; // [esp+10h] [ebp+8h]
    _BYTE* v13; // [esp+18h] [ebp+10h]
    int v14; // [esp+20h] [ebp+18h]

    v5 = *(_DWORD*) (a1 + 92);
    result = a5 - 1;
    v12 = *(_DWORD*) (a1 + 32);
    v11 = v5;
    if((int) (a5 - 1) >= 0) {
        v8 = 4 * a3;
        result = a5;
        v13 = a5;
        do {
            for(i = 0; i < v12; ++i) {
                v10 = *(_BYTE**) (v8 + *(_DWORD*) (a2 + 4 * i));
                result = (_BYTE*) (i + *a4);
                if(v5) {
                    v14 = v5;
                    do {
                        *result = *v10;
                        result += v12;
                        ++v10;
                        --v14;
                    }
                    while(v14);
                    v5 = v11;
                }
            }
            v8 += 4;
            ++a4;
            --v13;
        }
        while(v13);
    }
    return result;
}

//----- (004551D4) --------------------------------------------------------
const void** __cdecl sub_4551D4(int a1, int* a2, int a3, int a4, int a5) {
    return sub_44EE35(*a2, a3, a4, 0, a5, *(_DWORD*) (a1 + 92));
}

//----- (004551F7) --------------------------------------------------------
_BYTE* __cdecl sub_4551F7(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4, int a5) {
    _DWORD* v5; // eax
    int v6; // edi
    int v7; // ecx
    _BYTE* result; // eax
    int v9; // edx
    _DWORD* v10; // esi
    unsigned __int8* v11; // ecx
    _BYTE** v12; // eax
    int v13; // ebx
    int v14; // esi
    int v15; // esi
    int v16; // edi
    int v17; // [esp+8h] [ebp-24h]
    int v18; // [esp+Ch] [ebp-20h]
    int v19; // [esp+10h] [ebp-1Ch]
    int v20; // [esp+14h] [ebp-18h]
    int v21; // [esp+18h] [ebp-14h]
    int v22; // [esp+1Ch] [ebp-10h]
    int v23; // [esp+20h] [ebp-Ch]
    int v24; // [esp+24h] [ebp-8h]
    int v25; // [esp+24h] [ebp-8h]
    int v26; // [esp+28h] [ebp-4h]
    int v27; // [esp+34h] [ebp+8h]
    int v28; // [esp+3Ch] [ebp+10h]
    int v29; // [esp+3Ch] [ebp+10h]
    int v30; // [esp+44h] [ebp+18h]
    int v31; // [esp+44h] [ebp+18h]

    v5 = (_DWORD*) a1 [104];
    v6 = a1 [23];
    v27 = a1 [71];
    v21 = v5 [2];
    v18 = v5 [3];
    v7 = v5 [4];
    v20 = v5 [5];
    result = (_BYTE*) (a5 - 1);
    v17 = v6;
    v19 = v7;
    if(a5 - 1 >= 0) {
        v9 = 4 * a3;
        v10 = a2;
        v26 = a5;
        do {
            v30 = *(_DWORD*) (v9 + *v10);
            v11 = *(unsigned __int8**) (v9 + v10 [1]);
            v28 = *(_DWORD*) (v9 + v10 [2]);
            v24 = *(_DWORD*) (v9 + v10 [3]);
            v12 = a4++;
            result = *v12;
            v9 += 4;
            if(v6) {
                v13 = v30 - (_DWORD) v11;
                v14 = v28 - (_DWORD) v11;
                v23 = v30 - (_DWORD) v11;
                v22 = v28 - (_DWORD) v11;
                v25 = v24 - (_DWORD) v11;
                v29 = v6;
                while(1) {
                    v31 = v11 [v13];
                    v15 = 4 * v11 [v14];
                    v16 = 4 * *v11;
                    *result = *(_BYTE*) (v27 - *(_DWORD*) (v15 + v21) - v31 + 255);
                    result += 4;
                    *(result - 3) = *(_BYTE*) (v27 - ((*(_DWORD*) (v15 + v19) + *(_DWORD*) (v16 + v20)) >> 16) - v31 + 255);
                    *(result - 2) = *(_BYTE*) (v27 - *(_DWORD*) (v16 + v18) - v31 + 255);
                    *(result - 1) = (v11++) [v25];
                    if(!--v29)
                        break;
                    v13 = v23;
                    v14 = v22;
                }
                v6 = v17;
                v10 = a2;
            }
            --v26;
        }
        while(v26);
    }
    return result;
}

//----- (00455329) --------------------------------------------------------
unsigned int* __cdecl sub_455329(unsigned int a1, unsigned int* a2, unsigned int* a3, unsigned int* a4, int a5) {
    unsigned int* result; // eax
    unsigned int v8; // edi
    __m64 v10; // mm0
    __m64 v11; // mm3
    __m64 v12; // mm4
    __m64 v13; // mm6
    __m64 v14; // mm2
    __m64 v15; // mm5
    __m64 v16; // mm6
    __m64 v17; // mm7
    __m64 v18; // mm1
    __m64 v19; // mm0
    __m64 v20; // mm1
    __m64 v21; // mm4
    __m64 v22; // mm0
    __m64 v23; // mm3
    __m64 v24; // mm2
    __m64 v25; // mm3

    result = a2;
    v8 = a1 >> 2;
    do {
        v10 = _m_punpcklbw(_mm_cvtsi32_si64(*result), 0i64);
        v11 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a4), 0i64), (__m64)qword_479478);
        v12 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a3), 0i64), (__m64)qword_479478);
        v13 = _m_psllwi(v10, 8u);
        v14 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpcklwd(v12, v11), (__m64)qword_479480), _m_punpcklwd(v13, 0i64)), 8u);
        v15 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpckhwd(v12, v11), (__m64)qword_479480), _m_punpckhwd(v13, 0i64)), 8u);
        v16 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v11, v10), (__m64)qword_479488), 8u);
        v17 = _m_pmaddwd(_m_punpckhwd(v12, v10), (__m64)qword_479490);
        v18 = _m_pmaddwd(_m_punpckhwd(v11, v10), (__m64)qword_479488);
        v19 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v12, v10), (__m64)qword_479490), 8u);
        v20 = _m_psradi(v18, 8u);
        v21 = _m_psradi(v17, 8u);
        v22 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v16, v14), _m_punpckldq(v19, (__m64)(unsigned int)qword_6E61E0)),
            _m_packssdw(_m_punpckhdq(v16, v14), _m_punpckhdq(v19, (__m64)qword_6E61E0)));
        v23 = _m_psrlqi(_m_pand(v22, (__m64)qword_479498), 8u);
        a5 += 12;
        v24 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v20, v15), _m_punpckldq(v21, (__m64)(unsigned int)qword_6E61E0)),
            _m_packssdw(_m_punpckhdq(v20, v15), _m_punpckhdq(v21, (__m64)qword_6E61E0)));
        ++result;
        *(_DWORD*) (a5 - 12) = _mm_cvtsi64_si32(_m_por(v22, v23));
        v25 = _m_punpcklwd(_m_psrlqi(v23, 0x20u), v24);
        ++a4;
        *(_DWORD*) (a5 - 8) = _mm_cvtsi64_si32(v25);
        ++a3;
        *(_DWORD*) (a5 - 4) = _mm_cvtsi64_si32(_m_por(_m_psrlqi(v24, 0x18u), _m_psrlqi(v25, 0x30u)));
        --v8;
    }
    while(v8);
    return result;
}
// 479478: using guessed type __int64 qword_479478;
// 479480: using guessed type __int64 qword_479480;
// 479488: using guessed type __int64 qword_479488;
// 479490: using guessed type __int64 qword_479490;
// 479498: using guessed type __int64 qword_479498;
// 6E61E0: using guessed type __int64 qword_6E61E0;

//----- (00455466) --------------------------------------------------------
unsigned int* __cdecl sub_455466(_DWORD* a1, _DWORD* a2, int a3, int* a4, int a5) {
    _DWORD* v5; // eax
    int v6; // esi
    unsigned int v7; // edi
    int v8; // ecx
    unsigned int* result; // eax
    unsigned int v10; // ebx
    int v11; // eax
    unsigned int* v12; // edx
    unsigned int* v13; // edi
    unsigned int* v14; // ecx
    int* v15; // eax
    int v16; // edi
    _BYTE* v17; // edi
    int v18; // ecx
    int v19; // ecx
    int v20; // edx
    bool v21; // zf
    _DWORD* v22; // ebx
    int v23; // edx
    unsigned int** v24; // eax
    unsigned __int8* v25; // ecx
    int v26; // edx
    int v27; // edx
    int v28; // ebx
    unsigned int v29; // [esp+Ch] [ebp-2Ch]
    int v30; // [esp+Ch] [ebp-2Ch]
    int v31; // [esp+10h] [ebp-28h]
    int v32; // [esp+14h] [ebp-24h]
    int v33; // [esp+18h] [ebp-20h]
    int v34; // [esp+1Ch] [ebp-1Ch]
    unsigned int* v35; // [esp+20h] [ebp-18h]
    int v36; // [esp+24h] [ebp-14h]
    int v37; // [esp+28h] [ebp-10h]
    unsigned int v38; // [esp+28h] [ebp-10h]
    unsigned int v39; // [esp+2Ch] [ebp-Ch]
    int v40; // [esp+2Ch] [ebp-Ch]
    unsigned int v41; // [esp+30h] [ebp-8h]
    int v42; // [esp+34h] [ebp-4h]
    int v43; // [esp+34h] [ebp-4h]
    unsigned int* v44; // [esp+40h] [ebp+8h]
    int v45; // [esp+40h] [ebp+8h]
    int v46; // [esp+40h] [ebp+8h]
    unsigned int* v47; // [esp+48h] [ebp+10h]
    int v48; // [esp+48h] [ebp+10h]
    int v49; // [esp+48h] [ebp+10h]
    int v50; // [esp+48h] [ebp+10h]
    unsigned int* v51; // [esp+50h] [ebp+18h]
    int v52; // [esp+50h] [ebp+18h]
    unsigned __int8* v53; // [esp+50h] [ebp+18h]

    v5 = (_DWORD*) a1 [104];
    v6 = a1 [71];
    v7 = a1 [23];
    v36 = v5 [2];
    v33 = v5 [3];
    v8 = v5 [4];
    result = (unsigned int*) v5 [5];
    v10 = v7 & 0xFFFFFFF8;
    v41 = v7;
    v29 = v7 & 0xFFFFFFF8;
    v34 = v8;
    v35 = result;
    if(byte_479474) {
        if(a5 - 1 >= 0) {
            v31 = 3 * v10;
            v11 = 4 * a3;
            v37 = a5;
            while(1) {
                v12 = *(unsigned int**) (v11 + *a2);
                v13 = *(unsigned int**) (v11 + a2 [1]);
                v14 = *(unsigned int**) (v11 + a2 [2]);
                v32 = v11 + 4;
                v15 = a4++;
                v51 = v13;
                v16 = *v15;
                v47 = v12;
                v44 = v14;
                result = sub_455329(v10, v12, v51, v14, *v15);
                v17 = (_BYTE*) (v31 + v16);
                if(v10 < v41) {
                    v42 = (char*) v47 - (char*) v51;
                    v18 = (char*) v44 - (char*) v51;
                    result = (unsigned int*) ((char*) v51 + v10);
                    v48 = (char*) v44 - (char*) v51;
                    v39 = v41 - v10;
                    while(1) {
                        v19 = 4 * *((unsigned __int8*) result + v18);
                        v52 = *((unsigned __int8*) result + v42);
                        v20 = *(unsigned __int8*) result;
                        *v17 = *(_BYTE*) (v52 + *(_DWORD*) (v19 + v36) + v6);
                        v17 += 3;
                        *(v17 - 2) = *(_BYTE*) (v52 + ((int) (*(_DWORD*) (v19 + v34) + v35 [v20]) >> 16) + v6);
                        result = (unsigned int*) ((char*) result + 1);
                        v21 = v39-- == 1;
                        *(v17 - 1) = *(_BYTE*) (v52 + *(_DWORD*) (4 * v20 + v33) + v6);
                        if(v21)
                            break;
                        v18 = v48;
                    }
                    v10 = v29;
                }
                if(!--v37)
                    break;
                v11 = v32;
            }
        }
        _m_empty();
    }
    else {
        result = (unsigned int*) (a5 - 1);
        if(a5 - 1 >= 0) {
            v22 = a2;
            v23 = 4 * a3;
            v40 = a5;
            do {
                v49 = *(_DWORD*) (v23 + *v22);
                v53 = *(unsigned __int8**) (v23 + v22 [1]);
                v45 = *(_DWORD*) (v23 + v22 [2]);
                v24 = (unsigned int**) a4++;
                result = *v24;
                v23 += 4;
                v30 = v23;
                if(v7) {
                    v25 = v53;
                    v43 = v49 - (_DWORD) v53;
                    v26 = v45 - (_DWORD) v53;
                    v50 = v45 - (_DWORD) v53;
                    v38 = v7;
                    while(1) {
                        v27 = v25 [v26];
                        v28 = v25 [v43];
                        v46 = *v25;
                        *(_BYTE*) result = *(_BYTE*) (v28 + *(_DWORD*) (4 * v27 + v36) + v6);
                        v46 *= 4;
                        result = (unsigned int*) ((char*) result + 3);
                        *((_BYTE*) result - 2) = *(_BYTE*) (v28
                                                            + ((int) (*(_DWORD*) (4 * v27 + v34) + *(unsigned int*) ((char*) v35 + v46)) >> 16)
                                                            + v6);
                        ++v25;
                        v21 = v38-- == 1;
                        *((_BYTE*) result - 1) = *(_BYTE*) (v28 + *(_DWORD*) (v46 + v33) + v6);
                        if(v21)
                            break;
                        v26 = v50;
                    }
                    v23 = v30;
                    v22 = a2;
                    v7 = v41;
                }
                --v40;
            }
            while(v40);
        }
    }
    return result;
}
// 479474: using guessed type char byte_479474;

//----- (00455684) --------------------------------------------------------
int __cdecl sub_455684(int a1) {
    _DWORD* v1; // edi
    int v2; // eax
    bool v3; // zf
    int result; // eax
    bool v5; // zf
    int v6; // eax
    int v7; // ecx

    v1 = (_DWORD*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 24);
    *(_DWORD*) (a1 + 416) = v1;
    *v1 = nullsub_1;
    v2 = *(_DWORD*) (a1 + 36);
    if(v2 == 1) {
        v3 = *(_DWORD*) (a1 + 32) == 1;
        LABEL_10:
        if(v3)
            goto LABEL_12;
        goto LABEL_11;
    }
    if(v2 <= 1)
        goto LABEL_7;
    if(v2 <= 3) {
        v3 = *(_DWORD*) (a1 + 32) == 3;
        goto LABEL_10;
    }
    if(v2 <= 5) {
        v3 = *(_DWORD*) (a1 + 32) == 4;
        goto LABEL_10;
    }
    LABEL_7:
    if(*(int*) (a1 + 32) >= 1)
        goto LABEL_12;
    LABEL_11:
    *(_DWORD*) (*(_DWORD*) a1 + 20) = 8;
    (**(void(__cdecl***)(int))a1)(a1);
    LABEL_12:
    if(*(_DWORD*) (a1 + 40) != 1) {
        if(*(_DWORD*) (a1 + 40) == 2) {
            result = *(_DWORD*) (a1 + 36);
            *(_DWORD*) (a1 + 100) = 3;
            if(result == 3) {
                v1 [1] = sub_455466;
                goto LABEL_23;
            }
            v5 = result == 2;
        }
        else {
            if(*(_DWORD*) (a1 + 40) != 4) {
                if(*(_DWORD*) (a1 + 40) == *(_DWORD*) (a1 + 36)) {
                    result = *(_DWORD*) (a1 + 32);
                    *(_DWORD*) (a1 + 100) = result;
                    LABEL_26:
                    v1 [1] = sub_45516A;
                    goto LABEL_32;
                }
                LABEL_17:
                *(_DWORD*) (*(_DWORD*) a1 + 20) = 25;
                result = (**(int(__cdecl***)(int))a1)(a1);
                goto LABEL_32;
            }
            result = *(_DWORD*) (a1 + 36);
            *(_DWORD*) (a1 + 100) = 4;
            if(result == 5) {
                v1 [1] = sub_4551F7;
                LABEL_23:
                result = sub_4550BA(a1);
                goto LABEL_32;
            }
            v5 = result == 4;
        }
        if(v5)
            goto LABEL_26;
        goto LABEL_17;
    }
    v6 = *(_DWORD*) (a1 + 36);
    *(_DWORD*) (a1 + 100) = 1;
    if(v6 != 1 && v6 != 3)
        goto LABEL_17;
    v1 [1] = sub_4551D4;
    result = 1;
    if(*(int*) (a1 + 32) > 1) {
        v7 = 84;
        do {
            *(_BYTE*) (*(_DWORD*) (a1 + 196) + v7 + 48) = 0;
            ++result;
            v7 += 84;
        }
        while(result < *(_DWORD*) (a1 + 32));
    }
    LABEL_32:
    if(*(_BYTE*) (a1 + 74)) {
        *(_DWORD*) (a1 + 104) = 1;
    }
    else {
        result = *(_DWORD*) (a1 + 100);
        *(_DWORD*) (a1 + 104) = result;
    }
    return result;
}
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);

//----- (004557A5) --------------------------------------------------------
int __usercall sub_4557A5(int a1) {
    _DWORD* v2; // esi
    int result; // eax
    char* v4; // edx
    int i; // ecx
    int v6; // edi
    int v7; // edi
    int v8; // [esp+Ch] [ebp-8h]
    int v9; // [esp+10h] [ebp-4h]

    v2 = *(_DWORD**) (a1 + 412);
    v2 [4] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [5] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [6] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v2 [7] = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    result = 0;
    v4 = (char*) &unk_5B6900;
    v8 = -14831872;
    v9 = -11728000;
    for(i = 2919680; i >= -2831590; i -= 22554) {
        v6 = v9;
        v9 += 91881;
        *(_DWORD*) (result + v2 [4]) = v6 >> 16;
        v7 = v8;
        v8 += 116130;
        *(_DWORD*) (result + v2 [5]) = v7 >> 16;
        *(_DWORD*) (result + v2 [6]) = v4;
        *(_DWORD*) (result + v2 [7]) = i;
        v4 -= 46802;
        result += 4;
    }
    return result;
}

//----- (00455855) --------------------------------------------------------
int __cdecl sub_455855(int a1) {
    int result; // eax

    result = *(_DWORD*) (a1 + 412);
    *(_BYTE*) (result + 36) = 0;
    *(_DWORD*) (result + 44) = *(_DWORD*) (a1 + 96);
    return result;
}

//----- (0045586A) --------------------------------------------------------
const void** __cdecl sub_45586A(int a1, int a2, const void** a3, int a4, int a5, _DWORD* a6, int a7) {
    int v7; // esi
    _DWORD* v8; // ebx
    unsigned int v9; // edi
    const void** result; // eax
    int* v11; // eax
    int v12; // [esp+Ch] [ebp-8h] BYREF
    int v13; // [esp+10h] [ebp-4h]
    unsigned int v14; // [esp+34h] [ebp+20h]

    v7 = *(_DWORD*) (a1 + 412);
    if(*(_BYTE*) (v7 + 36)) {
        v8 = a6;
        v9 = 1;
        result = sub_44EE35(v7 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD*) (v7 + 40));
        *(_BYTE*) (v7 + 36) = 0;
    }
    else {
        v9 = 2;
        if(*(_DWORD*) (v7 + 44) < 2u)
            v9 = *(_DWORD*) (v7 + 44);
        v8 = a6;
        v14 = a7 - *a6;
        if(v9 > v14)
            v9 = v14;
        v11 = (int*) (a5 + 4 * *a6);
        v12 = *v11;
        if(v9 <= 1) {
            v13 = *(_DWORD*) (v7 + 32);
            *(_BYTE*) (v7 + 36) = 1;
        }
        else {
            v13 = v11 [1];
        }
        result = (const void**) (*(int(__cdecl**)(int, int, const void*, int*))(v7 + 12))(a1, a2, *a3, &v12);
    }
    *v8 += v9;
    *(_DWORD*) (v7 + 44) -= v9;
    if(!*(_BYTE*) (v7 + 36)) {
        result = a3;
        *a3 = (char*) *a3 + 1;
    }
    return result;
}

//----- (00455910) --------------------------------------------------------
int __cdecl sub_455910(int a1, int a2, _DWORD* a3, int a4, int a5, _DWORD* a6) {
    int result; // eax

    result = (*(int(__cdecl**)(int, int, _DWORD, int))(*(_DWORD*) (a1 + 412) + 12))(a1, a2, *a3, a5 + 4 * *a6);
    ++* a6;
    ++* a3;
    return result;
}

//----- (00455941) --------------------------------------------------------
_BYTE* __cdecl sub_455941(_DWORD* a1, _DWORD* a2, int a3, _BYTE** a4) {
    _DWORD* v4; // eax
    int v5; // ecx
    unsigned __int8* v6; // edi
    unsigned __int8* v7; // edx
    unsigned __int8* v8; // esi
    _BYTE* result; // eax
    int v10; // ebx
    int v11; // edx
    int v12; // esi
    int v13; // edx
    unsigned __int8* v14; // edi
    int v15; // edx
    _BYTE* v16; // eax
    int v17; // edi
    int v18; // ebx
    int v19; // esi
    int v20; // [esp+Ch] [ebp-18h]
    int v21; // [esp+10h] [ebp-14h]
    int v22; // [esp+14h] [ebp-10h]
    int v23; // [esp+18h] [ebp-Ch]
    unsigned __int8* v24; // [esp+1Ch] [ebp-8h]
    unsigned __int8* v25; // [esp+20h] [ebp-4h]
    int v26; // [esp+30h] [ebp+Ch]
    int v27; // [esp+34h] [ebp+10h]
    int v28; // [esp+34h] [ebp+10h]
    int v29; // [esp+34h] [ebp+10h]
    int v30; // [esp+38h] [ebp+14h]

    v4 = (_DWORD*) a1 [103];
    v5 = a1 [71];
    v20 = v4 [4];
    v21 = v4 [5];
    v23 = v4 [7];
    v22 = v4 [6];
    v6 = *(unsigned __int8**) (4 * a3 + *a2);
    v7 = *(unsigned __int8**) (4 * a3 + a2 [1]);
    v8 = *(unsigned __int8**) (4 * a3 + a2 [2]);
    result = *a4;
    if(a1 [23] >> 1) {
        v30 = a1 [23] >> 1;
        do {
            v10 = *v7;
            v25 = v7 + 1;
            v11 = 4 * *v8;
            v24 = v8 + 1;
            v26 = *(_DWORD*) (v11 + v20);
            v12 = *(_DWORD*) (v11 + v22) + *(_DWORD*) (4 * v10 + v23);
            v27 = *(_DWORD*) (4 * v10 + v21);
            v13 = *v6;
            *result = *(_BYTE*) (v13 + v26 + v5);
            v12 >>= 16;
            result [1] = *(_BYTE*) (v13 + v12 + v5);
            result [2] = *(_BYTE*) (v27 + v13 + v5);
            v14 = v6 + 1;
            v15 = *v14;
            v16 = result + 3;
            *v16 = *(_BYTE*) (v15 + v26 + v5);
            LOBYTE(v10) = *(_BYTE*) (v15 + v12 + v5);
            v8 = v24;
            v16 [1] = v10;
            v16 [2] = *(_BYTE*) (v27 + v15 + v5);
            v7 = v25;
            v6 = v14 + 1;
            result = v16 + 3;
            --v30;
        }
        while(v30);
    }
    if((a1 [23] & 1) != 0) {
        v17 = *v6;
        v28 = 4 * *v7;
        v18 = 4 * *v8;
        v19 = *(_DWORD*) (v18 + v22) + *(_DWORD*) (v28 + v23);
        v29 = *(_DWORD*) (v28 + v21);
        *result = *(_BYTE*) (v17 + *(_DWORD*) (v18 + v20) + v5);
        result [1] = *(_BYTE*) (v17 + (v19 >> 16) + v5);
        result [2] = *(_BYTE*) (v29 + v17 + v5);
    }
    return result;
}

//----- (00455A97) --------------------------------------------------------
char __cdecl sub_455A97(_DWORD* a1, _DWORD* a2, int a3, int a4) {
    _DWORD* v4; // ecx
    int v5; // eax
    unsigned __int8** v6; // edx
    unsigned __int8* v7; // edi
    int v8; // esi
    int v9; // ecx
    unsigned __int8* v10; // edx
    unsigned __int8* v11; // edi
    _BYTE* v12; // ecx
    _BYTE* v13; // esi
    int v14; // ebx
    int v15; // edx
    int v16; // edi
    int v17; // edx
    int v18; // edx
    _BYTE* v19; // ecx
    int v20; // edx
    int v21; // edx
    _BYTE* v22; // esi
    int v23; // ebx
    int v24; // edx
    int v25; // edi
    int v26; // edx
    int v27; // ecx
    int v29; // [esp+Ch] [ebp-20h]
    int v30; // [esp+10h] [ebp-1Ch]
    int v31; // [esp+14h] [ebp-18h]
    int v32; // [esp+18h] [ebp-14h]
    unsigned __int8* v33; // [esp+1Ch] [ebp-10h]
    unsigned __int8* v34; // [esp+20h] [ebp-Ch]
    int v35; // [esp+24h] [ebp-8h]
    int v36; // [esp+28h] [ebp-4h]
    int v37; // [esp+28h] [ebp-4h]
    unsigned __int8* v38; // [esp+38h] [ebp+Ch]
    unsigned __int8* v39; // [esp+38h] [ebp+Ch]
    unsigned __int8* v40; // [esp+3Ch] [ebp+10h]
    unsigned __int8* v41; // [esp+3Ch] [ebp+10h]
    int v42; // [esp+40h] [ebp+14h]
    int v43; // [esp+40h] [ebp+14h]

    v4 = (_DWORD*) a1 [103];
    v5 = a1 [71];
    v32 = v4 [4];
    v29 = v4 [5];
    v30 = v4 [6];
    v31 = v4 [7];
    v6 = (unsigned __int8**) (*a2 + 8 * a3);
    v7 = *v6;
    v8 = 4 * a3;
    v40 = v6 [1];
    v9 = a2 [2];
    v10 = *(unsigned __int8**) (v8 + a2 [1]);
    v38 = v7;
    v11 = *(unsigned __int8**) (v8 + v9);
    v12 = *(_BYTE**) a4;
    v13 = *(_BYTE**) (a4 + 4);
    if(a1 [23] >> 1) {
        v35 = a1 [23] >> 1;
        do {
            v14 = *v10;
            v34 = v10 + 1;
            v15 = 4 * *v11;
            v33 = v11 + 1;
            v42 = *(_DWORD*) (v15 + v32);
            v16 = *(_DWORD*) (v15 + v30) + *(_DWORD*) (4 * v14 + v31);
            v36 = *(_DWORD*) (4 * v14 + v29);
            v17 = *v38;
            *v12 = *(_BYTE*) (v17 + v42 + v5);
            v16 >>= 16;
            v39 = v38 + 1;
            v12 [1] = *(_BYTE*) (v17 + v16 + v5);
            v12 [2] = *(_BYTE*) (v36 + v17 + v5);
            v18 = *v39;
            v19 = v12 + 3;
            *v19 = *(_BYTE*) (v18 + v42 + v5);
            v19 [1] = *(_BYTE*) (v18 + v16 + v5);
            v19 [2] = *(_BYTE*) (v36 + v18 + v5);
            v20 = *v40;
            v38 = v39 + 1;
            *v13 = *(_BYTE*) (v20 + v42 + v5);
            v13 [1] = *(_BYTE*) (v20 + v16 + v5);
            v13 [2] = *(_BYTE*) (v36 + v20 + v5);
            v12 = v19 + 3;
            v41 = v40 + 1;
            v21 = *v41;
            v22 = v13 + 3;
            v40 = v41 + 1;
            *v22 = *(_BYTE*) (v21 + v42 + v5);
            v22 [1] = *(_BYTE*) (v21 + v16 + v5);
            v22 [2] = *(_BYTE*) (v36 + v21 + v5);
            v11 = v33;
            v10 = v34;
            v13 = v22 + 3;
            --v35;
        }
        while(v35);
    }
    if((a1 [23] & 1) != 0) {
        v23 = *v10;
        v24 = 4 * *v11;
        v43 = *(_DWORD*) (v24 + v32);
        v25 = *(_DWORD*) (v24 + v30) + *(_DWORD*) (4 * v23 + v31);
        v37 = *(_DWORD*) (4 * v23 + v29);
        v26 = *v38;
        *v12 = *(_BYTE*) (v26 + v43 + v5);
        v25 >>= 16;
        v12 [1] = *(_BYTE*) (v26 + v25 + v5);
        v12 [2] = *(_BYTE*) (v37 + v26 + v5);
        v27 = *v40;
        *v13 = *(_BYTE*) (v27 + v43 + v5);
        v13 [1] = *(_BYTE*) (v27 + v25 + v5);
        LOBYTE(v5) = *(_BYTE*) (v37 + v27 + v5);
        v13 [2] = v5;
    }
    return v5;
}

//----- (00455C7D) --------------------------------------------------------
int __cdecl sub_455C7D(int a1) {
    int v1; // esi
    int v3; // [esp-4h] [ebp-Ch]

    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 48);
    *(_DWORD*) (a1 + 412) = v1;
    *(_BYTE*) (v1 + 8) = 0;
    *(_DWORD*) v1 = sub_455855;
    *(_DWORD*) (v1 + 40) = *(_DWORD*) (a1 + 92) * *(_DWORD*) (a1 + 100);
    if(*(_DWORD*) (a1 + 272) == 2) {
        v3 = *(_DWORD*) (v1 + 40);
        *(_DWORD*) (v1 + 4) = sub_45586A;
        *(_DWORD*) (v1 + 12) = sub_455A97;
        *(_DWORD*) (v1 + 32) = (*(int(__cdecl**)(int, int, int))(*(_DWORD*) (a1 + 4) + 4))(a1, 1, v3);
    }
    else {
        *(_DWORD*) (v1 + 32) = 0;
        *(_DWORD*) (v1 + 4) = sub_455910;
        *(_DWORD*) (v1 + 12) = sub_455941;
    }
    return sub_4557A5(a1);
}

//----- (00455CF2) --------------------------------------------------------
_WORD* __cdecl sub_455CF2(int a1, _WORD* a2, int a3, int a4) {
    _WORD* result; // eax
    int v5; // ebx
    int v6; // esi
    int i; // edi
    unsigned __int8* v8; // ecx
    int v9; // [esp+14h] [ebp+8h]

    result = (_WORD*) a1;
    v5 = *(_DWORD*) (a1 + 92);
    v6 = *(_DWORD*) (*(_DWORD*) (a1 + 420) + 24);
    for(i = 0; i < a4; ++i) {
        result = a2;
        v8 = *(unsigned __int8**) &a2 [2 * i];
        if(v5) {
            v9 = v5;
            do {
                result = (_WORD*) (*(_DWORD*) (v6 + 4 * (*v8 >> 3)) + 2 * ((v8 [2] >> 3) + 32 * (v8 [1] >> 2)));
                if(!++ * result)
                    *result = -1;
                v8 += 3;
                --v9;
            }
            while(v9);
        }
    }
    return result;
}

//----- (00455D5E) --------------------------------------------------------
int* __usercall sub_455D5E(int a1, int a2) {
    int v3; // esi
    int* result; // eax
    int* v5; // ecx

    v3 = 0;
    result = 0;
    if(a1 > 0) {
        v5 = (int*) (a2 + 28);
        do {
            if(*v5 > v3 && *(v5 - 1) > 0) {
                result = v5 - 7;
                v3 = *v5;
            }
            v5 += 8;
            --a1;
        }
        while(a1);
    }
    return result;
}

//----- (00455D87) --------------------------------------------------------
int* __usercall sub_455D87(int a1, int a2) {
    int v3; // esi
    int* result; // eax
    int* v5; // ecx

    v3 = 0;
    result = 0;
    if(a1 > 0) {
        v5 = (int*) (a2 + 24);
        do {
            if(*v5 > v3) {
                result = v5 - 6;
                v3 = *v5;
            }
            v5 += 8;
            --a1;
        }
        while(a1);
    }
    return result;
}

//----- (00455DAA) --------------------------------------------------------
int __usercall sub_455DAA(int a1, int* a2) {
    int v2; // ecx
    int v3; // edi
    int v4; // eax
    int v6; // ecx
    int v7; // eax
    int v9; // ebx
    int v10; // ecx
    int v11; // edx
    _WORD* v12; // eax
    int v14; // ecx
    int v15; // edx
    _WORD* v16; // eax
    _WORD* v18; // eax
    int v19; // edx
    _WORD* v20; // eax
    int v21; // edx
    int v22; // edx
    int v23; // eax
    int v24; // ecx
    int v25; // edi
    int result; // eax
    int v27; // [esp+8h] [ebp-28h]
    int v28; // [esp+Ch] [ebp-24h]
    int v29; // [esp+10h] [ebp-20h]
    _WORD* v30; // [esp+14h] [ebp-1Ch]
    _WORD* v31; // [esp+14h] [ebp-1Ch]
    int v32; // [esp+14h] [ebp-1Ch]
    int v33; // [esp+14h] [ebp-1Ch]
    _WORD* v34; // [esp+14h] [ebp-1Ch]
    int v35; // [esp+18h] [ebp-18h]
    int v36; // [esp+18h] [ebp-18h]
    int v37; // [esp+1Ch] [ebp-14h]
    int v38; // [esp+20h] [ebp-10h]
    int v39; // [esp+24h] [ebp-Ch]
    int v40; // [esp+28h] [ebp-8h]
    int v41; // [esp+28h] [ebp-8h]
    int v42; // [esp+28h] [ebp-8h]
    int v43; // [esp+28h] [ebp-8h]
    int v44; // [esp+28h] [ebp-8h]
    int v45; // [esp+2Ch] [ebp-4h]
    int v46; // [esp+2Ch] [ebp-4h]
    int v47; // [esp+2Ch] [ebp-4h]
    int v48; // [esp+2Ch] [ebp-4h]
    int v49; // [esp+2Ch] [ebp-4h]
    int v50; // [esp+2Ch] [ebp-4h]

    v2 = *a2;
    v29 = a2 [3];
    v28 = *(_DWORD*) (*(_DWORD*) (a1 + 420) + 24);
    v3 = a2 [2];
    v39 = a2 [4];
    v35 = *a2;
    v38 = a2 [1];
    v27 = v3;
    v37 = a2 [5];
    if(*a2 < v38) {
        while(1) {
            v40 = a2 [2];
            if(v3 <= v29)
                break;
            LABEL_8:
            if(++v2 > v38)
                goto LABEL_11;
        }
        v4 = *(_DWORD*) (v28 + 4 * v2) + 2 * (v39 + 32 * v3);
        while(1) {
            v45 = a2 [4];
            v30 = (_WORD*) v4;
            if(v39 <= v37)
                break;
            LABEL_7:
            ++v40;
            v4 += 64;
            if(v40 > v29)
                goto LABEL_8;
        }
        while(!*v30++) {
            if(++v45 > v37)
                goto LABEL_7;
        }
        v35 = v2;
        *a2 = v2;
        LABEL_11:
        v6 = v38;
        if(v38 > v35) {
            while(1) {
                v41 = v3;
                if(v3 <= v29)
                    break;
                LABEL_18:
                if(--v6 < v35)
                    goto LABEL_21;
            }
            v7 = *(_DWORD*) (v28 + 4 * v6) + 2 * (v39 + 32 * v3);
            while(1) {
                v46 = v39;
                v31 = (_WORD*) v7;
                if(v39 <= v37)
                    break;
                LABEL_17:
                ++v41;
                v7 += 64;
                if(v41 > v29)
                    goto LABEL_18;
            }
            while(!*v31++) {
                if(++v46 > v37)
                    goto LABEL_17;
            }
            v38 = v6;
            a2 [1] = v6;
        }
    }
    LABEL_21:
    v9 = v29;
    if(v3 < v29) {
        v42 = v3;
        v10 = 2 * (v39 + 32 * v3);
        while(1) {
            v11 = v35;
            if(v35 <= v38)
                break;
            LABEL_29:
            ++v42;
            v10 += 64;
            if(v42 > v29)
                goto LABEL_32;
        }
        while(1) {
            v12 = (_WORD*) (v10 + *(_DWORD*) (v28 + 4 * v11));
            v47 = v39;
            if(v39 <= v37)
                break;
            LABEL_27:
            if(++v11 > v38) {
                v3 = v27;
                goto LABEL_29;
            }
        }
        while(!*v12++) {
            if(++v47 > v37)
                goto LABEL_27;
        }
        v3 = v42;
        v27 = v42;
        a2 [2] = v42;
        LABEL_32:
        v9 = v29;
        if(v29 > v3) {
            v43 = v29;
            v14 = 2 * (v39 + 32 * v29);
            while(1) {
                v15 = v35;
                if(v35 <= v38)
                    break;
                LABEL_40:
                --v43;
                v14 -= 64;
                if(v43 < v3) {
                    v9 = v29;
                    goto LABEL_43;
                }
            }
            while(1) {
                v16 = (_WORD*) (v14 + *(_DWORD*) (v28 + 4 * v15));
                v48 = v39;
                if(v39 <= v37)
                    break;
                LABEL_38:
                if(++v15 > v38) {
                    v3 = v27;
                    goto LABEL_40;
                }
            }
            while(!*v16++) {
                if(++v48 > v37)
                    goto LABEL_38;
            }
            v3 = v27;
            v9 = v43;
            v29 = v43;
            a2 [3] = v43;
        }
    }
    LABEL_43:
    if(v39 < v37) {
        v49 = v39;
        while(1) {
            v32 = v35;
            if(v35 <= v38)
                break;
            LABEL_50:
            if(++v49 > v37)
                goto LABEL_53;
        }
        while(1) {
            v18 = (_WORD*) (2 * (v49 + 32 * v3) + *(_DWORD*) (v28 + 4 * v32));
            v19 = v3;
            if(v3 <= v9)
                break;
            LABEL_49:
            if(++v32 > v38)
                goto LABEL_50;
        }
        while(!*v18) {
            ++v19;
            v18 += 32;
            if(v19 > v9)
                goto LABEL_49;
        }
        v39 = v49;
        a2 [4] = v49;
        LABEL_53:
        if(v37 > v39) {
            v50 = v37;
            while(1) {
                v33 = v35;
                if(v35 <= v38)
                    break;
                LABEL_60:
                if(--v50 < v39)
                    goto LABEL_63;
            }
            while(1) {
                v20 = (_WORD*) (2 * (v50 + 32 * v3) + *(_DWORD*) (v28 + 4 * v33));
                v21 = v3;
                if(v3 <= v9)
                    break;
                LABEL_59:
                if(++v33 > v38)
                    goto LABEL_60;
            }
            while(!*v20) {
                ++v21;
                v20 += 32;
                if(v21 > v9)
                    goto LABEL_59;
            }
            v37 = v50;
            a2 [5] = v50;
        }
    }
    LABEL_63:
    v22 = v9 - v3;
    v44 = 0;
    v23 = v35;
    a2 [6] = 16 * (v38 - v35) * 16 * (v38 - v35) + 12 * (v9 - v3) * 12 * (v9 - v3) + 8 * (v37 - v39) * 8 * (v37 - v39);
    while(v23 <= v38) {
        if(v27 <= v29) {
            v24 = *(_DWORD*) (v28 + 4 * v23) + 2 * (v39 + 32 * v27);
            v25 = v22 + 1;
            do {
                v34 = (_WORD*) v24;
                if(v39 <= v37) {
                    v36 = v37 - v39 + 1;
                    do {
                        if(*v34)
                            ++v44;
                        ++v34;
                        --v36;
                    }
                    while(v36);
                }
                v24 += 64;
                --v25;
            }
            while(v25);
        }
        ++v23;
    }
    result = v44;
    a2 [7] = v44;
    return result;
}

//----- (004560E2) --------------------------------------------------------
int __cdecl sub_4560E2(int a1, int a2, int a3, int a4) {
    int v4; // ebx
    _DWORD* v5; // edi
    int* v6; // eax
    int* v7; // esi
    int v8; // ecx
    int v9; // eax
    int v10; // ebx
    int v11; // ebx
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v16; // [esp+Ch] [ebp-4h]

    v4 = a3;
    if(a3 < a4) {
        v16 = 2 * a3;
        v5 = (_DWORD*) (32 * a3 + a2 + 12);
        do {
            if(v16 > a4)
                v6 = sub_455D87(v4, a2);
            else
                v6 = sub_455D5E(v4, a2);
            v7 = v6;
            if(!v6)
                break;
            *(v5 - 2) = v6 [1];
            *v5 = v6 [3];
            v5 [2] = v6 [5];
            *(v5 - 3) = *v6;
            *(v5 - 1) = v6 [2];
            v5 [1] = v6 [4];
            v8 = 16 * (v6 [1] - *v6);
            v9 = 12 * (v6 [3] - v6 [2]);
            v10 = 1;
            if(v8 > v9) {
                v9 = 16 * (v7 [1] - *v7);
                v10 = 0;
            }
            if(8 * (v7 [5] - v7 [4]) > v9)
                v10 = 2;
            if(v10) {
                v11 = v10 - 1;
                if(v11) {
                    if(v11 == 1) {
                        v12 = (v7 [4] + v7 [5]) / 2;
                        v7 [5] = v12;
                        v5 [1] = v12 + 1;
                    }
                }
                else {
                    v13 = (v7 [2] + v7 [3]) / 2;
                    v7 [3] = v13;
                    *(v5 - 1) = v13 + 1;
                }
            }
            else {
                v14 = (*v7 + v7 [1]) / 2;
                v7 [1] = v14;
                *(v5 - 3) = v14 + 1;
            }
            sub_455DAA(a1, v7);
            sub_455DAA(a1, v5 - 3);
            v16 += 2;
            v4 = a3 + 1;
            v5 += 8;
            ++a3;
        }
        while(a3 < a4);
    }
    return v4;
}

//----- (004561FC) --------------------------------------------------------
int __usercall sub_4561FC(int* a1, int a2, int a3) {
    int v3; // ebx
    int v4; // ecx
    int v5; // edx
    int v6; // eax
    int v7; // edi
    int v8; // edi
    int v9; // edi
    int result; // eax
    int v11; // [esp+Ch] [ebp-3Ch]
    int v12; // [esp+10h] [ebp-38h]
    int v13; // [esp+14h] [ebp-34h]
    int v14; // [esp+20h] [ebp-28h]
    int v15; // [esp+24h] [ebp-24h]
    int v16; // [esp+28h] [ebp-20h]
    int v17; // [esp+2Ch] [ebp-1Ch]
    int v18; // [esp+30h] [ebp-18h]
    int v19; // [esp+34h] [ebp-14h]
    int v20; // [esp+38h] [ebp-10h]
    int v21; // [esp+3Ch] [ebp-Ch]
    int v22; // [esp+40h] [ebp-8h]
    unsigned __int16* v23; // [esp+44h] [ebp-4h]

    v18 = 0;
    v17 = 0;
    v16 = 0;
    v15 = 0;
    v3 = a1 [5];
    v11 = a1 [1];
    v4 = a1 [2];
    v14 = a1 [3];
    v5 = a1 [4];
    v6 = *a1;
    v7 = a3;
    if(v6 <= v11) {
        v19 = 8 * v6 + 4;
        do {
            if(v4 <= v14) {
                v20 = 4 * v4 + 2;
                v21 = *(_DWORD*) (*(_DWORD*) (*(_DWORD*) (a2 + 420) + 24) + 4 * v6) + 2 * (v5 + 32 * v4);
                v8 = v14 - v4 + 1;
                v12 = v8;
                do {
                    v23 = (unsigned __int16*) v21;
                    if(v5 <= v3) {
                        v22 = 8 * v5 + 4;
                        v13 = v3 - v5 + 1;
                        do {
                            v9 = *v23++;
                            if(v9) {
                                v18 += v9;
                                v16 += v9 * v20;
                                v17 += v9 * v19;
                                v15 += v9 * v22;
                            }
                            v22 += 8;
                            --v13;
                        }
                        while(v13);
                        v8 = v12;
                    }
                    v21 += 64;
                    v20 += 4;
                    v12 = --v8;
                }
                while(v8);
                v7 = a3;
            }
            v19 += 8;
            ++v6;
        }
        while(v6 <= v11);
    }
    *(_BYTE*) (v7 + **(_DWORD**) (a2 + 116)) = ((v18 >> 1) + v17) / v18;
    *(_BYTE*) (v7 + *(_DWORD*) (*(_DWORD*) (a2 + 116) + 4)) = ((v18 >> 1) + v16) / v18;
    result = ((v18 >> 1) + v15) / v18;
    *(_BYTE*) (v7 + *(_DWORD*) (*(_DWORD*) (a2 + 116) + 8)) = result;
    return result;
}

//----- (00456334) --------------------------------------------------------
int __usercall sub_456334(int a1, int a2) {
    int* v2; // esi
    int v3; // eax
    int v4; // ebx
    int v5; // eax
    int* v7; // [esp+8h] [ebp-4h]
    int v8; // [esp+14h] [ebp+8h]

    v2 = (int*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 32 * a2);
    v2 [1] = 31;
    v2 [5] = 31;
    *v2 = 0;
    v2 [2] = 0;
    v2 [3] = 63;
    v2 [4] = 0;
    sub_455DAA(a1, v2);
    v3 = sub_4560E2(a1, (int) v2, 1, a2);
    v8 = 0;
    v4 = v3;
    if(v3 > 0) {
        v7 = v2;
        do {
            sub_4561FC(v7, a1, v8++);
            v7 += 8;
        }
        while(v8 < v4);
    }
    v5 = *(_DWORD*) a1;
    *(_DWORD*) (a1 + 112) = v4;
    *(_DWORD*) (v5 + 20) = 95;
    *(_DWORD*) (*(_DWORD*) a1 + 24) = v4;
    return (*(int(__cdecl**)(int, int))(*(_DWORD*) a1 + 4))(a1, 1);
}

//----- (004563C1) --------------------------------------------------------
int __usercall sub_4563C1(int a1, int a2, int a3, int a4, int a5) {
    int v5; // edx
    int v6; // ebx
    int* v7; // eax
    int v8; // ecx
    int v9; // eax
    int v10; // eax
    int v11; // ecx
    int v12; // esi
    int v13; // eax
    int v14; // ecx
    int v15; // eax
    int v16; // eax
    int v17; // ecx
    int v18; // eax
    int v19; // edx
    int v20; // eax
    int v21; // edx
    int v22; // eax
    int v23; // ecx
    bool v24; // cc
    int v25; // ecx
    int result; // eax
    int v27 [256]; // [esp+8h] [ebp-428h]
    int v28; // [esp+408h] [ebp-28h]
    int v29; // [esp+40Ch] [ebp-24h]
    int v30; // [esp+410h] [ebp-20h]
    int v31; // [esp+414h] [ebp-1Ch]
    int v32; // [esp+418h] [ebp-18h]
    int v33; // [esp+41Ch] [ebp-14h]
    int v34; // [esp+420h] [ebp-10h]
    int v35; // [esp+424h] [ebp-Ch]
    int v36; // [esp+428h] [ebp-8h]
    int v37; // [esp+42Ch] [ebp-4h]

    v5 = a3;
    v37 = 0;
    v32 = (2 * a3 + 24) >> 1;
    v6 = a4;
    v30 = (2 * a2 + 28) >> 1;
    v35 = *(_DWORD*) (a1 + 112);
    v29 = (2 * a4 + 24) >> 1;
    v36 = 0x7FFFFFFF;
    if(v35 > 0) {
        v7 = *(int**) (a1 + 116);
        v28 = *v7;
        v8 = v7 [1];
        v9 = v7 [2];
        v34 = v8;
        v33 = v9;
        do {
            v10 = *(unsigned __int8*) (v28 + v37);
            v11 = v5 + 24;
            if(v10 >= v5) {
                if(v10 > v11) {
                    v12 = 2 * (v10 - v11) * 2 * (v10 - v11);
                    LABEL_7:
                    v13 = v10 - v5;
                    goto LABEL_8;
                }
                v12 = 0;
                if(v10 > v32)
                    goto LABEL_7;
            }
            else {
                v12 = 2 * (v10 - v5) * 2 * (v10 - v5);
            }
            v13 = v10 - v11;
            LABEL_8:
            v14 = 2 * v13 * 2 * v13;
            v15 = *(unsigned __int8*) (v34 + v37);
            if(v15 < a2) {
                v12 += 3 * (v15 - a2) * 3 * (v15 - a2);
                v6 = a4;
                v16 = v15 - (a2 + 28);
                goto LABEL_15;
            }
            if(v15 > a2 + 28) {
                v12 += 3 * (v15 - (a2 + 28)) * 3 * (v15 - (a2 + 28));
                v6 = a4;
                LABEL_14:
                v16 = v15 - a2;
                goto LABEL_15;
            }
            if(v15 > v30)
                goto LABEL_14;
            v16 = v15 - (a2 + 28);
            LABEL_15:
            v17 = 3 * v16 * 3 * v16 + v14;
            v18 = *(unsigned __int8*) (v33 + v37);
            if(v18 < v6) {
                v12 += (v18 - v6) * (v18 - v6);
                v6 = a4;
                v19 = a4 + 24;
                LABEL_31:
                v20 = v18 - v19;
                goto LABEL_22;
            }
            v19 = v6 + 24;
            v31 = v6 + 24;
            if(v18 <= v6 + 24) {
                if(v18 <= v29)
                    goto LABEL_31;
            }
            else {
                v12 += (v18 - v31) * (v18 - v31);
                v6 = a4;
            }
            v20 = v18 - v6;
            LABEL_22:
            v21 = v20 * v20;
            v22 = v37;
            v23 = v21 + v17;
            v24 = v23 < v36;
            v5 = a3;
            v27 [v37] = v12;
            if(v24)
                v36 = v23;
            v37 = v22 + 1;
        }
        while(v22 + 1 < v35);
    }
    v25 = 0;
    for(result = 0; v25 < v35; ++v25) {
        if(v27 [v25] <= v36) {
            *(_BYTE*) (result + a5) = v25;
            ++result;
        }
    }
    return result;
}
// 4563C1: using guessed type int var_428[256];

//----- (00456541) --------------------------------------------------------
int __cdecl sub_456541(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE* a7) {
    int result; // eax
    int v8; // ebx
    _DWORD* v9; // edx
    int v10; // ecx
    int v11; // esi
    int v12; // edx
    int v13; // eax
    int v14; // esi
    int v15; // edx
    int v16; // ecx
    _DWORD v17 [128]; // [esp+4h] [ebp-228h] BYREF
    int v18; // [esp+204h] [ebp-28h]
    int v19; // [esp+208h] [ebp-24h]
    int v20; // [esp+20Ch] [ebp-20h]
    _BYTE* v21; // [esp+210h] [ebp-1Ch]
    int v22; // [esp+214h] [ebp-18h]
    int v23; // [esp+218h] [ebp-14h]
    int* v24; // [esp+21Ch] [ebp-10h]
    int v25; // [esp+220h] [ebp-Ch]
    int v26; // [esp+224h] [ebp-8h]
    int v27; // [esp+228h] [ebp-4h]

    v26 = 0;
    result = 0x7FFFFFFF;
    memset32(v17, 0x7FFFFFFF, 0x80u);
    if(a5 > 0) {
        do {
            v8 = *(unsigned __int8*) (v26 + a6);
            v9 = *(_DWORD**) (a1 + 116);
            v10 = a2 - *(unsigned __int8*) (v8 + *v9);
            v11 = 3 * (a3 - *(unsigned __int8*) (v9 [1] + v8));
            v12 = a4 - *(unsigned __int8*) (v9 [2] + v8);
            v10 *= 2;
            v13 = v10 * v10 + v11 * v11 + v12 * v12;
            v14 = 8 * (3 * v11 + 18);
            v15 = 16 * (v12 + 4);
            v24 = v17;
            v21 = a7;
            v27 = 32 * (v10 + 8);
            v19 = 4;
            do {
                v22 = v13;
                v25 = v14;
                v18 = 8;
                do {
                    v16 = v22;
                    v23 = v15;
                    v20 = 4;
                    do {
                        if(v16 < *v24) {
                            *v24 = v16;
                            *v21 = v8;
                        }
                        v16 += v23;
                        v23 += 128;
                        ++v24;
                        ++v21;
                        --v20;
                    }
                    while(v20);
                    v22 += v25;
                    v25 += 288;
                    --v18;
                }
                while(v18);
                v13 += v27;
                v27 += 512;
                --v19;
            }
            while(v19);
            result = ++v26;
        }
        while(v26 < a5);
    }
    return result;
}

//----- (0045665B) --------------------------------------------------------
_WORD* __usercall sub_45665B(int a1, int a2, int a3, int a4) {
    int v4; // esi
    int v5; // eax
    char* v6; // edx
    _DWORD* v7; // ecx
    int v8; // ebx
    _WORD* result; // eax
    int v10; // edi
    char v11 [256]; // [esp+Ch] [ebp-188h] BYREF
    char v12 [128]; // [esp+10Ch] [ebp-88h] BYREF
    int v13; // [esp+18Ch] [ebp-8h]
    int v14; // [esp+190h] [ebp-4h]
    int v15; // [esp+19Ch] [ebp+8h]
    int v16; // [esp+1A0h] [ebp+Ch]
    int v17; // [esp+1A0h] [ebp+Ch]
    int v18; // [esp+1A4h] [ebp+10h]
    int v19; // [esp+1A4h] [ebp+10h]

    v18 = a4 >> 2;
    v16 = a3 >> 2;
    v14 = *(_DWORD*) (*(_DWORD*) (a2 + 420) + 24);
    v4 = a1 >> 3;
    v13 = 32 * v18 + 4;
    v5 = sub_4563C1(a2, 32 * (a1 >> 3) + 2, 32 * v16 + 4, v13, (int) v11);
    sub_456541(a2, 32 * v16 + 4, 32 * v4 + 2, v13, v5, (int) v11, v12);
    v6 = v12;
    v15 = 2 * (4 * v18 + (v4 << 8));
    v7 = (_DWORD*) (v14 + 16 * v16);
    v17 = 4;
    do {
        v8 = v15;
        v19 = 8;
        do {
            result = (_WORD*) (v8 + *v7);
            v10 = 4;
            do {
                *result++ = (unsigned __int8) *v6++ + 1;
                --v10;
            }
            while(v10);
            v8 += 64;
            --v19;
        }
        while(v19);
        ++v7;
        --v17;
    }
    while(v17);
    return result;
}

//----- (0045672B) --------------------------------------------------------
int __cdecl sub_45672B(int a1, int a2, _DWORD* a3, int a4) {
    int result; // eax
    int v5; // ecx
    unsigned __int8* v6; // esi
    int v7; // ecx
    unsigned __int8* v8; // esi
    int v9; // eax
    int v10; // edx
    _WORD* v11; // edi
    _BYTE* v12; // ecx
    bool v13; // zf
    int v14; // [esp+0h] [ebp-10h]
    int v15; // [esp+4h] [ebp-Ch]
    int v16; // [esp+8h] [ebp-8h]
    int v17; // [esp+Ch] [ebp-4h]
    int v18; // [esp+1Ch] [ebp+Ch]
    _BYTE* v19; // [esp+24h] [ebp+14h]

    result = a1;
    v16 = *(_DWORD*) (*(_DWORD*) (a1 + 420) + 24);
    v5 = *(_DWORD*) (a1 + 92);
    v15 = v5;
    if(a4 > 0) {
        result = a2 - (_DWORD) a3;
        v14 = a2 - (_DWORD) a3;
        v17 = a4;
        do {
            v6 = *(unsigned __int8**) ((char*) a3 + result);
            v19 = (_BYTE*) *a3;
            if(v5) {
                v18 = v5;
                do {
                    v7 = *v6 >> 3;
                    v8 = v6 + 1;
                    v9 = *v8++ >> 2;
                    v10 = *v8 >> 3;
                    v11 = (_WORD*) (*(_DWORD*) (v16 + 4 * v7) + 2 * (v10 + 32 * v9));
                    v6 = v8 + 1;
                    if(!*v11)
                        sub_45665B(v9, a1, v7, v10);
                    v12 = v19++;
                    v13 = v18-- == 1;
                    *v12 = *(_BYTE*) v11 - 1;
                }
                while(!v13);
                v5 = v15;
                result = v14;
            }
            ++a3;
            --v17;
        }
        while(v17);
    }
    return result;
}

//----- (004567D4) --------------------------------------------------------
__int16 __cdecl sub_4567D4(_DWORD* a1, int a2, _DWORD* a3, int a4) {
    int v4; // ecx
    int v5; // edx
    int* v6; // eax
    int v7; // esi
    __int16 result; // ax
    int v9; // esi
    unsigned __int8* v10; // eax
    _BYTE* v11; // esi
    _WORD* v12; // esi
    int v13; // ebx
    int v14; // edi
    int v15; // edi
    int v16; // ebx
    _WORD* v17; // eax
    int v18; // eax
    int v19; // edi
    int v20; // ebx
    int v21; // eax
    int v22; // ecx
    int v23; // edi
    int v24; // ecx
    int v25; // ebx
    __int16 v26; // dx
    int v27; // ecx
    int v28; // eax
    __int16 v29; // dx
    bool v30; // zf
    int v31; // [esp+4h] [ebp-60h]
    int v32; // [esp+Ch] [ebp-58h]
    int v33; // [esp+10h] [ebp-54h]
    int v34; // [esp+14h] [ebp-50h]
    _WORD* v35; // [esp+18h] [ebp-4Ch]
    int v36; // [esp+20h] [ebp-44h]
    int v37; // [esp+24h] [ebp-40h]
    int v38; // [esp+28h] [ebp-3Ch]
    int v39; // [esp+2Ch] [ebp-38h]
    int v40; // [esp+30h] [ebp-34h]
    int v41; // [esp+34h] [ebp-30h]
    __int16 v42; // [esp+38h] [ebp-2Ch]
    __int16 v43; // [esp+3Ch] [ebp-28h]
    __int16 v44; // [esp+40h] [ebp-24h]
    int v45; // [esp+44h] [ebp-20h]
    _DWORD* v46; // [esp+48h] [ebp-1Ch]
    __int16 v47; // [esp+4Ch] [ebp-18h]
    __int16 v48; // [esp+50h] [ebp-14h]
    __int16 v49; // [esp+54h] [ebp-10h]
    int v50; // [esp+58h] [ebp-Ch]
    _BYTE* v51; // [esp+5Ch] [ebp-8h]
    int v52; // [esp+70h] [ebp+Ch]
    int v53; // [esp+74h] [ebp+10h]
    int v54; // [esp+78h] [ebp+14h]
    int v55; // [esp+78h] [ebp+14h]
    __int16 v56; // [esp+78h] [ebp+14h]
    __int16 v57; // [esp+78h] [ebp+14h]
    __int16 v58; // [esp+78h] [ebp+14h]

    v4 = a1 [105];
    v50 = a1 [71];
    v36 = *(_DWORD*) (v4 + 24);
    v5 = a1 [23];
    v6 = (int*) a1 [29];
    v45 = *(_DWORD*) (v4 + 40);
    v34 = *v6;
    v7 = v6 [1];
    v32 = v6 [2];
    result = a4;
    v31 = v4;
    v39 = v5;
    v33 = v7;
    if(a4 > 0) {
        v9 = a2 - (_DWORD) a3;
        v46 = a3;
        v37 = a2 - (_DWORD) a3;
        v38 = a4;
        while(1) {
            v10 = *(unsigned __int8**) ((char*) v46 + v9);
            v11 = (_BYTE*) *v46;
            v52 = (int) v10;
            v51 = (_BYTE*) *v46;
            if(*(_BYTE*) (v4 + 36)) {
                v41 = -1;
                *(_BYTE*) (v4 + 36) = 0;
                v52 = (int) &v10 [2 * v5 - 3 + v5];
                v51 = &v11 [v5 - 1];
                v12 = (_WORD*) (*(_DWORD*) (v4 + 32) + 2 * (3 * v5 + 3));
                v10 = (unsigned __int8*) v52;
                v53 = -3;
            }
            else {
                v12 = *(_WORD**) (v4 + 32);
                v41 = 1;
                v53 = 3;
                *(_BYTE*) (v4 + 36) = 1;
            }
            v5 = v39;
            v13 = 0;
            v47 = 0;
            v48 = 0;
            v49 = 0;
            v14 = 0;
            v54 = 0;
            v42 = 0;
            v43 = 0;
            v44 = 0;
            if(v39) {
                v40 = v39;
                while(1) {
                    v15 = *(unsigned __int8*) (*v10 + *(_DWORD*) (v45 + 4 * (((__int16) v12 [v53] + v14 + 8) >> 4)) + v50);
                    v16 = *(unsigned __int8*) (v10 [1] + *(_DWORD*) (v45 + 4 * (((__int16) v12 [v53 + 1] + v13 + 8) >> 4)) + v50);
                    v55 = *(unsigned __int8*) (v10 [2] + *(_DWORD*) (v45 + 4 * (((__int16) v12 [v53 + 2] + v54 + 8) >> 4)) + v50);
                    v17 = (_WORD*) (*(_DWORD*) (v36 + 4 * (v15 >> 3)) + 2 * ((v55 >> 3) + 32 * (v16 >> 2)));
                    v35 = v17;
                    if(!*v17) {
                        sub_45665B(v16 >> 2, (int) a1, v15 >> 3, v55 >> 3);
                        v17 = v35;
                    }
                    v18 = (unsigned __int16) *v17 - 1;
                    *v51 = v18;
                    v19 = v15 - *(unsigned __int8*) (v18 + v34);
                    v20 = v16 - *(unsigned __int8*) (v18 + v33);
                    v21 = v55 - *(unsigned __int8*) (v18 + v32);
                    v56 = v19;
                    v22 = 2 * v19;
                    v19 *= 3;
                    *v12 = v19 + v49;
                    v23 = v22 + v19;
                    v49 = v23 + v44;
                    v44 = v56;
                    v14 = v22 + v23;
                    v57 = v20;
                    v24 = 2 * v20;
                    v20 *= 3;
                    v12 [1] = v20 + v48;
                    v25 = v24 + v20;
                    v48 = v25 + v43;
                    v26 = v57;
                    v58 = v21;
                    v43 = v26;
                    v13 = v24 + v25;
                    v27 = 2 * v21;
                    v21 *= 3;
                    v12 [2] = v21 + v47;
                    v12 += v53;
                    v28 = v27 + v21;
                    v47 = v28 + v42;
                    v29 = v58;
                    v54 = v27 + v28;
                    v52 += v53;
                    v51 += v41;
                    v30 = v40-- == 1;
                    v42 = v29;
                    if(v30)
                        break;
                    v10 = (unsigned __int8*) v52;
                }
                v4 = v31;
                v5 = v39;
            }
            ++v46;
            v30 = v38-- == 1;
            *v12 = v49;
            v12 [1] = v48;
            result = v47;
            v12 [2] = v47;
            if(v30)
                break;
            v9 = v37;
        }
    }
    return result;
}

//----- (00456A42) --------------------------------------------------------
int __usercall sub_456A42(int a1) {
    int v1; // esi
    int result; // eax
    int v3; // edx
    int v4; // ecx
    int v5; // edi
    _DWORD* v6; // esi
    _DWORD* v7; // esi
    _DWORD* v8; // esi

    v1 = *(_DWORD*) (a1 + 420);
    result = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020;
    *(_DWORD*) (v1 + 40) = result;
    v3 = 0;
    v4 = 0;
    v5 = 0;
    v6 = (_DWORD*) result;
    do {
        *(_DWORD*) (result + 4 * v4) = v3;
        *v6 = v5;
        ++v4;
        --v6;
        ++v3;
        --v5;
    }
    while(v4 < 16);
    if(v4 < 48) {
        v7 = (_DWORD*) (result - 4 * v4);
        do {
            *(_DWORD*) (result + 4 * v4) = v3;
            *v7 = -v3;
            ++v4;
            --v7;
            v3 += (v4 & 1) == 0;
        }
        while(v4 < 48);
    }
    if(v4 <= 255) {
        v8 = (_DWORD*) (result - 4 * v4);
        do {
            *(_DWORD*) (result + 4 * v4) = v3;
            *v8 = -v3;
            ++v4;
            --v8;
        }
        while(v4 <= 255);
    }
    return result;
}

//----- (00456AD2) --------------------------------------------------------
int __cdecl sub_456AD2(int a1) {
    int v1; // esi
    int result; // eax

    v1 = *(_DWORD*) (a1 + 420);
    *(_DWORD*) (a1 + 116) = *(_DWORD*) (v1 + 16);
    result = sub_456334(a1, *(_DWORD*) (v1 + 20));
    *(_BYTE*) (v1 + 28) = 1;
    return result;
}

//----- (00456AF4) --------------------------------------------------------
int __cdecl sub_456AF4(_DWORD* a1, char a2) {
    bool v3; // zf
    int v4; // edi
    int result; // eax
    int v6; // ebx
    unsigned int v7; // ebx
    int i; // esi
    int v9; // [esp+10h] [ebp+8h]

    v3 = a1 [19] == 0;
    v4 = a1 [105];
    result = *(_DWORD*) (v4 + 24);
    v9 = result;
    if(!v3)
        a1 [19] = 2;
    if(a2) {
        *(_DWORD*) (v4 + 4) = sub_455CF2;
        *(_DWORD*) (v4 + 8) = sub_456AD2;
        *(_BYTE*) (v4 + 28) = 1;
    }
    else {
        if(a1 [19] == 2)
            *(_DWORD*) (v4 + 4) = sub_4567D4;
        else
            *(_DWORD*) (v4 + 4) = sub_45672B;
        *(_DWORD*) (v4 + 8) = nullsub_1;
        v6 = a1 [28];
        if(v6 < 1) {
            *(_DWORD*) (*a1 + 20) = 55;
            *(_DWORD*) (*a1 + 24) = 1;
            (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        result = 256;
        if(v6 > 256) {
            *(_DWORD*) (*a1 + 20) = 56;
            *(_DWORD*) (*a1 + 24) = 256;
            result = (*(int(__cdecl**)(_DWORD*)) * a1)(a1);
        }
        if(a1 [19] == 2) {
            v7 = 6 * (a1 [23] + 2);
            if(!*(_DWORD*) (v4 + 32))
                *(_DWORD*) (v4 + 32) = (*(int(__cdecl**)(_DWORD*, int, unsigned int))(a1 [1] + 4))(a1, 1, v7);
            result = sub_44EE9E(*(void**) (v4 + 32), v7);
            if(!*(_DWORD*) (v4 + 40))
                result = sub_456A42((int) a1);
            *(_BYTE*) (v4 + 36) = 0;
        }
    }
    if(*(_BYTE*) (v4 + 28)) {
        for(i = 0; i < 32; ++i)
            result = sub_44EE9E(*(void**) (v9 + 4 * i), 0x1000u);
        *(_BYTE*) (v4 + 28) = 0;
    }
    return result;
}
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);

//----- (00456BF6) --------------------------------------------------------
int __cdecl sub_456BF6(int a1) {
    int result; // eax

    result = *(_DWORD*) (a1 + 420);
    *(_BYTE*) (result + 28) = 1;
    return result;
}

//----- (00456C05) --------------------------------------------------------
int __cdecl sub_456C05(int a1) {
    int v1; // edi
    int v2; // ebp
    int result; // eax
    int v4; // ebp

    v1 = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 44);
    *(_DWORD*) (a1 + 420) = v1;
    v2 = 0;
    *(_DWORD*) v1 = sub_456AF4;
    *(_DWORD*) (v1 + 12) = sub_456BF6;
    *(_DWORD*) (v1 + 32) = 0;
    *(_DWORD*) (v1 + 40) = 0;
    if(*(_DWORD*) (a1 + 100) != 3) {
        *(_DWORD*) (*(_DWORD*) a1 + 20) = 46;
        (**(void(__cdecl***)(int))a1)(a1);
    }
    *(_DWORD*) (v1 + 24) = (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 128);
    do {
        result = (*(int(__cdecl**)(int, int, int))(*(_DWORD*) (a1 + 4) + 4))(a1, 1, 4096);
        *(_DWORD*) (*(_DWORD*) (v1 + 24) + v2) = result;
        v2 += 4;
    }
    while(v2 < 128);
    *(_BYTE*) (v1 + 28) = 1;
    if(*(_BYTE*) (a1 + 90)) {
        v4 = *(_DWORD*) (a1 + 84);
        if(v4 < 8) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 55;
            *(_DWORD*) (*(_DWORD*) a1 + 24) = 8;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        if(v4 > 256) {
            *(_DWORD*) (*(_DWORD*) a1 + 20) = 56;
            *(_DWORD*) (*(_DWORD*) a1 + 24) = 256;
            (**(void(__cdecl***)(int))a1)(a1);
        }
        result = (*(int(__cdecl**)(int, int, int, int))(*(_DWORD*) (a1 + 4) + 8))(a1, 1, v4, 3);
        *(_DWORD*) (v1 + 16) = result;
        *(_DWORD*) (v1 + 20) = v4;
    }
    else {
        *(_DWORD*) (v1 + 16) = 0;
    }
    if(*(_DWORD*) (a1 + 76))
        *(_DWORD*) (a1 + 76) = 2;
    if(*(_DWORD*) (a1 + 76) == 2) {
        *(_DWORD*) (v1 + 32) = (*(int(__cdecl**)(int, int, int))(*(_DWORD*) (a1 + 4) + 4))(
            a1,
            1,
            6 * (*(_DWORD*) (a1 + 92) + 2));
        return sub_456A42(a1);
    }
    return result;
}

//----- (00456D18) --------------------------------------------------------
int __cdecl sub_456D18(_DWORD* a1, char* a2) {
    _DWORD* v2; // esi
    signed int v3; // ebx
    int v4; // edi
    int v5; // eax
    int v6; // ecx
    int v7; // edi
    signed int v8; // edx
    int v9; // eax
    int* v10; // ecx
    int v11; // edi
    int v12; // eax
    int v14; // [esp+Ch] [ebp-10h]
    int v15; // [esp+10h] [ebp-Ch]
    int v16; // [esp+14h] [ebp-8h]
    char v17; // [esp+1Bh] [ebp-1h]

    v2 = a1;
    v3 = a1 [25];
    v14 = a1 [21];
    v4 = 1;
    do {
        v5 = ++v4;
        if(v3 > 1) {
            v6 = v3 - 1;
            do {
                v5 *= v4;
                --v6;
            }
            while(v6);
        }
    }
    while(v5 <= a1 [21]);
    v7 = v4 - 1;
    if(v7 < 2) {
        *(_DWORD*) (*a1 + 20) = 55;
        *(_DWORD*) (*a1 + 24) = v5;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    v15 = 1;
    if(v3 > 0) {
        v8 = v3;
        memset32(a2, v7, v3);
        do {
            --v8;
            v15 *= v7;
        }
        while(v8);
    }
    while(1) {
        v17 = 0;
        v16 = 0;
        if(v3 <= 0)
            break;
        while(1) {
            v9 = v16;
            if(v2 [10] == 2)
                v9 = dword_46F868 [v16];
            v10 = (int*) &a2 [4 * v9];
            v11 = *v10 + 1;
            v12 = v11 * (v15 / *v10);
            if(v12 > v14)
                break;
            ++v16;
            *v10 = v11;
            v15 = v12;
            v17 = 1;
            if(v16 >= v3)
                break;
            v2 = a1;
        }
        if(!v17)
            break;
        v2 = a1;
    }
    return v15;
}
// 46F868: using guessed type int dword_46F868[];

//----- (00456DE3) --------------------------------------------------------
int __cdecl sub_456DE3(int a1, int a2, int a3) {
    int v3; // ecx

    return (a3 / 2 + 255 * v3) / a3;
}
// 456DE7: variable 'v3' is possibly undefined

//----- (00456DFC) --------------------------------------------------------
int __usercall sub_456DFC(int a1, int a2) {
    return (510 * a1 + a2 + 255) / (2 * a2);
}

//----- (00456E0F) --------------------------------------------------------
int __usercall sub_456E0F(_DWORD* a1) {
    int v1; // edi
    int v2; // eax
    int* v3; // eax
    int v4; // eax
    int v5; // ecx
    int v6; // ebx
    char v7; // al
    int i; // ecx
    int v9; // edx
    int result; // eax
    int v11; // [esp+8h] [ebp-28h]
    int v12; // [esp+Ch] [ebp-24h]
    _DWORD* v13; // [esp+10h] [ebp-20h]
    int* v14; // [esp+14h] [ebp-1Ch]
    int v15; // [esp+18h] [ebp-18h]
    int v16; // [esp+1Ch] [ebp-14h]
    int v17; // [esp+20h] [ebp-10h]
    int v18; // [esp+24h] [ebp-Ch]
    int v19; // [esp+28h] [ebp-8h]
    int j; // [esp+2Ch] [ebp-4h]

    v12 = a1 [105];
    v1 = sub_456D18(a1, (char*) (v12 + 32));
    v2 = *a1;
    if(a1 [25] == 3) {
        v3 = (int*) (v2 + 24);
        *v3 = v1;
        v3 [1] = *(_DWORD*) (v12 + 32);
        v3 [2] = *(_DWORD*) (v12 + 36);
        v3 [3] = *(_DWORD*) (v12 + 40);
        *(_DWORD*) (*a1 + 20) = 93;
    }
    else {
        *(_DWORD*) (v2 + 20) = 94;
        *(_DWORD*) (*a1 + 24) = v1;
    }
    (*(void(__cdecl**)(_DWORD*, int))(*a1 + 4))(a1, 1);
    v4 = (*(int(__cdecl**)(_DWORD*, int, int, _DWORD))(a1 [1] + 8))(a1, 1, v1, a1 [25]);
    v17 = 0;
    v5 = v4;
    v11 = v4;
    v15 = v1;
    if((int) a1 [25] > 0) {
        v13 = (_DWORD*) v4;
        v14 = (int*) (v12 + 32);
        do {
            v6 = *v14;
            v19 = 0;
            v18 = v15 / *v14;
            if(*v14 > 0) {
                v16 = 0;
                do {
                    v7 = sub_456DE3((int) a1, v17, v6 - 1);
                    for(i = v16; i < v1; i += v15) {
                        for(j = 0; j < v18; *(_BYTE*) (v9 + i) = v7) {
                            v9 = j + *v13;
                            ++j;
                        }
                    }
                    ++v19;
                    v16 += v18;
                }
                while(v19 < v6);
            }
            ++v17;
            ++v14;
            ++v13;
            v15 = v18;
        }
        while(v17 < a1 [25]);
        v5 = v11;
    }
    result = v12;
    *(_DWORD*) (v12 + 20) = v1;
    *(_DWORD*) (v12 + 16) = v5;
    return result;
}

//----- (00456F2C) --------------------------------------------------------
int __usercall sub_456F2C(_DWORD* a1) {
    int v1; // esi
    int v2; // ebx
    int result; // eax
    int v4; // ecx
    _BYTE* v5; // ebx
    int v6; // eax
    int v7; // edx
    int v8; // edx
    int v9; // [esp+8h] [ebp-1Ch]
    int v10; // [esp+Ch] [ebp-18h]
    int* v11; // [esp+10h] [ebp-14h]
    int v12; // [esp+14h] [ebp-10h]
    int v13; // [esp+18h] [ebp-Ch]
    _BYTE* v14; // [esp+18h] [ebp-Ch]
    int v15; // [esp+1Ch] [ebp-8h]
    int i; // [esp+20h] [ebp-4h]
    int v17; // [esp+20h] [ebp-4h]

    v1 = a1 [105];
    if(a1 [19] == 1) {
        v12 = 510;
        *(_BYTE*) (v1 + 28) = 1;
    }
    else {
        v12 = 0;
        *(_BYTE*) (v1 + 28) = 0;
    }
    v2 = 0;
    *(_DWORD*) (v1 + 24) = (*(int(__cdecl**)(_DWORD*, int, int, _DWORD))(a1 [1] + 8))(a1, 1, v12 + 256, a1 [25]);
    result = *(_DWORD*) (v1 + 20);
    v15 = 0;
    if((int) a1 [25] > 0) {
        v11 = (int*) (v1 + 32);
        while(1) {
            v4 = *v11;
            v10 = result / *v11;
            if(v12)
                *(_DWORD*) (*(_DWORD*) (v1 + 24) + 4 * v2) += 255;
            v5 = *(_BYTE**) (*(_DWORD*) (v1 + 24) + 4 * v2);
            v13 = 0;
            v9 = v4 - 1;
            v6 = sub_456DFC(0, v4 - 1);
            for(i = 0; i <= 255; ++i) {
                while(i > v6)
                    v6 = sub_456DFC(++v13, v9);
                v7 = i;
                v5 [v7] = v13 * v10;
            }
            if(v12) {
                v17 = 1;
                v14 = v5 - 1;
                do {
                    *v14 = *v5;
                    v8 = v17++;
                    --v14;
                    v5 [v8 + 255] = v5 [255];
                }
                while(v17 <= 255);
            }
            result = ++v15;
            ++v11;
            if(v15 >= a1 [25])
                break;
            result = v10;
            v2 = v15;
        }
    }
    return result;
}

//----- (0045704D) --------------------------------------------------------
int* __usercall sub_45704D(int a1, int a2) {
    int* v3; // edi
    int v4; // ebx
    unsigned __int8* v5; // esi
    int i; // ecx
    int v7; // eax
    int* v9; // [esp+Ch] [ebp-4h]

    v3 = (int*) (**(int(__cdecl***)(int, int, int))(a1 + 4))(a1, 1, 1024);
    v4 = (a2 << 9) - 512;
    v9 = v3;
    v5 = (unsigned __int8*) &unk_46F768;
    do {
        for(i = 0; i < 16; ++i) {
            v7 = (65025 - 510 * v5 [i]) / v4;
            *v3++ = v7;
        }
        v5 += 16;
    }
    while((int) v5 < (int) dword_46F868);
    return v9;
}
// 46F868: using guessed type int dword_46F868[];

//----- (004570AF) --------------------------------------------------------
void __usercall sub_4570AF(int a1) {
    int v1; // edx
    int v2; // ebx
    int** v3; // esi
    int v4; // ecx
    int v5; // eax
    _DWORD* v6; // edx
    int* v7; // eax
    int v8; // [esp+4h] [ebp-4h]

    v1 = *(_DWORD*) (a1 + 420);
    v2 = 0;
    v8 = v1;
    if(*(int*) (a1 + 100) > 0) {
        v3 = (int**) (v1 + 52);
        while(1) {
            v4 = (int) *(v3 - 5);
            v5 = 0;
            if(v2 <= 0)
                goto LABEL_10;
            v6 = (_DWORD*) (v1 + 32);
            while(v4 != *v6) {
                ++v5;
                ++v6;
                if(v5 >= v2)
                    goto LABEL_10;
            }
            v7 = *(int**) (v8 + 4 * v5 + 52);
            if(!v7)
                LABEL_10:
            v7 = sub_45704D(a1, v4);
            *v3 = v7;
            ++v2;
            ++v3;
            if(v2 >= *(_DWORD*) (a1 + 100))
                break;
            v1 = v8;
        }
    }
}

//----- (00457108) --------------------------------------------------------
int __cdecl sub_457108(_DWORD* a1, int a2, _DWORD* a3, int a4) {
    int v4; // esi
    int result; // eax
    _DWORD* v6; // ecx
    int v7; // edi
    unsigned __int8* v8; // edx
    int v9; // esi
    _BYTE* v10; // esi
    bool v11; // zf
    int v12; // [esp+4h] [ebp-Ch]
    int v13; // [esp+8h] [ebp-8h]
    int v14; // [esp+Ch] [ebp-4h]
    char v15; // [esp+18h] [ebp+8h]
    int v16; // [esp+1Ch] [ebp+Ch]
    int v17; // [esp+20h] [ebp+10h]
    _BYTE* v18; // [esp+24h] [ebp+14h]

    v4 = a1 [23];
    result = a1 [25];
    v14 = *(_DWORD*) (a1 [105] + 24);
    v12 = v4;
    v13 = result;
    if(a4 > 0) {
        v6 = a3;
        v7 = a2 - (_DWORD) a3;
        v16 = a4;
        do {
            v8 = *(unsigned __int8**) ((char*) v6 + v7);
            v18 = (_BYTE*) *v6;
            if(v4) {
                v17 = v4;
                do {
                    v15 = 0;
                    v9 = 0;
                    if(result > 0) {
                        do {
                            v15 += *(_BYTE*) (*(_DWORD*) (v14 + 4 * v9) + *v8);
                            result = v13;
                            ++v8;
                            ++v9;
                        }
                        while(v9 < v13);
                    }
                    v10 = v18++;
                    v11 = v17-- == 1;
                    *v10 = v15;
                }
                while(!v11);
                v4 = v12;
            }
            ++v6;
            --v16;
        }
        while(v16);
    }
    return result;
}

//----- (00457190) --------------------------------------------------------
int __cdecl sub_457190(int a1, int a2, _DWORD* a3, int a4) {
    int* v4; // eax
    int v5; // edx
    int result; // eax
    int v7; // edx
    _DWORD* v8; // edi
    unsigned __int8* v9; // ecx
    _BYTE* v10; // esi
    char v11; // dl
    unsigned __int8* v12; // ecx
    char v13; // dl
    char v14; // al
    int v15; // [esp+0h] [ebp-10h]
    int v16; // [esp+4h] [ebp-Ch]
    int v17; // [esp+8h] [ebp-8h]
    int v18; // [esp+Ch] [ebp-4h]
    int v19; // [esp+18h] [ebp+8h]
    int v20; // [esp+20h] [ebp+10h]

    v4 = *(int**) (*(_DWORD*) (a1 + 420) + 24);
    v18 = *v4;
    v5 = v4 [1];
    result = v4 [2];
    v17 = v5;
    v7 = *(_DWORD*) (a1 + 92);
    v16 = result;
    v15 = v7;
    if(a4 > 0) {
        v8 = a3;
        result = a2 - (_DWORD) a3;
        v20 = a2 - (_DWORD) a3;
        do {
            v9 = *(unsigned __int8**) ((char*) v8 + result);
            v10 = (_BYTE*) *v8;
            if(v7) {
                v19 = v7;
                do {
                    v11 = *(_BYTE*) (*v9 + v18);
                    v12 = v9 + 1;
                    v13 = *(_BYTE*) (*v12++ + v17) + v11;
                    v14 = *(_BYTE*) (*v12 + v16);
                    v9 = v12 + 1;
                    *v10++ = v14 + v13;
                    --v19;
                }
                while(v19);
                v7 = v15;
                result = v20;
            }
            ++v8;
            --a4;
        }
        while(a4);
    }
    return result;
}

//----- (0045721D) --------------------------------------------------------
int __cdecl sub_45721D(_DWORD* a1, int a2, void** a3, int a4) {
    _DWORD* v4; // esi
    int result; // eax
    void** v6; // ebx
    int v7; // edi
    int v8; // eax
    _BYTE* v9; // edi
    unsigned __int8* v10; // eax
    int v11; // ecx
    int v12; // edx
    bool v13; // zf
    char v14; // [esp+4h] [ebp-24h]
    int v15; // [esp+8h] [ebp-20h]
    int v16; // [esp+Ch] [ebp-1Ch]
    int v17; // [esp+10h] [ebp-18h]
    _DWORD* v18; // [esp+14h] [ebp-14h]
    int v19; // [esp+18h] [ebp-10h]
    void** v20; // [esp+1Ch] [ebp-Ch]
    unsigned int v21; // [esp+20h] [ebp-8h]
    int v22; // [esp+24h] [ebp-4h]
    int v23; // [esp+30h] [ebp+8h]
    unsigned int v24; // [esp+34h] [ebp+Ch]
    _DWORD* v25; // [esp+38h] [ebp+10h]
    int v26; // [esp+3Ch] [ebp+14h]

    v4 = (_DWORD*) a1 [105];
    v21 = a1 [23];
    result = a4;
    v22 = a1 [25];
    if(a4 > 0) {
        v6 = a3;
        v7 = a2 - (_DWORD) a3;
        v20 = a3;
        v15 = a2 - (_DWORD) a3;
        v19 = a4;
        do {
            sub_44EE9E(*v6, v21);
            v8 = v4 [12];
            v23 = 0;
            v14 = v8;
            if(v22 > 0) {
                v17 = v8 << 6;
                v18 = (void**) ((char*) v6 + v7);
                v25 = v4 + 13;
                do {
                    v26 = 0;
                    v9 = *v6;
                    v10 = (unsigned __int8*) (v23 + *v18);
                    v16 = *(_DWORD*) (v4 [6] + 4 * v23);
                    v11 = v17 + *v25;
                    if(v21) {
                        v24 = v21;
                        do {
                            v12 = *v10;
                            v10 += v22;
                            *v9++ += *(_BYTE*) (v12 + *(_DWORD*) (v11 + 4 * v26) + v16);
                            v13 = v24-- == 1;
                            v26 = ((_BYTE) v26 + 1) & 0xF;
                        }
                        while(!v13);
                        v6 = v20;
                    }
                    ++v23;
                    ++v25;
                }
                while(v23 < v22);
                v7 = v15;
                LOBYTE(v8) = v14;
            }
            result = ((_BYTE) v8 + 1) & 0xF;
            ++v6;
            v13 = v19-- == 1;
            v4 [12] = result;
            v20 = v6;
        }
        while(!v13);
    }
    return result;
}

//----- (00457308) --------------------------------------------------------
_DWORD* __cdecl sub_457308(int a1, int a2, _BYTE** a3, int a4) {
    _DWORD* result; // eax
    int* v5; // ecx
    int v6; // edx
    unsigned __int8* v7; // ecx
    int v8; // edx
    int v9; // esi
    unsigned __int8* v10; // ecx
    bool v11; // zf
    int v12; // [esp+4h] [ebp-28h]
    int v13; // [esp+8h] [ebp-24h]
    int v14; // [esp+Ch] [ebp-20h]
    int v15; // [esp+10h] [ebp-1Ch]
    int v16; // [esp+14h] [ebp-18h]
    int v17; // [esp+18h] [ebp-14h]
    int v18; // [esp+1Ch] [ebp-10h]
    int v19; // [esp+20h] [ebp-Ch]
    int v20; // [esp+24h] [ebp-8h]
    _BYTE** v21; // [esp+28h] [ebp-4h]
    int v22; // [esp+34h] [ebp+8h]
    int v23; // [esp+38h] [ebp+Ch]
    _BYTE* v24; // [esp+3Ch] [ebp+10h]
    char v25; // [esp+40h] [ebp+14h]
    char v26; // [esp+40h] [ebp+14h]

    result = *(_DWORD**) (a1 + 420);
    v5 = (int*) result [6];
    v16 = *v5;
    v13 = v5 [2];
    v18 = *(_DWORD*) (a1 + 92);
    v15 = v5 [1];
    if(a4 > 0) {
        v6 = a2 - (_DWORD) a3;
        v21 = a3;
        v19 = a2 - (_DWORD) a3;
        v20 = a4;
        while(1) {
            v7 = *(_BYTE**) ((char*) v21 + v6);
            v22 = 0;
            v12 = result [12];
            v24 = *v21;
            v8 = (v12 << 6) + result [14];
            v9 = (v12 << 6) + result [13];
            v17 = v8;
            v14 = (v12 << 6) + result [15];
            if(v18) {
                v23 = v18;
                while(1) {
                    v25 = *(_BYTE*) (*v7 + *(_DWORD*) (v9 + 4 * v22) + v16);
                    v10 = v7 + 1;
                    v26 = *(_BYTE*) (*v10++ + *(_DWORD*) (v8 + 4 * v22) + v15) + v25;
                    *v24 = *(_BYTE*) (*v10 + *(_DWORD*) (v14 + 4 * v22) + v13) + v26;
                    v7 = v10 + 1;
                    ++v24;
                    v11 = v23-- == 1;
                    v22 = ((_BYTE) v22 + 1) & 0xF;
                    if(v11)
                        break;
                    v8 = v17;
                }
            }
            ++v21;
            v11 = v20-- == 1;
            result [12] = ((_BYTE) v12 + 1) & 0xF;
            if(v11)
                break;
            v6 = v19;
        }
    }
    return result;
}

//----- (00457407) --------------------------------------------------------
char __cdecl sub_457407(_DWORD* a1, int a2, void** a3, int a4) {
    int v4; // ebx
    int v5; // eax
    int v7; // esi
    unsigned __int8* v8; // edi
    _BYTE* v9; // esi
    _WORD* v10; // ecx
    int v11; // eax
    int v12; // eax
    int v13; // edx
    bool v14; // zf
    int v16; // [esp+4h] [ebp-3Ch]
    int v17; // [esp+8h] [ebp-38h]
    int v18; // [esp+10h] [ebp-30h]
    int v19; // [esp+14h] [ebp-2Ch]
    int v20; // [esp+18h] [ebp-28h]
    int v21; // [esp+1Ch] [ebp-24h]
    _DWORD* v22; // [esp+20h] [ebp-20h]
    int v23; // [esp+24h] [ebp-1Ch]
    unsigned int v24; // [esp+28h] [ebp-18h]
    int v25; // [esp+2Ch] [ebp-14h]
    __int16 v26; // [esp+30h] [ebp-10h]
    __int16 v27; // [esp+34h] [ebp-Ch]
    unsigned int v28; // [esp+38h] [ebp-8h]
    int v29; // [esp+3Ch] [ebp-4h]
    int v30; // [esp+48h] [ebp+8h]
    int v31; // [esp+4Ch] [ebp+Ch]
    _DWORD* v32; // [esp+50h] [ebp+10h]
    void** v33; // [esp+54h] [ebp+14h]

    v29 = a1 [25];
    v4 = a1 [105];
    v5 = a1 [71];
    v28 = a1 [23];
    v17 = v4;
    v21 = v5;
    if(a4 > 0) {
        v7 = a2 - (_DWORD) a3;
        v33 = a3;
        v16 = a2 - (_DWORD) a3;
        v23 = a4;
        do {
            sub_44EE9E(*v33, v28);
            v30 = 0;
            if(v29 > 0) {
                v22 = (void**) ((char*) v33 + v7);
                v32 = (_DWORD*) (v4 + 68);
                do {
                    v8 = (unsigned __int8*) (v30 + *v22);
                    v9 = *v33;
                    if(*(_BYTE*) (v4 + 84)) {
                        v31 = -1;
                        v9 += v28 - 1;
                        v8 += v29 * (v28 - 1);
                        v25 = -v29;
                        v10 = (_WORD*) (*v32 + 2 * v28 + 2);
                    }
                    else {
                        v25 = v29;
                        v10 = (_WORD*) *v32;
                        v31 = 1;
                    }
                    v20 = *(_DWORD*) (4 * v30 + *(_DWORD*) (v4 + 24));
                    v19 = *(_DWORD*) (4 * v30 + *(_DWORD*) (v4 + 16));
                    v11 = 0;
                    v27 = 0;
                    v26 = 0;
                    if(v28) {
                        v24 = v28;
                        do {
                            v12 = *(unsigned __int8*) (*v8 + (((__int16) v10 [v31] + v11 + 8) >> 4) + v21);
                            v13 = *(unsigned __int8*) (v12 + v20);
                            *v9 += v13;
                            v8 += v25;
                            v9 += v31;
                            v18 = v12 - *(unsigned __int8*) (v13 + v19);
                            *v10 = 3 * v18 + v27;
                            v27 = 5 * v18 + v26;
                            v11 = 7 * v18;
                            v14 = v24-- == 1;
                            v26 = v18;
                            v10 += v31;
                        }
                        while(!v14);
                        v4 = v17;
                    }
                    ++v30;
                    ++v32;
                    *v10 = v27;
                }
                while(v30 < v29);
                v7 = v16;
            }
            LOBYTE(v5) = *(_BYTE*) (v4 + 84) == 0;
            ++v33;
            v14 = v23-- == 1;
            *(_BYTE*) (v4 + 84) = v5;
        }
        while(!v14);
    }
    return v5;
}

//----- (0045758B) --------------------------------------------------------
int __usercall sub_45758B(_DWORD* a1) {
    int result; // eax
    int v2; // edi
    int v3; // ebp
    int* v4; // ebx

    result = a1 [105];
    v2 = 0;
    v3 = 2 * a1 [23] + 4;
    if((int) a1 [25] > 0) {
        v4 = (int*) (result + 68);
        do {
            result = (*(int(__cdecl**)(_DWORD*, int, int))(a1 [1] + 4))(a1, 1, v3);
            *v4 = result;
            ++v2;
            ++v4;
        }
        while(v2 < a1 [25]);
    }
    return result;
}

//----- (004575C1) --------------------------------------------------------
void __cdecl sub_4575C1(_DWORD* a1) {
    int v1; // esi
    int v2; // eax
    int v3; // eax
    void** v4; // ebx
    bool v5; // zf
    int v6; // esi
    unsigned int i; // ebp

    v1 = a1 [105];
    a1 [29] = *(_DWORD*) (v1 + 16);
    a1 [28] = *(_DWORD*) (v1 + 20);
    v2 = a1 [19];
    if(v2) {
        v3 = v2 - 1;
        if(v3) {
            if(v3 == 1) {
                *(_BYTE*) (v1 + 84) = 0;
                v4 = (void**) (v1 + 68);
                v5 = *(_DWORD*) (v1 + 68) == 0;
                *(_DWORD*) (v1 + 4) = sub_457407;
                if(v5)
                    sub_45758B(a1);
                v6 = 0;
                for(i = 2 * a1 [23] + 4; v6 < a1 [25]; ++v4) {
                    sub_44EE9E(*v4, i);
                    ++v6;
                }
            }
            else {
                *(_DWORD*) (*a1 + 20) = 47;
                (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
            }
        }
        else {
            if(a1 [25] == 3)
                *(_DWORD*) (v1 + 4) = sub_457308;
            else
                *(_DWORD*) (v1 + 4) = sub_45721D;
            v5 = *(_BYTE*) (v1 + 28) == 0;
            *(_DWORD*) (v1 + 48) = 0;
            if(v5)
                sub_456F2C(a1);
            if(!*(_DWORD*) (v1 + 52))
                sub_4570AF((int) a1);
        }
    }
    else if(a1 [25] == 3) {
        *(_DWORD*) (v1 + 4) = sub_457190;
    }
    else {
        *(_DWORD*) (v1 + 4) = sub_457108;
    }
}

//----- (00457689) --------------------------------------------------------
int __cdecl sub_457689(int a1) {
    *(_DWORD*) (*(_DWORD*) a1 + 20) = 45;
    return (**(int(__cdecl***)(int))a1)(a1);
}

//----- (0045769D) --------------------------------------------------------
int __cdecl sub_45769D(_DWORD* a1) {
    _DWORD* v1; // eax
    int result; // eax

    v1 = (_DWORD*) (*(int(__cdecl**)(_DWORD*, int, int))a1 [1])(a1, 1, 88);
    a1 [105] = v1;
    v1 [17] = 0;
    v1 [13] = 0;
    *v1 = sub_4575C1;
    v1 [2] = nullsub_1;
    v1 [3] = sub_457689;
    if((int) a1 [25] > 4) {
        *(_DWORD*) (*a1 + 20) = 54;
        *(_DWORD*) (*a1 + 24) = 4;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    if((int) a1 [21] > 256) {
        *(_DWORD*) (*a1 + 20) = 56;
        *(_DWORD*) (*a1 + 24) = 256;
        (*(void(__cdecl**)(_DWORD*)) * a1)(a1);
    }
    sub_456E0F(a1);
    result = sub_456F2C(a1);
    if(a1 [19] == 2)
        return sub_45758B(a1);
    return result;
}
// 444938: using guessed type int __cdecl nullsub_1(_DWORD);

//----- (00457726) --------------------------------------------------------
int(__cdecl* __cdecl sub_457726(_DWORD* a1, int a2, _DWORD* a3))(_DWORD, _DWORD, _DWORD) {
    int v3; // eax
    int(__cdecl * result)(_DWORD, _DWORD, _DWORD); // eax

    if(a3)
        *a3 = a1 [15];
    if(*a1 == 4 || *a1 == 5)
        (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*) (a2 + 40), a1 [3]);
    if(*a1 == 6)
        sub_4591A5(a1 [1], a2);
    v3 = a1 [10];
    a1 [13] = v3;
    a1 [12] = v3;
    result = (int(__cdecl*)(_DWORD, _DWORD, _DWORD))a1 [14];
    *a1 = 0;
    a1 [7] = 0;
    a1 [8] = 0;
    if(result) {
        result = (int(__cdecl*)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
        a1 [15] = result;
        *(_DWORD*) (a2 + 48) = result;
    }
    return result;
}

//----- (00457791) --------------------------------------------------------
_DWORD* __cdecl sub_457791(int a1, int a2, int a3) {
    _DWORD* v3; // edi
    int v4; // eax
    int v5; // eax

    v3 = (_DWORD*) (*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*) (a1 + 40), 1, 64);
    if(!v3)
        return 0;
    v4 = (*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*) (a1 + 40), 8, 1440);
    v3 [9] = v4;
    if(!v4) {
        (*(void(__cdecl**)(_DWORD, _DWORD*))(a1 + 36))(*(_DWORD*) (a1 + 40), v3);
        return 0;
    }
    v5 = (*(int(__cdecl**)(_DWORD, int, int))(a1 + 32))(*(_DWORD*) (a1 + 40), 1, a3);
    v3 [10] = v5;
    if(!v5) {
        (*(void(__cdecl**)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD*) (a1 + 40), v3 [9]);
        (*(void(__cdecl**)(_DWORD, _DWORD*))(a1 + 36))(*(_DWORD*) (a1 + 40), v3);
        return 0;
    }
    *v3 = 0;
    v3 [11] = a3 + v5;
    v3 [14] = a2;
    sub_457726(v3, a1, 0);
    return v3;
}

//----- (0045781C) --------------------------------------------------------
int __cdecl sub_45781C(int* a1, int a2, int a3) {
    int v3; // ecx
    unsigned int v5; // eax
    unsigned int v6; // ecx
    unsigned int v7; // eax
    int v8; // eax
    unsigned int v9; // edi
    unsigned __int8* v10; // edx
    unsigned int v11; // esi
    int v12; // eax
    int v13; // eax
    int v14; // eax
    int v15; // eax
    int* v16; // eax
    unsigned int i; // esi
    int v18; // eax
    int v19; // eax
    unsigned int v20; // edi
    int v21; // ecx
    unsigned int v22; // ecx
    int v23; // eax
    int v24; // eax
    unsigned int v25; // ecx
    int v26; // ecx
    unsigned int v27; // edx
    unsigned int v28; // eax
    unsigned int v29; // esi
    int v30; // esi
    unsigned int v31; // edx
    unsigned int v32; // eax
    unsigned int v33; // edi
    unsigned int v34; // edi
    unsigned int v35; // eax
    const void* v36; // esi
    void* v37; // edi
    unsigned int v38; // ecx
    unsigned __int8* v39; // edi
    int v40; // eax
    unsigned int v41; // eax
    unsigned int v42; // ecx
    unsigned int v43; // eax
    int v44; // eax
    unsigned int j; // ecx
    int v46; // eax
    int v47; // ecx
    char v48; // al
    int v49; // edx
    unsigned int v50; // ecx
    unsigned int v51; // eax
    int v52; // edx
    int v53; // eax
    int v54; // ecx
    unsigned int v55; // edx
    int v56; // eax
    int v57; // edx
    int v58; // ecx
    int v59; // eax
    unsigned int v60; // eax
    int v61; // eax
    int v62; // eax
    unsigned int v63; // eax
    int v64; // eax
    unsigned int v65; // edi
    unsigned int v66; // ecx
    unsigned int v67; // eax
    int v68; // eax
    unsigned __int8* v69; // ecx
    unsigned int v70; // eax
    int v71; // ecx
    unsigned int v72; // eax
    unsigned int v74; // ecx
    unsigned __int8* v75; // ecx
    int v76; // ecx
    unsigned __int8* v77; // eax
    bool v78; // zf
    unsigned __int8* v79; // eax
    unsigned __int8* v80; // eax
    unsigned int v81; // eax
    int v82; // eax
    unsigned int v83; // ecx
    unsigned int v84; // ecx
    int v85; // edx
    int v86; // [esp-28h] [ebp-64h]
    _DWORD* v87; // [esp-1Ch] [ebp-58h]
    _DWORD* v88; // [esp-14h] [ebp-50h]
    int v89; // [esp-8h] [ebp-44h]
    int v90; // [esp-8h] [ebp-44h]
    int* v91; // [esp-8h] [ebp-44h]
    int v92; // [esp-4h] [ebp-40h]
    int v93; // [esp-4h] [ebp-40h]
    int v94; // [esp+Ch] [ebp-30h] BYREF
    int v95; // [esp+10h] [ebp-2Ch] BYREF
    int v96; // [esp+14h] [ebp-28h] BYREF
    int v97; // [esp+18h] [ebp-24h] BYREF
    int v98; // [esp+1Ch] [ebp-20h] BYREF
    int v99; // [esp+20h] [ebp-1Ch] BYREF
    unsigned int v100; // [esp+24h] [ebp-18h] BYREF
    unsigned int v101; // [esp+28h] [ebp-14h]
    int v102; // [esp+2Ch] [ebp-10h] BYREF
    unsigned int v103; // [esp+30h] [ebp-Ch]
    unsigned int v104; // [esp+34h] [ebp-8h]
    unsigned int v105; // [esp+38h] [ebp-4h]
    unsigned int v106; // [esp+44h] [ebp+8h]
    unsigned int v107; // [esp+44h] [ebp+8h]

    v3 = *(_DWORD*) a2;
    v104 = *(_DWORD*) (a2 + 4);
    v106 = a1 [8];
    v5 = a1 [7];
    v102 = v3;
    v6 = a1 [13];
    v105 = v5;
    v7 = a1 [12];
    v103 = v6;
    if(v6 >= v7)
        v8 = a1 [11] - v6;
    else
        v8 = v7 - v6 - 1;
    v101 = v8;
    while(2) {
        switch(*a1) {
            case 0:
                v9 = v105;
                v10 = (unsigned __int8*) v102;
                v11 = v106;
                while(v9 < 3) {
                    if(!v104) {
                        v16 = (int*) a2;
                        a1 [8] = v11;
                        a1 [7] = v9;
                        v69 = &v10 [-*(_DWORD*) a2];
                        *(_DWORD*) a2 = v10;
                        goto LABEL_112;
                    }
                    v12 = *v10;
                    a3 = 0;
                    --v104;
                    v11 |= v12 << v9;
                    ++v10;
                    v9 += 8;
                    v106 = v11;
                    v102 = (int) v10;
                    v105 = v9;
                }
                v13 = (unsigned __int8) (v11 & 7) >> 1;
                a1 [6] = v11 & 1;
                if(!v13) {
                    v20 = v9 - 3;
                    v21 = v20 & 7;
                    v105 = v20 - v21;
                    *a1 = 1;
                    v106 = v11 >> 3 >> v21;
                    continue;
                }
                v14 = v13 - 1;
                if(v14) {
                    v15 = v14 - 1;
                    if(!v15) {
                        v18 = 3;
                        v106 = v11 >> 3;
                        v105 = v9 - 3;
                        goto LABEL_26;
                    }
                    if(v15 != 1)
                        continue;
                    v16 = (int*) a2;
                    i = v11 >> 3;
                    *a1 = 9;
                    *(_DWORD*) (a2 + 24) = "invalid block type";
                    a1 [7] = v9 - 3;
                    goto LABEL_107;
                }
                sub_4596BD(&v96, &v97, &v98, &v99);
                v19 = sub_458C1B(v96, v97, v98, v99, a2);
                a1 [1] = v19;
                if(v19) {
                    v105 -= 3;
                    v106 = v11 >> 3;
                    *a1 = 6;
                    continue;
                }
                a1 [7] = v105;
                v70 = v104;
                a1 [8] = v11;
                *(_DWORD*) (a2 + 4) = v70;
                v71 = v102 - *(_DWORD*) a2;
                *(_DWORD*) a2 = v102;
                v72 = v103;
                *(_DWORD*) (a2 + 8) += v71;
                a1 [13] = v72;
                return sub_4596EC(a1, (_DWORD*) a2, -4);
            case 1:
                v22 = v105;
                v10 = (unsigned __int8*) v102;
                for(i = v106; v22 < 0x20; v102 = (int) v10) {
                    if(!v104) {
                        v16 = (int*) a2;
                        a1 [7] = v22;
                        a1 [8] = i;
                        v69 = &v10 [-*(_DWORD*) a2];
                        *(_DWORD*) (a2 + 4) = 0;
                        *(_DWORD*) a2 = v10;
                        goto LABEL_113;
                    }
                    v23 = *v10;
                    --v104;
                    v24 = v23 << v22;
                    v22 += 8;
                    a3 = 0;
                    i |= v24;
                    ++v10;
                }
                if(~i >> 16 != (unsigned __int16) i) {
                    v16 = (int*) a2;
                    *a1 = 9;
                    *(_DWORD*) (a2 + 24) = "invalid stored block lengths";
                    a1 [7] = v22;
                    LABEL_107:
                    v74 = v104;
                    a1 [8] = i;
                    v16 [1] = v74;
                    v75 = &v10 [-*v16];
                    *v16 = (int) v10;
                    goto LABEL_116;
                }
                a1 [1] = (unsigned __int16) i;
                v78 = a1 [1] == 0;
                v105 = 0;
                v106 = 0;
                if(v78)
                    goto LABEL_25;
                v18 = 2;
                goto LABEL_26;
            case 2:
                if(!v104) {
                    v92 = a3;
                    a1 [8] = v106;
                    a1 [7] = v105;
                    v16 = (int*) a2;
                    *(_DWORD*) (a2 + 4) = 0;
                    LABEL_137:
                    v85 = v102 - *v16;
                    *v16 = v102;
                    v16 [2] += v85;
                    goto LABEL_138;
                }
                v25 = v101;
                if(!v101) {
                    v26 = a1 [11];
                    v27 = v103;
                    if(v103 != v26)
                        goto LABEL_35;
                    v28 = a1 [12];
                    v29 = a1 [10];
                    if(v28 == v29)
                        goto LABEL_35;
                    v27 = a1 [10];
                    v103 = v27;
                    v25 = v29 >= v28 ? v26 - v29 : v28 - v29 - 1;
                    v101 = v25;
                    if(!v25) {
                        LABEL_35:
                        v30 = a2;
                        a1 [13] = v27;
                        a3 = sub_4596EC(a1, (_DWORD*) a2, a3);
                        v32 = a1 [12];
                        v103 = a1 [13];
                        v31 = v103;
                        if(v103 >= v32)
                            v25 = a1 [11] - v103;
                        else
                            v25 = v32 - v103 - 1;
                        v33 = a1 [11];
                        v101 = v25;
                        v100 = v33;
                        if(v103 == v33) {
                            v34 = a1 [10];
                            if(v32 != v34) {
                                v31 = a1 [10];
                                v103 = v31;
                                if(v34 >= v32)
                                    v25 = v100 - v34;
                                else
                                    v25 = v32 - v34 - 1;
                                v101 = v25;
                            }
                        }
                        if(!v25) {
                            a1 [8] = v106;
                            a1 [7] = v105;
                            *(_DWORD*) (a2 + 4) = v104;
                            v76 = v102 - *(_DWORD*) a2;
                            *(_DWORD*) a2 = v102;
                            *(_DWORD*) (a2 + 8) += v76;
                            a1 [13] = v31;
                            goto LABEL_110;
                        }
                    }
                }
                v35 = a1 [1];
                a3 = 0;
                if(v35 > v104)
                    v35 = v104;
                if(v35 > v25)
                    v35 = v25;
                v36 = (const void*) v102;
                v37 = (void*) v103;
                v102 += v35;
                v104 -= v35;
                v103 += v35;
                v101 -= v35;
                qmemcpy(v37, v36, v35);
                v78 = a1 [1] == v35;
                a1 [1] -= v35;
                if(v78) {
                    LABEL_25:
                    v18 = a1 [6] != 0 ? 7 : 0;
                    LABEL_26:
                    *a1 = v18;
                }
                continue;
            case 3:
                v38 = v105;
                v39 = (unsigned __int8*) v102;
                while(2) {
                    if(v38 < 0xE) {
                        if(v104) {
                            v40 = *v39;
                            a3 = 0;
                            --v104;
                            v106 |= v40 << v38;
                            ++v39;
                            v38 += 8;
                            v105 = v38;
                            continue;
                        }
                        a1 [8] = v106;
                        a1 [7] = v105;
                        v16 = (int*) a2;
                        v69 = &v39 [-*(_DWORD*) a2];
                        *(_DWORD*) a2 = v39;
                        LABEL_112:
                        v16 [1] = 0;
                        LABEL_113:
                        v16 [2] += (int) v69;
                        v92 = a3;
                        goto LABEL_138;
                    }
                    break;
                }
                v41 = v106 & 0x3FFF;
                v42 = v106 & 0x1F;
                a1 [1] = v41;
                if(v42 > 0x1D || (v43 = (v41 >> 5) & 0x1F, v43 > 0x1D)) {
                    v16 = (int*) a2;
                    *a1 = 9;
                    *(_DWORD*) (a2 + 24) = "too many length or distance symbols";
                    a1 [8] = v106;
                    a1 [7] = v105;
                    *(_DWORD*) (a2 + 4) = v104;
                    v75 = &v39 [-*(_DWORD*) a2];
                    *(_DWORD*) a2 = v39;
                    LABEL_116:
                    v16 [2] += (int) v75;
                    v92 = -3;
                    LABEL_138:
                    v83 = v103;
                    v91 = v16;
                    LABEL_139:
                    a1 [13] = v83;
                    return sub_4596EC(a1, v91, v92);
                }
                v30 = a2;
                v44 = (*(int(__cdecl**)(_DWORD, unsigned int, int))(a2 + 32))(*(_DWORD*) (a2 + 40), v43 + v42 + 258, 4);
                a1 [3] = v44;
                if(!v44)
                    goto LABEL_114;
                v106 >>= 14;
                v105 -= 14;
                a1 [2] = 0;
                *a1 = 4;
                LABEL_60:
                if(a1 [2] >= ((unsigned int) a1 [1] >> 10) + 4) {
                    LABEL_68:
                    while((unsigned int) a1 [2] < 0x13)
                        *(_DWORD*) (a1 [3] + 4 * dword_46F878 [a1 [2]++]) = 0;
                    v89 = a1 [9];
                    v88 = (_DWORD*) a1 [3];
                    a1 [4] = 7;
                    v101 = sub_45953B(v88, (unsigned int*) a1 + 4, a1 + 5, v89, v30);
                    if(v101) {
                        (*(void(__cdecl**)(_DWORD, int))(v30 + 36))(*(_DWORD*) (v30 + 40), a1 [3]);
                        v78 = v101 == -3;
                        LABEL_118:
                        if(v78)
                            *a1 = 9;
                        v93 = v101;
                        a1 [8] = v106;
                        a1 [7] = v105;
                        *(_DWORD*) (v30 + 4) = v104;
                        v79 = &v39 [-*(_DWORD*) v30];
                        *(_DWORD*) v30 = v39;
                        *(_DWORD*) (v30 + 8) += v79;
                        a1 [13] = v103;
                        return sub_4596EC(a1, (_DWORD*) v30, v93);
                    }
                    a1 [2] = 0;
                    *a1 = 5;
                    LABEL_92:
                    while(a1 [2] < (((unsigned int) a1 [1] >> 5) & 0x1F) + (a1 [1] & 0x1F) + 258) {
                        v51 = a1 [4];
                        while(v105 < v51) {
                            if(!v104)
                                goto LABEL_121;
                            v52 = *v39;
                            a3 = 0;
                            --v104;
                            v106 |= v52 << v105;
                            ++v39;
                            v105 += 8;
                        }
                        v53 = a1 [5] + 8 * (v106 & dword_47A5D8 [v51]);
                        v54 = *(unsigned __int8*) (v53 + 1);
                        v55 = *(_DWORD*) (v53 + 4);
                        v101 = v54;
                        v100 = v55;
                        if(v55 >= 0x10) {
                            if(v55 == 18)
                                v56 = 7;
                            else
                                v56 = v55 - 14;
                            v102 = 8 * (v55 == 18) + 3;
                            while(v105 < v56 + v101) {
                                if(!v104)
                                    goto LABEL_121;
                                v57 = *v39;
                                a3 = 0;
                                --v104;
                                v106 |= v57 << v105;
                                ++v39;
                                v105 += 8;
                            }
                            v107 = v106 >> v101;
                            v102 += v107 & dword_47A5D8 [v56];
                            v106 = v107 >> v56;
                            v105 -= v101 + v56;
                            v58 = a1 [2];
                            if(v58 + v102 > (((unsigned int) a1 [1] >> 5) & 0x1F) + (a1 [1] & 0x1F) + 258) {
                                LABEL_122:
                                (*(void(__cdecl**)(_DWORD, int))(v30 + 36))(*(_DWORD*) (v30 + 40), a1 [3]);
                                *a1 = 9;
                                *(_DWORD*) (v30 + 24) = "invalid bit length repeat";
                                a1 [8] = v106;
                                a1 [7] = v105;
                                *(_DWORD*) (v30 + 4) = v104;
                                *(_DWORD*) (v30 + 8) += &v39 [-*(_DWORD*) v30];
                                v81 = v103;
                                *(_DWORD*) v30 = v39;
                                a1 [13] = v81;
                                return sub_4596EC(a1, (_DWORD*) v30, -3);
                            }
                            if(v100 == 16) {
                                if(!v58)
                                    goto LABEL_122;
                                v59 = *(_DWORD*) (a1 [3] + 4 * v58 - 4);
                            }
                            else {
                                v59 = 0;
                            }
                            do {
                                *(_DWORD*) (a1 [3] + 4 * v58++) = v59;
                                --v102;
                            }
                            while(v102);
                            a1 [2] = v58;
                        }
                        else {
                            v106 >>= v54;
                            v105 -= v54;
                            *(_DWORD*) (a1 [3] + 4 * a1 [2]++) = v55;
                        }
                    }
                    v60 = a1 [1];
                    a1 [5] = 0;
                    v90 = a1 [9];
                    v87 = (_DWORD*) a1 [3];
                    v100 = 9;
                    v102 = 6;
                    v61 = sub_4595BA(
                        (v60 & 0x1F) + 257,
                        ((v60 >> 5) & 0x1F) + 1,
                        v87,
                        &v100,
                        (unsigned int*) &v102,
                        &v94,
                        &v95,
                        v90,
                        v30);
                    v86 = a1 [3];
                    v101 = v61;
                    (*(void(__cdecl**)(_DWORD, int))(v30 + 36))(*(_DWORD*) (v30 + 40), v86);
                    if(v101) {
                        v78 = v101 == -3;
                        goto LABEL_118;
                    }
                    v62 = sub_458C1B(v100, v102, v94, v95, v30);
                    if(!v62) {
                        LABEL_114:
                        a1 [8] = v106;
                        a1 [7] = v105;
                        *(_DWORD*) (v30 + 4) = v104;
                        v77 = &v39 [-*(_DWORD*) v30];
                        *(_DWORD*) v30 = v39;
                        *(_DWORD*) (v30 + 8) += v77;
                        a1 [13] = v103;
                        v93 = -4;
                        return sub_4596EC(a1, (_DWORD*) v30, v93);
                    }
                    a1 [1] = v62;
                    *a1 = 6;
                    LABEL_97:
                    a1 [8] = v106;
                    a1 [7] = v105;
                    *(_DWORD*) (v30 + 4) = v104;
                    *(_DWORD*) (v30 + 8) += &v39 [-*(_DWORD*) v30];
                    v63 = v103;
                    *(_DWORD*) v30 = v39;
                    a1 [13] = v63;
                    v64 = sub_458C4F(a1, v30, a3);
                    if(v64 != 1) {
                        v93 = v64;
                        return sub_4596EC(a1, (_DWORD*) v30, v93);
                    }
                    a3 = 0;
                    sub_4591A5(a1 [1], v30);
                    v65 = *(_DWORD*) v30;
                    v104 = *(_DWORD*) (v30 + 4);
                    v106 = a1 [8];
                    v66 = a1 [13];
                    v105 = a1 [7];
                    v67 = a1 [12];
                    v102 = v65;
                    v103 = v66;
                    if(v66 >= v67)
                        v68 = a1 [11] - v66;
                    else
                        v68 = v67 - v66 - 1;
                    v78 = a1 [6] == 0;
                    v101 = v68;
                    if(!v78) {
                        *a1 = 7;
                        LABEL_128:
                        a1 [13] = v66;
                        v82 = sub_4596EC(a1, (_DWORD*) v30, a3);
                        v83 = a1 [13];
                        if(a1 [12] == v83) {
                            *a1 = 8;
                            LABEL_132:
                            a1 [8] = v106;
                            a1 [7] = v105;
                            *(_DWORD*) (v30 + 4) = v104;
                            v92 = 1;
                            *(_DWORD*) (v30 + 8) += v65 - *(_DWORD*) v30;
                        }
                        else {
                            a1 [8] = v106;
                            a1 [7] = v105;
                            *(_DWORD*) (v30 + 4) = v104;
                            v92 = v82;
                            *(_DWORD*) (v30 + 8) += v65 - *(_DWORD*) v30;
                        }
                        *(_DWORD*) v30 = v65;
                        v91 = (int*) v30;
                        goto LABEL_139;
                    }
                    *a1 = 0;
                    continue;
                }
                LABEL_61:
                for(j = v105; ; v105 = j) {
                    if(j >= 3) {
                        v47 = dword_46F878 [a1 [2]];
                        v48 = v106;
                        v49 = a1 [3];
                        v106 >>= 3;
                        v105 -= 3;
                        *(_DWORD*) (v49 + 4 * v47) = v48 & 7;
                        v50 = a1 [1];
                        if(++a1 [2] >= (v50 >> 10) + 4)
                            goto LABEL_68;
                        goto LABEL_61;
                    }
                    if(!v104)
                        break;
                    v46 = *v39;
                    a3 = 0;
                    --v104;
                    v106 |= v46 << j;
                    ++v39;
                    j += 8;
                }
                LABEL_121:
                a1 [8] = v106;
                a1 [7] = v105;
                *(_DWORD*) (v30 + 4) = 0;
                v80 = &v39 [-*(_DWORD*) v30];
                *(_DWORD*) v30 = v39;
                *(_DWORD*) (v30 + 8) += v80;
                a1 [13] = v103;
                LABEL_110:
                v93 = a3;
                return sub_4596EC(a1, (_DWORD*) v30, v93);
            case 4:
                v39 = (unsigned __int8*) v102;
                v30 = a2;
                goto LABEL_60;
            case 5:
                v39 = (unsigned __int8*) v102;
                v30 = a2;
                goto LABEL_92;
            case 6:
                v39 = (unsigned __int8*) v102;
                v30 = a2;
                goto LABEL_97;
            case 7:
                v66 = v103;
                v65 = v102;
                v30 = a2;
                goto LABEL_128;
            case 8:
                v83 = v103;
                v65 = v102;
                v30 = a2;
                goto LABEL_132;
            case 9:
                v92 = -3;
                goto LABEL_136;
            default:
                v92 = -2;
                LABEL_136:
                v84 = v104;
                a1 [8] = v106;
                a1 [7] = v105;
                v16 = (int*) a2;
                *(_DWORD*) (a2 + 4) = v84;
                goto LABEL_137;
        }
    }
}
// 46F878: using guessed type int dword_46F878[19];
// 47A5D8: using guessed type int dword_47A5D8[19];

//----- (00458135) --------------------------------------------------------
int __cdecl sub_458135(_DWORD* a1, int a2) {
    sub_457726(a1, a2, 0);
    (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*) (a2 + 40), a1 [10]);
    (*(void(__cdecl**)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD*) (a2 + 40), a1 [9]);
    (*(void(__cdecl**)(_DWORD, _DWORD*))(a2 + 36))(*(_DWORD*) (a2 + 40), a1);
    return 0;
}

//----- (00458169) --------------------------------------------------------
int __cdecl sub_458169(unsigned int a1, unsigned __int8* a2, unsigned int a3) {
    unsigned __int8* v3; // ecx
    unsigned int v4; // esi
    unsigned int v5; // edi
    int v7; // edx
    unsigned int v8; // eax
    int v9; // esi
    int v10; // edi
    int v11; // esi
    int v12; // edi
    int v13; // esi
    int v14; // edi
    int v15; // esi
    int v16; // edi
    int v17; // esi
    int v18; // edi
    int v19; // esi
    int v20; // edi
    int v21; // esi
    int v22; // edi
    int v23; // esi
    int v24; // edi
    int v25; // esi
    int v26; // edi
    int v27; // esi
    int v28; // edi
    int v29; // esi
    int v30; // edi
    int v31; // esi
    int v32; // edi
    int v33; // esi
    int v34; // edi
    int v35; // esi
    int v36; // edi
    int v37; // esi
    int v38; // edi

    v3 = a2;
    v4 = (unsigned __int16) a1;
    v5 = HIWORD(a1);
    if(!a2)
        return 1;
    for(; a3; v5 %= 0xFFF1u) {
        v7 = 5552;
        if(a3 < 0x15B0)
            v7 = a3;
        a3 -= v7;
        if(v7 >= 16) {
            v8 = (unsigned int) v7 >> 4;
            v7 += -16 * ((unsigned int) v7 >> 4);
            do {
                v9 = *v3 + v4;
                v10 = v9 + v5;
                v11 = v3 [1] + v9;
                v12 = v11 + v10;
                v13 = v3 [2] + v11;
                v14 = v13 + v12;
                v15 = v3 [3] + v13;
                v16 = v15 + v14;
                v17 = v3 [4] + v15;
                v18 = v17 + v16;
                v19 = v3 [5] + v17;
                v20 = v19 + v18;
                v21 = v3 [6] + v19;
                v22 = v21 + v20;
                v23 = v3 [7] + v21;
                v24 = v23 + v22;
                v25 = v3 [8] + v23;
                v26 = v25 + v24;
                v27 = v3 [9] + v25;
                v28 = v27 + v26;
                v29 = v3 [10] + v27;
                v30 = v29 + v28;
                v31 = v3 [11] + v29;
                v32 = v31 + v30;
                v33 = v3 [12] + v31;
                v34 = v33 + v32;
                v35 = v3 [13] + v33;
                v36 = v35 + v34;
                v37 = v3 [14] + v35;
                v38 = v37 + v36;
                v4 = v3 [15] + v37;
                v5 = v4 + v38;
                v3 += 16;
                --v8;
            }
            while(v8);
        }
        for(; v7; --v7) {
            v4 += *v3++;
            v5 += v4;
        }
        v4 %= 0xFFF1u;
    }
    return v4 | (v5 << 16);
}

//----- (00458282) --------------------------------------------------------
int __cdecl sub_458282(int a1, int a2, int a3) {
    return sub_45E194(a2, a3);
}

//----- (00458292) --------------------------------------------------------
_BYTE* __cdecl sub_458292(int a1, int a2, int a3, int a4, int a5) {
    int v5; // ecx
    int v6; // edx
    unsigned __int16* v7; // esi
    char* v8; // edi
    _WORD* v9; // ecx
    unsigned __int16 v10; // ax
    unsigned __int16 v11; // bx
    __int16 v12; // ax
    unsigned __int16 v13; // bx
    bool v14; // zf
    int v15; // eax
    int v16; // eax
    int v17; // edx
    int v18; // eax
    int v19; // esi
    int v20; // eax
    int v21; // edi
    int v22; // edx
    int v23; // edi
    int v24; // ebx
    int v25; // esi
    int v26; // esi
    int v27; // eax
    char* v28; // ecx
    int v29; // ebx
    _BYTE* result; // eax
    char v31; // bl
    int v32; // esi
    int v33; // edx
    int v34; // edi
    int v35; // edx
    int v36; // esi
    int v37; // ebx
    int v38; // esi
    int v39; // edx
    int v40; // ebx
    int v41; // edi
    int v42; // edi
    char v43; // [esp+Ch] [ebp-98h] BYREF
    char v44 [96]; // [esp+2Ch] [ebp-78h] BYREF
    int v45; // [esp+8Ch] [ebp-18h]
    unsigned __int16* v46; // [esp+90h] [ebp-14h]
    char* v47; // [esp+94h] [ebp-10h]
    int v48; // [esp+98h] [ebp-Ch]
    int v49; // [esp+9Ch] [ebp-8h]
    int v50; // [esp+A0h] [ebp-4h]
    int v51; // [esp+ACh] [ebp+8h]
    int v52; // [esp+ACh] [ebp+8h]
    __int16 v53; // [esp+B0h] [ebp+Ch]
    __int16 v54; // [esp+B0h] [ebp+Ch]
    int v55; // [esp+B0h] [ebp+Ch]
    unsigned __int16 v56; // [esp+B4h] [ebp+10h]
    __int16 v57; // [esp+B4h] [ebp+10h]
    int v58; // [esp+B4h] [ebp+10h]
    int v59; // [esp+B4h] [ebp+10h]

    v5 = *(_DWORD*) (a2 + 80);
    v6 = *(_DWORD*) (a1 + 284) + 128;
    v7 = (unsigned __int16*) (a3 + 96);
    v8 = v44;
    v48 = v6;
    v51 = 8;
    v47 = v44;
    v46 = (unsigned __int16*) (a3 + 96);
    v9 = (_WORD*) (v5 + 96);
    do {
        if(v51 != 4) {
            v56 = v7 [8];
            v10 = *v7;
            v53 = *(v7 - 8);
            LOWORD(v50) = *(v7 - 24);
            v11 = *(v7 - 40);
            v45 = v10;
            v49 = v11;
            v12 = v53 | v50 | v11 | v10;
            v13 = *(v7 - 32);
            v14 = (v13 | (unsigned __int16) (v56 | v12)) == 0;
            v15 = (__int16) *(v9 - 48);
            if(v14) {
                v16 = 4 * (__int16) *(v7 - 48) * v15;
                *((_DWORD*) v8 - 8) = v16;
                *(_DWORD*) v8 = v16;
                *((_DWORD*) v8 + 16) = v16;
            }
            else {
                v17 = 15137 * (__int16) (v13 * *(v9 - 32)) - 6270 * (__int16) (v45 * *v9);
                v18 = ((__int16) *(v7 - 48) * v15) << 14;
                v19 = v17 + v18;
                v20 = v18 - v17;
                LOWORD(v17) = v56 * v9 [8];
                v57 = v50 * *(v9 - 24);
                v54 = v53 * *(v9 - 8);
                v49 = (__int16) v49 * (__int16) *(v9 - 40);
                v21 = v57;
                v50 = (__int16) v49;
                v58 = (__int16) v17;
                v22 = 8697 * (__int16) v49 + 11893 * v54 - 1730 * (__int16) v17 - 17799 * v21;
                v23 = 20995 * (__int16) v49 + 7373 * v21 - 4926 * v54 - 4176 * v58;
                v24 = v19 + v23 + 2048;
                v25 = v19 - v23;
                v8 = v47;
                *((_DWORD*) v47 - 8) = v24 >> 12;
                *((_DWORD*) v8 + 16) = (v25 + 2048) >> 12;
                v26 = v20 + v22 + 2048;
                v27 = v20 - v22;
                v6 = v48;
                *(_DWORD*) v8 = v26 >> 12;
                v7 = v46;
                v16 = (v27 + 2048) >> 12;
            }
            *((_DWORD*) v8 + 8) = v16;
        }
        ++v7;
        v8 += 4;
        ++v9;
        --v51;
        v46 = v7;
        v47 = v8;
    }
    while(v51 > 0);
    v52 = 0;
    v28 = &v43;
    do {
        v29 = *((_DWORD*) v28 + 5);
        result = (_BYTE*) (a5 + *(_DWORD*) (a4 + 4 * v52));
        if(*((_DWORD*) v28 + 2) | *((_DWORD*) v28 + 6) | *((_DWORD*) v28 + 7) | v29 | *((_DWORD*) v28 + 3) | *((_DWORD*) v28 + 1)) {
            v32 = 15137 * *((__int16*) v28 + 4) - 6270 * *((__int16*) v28 + 12);
            v33 = *(_DWORD*) v28 << 14;
            v34 = v32 + v33;
            v35 = v33 - v32;
            v50 = *((__int16*) v28 + 2);
            v59 = *((__int16*) v28 + 14);
            v55 = (__int16) v29;
            v36 = 8697 * v50 + 11893 * (__int16) v29 - 1730 * v59;
            v49 = v35;
            v37 = *((__int16*) v28 + 6);
            v38 = v36 - 17799 * v37;
            v39 = 20995 * v50 + 7373 * v37 - 4926 * v55 - 4176 * v59;
            v40 = (v34 + v39 + 0x40000) >> 19;
            v41 = v34 - v39;
            v6 = v48;
            *result = *(_BYTE*) ((v40 & 0x3FF) + v48);
            LOBYTE(v40) = *(_BYTE*) ((((v41 + 0x40000) >> 19) & 0x3FF) + v6);
            v42 = v49;
            result [3] = v40;
            result [1] = *(_BYTE*) ((((v42 + v38 + 0x40000) >> 19) & 0x3FF) + v6);
            v31 = *(_BYTE*) ((((v42 - v38 + 0x40000) >> 19) & 0x3FF) + v6);
        }
        else {
            v31 = *(_BYTE*) ((((*(_DWORD*) v28 + 16) >> 5) & 0x3FF) + v6);
            *result = v31;
            result [1] = v31;
            result [3] = v31;
        }
        v28 += 32;
        ++v52;
        result [2] = v31;
    }
    while(v52 < 4);
    return result;
}

//----- (004585A7) --------------------------------------------------------
char* __cdecl sub_4585A7(int a1, int a2, int a3, int a4, int a5) {
    int v5; // ecx
    int v6; // ebx
    char* v7; // edi
    _WORD* v8; // esi
    _WORD* v9; // ecx
    int v10; // eax
    int v11; // edx
    int v12; // eax
    int v13; // eax
    int v14; // edx
    char* result; // eax
    _BYTE* v16; // edi
    int v17; // ecx
    char v18; // cl
    int v19; // ecx
    int v20; // esi
    char v21 [64]; // [esp+Ch] [ebp-48h] BYREF
    int v22; // [esp+4Ch] [ebp-8h]
    char* v23; // [esp+50h] [ebp-4h]
    int v24; // [esp+5Ch] [ebp+8h]
    int v25; // [esp+5Ch] [ebp+8h]

    v5 = *(_DWORD*) (a2 + 80);
    v6 = *(_DWORD*) (a1 + 284) + 128;
    v7 = v21;
    v8 = (_WORD*) (a3 + 48);
    v22 = v6;
    v23 = v21;
    v24 = 8;
    v9 = (_WORD*) (v5 + 48);
    do {
        if(v24 != 6 && v24 != 4 && v24 != 2) {
            v10 = (__int16) *(v9 - 24);
            v11 = (__int16) *(v8 - 24);
            if(*v8 | (unsigned __int16) (*(v8 - 16) | v8 [16] | v8 [32])) {
                v13 = (v11 * v10) << 15;
                v14 = 29692 * (__int16) (*(v8 - 16) * *(v9 - 16))
                    + 6967 * (__int16) (v8 [16] * v9 [16])
                    - 5906 * (__int16) (v8 [32] * v9 [32])
                    - 10426 * (__int16) (*v8 * *v9);
                v7 = v23;
                *(_DWORD*) v23 = (v14 + v13 + 4096) >> 13;
                v6 = v22;
                v12 = (v13 - v14 + 4096) >> 13;
            }
            else {
                v12 = 4 * v11 * v10;
                *(_DWORD*) v7 = v12;
            }
            *((_DWORD*) v7 + 8) = v12;
        }
        ++v8;
        v7 += 4;
        ++v9;
        --v24;
        v23 = v7;
    }
    while(v24 > 0);
    v25 = 0;
    result = v21;
    do {
        v16 = (_BYTE*) (a5 + *(_DWORD*) (a4 + 4 * v25));
        v17 = *(_DWORD*) result;
        if(*((_DWORD*) result + 5) | *((_DWORD*) result + 1) | *((_DWORD*) result + 3) | *((_DWORD*) result + 7)) {
            v19 = v17 << 15;
            v20 = 6967 * *((__int16*) result + 10)
                + 29692 * *((__int16*) result + 2)
                + -10426 * *((__int16*) result + 6)
                - 5906 * *((__int16*) result + 14);
            v6 = v22;
            *v16 = *(_BYTE*) ((((v20 + v19 + 0x80000) >> 20) & 0x3FF) + v22);
            v18 = *(_BYTE*) ((((v19 - v20 + 0x80000) >> 20) & 0x3FF) + v6);
        }
        else {
            v18 = *(_BYTE*) ((((v17 + 16) >> 5) & 0x3FF) + v6);
            *v16 = v18;
        }
        result += 32;
        ++v25;
        v16 [1] = v18;
    }
    while(v25 < 2);
    return result;
}

//----- (00458765) --------------------------------------------------------
char __cdecl sub_458765(int a1, int a2, __int16* a3, _DWORD* a4, int a5) {
    char result; // al

    result = *(_BYTE*) ((((*a3 * **(__int16**) (a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD*) (a1 + 284) + 128);
    *(_BYTE*) (a5 + *a4) = result;
    return result;
}

//----- (004587A2) --------------------------------------------------------
int __cdecl sub_4587A2(int a1, int a2, __m64* a3, int a4, int a5) {
    __m64* v6; // [esp-14h] [ebp-A4h]
    int v7; // [esp-4h] [ebp-94h]
    __m64 v8 [17]; // [esp+8h] [ebp-88h] BYREF

    v7 = *(_DWORD*) (a1 + 284) + 128;
    v6 = *(__m64**)(a2 + 80);
    if(byte_479474)
        return sub_459CEE(a3, v6, v8, a4, a5, v7);
    else
        return sub_459801((__int16*) a3, (__int16*) v6, (int*) v8, a4, a5, v7);
}
// 479474: using guessed type char byte_479474;
// 4587A2: using guessed type __m64 var_88[17];

//----- (004587EE) --------------------------------------------------------
char __cdecl sub_4587EE(int a1, int a2, __m64* a3, _DWORD* a4, int a5) {
    __m64* v6; // [esp-10h] [ebp-A0h]
    int v7; // [esp-4h] [ebp-94h]
    __m64 v8 [17]; // [esp+8h] [ebp-88h] BYREF

    v7 = *(_DWORD*) (a1 + 284) + 128;
    v6 = *(__m64**)(a2 + 80);
    if(byte_479474)
        return sub_45A822(a3, v8, v6, a4, a5, v7);
    else
        return sub_45A479(a3, v8, v6, (int) a4, a5, v7);
}
// 479474: using guessed type char byte_479474;
// 4587EE: using guessed type __m64 var_88[17];

//----- (0045883A) --------------------------------------------------------
char __cdecl sub_45883A(int a1, int a2, __int16* a3, int a4, int a5) {
    float* v6; // ecx
    float* v7; // eax
    __int16 v8; // si
    __int16 v9; // di
    double v10; // st5
    int v11; // edi
    double v12; // st4
    double v13; // st5
    double v14; // st4
    double v15; // st3
    double v16; // st5
    double v17; // st4
    double v18; // st3
    double v19; // st2
    double v20; // st2
    double v21; // st4
    double v22; // st3
    double v23; // st2
    double v24; // st1
    float* v25; // esi
    _BYTE* v26; // edi
    double v27; // st5
    double v28; // st4
    double v29; // st3
    double v30; // st5
    double v31; // st4
    double v32; // st4
    double v33; // st3
    double v34; // st2
    double v35; // st1
    double v36; // st3
    double v37; // st4
    double v38; // st5
    __int64 v39; // rax
    double v40; // st5
    __int64 v41; // rax
    double v42; // st5
    char result; // al
    bool v44; // cc
    char v45; // [esp+Ch] [ebp-118h] BYREF
    char v46; // [esp+14h] [ebp-110h] BYREF
    int v47; // [esp+10Ch] [ebp-18h]
    float v48; // [esp+110h] [ebp-14h]
    int v49; // [esp+114h] [ebp-10h]
    float v50; // [esp+118h] [ebp-Ch]
    float v51; // [esp+11Ch] [ebp-8h]
    float v52; // [esp+120h] [ebp-4h]
    float v53; // [esp+12Ch] [ebp+8h]
    float v54; // [esp+12Ch] [ebp+8h]
    float v55; // [esp+12Ch] [ebp+8h]
    float v56; // [esp+130h] [ebp+Ch]
    float v57; // [esp+130h] [ebp+Ch]
    float v58; // [esp+130h] [ebp+Ch]
    float v59; // [esp+130h] [ebp+Ch]
    float v60; // [esp+130h] [ebp+Ch]
    float v61; // [esp+130h] [ebp+Ch]
    int v62; // [esp+134h] [ebp+10h]
    float v63; // [esp+134h] [ebp+10h]
    float v64; // [esp+134h] [ebp+10h]
    float v65; // [esp+134h] [ebp+10h]

    v49 = *(_DWORD*) (a1 + 284) + 128;
    v6 = *(float**) (a2 + 80);
    v7 = (float*) &v45;
    v47 = 8;
    do {
        v8 = a3 [56];
        v9 = a3 [48];
        v10 = (double) *a3 * *v6;
        if((unsigned __int16) v8 | (unsigned __int16) (v9 | a3 [40] | a3 [32] | a3 [24] | a3 [16] | a3 [8])) {
            v53 = v6 [16] * (double) a3 [16];
            v62 = v9;
            v11 = a3 [8];
            v12 = v6 [32] * (double) a3 [32];
            v63 = v6 [48] * (double) v62;
            v56 = v12 + v10;
            v13 = v10 - v12;
            v14 = v63 + v53;
            v15 = (v53 - v63) * 1.4142135 - v14;
            v48 = v14 + v56;
            v64 = v56 - v14;
            v54 = v15 + v13;
            v16 = v13 - v15;
            v17 = v6 [8] * (double) v11;
            v18 = v6 [24] * (double) a3 [24];
            v19 = v6 [40] * (double) a3 [40];
            LODWORD(v50) = v8;
            v57 = v19;
            v20 = v6 [56] * (double) v8;
            v51 = v57 + v18;
            v58 = v57 - v18;
            v52 = v20 + v17;
            v21 = v17 - v20;
            v22 = v52 + v51;
            v50 = (v21 + v58) * 1.847759;
            v23 = v50 - v58 * 2.613126 - v22;
            v24 = (v52 - v51) * 1.4142135 - v23;
            v52 = v24;
            v51 = v21 * 1.0823922 - v50 + v24;
            *v7 = v22 + v48;
            v7 [56] = v48 - v22;
            v7 [8] = v54 + v23;
            v7 [48] = v54 - v23;
            v7 [16] = v52 + v16;
            v7 [40] = v16 - v52;
            v7 [32] = v51 + v64;
            v7 [24] = v64 - v51;
        }
        else {
            *v7 = v10;
            v7 [8] = v10;
            v7 [16] = v10;
            v7 [24] = v10;
            v7 [32] = v10;
            v7 [40] = v10;
            v7 [48] = v10;
            v7 [56] = v10;
        }
        ++v6;
        ++a3;
        ++v7;
        --v47;
    }
    while(*(float*) &v47 != 0.0);
    v50 = 0.0;
    v25 = (float*) &v46;
    do {
        v26 = (_BYTE*) (a5 + *(_DWORD*) (a4 + 4 * LODWORD(v50)));
        v59 = v25 [2] + *(v25 - 2);
        v27 = *(v25 - 2) - v25 [2];
        v28 = *v25 + v25 [4];
        v29 = (*v25 - v25 [4]) * 1.4142135 - v28;
        v48 = v28 + v59;
        v65 = v59 - v28;
        v55 = v29 + v27;
        v30 = v27 - v29;
        v31 = v25 [3] + v25 [1];
        v51 = v31;
        v60 = v25 [3] - v25 [1];
        v52 = v25 [5] + *(v25 - 1);
        *(float*) &v47 = *(v25 - 1) - v25 [5];
        v32 = v31 + v52;
        v33 = (*(float*) &v47 + v60) * 1.847759;
        v34 = v33 - v60 * 2.613126 - v32;
        v61 = v34;
        v35 = (v52 - v51) * 1.4142135 - v34;
        v52 = v35;
        v51 = *(float*) &v47 * 1.0823922 - v33 + v35;
        v36 = v48 - v32;
        *v26 = *(_BYTE*) ((((int) ((__int64) (v48 + v32) + 4) >> 3) & 0x3FF) + v49);
        v26 [7] = *(_BYTE*) ((((int) ((__int64) v36 + 4) >> 3) & 0x3FF) + v49);
        v26 [1] = *(_BYTE*) ((((int) ((__int64) (v61 + v55) + 4) >> 3) & 0x3FF) + v49);
        v37 = v52 + v30;
        v26 [6] = *(_BYTE*) ((((int) ((__int64) (v55 - v61) + 4) >> 3) & 0x3FF) + v49);
        v38 = v30 - v52;
        v26 [2] = *(_BYTE*) ((((int) ((__int64) v37 + 4) >> 3) & 0x3FF) + v49);
        v39 = (__int64) v38;
        v40 = v51 + v65;
        v26 [5] = *(_BYTE*) (((((int) v39 + 4) >> 3) & 0x3FF) + v49);
        v41 = (__int64) v40;
        v42 = v65 - v51;
        v26 [4] = *(_BYTE*) (((((int) v41 + 4) >> 3) & 0x3FF) + v49);
        result = *(_BYTE*) ((((int) ((__int64) v42 + 4) >> 3) & 0x3FF) + v49);
        v25 += 8;
        v44 = ++LODWORD(v50) < 8;
        v26 [3] = result;
    }
    while(v44);
    return result;
}

//----- (00458C1B) --------------------------------------------------------
int __cdecl sub_458C1B(char a1, char a2, int a3, int a4, int a5) {
    int result; // eax

    result = (*(int(__cdecl**)(_DWORD, int, int))(a5 + 32))(*(_DWORD*) (a5 + 40), 1, 28);
    if(result) {
        *(_DWORD*) result = 0;
        *(_BYTE*) (result + 16) = a1;
        *(_BYTE*) (result + 17) = a2;
        *(_DWORD*) (result + 20) = a3;
        *(_DWORD*) (result + 24) = a4;
    }
    return result;
}

//----- (00458C4F) --------------------------------------------------------
int __cdecl sub_458C4F(_DWORD* a1, int a2, int a3) {
    _BYTE* v5; // edx
    int v6; // ebx
    unsigned int v7; // eax
    unsigned int v8; // eax
    int v9; // eax
    unsigned int v10; // eax
    int v11; // eax
    unsigned int v12; // eax
    unsigned __int8* v13; // eax
    int v14; // ecx
    unsigned int v15; // eax
    int v16; // ecx
    unsigned int v17; // eax
    unsigned int v18; // eax
    int v19; // ecx
    unsigned int v20; // eax
    unsigned int v21; // eax
    unsigned int v22; // ecx
    int v23; // eax
    unsigned int v24; // eax
    unsigned int v25; // ecx
    unsigned int v27; // eax
    unsigned int v28; // ecx
    int v29; // eax
    unsigned int v30; // eax
    unsigned int v31; // ecx
    int v32; // eax
    unsigned __int8* v33; // ebx
    unsigned __int8* v34; // ecx
    int v36; // [esp-4h] [ebp-28h]
    char v37; // [esp+Ch] [ebp-18h]
    unsigned int v38; // [esp+Ch] [ebp-18h]
    unsigned int v39; // [esp+Ch] [ebp-18h]
    _BYTE* v40; // [esp+10h] [ebp-14h]
    _BYTE* v41; // [esp+14h] [ebp-10h]
    _BYTE* v42; // [esp+14h] [ebp-10h]
    unsigned int v43; // [esp+18h] [ebp-Ch]
    unsigned int v44; // [esp+1Ch] [ebp-8h]
    unsigned __int8* v45; // [esp+20h] [ebp-4h]
    unsigned int v46; // [esp+2Ch] [ebp+8h]
    unsigned int v47; // [esp+30h] [ebp+Ch]
    int v48; // [esp+34h] [ebp+10h]

    v45 = *(unsigned __int8**) a2;
    v5 = (_BYTE*) a1 [13];
    v6 = a1 [1];
    v44 = *(_DWORD*) (a2 + 4);
    v47 = a1 [8];
    v46 = a1 [7];
    v7 = a1 [12];
    if((unsigned int) v5 >= v7)
        v8 = a1 [11] - (_DWORD) v5;
    else
        v8 = v7 - (_DWORD) v5 - 1;
    v43 = v8;
    while(2) {
        switch(*(_DWORD*) v6) {
            case 0:
                if(v8 >= 0x102 && v44 >= 0xA) {
                    a1 [8] = v47;
                    a1 [7] = v46;
                    *(_DWORD*) (a2 + 4) = v44;
                    *(_DWORD*) (a2 + 8) += &v45 [-*(_DWORD*) a2];
                    *(_DWORD*) a2 = v45;
                    a1 [13] = v5;
                    v9 = sub_45B5F5(
                        *(unsigned __int8*) (v6 + 16),
                        *(unsigned __int8*) (v6 + 17),
                        *(_DWORD*) (v6 + 20),
                        *(_DWORD*) (v6 + 24),
                        a1,
                        (unsigned __int8**) a2);
                    v5 = (_BYTE*) a1 [13];
                    a3 = v9;
                    v45 = *(unsigned __int8**) a2;
                    v44 = *(_DWORD*) (a2 + 4);
                    v47 = a1 [8];
                    v46 = a1 [7];
                    v10 = a1 [12];
                    v11 = (unsigned int) v5 >= v10 ? a1 [11] - (_DWORD) v5 : v10 - (_DWORD) v5 - 1;
                    v43 = v11;
                    if(a3) {
                        *(_DWORD*) v6 = 2 * (a3 != 1) + 7;
                        goto LABEL_13;
                    }
                }
                *(_DWORD*) (v6 + 12) = *(unsigned __int8*) (v6 + 16);
                *(_DWORD*) (v6 + 8) = *(_DWORD*) (v6 + 20);
                *(_DWORD*) v6 = 1;
                goto LABEL_17;
            case 1:
                LABEL_17:
                while(2) {
                    v12 = *(_DWORD*) (v6 + 12);
                    if(v46 < v12) {
                        if(v44) {
                            a3 = 0;
                            --v44;
                            v47 |= *v45++ << v46;
                            v46 += 8;
                            continue;
                        }
                        goto LABEL_84;
                    }
                    break;
                }
                v13 = (unsigned __int8*) (*(_DWORD*) (v6 + 8) + 8 * (v47 & dword_47A5D8 [v12]));
                v47 >>= v13 [1];
                v46 -= v13 [1];
                v37 = *v13;
                if(!*v13) {
                    *(_DWORD*) (v6 + 8) = *((_DWORD*) v13 + 1);
                    *(_DWORD*) v6 = 6;
                    goto LABEL_13;
                }
                v14 = *v13;
                if((v37 & 0x10) != 0) {
                    *(_DWORD*) (v6 + 8) = v37 & 0xF;
                    *(_DWORD*) (v6 + 4) = *((_DWORD*) v13 + 1);
                    *(_DWORD*) v6 = 2;
                    goto LABEL_13;
                }
                if((v37 & 0x40) == 0)
                    goto LABEL_35;
                if((v37 & 0x20) == 0) {
                    *(_DWORD*) v6 = 9;
                    *(_DWORD*) (a2 + 24) = "invalid literal/length code";
                    goto LABEL_82;
                }
                *(_DWORD*) v6 = 7;
                goto LABEL_13;
            case 2:
                while(2) {
                    v15 = *(_DWORD*) (v6 + 8);
                    if(v46 < v15) {
                        if(v44) {
                            a3 = 0;
                            --v44;
                            v47 |= *v45++ << v46;
                            v46 += 8;
                            continue;
                        }
                        goto LABEL_84;
                    }
                    break;
                }
                v16 = *(_DWORD*) (v6 + 8);
                *(_DWORD*) (v6 + 4) += v47 & dword_47A5D8 [v15];
                v47 >>= v16;
                v46 -= v16;
                *(_DWORD*) (v6 + 12) = *(unsigned __int8*) (v6 + 17);
                *(_DWORD*) (v6 + 8) = *(_DWORD*) (v6 + 24);
                *(_DWORD*) v6 = 3;
                LABEL_31:
                while(1) {
                    v17 = *(_DWORD*) (v6 + 12);
                    if(v46 >= v17)
                        break;
                    if(!v44)
                        goto LABEL_84;
                    a3 = 0;
                    --v44;
                    v47 |= *v45++ << v46;
                    v46 += 8;
                }
                v13 = (unsigned __int8*) (*(_DWORD*) (v6 + 8) + 8 * (v47 & dword_47A5D8 [v17]));
                v47 >>= v13 [1];
                v46 -= v13 [1];
                v14 = *v13;
                if((v14 & 0x10) != 0) {
                    *(_DWORD*) (v6 + 8) = v14 & 0xF;
                    *(_DWORD*) (v6 + 12) = *((_DWORD*) v13 + 1);
                    *(_DWORD*) v6 = 4;
                    goto LABEL_13;
                }
                if((v14 & 0x40) != 0) {
                    *(_DWORD*) v6 = 9;
                    *(_DWORD*) (a2 + 24) = "invalid distance code";
                    LABEL_82:
                    v36 = -3;
                    LABEL_93:
                    a1 [8] = v47;
                    a1 [7] = v46;
                    *(_DWORD*) (a2 + 4) = v44;
                    goto LABEL_94;
                }
                LABEL_35:
                *(_DWORD*) (v6 + 12) = v14;
                *(_DWORD*) (v6 + 8) = &v13 [8 * *((_DWORD*) v13 + 1)];
                LABEL_13:
                v8 = v43;
                continue;
            case 3:
                goto LABEL_31;
            case 4:
                LABEL_38:
                v18 = *(_DWORD*) (v6 + 8);
                if(v46 >= v18) {
                    v19 = *(_DWORD*) (v6 + 8);
                    *(_DWORD*) (v6 + 12) += v47 & dword_47A5D8 [v18];
                    v47 >>= v19;
                    v46 -= v19;
                    *(_DWORD*) v6 = 5;
                    LABEL_40:
                    v20 = *(_DWORD*) (v6 + 12);
                    if((unsigned int) &v5 [-a1 [10]] >= v20)
                        v40 = &v5 [-v20];
                    else
                        v40 = &v5 [a1 [11] - a1 [10] - *(_DWORD*) (v6 + 12)];
                    v8 = v43;
                    if(*(_DWORD*) (v6 + 4)) {
                        while(1) {
                            if(!v8) {
                                if(v5 != (_BYTE*) a1 [11]
                                   || (v21 = a1 [12], v22 = a1 [10], v21 == v22)
                                   || ((v5 = (_BYTE*) a1 [10], v22 >= v21) ? (v8 = a1 [11] - v22) : (v8 = v21 - v22 - 1), !v8)) {
                                    a1 [13] = v5;
                                    v23 = sub_4596EC(a1, (_DWORD*) a2, a3);
                                    v5 = (_BYTE*) a1 [13];
                                    v48 = v23;
                                    v24 = a1 [12];
                                    v38 = v24;
                                    if((unsigned int) v5 >= v24)
                                        v8 = a1 [11] - (_DWORD) v5;
                                    else
                                        v8 = v24 - (_DWORD) v5 - 1;
                                    v41 = (_BYTE*) a1 [11];
                                    if(v5 == v41) {
                                        v25 = a1 [10];
                                        if(v38 != v25) {
                                            v5 = (_BYTE*) a1 [10];
                                            if(v25 >= v38)
                                                v8 = (unsigned int) &v41 [-v25];
                                            else
                                                v8 = v38 - v25 - 1;
                                        }
                                    }
                                    if(!v8)
                                        break;
                                }
                            }
                            a3 = 0;
                            *v5++ = *v40++;
                            v43 = --v8;
                            if(v40 == (_BYTE*) a1 [11])
                                v40 = (_BYTE*) a1 [10];
                            if((*(_DWORD*) (v6 + 4))-- == 1)
                                goto LABEL_63;
                        }
                        LABEL_85:
                        v36 = v48;
                        goto LABEL_93;
                    }
                    LABEL_63:
                    *(_DWORD*) v6 = 0;
                    continue;
                }
                if(v44) {
                    a3 = 0;
                    --v44;
                    v47 |= *v45++ << v46;
                    v46 += 8;
                    goto LABEL_38;
                }
                LABEL_84:
                v36 = a3;
                a1 [8] = v47;
                a1 [7] = v46;
                *(_DWORD*) (a2 + 4) = 0;
                LABEL_94:
                v34 = &v45 [-*(_DWORD*) a2];
                *(_DWORD*) a2 = v45;
                *(_DWORD*) (a2 + 8) += v34;
                LABEL_95:
                a1 [13] = v5;
                return sub_4596EC(a1, (_DWORD*) a2, v36);
            case 5:
                goto LABEL_40;
            case 6:
                if(!v8) {
                    if(v5 != (_BYTE*) a1 [11]
                       || (v27 = a1 [12], v28 = a1 [10], v27 == v28)
                       || ((v5 = (_BYTE*) a1 [10], v28 >= v27) ? (v8 = a1 [11] - v28) : (v8 = v27 - v28 - 1), !v8)) {
                        a1 [13] = v5;
                        v29 = sub_4596EC(a1, (_DWORD*) a2, a3);
                        v5 = (_BYTE*) a1 [13];
                        v48 = v29;
                        v30 = a1 [12];
                        v39 = v30;
                        if((unsigned int) v5 >= v30)
                            v8 = a1 [11] - (_DWORD) v5;
                        else
                            v8 = v30 - (_DWORD) v5 - 1;
                        v42 = (_BYTE*) a1 [11];
                        if(v5 == v42) {
                            v31 = a1 [10];
                            if(v39 != v31) {
                                v5 = (_BYTE*) a1 [10];
                                if(v31 >= v39)
                                    v8 = (unsigned int) &v42 [-v31];
                                else
                                    v8 = v39 - v31 - 1;
                            }
                        }
                        if(!v8)
                            goto LABEL_85;
                    }
                }
                a3 = 0;
                *v5++ = *(_BYTE*) (v6 + 8);
                v43 = --v8;
                goto LABEL_63;
            case 7:
                if(v46 > 7) {
                    v46 -= 8;
                    ++v44;
                    --v45;
                }
                a1 [13] = v5;
                v32 = sub_4596EC(a1, (_DWORD*) a2, a3);
                v5 = (_BYTE*) a1 [13];
                if((_BYTE*) a1 [12] != v5) {
                    a1 [8] = v47;
                    a1 [7] = v46;
                    *(_DWORD*) (a2 + 4) = v44;
                    v33 = &v45 [-*(_DWORD*) a2];
                    *(_DWORD*) a2 = v45;
                    *(_DWORD*) (a2 + 8) += v33;
                    v36 = v32;
                    goto LABEL_95;
                }
                *(_DWORD*) v6 = 8;
                LABEL_91:
                v36 = 1;
                goto LABEL_93;
            case 8:
                goto LABEL_91;
            case 9:
                goto LABEL_82;
            default:
                v36 = -2;
                goto LABEL_93;
        }
    }
}
// 47A5D8: using guessed type int dword_47A5D8[19];

//----- (004591A5) --------------------------------------------------------
int __cdecl sub_4591A5(int a1, int a2) {
    return (*(int(__cdecl**)(_DWORD, int))(a2 + 36))(*(_DWORD*) (a2 + 40), a1);
}

//----- (004591B6) --------------------------------------------------------
int __usercall sub_4591B6(
    unsigned int* a1,
    _DWORD* a2,
    unsigned int a3,
    unsigned int a4,
    int a5,
    int a6,
    _DWORD* a7,
    int a8,
    unsigned int* a9,
    unsigned int* a10) {
    _DWORD* v10; // ecx
    unsigned int v12; // edx
    unsigned int v14; // ebx
    unsigned int v15; // ecx
    unsigned int v16; // eax
    int v17; // edx
    int v18; // edx
    unsigned int v19; // esi
    int* v20; // ecx
    int v21; // ebx
    int v22; // edx
    int v23; // ecx
    unsigned int v24; // eax
    int v25; // ebx
    int* v26; // ecx
    unsigned int v27; // ebx
    int v28; // eax
    int* v29; // eax
    int v30; // ecx
    int v31; // eax
    int v32; // ebx
    int v33; // eax
    int j; // ecx
    unsigned int v35; // esi
    unsigned int v36; // ecx
    unsigned int v37; // eax
    unsigned int v38; // eax
    int* v39; // edx
    unsigned int v40; // edx
    unsigned int v41; // eax
    unsigned int v42; // eax
    unsigned int v43; // esi
    int* v44; // edx
    unsigned int v45; // esi
    unsigned int v46; // eax
    int v47; // ecx
    int v48; // edx
    unsigned int v49; // eax
    int v50; // eax
    int v51; // esi
    unsigned int v52; // eax
    _DWORD* v53; // ecx
    unsigned int v54; // esi
    unsigned int i; // eax
    int v56; // ecx
    int v57; // eax
    int v59 [15]; // [esp+Ch] [ebp-A4h] BYREF
    int v60; // [esp+48h] [ebp-68h] BYREF
    int v61 [15]; // [esp+4Ch] [ebp-64h]
    int v62; // [esp+88h] [ebp-28h] BYREF
    int v63 [15]; // [esp+8Ch] [ebp-24h] BYREF
    int v64; // [esp+C8h] [ebp+18h]
    int v65; // [esp+CCh] [ebp+1Ch]
    int v66; // [esp+D0h] [ebp+20h]
    int v67; // [esp+D4h] [ebp+24h]
    int v68; // [esp+D8h] [ebp+28h]
    int v69; // [esp+DCh] [ebp+2Ch]
    int* v70; // [esp+E0h] [ebp+30h]
    unsigned int v71; // [esp+E4h] [ebp+34h]
    int v72; // [esp+E8h] [ebp+38h]
    int v73; // [esp+ECh] [ebp+3Ch]
    unsigned int v74; // [esp+F0h] [ebp+40h]
    unsigned int v75; // [esp+F4h] [ebp+44h]
    int v76; // [esp+F8h] [ebp+48h]
    int v77; // [esp+FCh] [ebp+4Ch]
    unsigned int v78; // [esp+100h] [ebp+50h]
    int* v79; // [esp+10Ch] [ebp+5Ch]
    unsigned int* v80; // [esp+10Ch] [ebp+5Ch]
    int v81; // [esp+110h] [ebp+60h]

    v10 = a2;
    v62 = 0;
    memset(v63, 0, sizeof(v63));
    v12 = a3;
    do {
        ++v63 [*v10++ - 1];
        --v12;
    }
    while(v12);
    if(v62 != a3) {
        v14 = *a1;
        v78 = *a1;
        v15 = 1;
        v16 = 15;
        do {
            if(v63 [v15 - 1])
                break;
            ++v15;
        }
        while(v15 <= 0xF);
        v77 = v15;
        if(v14 < v15)
            v78 = v15;
        do {
            if(v63 [v16 - 1])
                break;
            --v16;
        }
        while(v16);
        v68 = v16;
        if(v78 > v16)
            v78 = v16;
        *a1 = v78;
        v17 = 1 << v15;
        while(v15 < v16) {
            v18 = v17 - v63 [v15 - 1];
            if(v18 < 0)
                return -3;
            ++v15;
            v17 = 2 * v18;
        }
        v19 = v16;
        v20 = &v63 [v16 - 1];
        v21 = *v20;
        v22 = v17 - *v20;
        v66 = v22;
        if(v22 < 0)
            return -3;
        *v20 = v22 + v21;
        v23 = 0;
        v24 = v16 - 1;
        v61 [0] = 0;
        if(v24) {
            v25 = 0;
            do {
                v23 += v63 [v25++];
                --v24;
                v61 [v25] = v23;
            }
            while(v24);
        }
        v26 = a2;
        v27 = 0;
        do {
            v28 = *v26++;
            v79 = v26;
            if(v28) {
                v29 = &v61 [v28 - 1];
                v30 = *v29;
                a10 [v30] = v27;
                v22 = v66;
                *v29 = v30 + 1;
                v26 = v79;
            }
            ++v27;
        }
        while(v27 < a3);
        v31 = v61 [v19 - 1];
        v76 = -1;
        v81 = v31;
        v80 = a10;
        v32 = -v78;
        v71 = 0;
        v60 = 0;
        v59 [0] = 0;
        v69 = 0;
        v75 = 0;
        if(v77 > v68) {
            LABEL_68:
            if(!v22 || v68 == 1)
                return 0;
            return -5;
        }
        else {
            v67 = v77 - 1;
            v70 = &v63 [v77 - 1];
            while(1) {
                v72 = *v70;
                if(v72)
                    break;
                LABEL_67:
                ++v77;
                ++v70;
                ++v67;
                if(v77 > v68)
                    goto LABEL_68;
            }
            while(1) {
                --v72;
                v33 = v32 + v78;
                if(v77 > (int) (v32 + v78))
                    break;
                LABEL_50:
                BYTE1(v73) = v77 - v32;
                if(v80 < &a10 [v81]) {
                    v49 = *v80;
                    if(*v80 >= a4) {
                        v50 = 4 * (v49 - a4);
                        LOBYTE(v73) = *(_BYTE*) (v50 + a6) + 80;
                        v49 = *(_DWORD*) (v50 + a5);
                    }
                    else {
                        LOBYTE(v73) = v49 < 0x100 ? 0 : 0x60;
                    }
                    ++v80;
                    v74 = v49;
                }
                else {
                    LOBYTE(v73) = -64;
                }
                v51 = 1 << (v77 - v32);
                v52 = v71 >> v32;
                if(v71 >> v32 < v75) {
                    v53 = (_DWORD*) (v69 + 8 * v52);
                    do {
                        *v53 = v73;
                        v53 [1] = v74;
                        v52 += v51;
                        v53 += 2 * v51;
                    }
                    while(v52 < v75);
                    v22 = v66;
                }
                v54 = v71;
                for(i = 1 << v67; (i & v54) != 0; i >>= 1)
                    v54 ^= i;
                v71 = i ^ v54;
                v56 = (i ^ v54) & ((1 << v32) - 1);
                v57 = v76;
                if(v56 != v61 [v76 - 1]) {
                    do {
                        v32 -= v78;
                        --v57;
                    }
                    while((v71 & ((1 << v32) - 1)) != v61 [v57 - 1]);
                    v76 = v57;
                }
                if(!v72)
                    goto LABEL_67;
            }
            for(j = v32 - v78; ; j = v64) {
                ++v76;
                v32 += v78;
                v35 = v68 - v32;
                v64 = v78 + j;
                v65 = v78 + v33;
                if(v68 - v32 > v78)
                    v35 = v78;
                v36 = v77 - v32;
                v37 = 1 << (v77 - v32);
                if(v37 > v72 + 1) {
                    v38 = -1 - v72 + v37;
                    v39 = v70;
                    if(v36 < v35 && ++v36 < v35) {
                        while(1) {
                            v75 = (unsigned int) (v39 + 1);
                            v40 = v39 [1];
                            v41 = 2 * v38;
                            if(v41 <= v40)
                                break;
                            v38 = v41 - v40;
                            if(++v36 >= v35)
                                break;
                            v39 = (int*) v75;
                        }
                    }
                }
                v42 = *a9;
                v43 = *a9 + (1 << v36);
                v75 = 1 << v36;
                if(v43 > 0x5A0)
                    break;
                v44 = &v59 [v76];
                v69 = a8 + 8 * v42;
                *v44 = v69;
                *a9 = v43;
                if(v76) {
                    v45 = v71;
                    v61 [v76 - 1] = v71;
                    BYTE1(v73) = v78;
                    LOBYTE(v73) = v36;
                    v46 = v45 >> v64;
                    v47 = *(v44 - 1);
                    v48 = ((v69 - v47) >> 3) - (v45 >> v64);
                    *(_DWORD*) (v47 + 8 * v46) = v73;
                    v74 = v48;
                    *(_DWORD*) (v47 + 8 * v46 + 4) = v48;
                }
                else {
                    *a7 = v69;
                }
                v33 = v65;
                if(v77 <= v65) {
                    v22 = v66;
                    goto LABEL_50;
                }
            }
            return -4;
        }
    }
    *a7 = 0;
    *a1 = 0;
    return 0;
}
// 4591B6: using guessed type int var_B8[15];
// 4591B6: using guessed type int var_F8[15];

//----- (0045953B) --------------------------------------------------------
int __cdecl sub_45953B(_DWORD* a1, unsigned int* a2, _DWORD* a3, int a4, int a5) {
    unsigned int* v6; // eax
    int v8; // eax
    int v9; // ebx
    unsigned int v10; // [esp+4h] [ebp-4h] BYREF
    unsigned int* v11; // [esp+20h] [ebp+18h]

    v10 = 0;
    v6 = (unsigned int*) (*(int(__cdecl**)(_DWORD, int, int))(a5 + 32))(*(_DWORD*) (a5 + 40), 19, 4);
    v11 = v6;
    if(!v6)
        return -4;
    v8 = sub_4591B6(a2, a1, 0x13u, 0x13u, 0, 0, a3, a4, &v10, v6);
    v9 = v8;
    if(v8 == -3) {
        *(_DWORD*) (a5 + 24) = "oversubscribed dynamic bit lengths tree";
    }
    else if(v8 == -5 || !*a2) {
        *(_DWORD*) (a5 + 24) = "incomplete dynamic bit lengths tree";
        v9 = -3;
    }
    (*(void(__cdecl**)(_DWORD, unsigned int*))(a5 + 36))(*(_DWORD*) (a5 + 40), v11);
    return v9;
}

//----- (004595BA) --------------------------------------------------------
int __cdecl sub_4595BA(
    unsigned int a1,
    unsigned int a2,
    _DWORD* a3,
    unsigned int* a4,
    unsigned int* a5,
    _DWORD* a6,
    _DWORD* a7,
    int a8,
    int a9) {
    unsigned int* v10; // eax
    int v12; // eax
    int v13; // edi
    unsigned int v14; // [esp+4h] [ebp-4h] BYREF
    unsigned int* v15; // [esp+30h] [ebp+28h]

    v14 = 0;
    v10 = (unsigned int*) (*(int(__cdecl**)(_DWORD, int, int))(a9 + 32))(*(_DWORD*) (a9 + 40), 288, 4);
    v15 = v10;
    if(!v10)
        return -4;
    v12 = sub_4591B6(a4, a3, a1, 0x101u, (int) &unk_46F9F0, (int) &unk_46FA70, a6, a8, &v14, v10);
    if(v12) {
        if(v12 == -3) {
            *(_DWORD*) (a9 + 24) = "oversubscribed literal/length tree";
            goto LABEL_20;
        }
        if(v12 == -4)
            goto LABEL_20;
        LABEL_18:
        *(_DWORD*) (a9 + 24) = "incomplete literal/length tree";
        goto LABEL_19;
    }
    if(!*a4)
        goto LABEL_18;
    v12 = sub_4591B6(a5, &a3 [a1], a2, 0, (int) &unk_46FAF0, (int) &unk_46FB68, a7, a8, &v14, v15);
    if(v12) {
        switch(v12) {
            case -3:
                *(_DWORD*) (a9 + 24) = "oversubscribed distance tree";
                break;
            case -5:
                *(_DWORD*) (a9 + 24) = "incomplete distance tree";
                LABEL_19:
                v12 = -3;
                break;
            case -4:
                break;
            default:
                LABEL_14:
                *(_DWORD*) (a9 + 24) = "empty distance tree with lengths";
                goto LABEL_19;
        }
        LABEL_20:
        v13 = v12;
        goto LABEL_21;
    }
    if(!*a5 && a1 > 0x101)
        goto LABEL_14;
    v13 = 0;
    LABEL_21:
    (*(void(__cdecl**)(_DWORD, unsigned int*))(a9 + 36))(*(_DWORD*) (a9 + 40), v15);
    return v13;
}

//----- (004596BD) --------------------------------------------------------
int __cdecl sub_4596BD(_DWORD* a1, _DWORD* a2, _DWORD* a3, _DWORD* a4) {
    *a1 = dword_4794D0;
    *a2 = dword_4794D4;
    *a3 = &unk_4794D8;
    *a4 = &unk_47A4D8;
    return 0;
}
// 4794D0: using guessed type int dword_4794D0;
// 4794D4: using guessed type int dword_4794D4;

//----- (004596EC) --------------------------------------------------------
int __cdecl sub_4596EC(_DWORD* a1, _DWORD* a2, int a3) {
    char* v4; // edx
    unsigned int v5; // edi
    unsigned int v6; // eax
    unsigned int v7; // edi
    int(__cdecl * v8)(_DWORD, char*, unsigned int); // eax
    int v9; // eax
    char v10; // al
    unsigned int v11; // ecx
    char* v12; // edi
    char* v13; // eax
    char* v14; // edx
    unsigned int v15; // eax
    unsigned int v16; // edi
    int(__cdecl * v17)(_DWORD, char*, unsigned int); // eax
    int v18; // eax
    char v19; // al
    unsigned int v20; // ecx
    char* v21; // edi
    char* v23; // [esp+Ch] [ebp-8h]
    char* v24; // [esp+Ch] [ebp-8h]
    unsigned int v25; // [esp+10h] [ebp-4h]
    unsigned int v26; // [esp+10h] [ebp-4h]
    char* v27; // [esp+1Ch] [ebp+8h]
    char* v28; // [esp+1Ch] [ebp+8h]
    char* v29; // [esp+1Ch] [ebp+8h]

    v4 = (char*) a1 [12];
    v5 = a1 [13];
    v23 = (char*) a2 [3];
    v27 = v4;
    if((unsigned int) v4 > v5)
        v5 = a1 [11];
    v6 = a2 [4];
    v7 = v5 - (_DWORD) v4;
    v25 = v7;
    if(v7 > v6) {
        v25 = a2 [4];
        v7 = v25;
    }
    if(v7 && a3 == -5)
        a3 = 0;
    a2 [5] += v7;
    a2 [4] = v6 - v7;
    v8 = (int(__cdecl*)(_DWORD, char*, unsigned int))a1 [14];
    if(v8) {
        v9 = v8(a1 [15], v4, v7);
        v4 = v27;
        a1 [15] = v9;
        a2 [12] = v9;
    }
    v10 = v7;
    v11 = v7 >> 2;
    qmemcpy(v23, v4, 4 * (v7 >> 2));
    v12 = &v23 [4 * (v7 >> 2)];
    v24 = &v23 [v25];
    v28 = &v27 [v25];
    qmemcpy(v12, &v4 [4 * v11], v10 & 3);
    v13 = (char*) a1 [11];
    if(v28 == v13) {
        v14 = (char*) a1 [10];
        v29 = v14;
        if((char*) a1 [13] == v13)
            a1 [13] = v14;
        v15 = a2 [4];
        v16 = a1 [13] - (_DWORD) v14;
        v26 = v16;
        if(v16 > v15) {
            v26 = a2 [4];
            v16 = v26;
        }
        if(v16 && a3 == -5)
            a3 = 0;
        a2 [5] += v16;
        a2 [4] = v15 - v16;
        v17 = (int(__cdecl*)(_DWORD, char*, unsigned int))a1 [14];
        if(v17) {
            v18 = v17(a1 [15], v14, v16);
            v14 = v29;
            a1 [15] = v18;
            a2 [12] = v18;
        }
        v19 = v16;
        v20 = v16 >> 2;
        qmemcpy(v24, v14, 4 * (v16 >> 2));
        v21 = &v24 [4 * (v16 >> 2)];
        v24 += v26;
        v28 = &v29 [v26];
        qmemcpy(v21, &v14 [4 * v20], v19 & 3);
    }
    a2 [3] = v24;
    a1 [12] = v28;
    return a3;
}

//----- (00459801) --------------------------------------------------------
int __cdecl sub_459801(__int16* a1, __int16* a2, int* a3, int a4, int a5, int a6) {
    int v6; // ecx
    int v7; // ebx
    int v8; // eax
    int v9; // ebx
    int v10; // eax
    int v11; // edx
    int v12; // ebx
    int v13; // edx
    int v14; // edx
    int v15; // ebx
    int v16; // edx
    int v17; // esi
    int v18; // ecx
    int v19; // ebx
    int v20; // eax
    int v21; // ecx
    int v22; // eax
    int v23; // edx
    int v24; // ecx
    int v25; // esi
    int v26; // edi
    int* v27; // edi
    int v28; // ecx
    int v29; // ebx
    int v30; // eax
    int v31; // ebx
    int v32; // edx
    int v33; // ebx
    int v34; // edx
    int v35; // eax
    int v36; // edx
    int v37; // esi
    int v38; // ecx
    int v39; // ebx
    int v40; // eax
    int v41; // ecx
    int v42; // eax
    int v43; // edx
    int v44; // esi
    int result; // eax
    int v46; // [esp+Ch] [ebp-44h]
    int v47; // [esp+18h] [ebp-38h]
    int v48; // [esp+20h] [ebp-30h]
    int v49; // [esp+24h] [ebp-2Ch]
    int v50; // [esp+24h] [ebp-2Ch]
    int v51; // [esp+24h] [ebp-2Ch]
    int v52; // [esp+28h] [ebp-28h]
    int v53; // [esp+28h] [ebp-28h]
    int v54; // [esp+2Ch] [ebp-24h]
    int v55; // [esp+2Ch] [ebp-24h]
    int v56; // [esp+30h] [ebp-20h]
    int v57; // [esp+30h] [ebp-20h]
    int v58; // [esp+34h] [ebp-1Ch]
    int v59; // [esp+34h] [ebp-1Ch]
    int v60; // [esp+38h] [ebp-18h]
    int v61; // [esp+38h] [ebp-18h]
    int v62; // [esp+38h] [ebp-18h]
    int v63; // [esp+38h] [ebp-18h]
    int v64; // [esp+3Ch] [ebp-14h]
    int v65; // [esp+3Ch] [ebp-14h]
    int v66; // [esp+3Ch] [ebp-14h]
    int v67; // [esp+3Ch] [ebp-14h]
    int v68; // [esp+3Ch] [ebp-14h]
    int v69; // [esp+40h] [ebp-10h]
    int v70; // [esp+40h] [ebp-10h]
    int* v71; // [esp+44h] [ebp-Ch]
    int* v72; // [esp+44h] [ebp-Ch]

    v71 = a3;
    v69 = 8;
    do {
        v6 = a2 [48] * a1 [48];
        v7 = a2 [16] * a1 [16];
        v8 = 6270 * v7;
        v9 = 4433 * (v6 + v7);
        v64 = v9 - 15137 * v6;
        v60 = v9 + v8;
        v10 = *a2 * *a1;
        v11 = a2 [32] * a1 [32];
        v12 = (v10 + v11) << 13;
        v13 = (v10 - v11) << 13;
        v58 = v60 + v12;
        v56 = v64 + v13;
        v54 = v12 - v60;
        v52 = v13 - v64;
        v49 = a2 [56] * a1 [56];
        v65 = a2 [24] * a1 [24];
        v61 = a2 [8] * a1 [8];
        v14 = a2 [40] * a1 [40];
        v15 = v61 + v14;
        v16 = -20995 * (v65 + v14);
        v17 = 9633 * (v15 + v65 + v49);
        v18 = v17 - 16069 * (v65 + v49);
        v19 = v17 - 3196 * v15;
        v20 = v18 - 7373 * (v61 + v49);
        v21 = v16 + v18;
        v22 = 2446 * v49 + v20;
        v23 = 16819 * a2 [40] * a1 [40] + v19 + v16;
        v24 = 25172 * v65 + v21;
        v25 = 12299 * v61 + v19 - 7373 * (v61 + v49);
        v71 [32] = (v54 - v22 + 1024) >> 11;
        v71 [24] = (v54 + v22 + 1024) >> 11;
        v71 [40] = (v52 - v23 + 1024) >> 11;
        v71 [48] = (v56 - v24 + 1024) >> 11;
        v71 [16] = (v52 + v23 + 1024) >> 11;
        v71 [8] = (v56 + v24 + 1024) >> 11;
        v71 [56] = (v58 - v25 + 1024) >> 11;
        *v71 = (v25 + v58 + 1024) >> 11;
        ++a1;
        ++v71;
        ++a2;
        --v69;
    }
    while(v69);
    v70 = 8;
    v46 = 0;
    v72 = a3;
    do {
        v26 = *(_DWORD*) (v46 + a4);
        v46 += 4;
        v27 = (int*) (a5 + v26);
        v28 = v72 [6];
        v29 = v72 [2];
        v30 = 6270 * v29;
        v31 = 4433 * (v28 + v29);
        v66 = v31 - 15137 * v28;
        v62 = v31 + v30;
        v32 = v72 [4];
        v33 = (*v72 + v32) << 13;
        v34 = (*v72 - v32) << 13;
        v59 = v62 + v33;
        v57 = v66 + v34;
        v55 = v33 - v62;
        v53 = v34 - v66;
        v50 = v72 [7];
        v67 = v72 [3];
        v35 = v72 [5];
        v63 = v72 [1];
        v47 = 16819 * v35;
        v36 = -20995 * (v67 + v35);
        v37 = 9633 * (v63 + v35 + v67 + v50);
        v38 = v37 - 16069 * (v67 + v50);
        v39 = v37 - 3196 * (v63 + v35);
        v40 = v38 - 7373 * (v63 + v50);
        v41 = v36 + v38;
        v42 = 2446 * v50 + v40;
        v43 = v47 + v39 + v36;
        v44 = 12299 * v63 + v39 - 7373 * (v63 + v50);
        v51 = v42;
        v48 = v43;
        v68 = 25172 * v67 + v41;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((v42 + v55 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*) (a6 + (((v59 - v44 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((v48 + v53 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*) (a6 + (((v57 - v68 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((v68 + v57 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*) (a6 + (((v53 - v48 + 0x20000) >> 18) & 0x3FF));
        v42 <<= 8;
        v43 <<= 8;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((v44 + v59 + 0x20000) >> 18) & 0x3FF));
        LOBYTE(v43) = *(_BYTE*) (a6 + (((v55 - v51 + 0x20000) >> 18) & 0x3FF));
        *v27 = v42;
        v27 [1] = v43;
        v72 += 8;
        result = --v70;
    }
    while(v70);
    return result;
}

//----- (00459CEE) --------------------------------------------------------
int __cdecl sub_459CEE(__m64* a1, __m64* a2, __m64* a3, int a4, int a5, int a6) {
    __m64 v6; // mm0
    __m64 v7; // mm2
    __m64 v8; // mm4
    __m64 v9; // mm5
    __m64 v10; // mm0
    __m64 v11; // mm6
    __m64 v12; // mm0
    __m64 v13; // mm6
    __m64 v14; // mm4
    __m64 v15; // mm3
    __m64 v16; // mm5
    __m64 v17; // mm6
    __m64 v18; // mm1
    __m64 v19; // mm0
    __m64 v20; // mm1
    __m64 v21; // mm6
    __m64 v22; // mm0
    __m64 v23; // mm6
    __m64 v24; // mm2
    __m64 v25; // mm1
    __m64 v26; // mm0
    __m64 v27; // mm2
    __m64 v28; // mm1
    __m64 v29; // mm3
    __m64 v30; // mm6
    __m64 v31; // mm4
    __m64 v32; // mm5
    __m64 v33; // mm7
    __m64 v34; // mm0
    __m64 v35; // mm2
    __m64 v36; // mm4
    __m64 v37; // mm1
    __m64 v38; // mm5
    __m64 v39; // mm3
    __m64 v40; // mm0
    __m64 v41; // mm7
    __m64 v42; // mm6
    __m64 v43; // mm1
    __m64 v44; // mm5
    __m64 v45; // mm2
    __m64 v46; // mm4
    __m64 v47; // mm6
    __m64 v48; // mm0
    __m64 v49; // mm1
    __m64 v50; // mm0
    __m64 v51; // mm2
    __m64 v52; // mm0
    __m64 v53; // mm1
    __m64 v54; // mm4
    __m64 v55; // mm7
    __m64 v56; // mm1
    __m64 v57; // mm0
    __m64 v58; // mm6
    __m64 v59; // mm2
    __m64 v60; // mm6
    __m64 v61; // mm0
    __m64 v62; // mm3
    __m64 v63; // mm1
    int result; // eax
    __m64 v65; // mm1
    __m64 v66; // mm4
    __m64 v67; // mm2
    __m64 v68; // mm5
    __m64 v69; // mm7
    __m64 v70; // mm5
    __m64 v71; // mm3
    __m64 v72; // mm4
    __m64 v73; // mm7
    __m64 v74; // mm5
    __m64 v75; // mm3
    __m64 v76; // mm5
    __m64 v77; // mm1
    __m64 v78; // mm0
    __m64 v79; // mm1
    __m64 v80; // mm3
    __m64 v81; // mm2
    __m64 v82; // mm1
    __m64 v83; // mm0
    int v84; // edi
    __m64 v85; // mm3
    unsigned int v86; // eax
    __m64 v87; // mm4
    __m64 v88; // mm2
    int v89; // [esp+Ch] [ebp-FCh]
    int v90; // [esp+Ch] [ebp-FCh]
    int v91; // [esp+10h] [ebp-F8h]
    __m64* v93; // [esp+18h] [ebp-F0h]
    __m64* v94; // [esp+18h] [ebp-F0h]
    __m64 v96; // [esp+20h] [ebp-E8h]
    __m64 v97; // [esp+28h] [ebp-E0h]
    __m64 v98; // [esp+30h] [ebp-D8h]
    __m64 v99; // [esp+38h] [ebp-D0h]
    __m64 v100; // [esp+40h] [ebp-C8h]
    __m64 v101; // [esp+50h] [ebp-B8h]
    __m64 v102; // [esp+58h] [ebp-B0h]
    __m64 v103; // [esp+60h] [ebp-A8h]
    __m64 v104; // [esp+70h] [ebp-98h]
    __m64 v105; // [esp+80h] [ebp-88h]
    __m64 v106; // [esp+88h] [ebp-80h]
    __m64 v107; // [esp+90h] [ebp-78h]
    __m64 v108; // [esp+98h] [ebp-70h]
    __m64 v109; // [esp+A0h] [ebp-68h]
    __m64 v110; // [esp+B0h] [ebp-58h]
    __m64 v111; // [esp+C0h] [ebp-48h]
    __m64 v112; // [esp+C8h] [ebp-40h]
    __m64 v113; // [esp+D0h] [ebp-38h]
    __m64 v114; // [esp+E0h] [ebp-28h]
    __m64 v115; // [esp+E8h] [ebp-20h]
    __m64 v116; // [esp+F0h] [ebp-18h]
    __m64 v117; // [esp+F8h] [ebp-10h]
    __m64 v118; // [esp+100h] [ebp-8h]

    v89 = 2;
    v93 = a3;
    do {
        v6 = _m_pmullw(a1 [4], a2 [4]);
        v7 = _m_pmullw(a1 [12], a2 [12]);
        v8 = _m_pmaddwd(v6, (__m64)0x187E0000187Ei64);
        v9 = _m_pmaddwd(_m_psrlqi(v6, 0x10u), (__m64)0x187E0000187Ei64);
        v10 = _m_paddw(v6, v7);
        v11 = _m_psrlqi(v10, 0x10u);
        v12 = _m_pmaddwd(v10, (__m64)0x115100001151i64);
        v13 = _m_pmaddwd(v11, (__m64)0x115100001151i64);
        v14 = _m_paddd(v8, v12);
        v15 = _m_paddd(
            _m_paddd(
            _m_pxor(_m_pmaddwd(_m_psrlqi(v7, 0x10u), (__m64)0x3B2100003B21i64), (__m64) - 1i64),
            (__m64)0x100000001i64),
            v13);
        v16 = _m_paddd(v9, v13);
        v118 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v7, (__m64)0x3B2100003B21i64), (__m64) - 1i64), (__m64)0x100000001i64),
            v12);
        v17 = _m_pmullw(a1 [8], a2 [8]);
        v18 = _m_pmullw((__m64)a1->m64_u64, (__m64)a2->m64_u64);
        v19 = _m_paddw(v18, v17);
        v20 = _m_psubw(v18, v17);
        v21 = v19;
        v22 = _m_pslldi(_m_pmaddwd(v19, (__m64)0x100000001i64), 0xDu);
        v23 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v21, 0x10u), (__m64)0x100000001i64), 0xDu);
        v24 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v20, 0x10u), (__m64)0x100000001i64), 0xDu);
        v116 = _m_psubd(v22, v14);
        v114 = _m_paddd(v16, v23);
        v113 = _m_psubd(v23, v16);
        v111 = _m_paddd(v14, v22);
        v25 = _m_pslldi(_m_pmaddwd(v20, (__m64)0x100000001i64), 0xDu);
        v110 = _m_paddd(v15, v24);
        v109 = _m_psubd(v24, v15);
        v107 = _m_paddd(v118, v25);
        v105 = _m_psubd(v25, v118);
        v104 = _m_pmullw(a1 [2], a2 [2]);
        v103 = _m_pmullw(a1 [14], a2 [14]);
        v26 = _m_paddw(v103, v104);
        v101 = _m_pmullw(a1 [10], a2 [10]);
        v100 = _m_pmullw(a1 [6], a2 [6]);
        v27 = _m_paddw(v101, v100);
        v28 = _m_paddw(v103, v100);
        v29 = _m_paddw(v101, v104);
        v30 = _m_paddw(v28, v29);
        v98 = _m_pmaddwd(v30, (__m64)0x25A1000025A1i64);
        v31 = _m_psrlqi(v27, 0x10u);
        v97 = _m_pmaddwd(_m_psrlqi(v30, 0x10u), (__m64)0x25A1000025A1i64);
        v32 = _m_psrlqi(v28, 0x10u);
        v112 = _m_paddd(_m_pxor(_m_pmaddwd(v26, (__m64)0x1CCD00001CCDi64), (__m64) - 1i64), (__m64)0x100000001i64);
        v33 = _m_pmaddwd(_m_psrlqi(v26, 0x10u), (__m64)0x1CCD00001CCDi64);
        v34 = _m_psrlqi(v29, 0x10u);
        v35 = _m_paddd(_m_pxor(_m_pmaddwd(v27, (__m64)0x520300005203i64), (__m64) - 1i64), (__m64)0x100000001i64);
        v36 = _m_paddd(_m_pxor(_m_pmaddwd(v31, (__m64)0x520300005203i64), (__m64) - 1i64), (__m64)0x100000001i64);
        v106 = _m_paddd(_m_pxor(v33, (__m64) - 1i64), (__m64)0x100000001i64);
        v37 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v28, (__m64)0x3EC500003EC5i64), (__m64) - 1i64), (__m64)0x100000001i64),
            v98);
        v38 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v32, (__m64)0x3EC500003EC5i64), (__m64) - 1i64), (__m64)0x100000001i64),
            v97);
        v39 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v29, (__m64)0xC7C00000C7Ci64), (__m64) - 1i64), (__m64)0x100000001i64),
            v98);
        v40 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v34, (__m64)0xC7C00000C7Ci64), (__m64) - 1i64), (__m64)0x100000001i64),
            v97);
        v96 = _m_paddd(v37, v35);
        v102 = _m_paddd(v38, v36);
        v115 = _m_paddd(_m_pmaddwd(v103, (__m64)0x98E0000098Ei64), _m_paddd(v112, v37));
        v99 = _m_paddd(_m_pmaddwd(_m_psrlqi(v103, 0x10u), (__m64)0x98E0000098Ei64), _m_paddd(v106, v38));
        v41 = _m_paddd(_m_pmaddwd(v104, (__m64)0x300B0000300Bi64), _m_paddd(v39, v112));
        v42 = _m_paddd(_m_pmaddwd(_m_psrlqi(v104, 0x10u), (__m64)0x300B0000300Bi64), _m_paddd(v40, v106));
        v108 = _m_paddd(_m_pmaddwd(v101, (__m64)0x41B3000041B3i64), _m_paddd(v35, v39));
        v117 = _m_paddd(_m_pmaddwd(_m_psrlqi(v101, 0x10u), (__m64)0x41B3000041B3i64), _m_paddd(v36, v40));
        v43 = _m_psradi(_m_paddd(_m_psubd(v114, v42), (__m64)0x40000000400i64), 0xBu);
        v44 = _m_paddd(_m_pmaddwd(v100, (__m64)0x625400006254i64), v96);
        v45 = _m_psradi(_m_paddd(_m_psubd(v111, v41), (__m64)0x40000000400i64), 0xBu);
        v46 = _m_paddd(_m_pmaddwd(_m_psrlqi(v100, 0x10u), (__m64)0x625400006254i64), v102);
        v93 [14].m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v45, v43), _m_punpckhwd(v45, v43));
        v47 = _m_psradi(_m_paddd(_m_paddd(v42, v114), (__m64)0x40000000400i64), 0xBu);
        v48 = _m_psradi(_m_paddd(_m_paddd(v41, v111), (__m64)0x40000000400i64), 0xBu);
        v93->m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v48, v47), _m_punpckhwd(v48, v47));
        v49 = _m_psradi(_m_paddd(_m_psubd(v110, v46), (__m64)0x40000000400i64), 0xBu);
        v50 = _m_psradi(_m_paddd(_m_psubd(v107, v44), (__m64)0x40000000400i64), 0xBu);
        v51 = _m_punpcklwd(v50, v49);
        v52 = _m_punpckhwd(v50, v49);
        v53 = _m_psradi(_m_paddd(_m_paddd(v44, v107), (__m64)0x40000000400i64), 0xBu);
        v93 [12].m64_u64 = (unsigned __int64) _m_punpckldq(v51, v52);
        v54 = _m_psradi(_m_paddd(_m_paddd(v46, v110), (__m64)0x40000000400i64), 0xBu);
        v93 [2].m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v53, v54), _m_punpckhwd(v53, v54));
        v55 = _m_psradi(_m_paddd(_m_paddd(v109, v117), (__m64)0x40000000400i64), 0xBu);
        v56 = _m_psradi(_m_paddd(_m_paddd(v105, v108), (__m64)0x40000000400i64), 0xBu);
        v57 = _m_psradi(_m_paddd(_m_psubd(v109, v117), (__m64)0x40000000400i64), 0xBu);
        v93 [4].m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v56, v55), _m_punpckhwd(v56, v55));
        v58 = _m_psradi(_m_paddd(_m_psubd(v105, v108), (__m64)0x40000000400i64), 0xBu);
        v59 = _m_punpckldq(_m_punpcklwd(v58, v57), _m_punpckhwd(v58, v57));
        v60 = _m_psradi(_m_paddd(_m_paddd(v116, v115), (__m64)0x40000000400i64), 0xBu);
        v61 = _m_psradi(_m_paddd(_m_paddd(v113, v99), (__m64)0x40000000400i64), 0xBu);
        v62 = _m_psradi(_m_paddd(_m_psubd(v116, v115), (__m64)0x40000000400i64), 0xBu);
        v93 [10].m64_u64 = (unsigned __int64) v59;
        v63 = _m_psradi(_m_paddd(_m_psubd(v113, v99), (__m64)0x40000000400i64), 0xBu);
        v93 [6].m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v60, v61), _m_punpckhwd(v60, v61));
        ++a1;
        ++a2;
        v93 [8].m64_u64 = (unsigned __int64) _m_punpckldq(_m_punpcklwd(v62, v63), _m_punpckhwd(v62, v63));
        ++v93;
        result = --v89;
    }
    while(v89);
    v90 = 8;
    v94 = a3;
    v91 = 0;
    do {
        v65 = v94 [1];
        v66 = _m_paddw((__m64)v94->m64_u64, v65);
        v67 = _m_pmaddwd(v66, (__m64)0x115100000000i64);
        v68 = _m_pmaddwd(_m_punpckhdq((__m64)v94->m64_u64, v65), (__m64)0x3B210000187Ei64);
        v69 = _m_psradi(_m_pslldi(_m_punpckldq(v66, _m_psubw((__m64)v94->m64_u64, v65)), 0x10u), 3u);
        v70 = _m_paddd(
            _m_punpckldq(v68, _m_psrlqi(_m_paddd(_m_pxor(v68, (__m64) - 1i64), (__m64)0x100000001i64), 0x20u)),
            _m_punpckhdq(v67, v67));
        v71 = v66;
        v72 = _m_paddd(v69, v70);
        v73 = _m_psubd(v69, v70);
        v74 = _m_pmaddwd(_m_paddw(_m_punpckldq(v71, v71), v71), (__m64)0x25A1000000000000i64);
        v75 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v71, (__m64)0x3EC500000C7C0000i64), (__m64) - 1i64), (__m64)0x100000001i64),
            _m_punpckhdq(v74, v74));
        v76 = _m_paddd(
            _m_pxor(
            _m_pmaddwd(
            _m_paddw(_m_punpckhdq((__m64)v94->m64_u64, _m_punpckldq((__m64)v94->m64_u64, (__m64)v94->m64_u64)), v65),
            (__m64)0x1CCD000052030000i64),
            (__m64) - 1i64),
            (__m64)0x100000001i64);
        v77 = _m_paddd(_m_pmaddwd(v65, (__m64)0x98E000041B30000i64), _m_paddd(v76, v75));
        v78 = _m_paddd(
            _m_pmaddwd((__m64)v94->m64_u64, (__m64)0x62540000300B0000i64),
            _m_paddd(_m_punpckhdq(v76, _m_punpckldq(v76, v76)), v75));
        v79 = _m_punpckhdq(v77, _m_punpckldq(v77, v77));
        v80 = _m_psubd(v72, v78);
        v81 = _m_psubd(v73, v79);
        v82 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v79, v73), (__m64)0x2000000020000i64), 0x12u), (__m64)0x3FF000003FFi64);
        v83 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v78, v72), (__m64)0x2000000020000i64), 0x12u), (__m64)0x3FF000003FFi64);
        BYTE1(result) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(v82));
        v84 = *(_DWORD*) (v91 + a4);
        LOBYTE(result) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(_m_psrlqi(v82, 0x20u)));
        v91 += 4;
        v85 = _m_pand(_m_psradi(_m_paddd(v80, (__m64)0x2000000020000i64), 0x12u), (__m64)0x3FF000003FFi64);
        v86 = result << 16;
        LOBYTE(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(v83));
        BYTE1(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(_m_psrlqi(v83, 0x20u)));
        v87 = _mm_cvtsi32_si64(v86);
        v88 = _m_pand(_m_psradi(_m_paddd(v81, (__m64)0x2000000020000i64), 0x12u), (__m64)0x3FF000003FFi64);
        BYTE1(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(v85));
        LOBYTE(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(_m_psrlqi(v85, 0x20u)));
        v86 <<= 16;
        LOBYTE(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(v88));
        BYTE1(v86) = *(_BYTE*) (a6 + _mm_cvtsi64_si32(_m_psrlqi(v88, 0x20u)));
        v94 += 2;
        *(__m64*)(a5 + v84) = _m_punpckldq(v87, _mm_cvtsi32_si64(v86));
        result = v90 - 1;
        v90 = result;
    }
    while(result);
    _m_empty();
    return result;
}

//----- (0045A479) --------------------------------------------------------
__int16 __cdecl sub_45A479(_WORD* a1, _WORD* a2, _WORD* a3, int a4, int a5, int a6) {
    __int16 v6; // bx
    __int16 v7; // dx
    __int16 v8; // ax
    __int16 v9; // bx
    __int16 v10; // bx
    __int16 v11; // ax
    __int16 v12; // bx
    __int16 v13; // cx
    __int16 v14; // ax
    __int16 v15; // bx
    __int16 v16; // dx
    __int16 v17; // bx
    __int16 v18; // cx
    __int16 v19; // ax
    int v20; // ecx
    __int16 v21; // dx
    int v22; // ebx
    __int16 v23; // dx
    __int16 v24; // dx
    _BYTE* v25; // edi
    __int16 v26; // bx
    __int16 v27; // dx
    __int16 v28; // ax
    __int16 v29; // bx
    __int16 v30; // bx
    __int16 v31; // ax
    __int16 v32; // bx
    __int16 v33; // cx
    __int16 v34; // ax
    __int16 v35; // bx
    __int16 v36; // dx
    __int16 v37; // bx
    __int16 v38; // cx
    __int16 v39; // ax
    int v40; // ecx
    __int16 v41; // dx
    int v42; // ebx
    __int16 v43; // dx
    __int16 result; // ax
    __int16 v45; // [esp+Ch] [ebp-2Ch]
    __int16 v46; // [esp+10h] [ebp-28h]
    __int16 v47; // [esp+10h] [ebp-28h]
    __int16 v48; // [esp+10h] [ebp-28h]
    __int16 v49; // [esp+10h] [ebp-28h]
    __int16 v50; // [esp+14h] [ebp-24h]
    __int16 v51; // [esp+14h] [ebp-24h]
    __int16 v52; // [esp+18h] [ebp-20h]
    __int16 v53; // [esp+18h] [ebp-20h]
    __int16 v54; // [esp+1Ch] [ebp-1Ch]
    __int16 v55; // [esp+1Ch] [ebp-1Ch]
    __int16 v56; // [esp+20h] [ebp-18h]
    __int16 v57; // [esp+20h] [ebp-18h]
    __int16 v58; // [esp+20h] [ebp-18h]
    __int16 v59; // [esp+20h] [ebp-18h]
    __int16 v60; // [esp+20h] [ebp-18h]
    __int16 v61; // [esp+24h] [ebp-14h]
    __int16 v62; // [esp+24h] [ebp-14h]
    int v63; // [esp+28h] [ebp-10h]
    _WORD* v64; // [esp+2Ch] [ebp-Ch]
    _WORD* v65; // [esp+2Ch] [ebp-Ch]

    v64 = a2;
    v61 = 8;
    do {
        v6 = a3 [32] * a1 [32];
        v7 = a3 [48] * a1 [48];
        v56 = *a3 * *a1;
        v8 = v6 + v56;
        v57 = v56 - v6;
        v9 = a3 [16] * a1 [16];
        v54 = v7 + v9 + v8;
        v52 = v8 - (v7 + v9);
        v10 = ((362 * (__int16) (v9 - v7)) >> 8) - (v7 + v9);
        v11 = v10 + v57;
        v58 = v57 - v10;
        v50 = v11;
        v12 = a3 [56] * a1 [56];
        v13 = a3 [24] * a1 [24];
        v46 = a3 [8] * a1 [8];
        v14 = v12 + v46;
        v47 = v46 - v12;
        v15 = a3 [40] * a1 [40];
        v16 = v13 + v15;
        v17 = v15 - v13;
        v18 = v14;
        v19 = v16 + v14;
        v20 = (__int16) (v18 - v16);
        v21 = v17;
        v22 = (473 * (__int16) (v47 + v17)) >> 8;
        v23 = v22 + ((-669 * v21) >> 8) - v19;
        *v64 = v54 + v19;
        v64 [56] = v54 - v19;
        v64 [8] = v50 + v23;
        v64 [48] = v50 - v23;
        v24 = ((362 * v20) >> 8) - v23;
        v64 [16] = v58 + v24;
        v64 [40] = v58 - v24;
        LOWORD(v20) = v24 + ((277 * v47) >> 8) - v22;
        v64 [32] = v52 + v20;
        v64 [24] = v52 - v20;
        ++a1;
        ++a3;
        ++v64;
        --v61;
    }
    while(v61);
    v63 = 0;
    v62 = 8;
    v65 = a2;
    do {
        v25 = (_BYTE*) (a5 + *(_DWORD*) (v63 + a4));
        v63 += 4;
        v26 = v65 [4];
        v27 = v65 [6];
        v28 = v26 + *v65;
        v59 = *v65 - v26;
        v29 = v65 [2];
        v55 = v27 + v29 + v28;
        v53 = v28 - (v27 + v29);
        v30 = ((362 * (__int16) (v29 - v27)) >> 8) - (v27 + v29);
        v31 = v30 + v59;
        v60 = v59 - v30;
        v51 = v31;
        v32 = v65 [7];
        v33 = v65 [3];
        v48 = v65 [1];
        v34 = v32 + v48;
        v49 = v48 - v32;
        v35 = v65 [5];
        v36 = v33 + v35;
        v37 = v35 - v33;
        v38 = v34;
        v39 = v36 + v34;
        v40 = (__int16) (v38 - v36);
        v41 = v37;
        v42 = (473 * (__int16) (v49 + v37)) >> 8;
        v43 = v42 + ((-669 * v41) >> 8) - v39;
        LOWORD(v40) = ((362 * v40) >> 8) - v43;
        v45 = v40 + ((277 * v49) >> 8) - v42;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((__int16) (v55 - v39) >> 5) & 0x3FF));
        *v25 = *(_BYTE*) (a6 + (((__int16) (v55 + v39) >> 5) & 0x3FF));
        v25 [7] = v42;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((__int16) (v51 - v43) >> 5) & 0x3FF));
        v25 [1] = *(_BYTE*) (a6 + (((__int16) (v51 + v43) >> 5) & 0x3FF));
        v25 [6] = v42;
        LOBYTE(v42) = *(_BYTE*) (a6 + (((__int16) (v60 - v40) >> 5) & 0x3FF));
        v25 [2] = *(_BYTE*) (a6 + (((__int16) (v60 + v40) >> 5) & 0x3FF));
        v25 [5] = v42;
        LOBYTE(v39) = *(_BYTE*) (a6 + (((__int16) (v53 - v45) >> 5) & 0x3FF));
        v25 [4] = *(_BYTE*) (a6 + (((__int16) (v53 + v45) >> 5) & 0x3FF));
        v25 [3] = v39;
        v65 += 8;
        result = --v62;
    }
    while(v62);
    return result;
}

//----- (0045A822) --------------------------------------------------------
char __cdecl sub_45A822(__m64* a1, __m64* a2, __m64* a3, _DWORD* a4, int a5, int a6) {
    __m64 v6; // mm0
    __m64 v7; // mm2
    __m64 v8; // mm5
    __m64 v9; // mm6
    __m64 v10; // mm2
    __m64 v11; // mm4
    __m64 v12; // mm3
    __m64 v13; // mm4
    __m64 v14; // mm5
    __m64 v15; // mm6
    __m64 v16; // mm0
    __m64 v17; // mm3
    __m64 v18; // mm7
    __m64 v19; // mm4
    __m64 v20; // mm3
    __m64 v21; // mm0
    __m64 v22; // mm5
    __m64 v23; // mm4
    __m64 v24; // mm0
    __m64 v25; // mm4
    __m64 v26; // mm5
    __m64 v27; // mm2
    __m64 v28; // mm1
    __m64 v29; // mm0
    __m64 v30; // mm3
    __m64 v31; // mm4
    __m64 v32; // mm1
    __m64 v33; // mm2
    __m64 v34; // mm4
    __m64 v35; // mm0
    __m64 v36; // mm6
    __m64 v37; // mm3
    __m64 v38; // mm0
    __m64 v39; // mm1
    __m64 m64_u64; // mm6
    __m64 v41; // mm1
    __m64 v42; // mm7
    __m64 v43; // mm5
    __m64 v44; // mm2
    __m64 v45; // mm4
    __m64 v46; // mm0
    __m64 v47; // mm1
    __m64 v48; // mm4
    __m64 v49; // mm3
    __m64 v50; // mm1
    __m64 v51; // mm6
    __m64 v52; // mm5
    __m64 v53; // mm6
    __m64 v54; // mm7
    __m64 v55; // mm3
    __m64 v56; // mm0
    __m64 v57; // mm3
    __m64 v58; // mm4
    __m64 v59; // mm6
    __m64 v60; // mm5
    __m64 v61; // mm6
    __m64 v62; // mm4
    __m64 v63; // mm5
    __m64 v64; // mm1
    __m64 v65; // mm2
    __m64 v66; // mm7
    __m64 v67; // mm3
    __m64 v68; // mm6
    __m64 v69; // mm3
    __m64 v70; // mm1
    __m64 v71; // mm4
    __m64 v72; // mm0
    __m64 v73; // mm2
    __m64 v74; // mm6
    __m64 v75; // mm1
    __m64 v76; // mm0
    __m64 v77; // mm5
    __m64 v78; // mm6
    __m64 v79; // mm0
    __m64 v80; // mm5
    __m64 v81; // mm0
    __m64 v82; // mm6
    __m64 v83; // mm2
    __m64 v84; // mm3
    __m64 v85; // mm7
    __m64 v86; // mm2
    __m64 v87; // mm5
    __m64 v88; // mm4
    __m64 v89; // mm3
    __m64 v90; // mm2
    __m64 v91; // mm7
    __m64 v92; // mm3
    __m64 v93; // mm1
    __m64 v94; // mm2
    __m64 v95; // mm0
    __m64 v96; // mm2
    __m64 v97; // mm1
    __m64 v98; // mm4
    __m64 v99; // mm3
    __m64 v100; // mm4
    __m64 v101; // mm1
    __m64 v102; // mm5
    __m64 v103; // mm0
    __m64 v104; // mm1
    __m64 v105; // mm3
    __m64 v106; // mm2
    __m64 v107; // mm5
    __m64 v108; // mm4
    __m64 v109; // mm1
    __m64 v110; // mm0
    __m64 v111; // mm3
    __m64 v112; // mm1
    __m64 v113; // mm4
    __m64 v114; // mm2
    __m64 v115; // mm0
    __m64 v116; // mm2
    __m64 v117; // mm0
    __m64 v118; // mm2
    __m64 v119; // mm5
    __m64 v120; // mm4
    __m64 v121; // mm2
    __m64 v122; // mm1
    __m64 v123; // mm4
    __m64 v124; // mm6
    __m64 v125; // mm5
    __m64 v126; // mm0
    __m64 v127; // mm3
    __m64 v128; // mm7
    __m64 v129; // mm4
    __m64 v130; // mm3
    __m64 v131; // mm0
    __m64 v132; // mm2
    __m64 v133; // mm6
    __m64 v134; // mm4
    __m64 v135; // mm5
    __m64 v136; // mm1
    __m64 v137; // mm0
    __m64 v138; // mm3
    __m64 v139; // mm1
    __m64 v140; // mm2
    __m64 v141; // mm4
    __m64 v142; // mm0
    __m64 v143; // mm6
    __m64 v144; // mm3
    __m64 v145; // mm0
    __m64 v146; // mm1
    __m64 v147; // mm6
    __m64 v148; // mm1
    __m64 v149; // mm7
    __m64 v150; // mm5
    __m64 v151; // mm2
    __m64 v152; // mm6
    __m64 v153; // mm4
    __m64 v154; // mm3
    __m64 v155; // mm1
    __m64 v156; // mm5
    __m64 v157; // mm7
    __m64 v158; // mm6
    __m64 v159; // mm4
    __m64 v160; // mm3
    __m64 v161; // mm0
    __m64 v162; // mm3
    __m64 v163; // mm6
    __m64 v164; // mm5
    __m64 v165; // mm6
    __m64 v166; // mm4
    __m64 v167; // mm5
    __m64 v168; // mm1
    __m64 v169; // mm2
    __m64 v170; // mm4
    __m64 v171; // mm2
    __m64 v172; // mm3
    __m64 v173; // mm6
    __m64 v174; // mm3
    __m64 v175; // mm1
    __m64 v176; // mm4
    __m64 v177; // mm2
    __m64 v178; // mm6
    __m64 v179; // mm1
    __m64 v180; // mm5
    __m64 v181; // mm0
    __m64 v182; // mm6
    _BYTE* v183; // ebx
    __m64 v184; // mm0
    __m64 v185; // mm5
    __m64 v186; // mm0
    __m64 v187; // mm2
    __m64 v188; // mm6
    __m64 v189; // mm3
    __m64 v190; // mm7
    __m64 v191; // mm2
    __m64 v192; // mm4
    __m64 v193; // mm5
    __m64 v194; // mm5
    __m64 v195; // mm5
    _BYTE* v196; // ebx
    __m64 v197; // mm4
    __m64 v198; // mm3
    __m64 v199; // mm4
    __m64 v200; // mm4
    __m64 v201; // mm4
    _BYTE* v202; // ecx
    __m64 v203; // mm0
    __m64 v204; // mm0
    __m64 v205; // mm0
    _BYTE* v206; // ebx
    __m64 v207; // mm3
    __m64 v208; // mm3
    __m64 v209; // mm3
    _BYTE* v210; // ebx
    __m64 v211; // mm4
    __m64 v212; // mm5
    __m64 v213; // mm2
    __m64 v214; // mm3
    __m64 v215; // mm7
    __m64 v216; // mm3
    __m64 v217; // mm1
    __m64 v218; // mm6
    __m64 v219; // mm6
    __m64 v220; // mm6
    _BYTE* v221; // ebx
    __m64 v222; // mm2
    __m64 v223; // mm2
    __m64 v224; // mm2
    _BYTE* v225; // ecx
    __m64 v226; // mm5
    __m64 v227; // mm5
    __m64 v228; // mm5
    _BYTE* v229; // ebx
    __m64 v230; // mm1
    __m64 v231; // mm1
    __m64 v232; // mm1
    _BYTE* v233; // ebx
    __m64 v234; // mm1
    __m64 v235; // mm2
    __m64 v236; // mm0
    __m64 v237; // mm2
    __m64 v238; // mm4
    __m64 v239; // mm1
    __m64 v240; // mm5
    __m64 v241; // mm3
    __m64 v242; // mm4
    __m64 v243; // mm1
    __m64 v244; // mm0
    __m64 v245; // mm1
    __m64 v246; // mm3
    __m64 v247; // mm0
    __m64 v248; // mm0
    __m64 v249; // mm0
    _BYTE* v250; // ebx
    __m64 v251; // mm2
    __m64 v252; // mm5
    __m64 v253; // mm4
    __m64 v254; // mm1
    __m64 v255; // mm1
    __m64 v256; // mm1
    _BYTE* v257; // ecx
    __m64 v258; // mm0
    __m64 v259; // mm1
    __m64 v260; // mm3
    __m64 v261; // mm1
    __m64 v262; // mm4
    __m64 v263; // mm2
    __m64 v264; // mm2
    __m64 v265; // mm2
    _BYTE* v266; // ebx
    __m64 v267; // mm2
    __m64 v268; // mm5
    __m64 v269; // mm5
    __m64 v270; // mm5
    __m64 v271; // mm0
    __m64 v272; // mm2
    __m64 v273; // mm4
    __m64 v274; // mm5
    _BYTE* v275; // ebx
    __m64 v276; // mm3
    __m64 v277; // mm3
    __m64 v278; // mm3
    _BYTE* v279; // ebx
    __m64 v280; // mm4
    __m64 v281; // mm4
    __m64 v282; // mm4
    _BYTE* v283; // ecx
    __m64 v284; // mm1
    __m64 v285; // mm1
    __m64 v286; // mm1
    _BYTE* v287; // ebx
    __m64 v288; // mm5
    __m64 v289; // mm5
    __m64 v290; // mm5
    char result; // al
    __m64 v292; // [esp+14h] [ebp-10h]
    __m64 v293; // [esp+14h] [ebp-10h]
    __m64 v294; // [esp+1Ch] [ebp-8h]

    v6 = _m_pmullw(a1 [12], a3 [12]);
    v7 = _m_pmullw(a1 [4], a3 [4]);
    v8 = _m_pmullw(a1 [8], a3 [8]);
    v9 = _m_psubw(v7, v6);
    v10 = _m_paddw(v7, v6);
    v11 = _m_pmullw((__m64)a1->m64_u64, (__m64)a3->m64_u64);
    v12 = _m_paddw(v11, v8);
    v13 = _m_psubw(v11, v8);
    v14 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v9, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v9, 0i64), (__m64)0x16A0000016Ai64), 8u)),
        v10);
    a2 [4].m64_u64 = (unsigned __int64) _m_paddw(v12, v10);
    a2 [12].m64_u64 = (unsigned __int64) _m_paddw(v14, v13);
    v15 = _m_psubw(v12, v10);
    a2->m64_u64 = (unsigned __int64) _m_psubw(v13, v14);
    v16 = _m_pmullw(a1 [6], a3 [6]);
    v17 = _m_pmullw(a1 [10], a3 [10]);
    v18 = _m_psubw(v17, v16);
    v19 = _m_pmullw(a1 [14], a3 [14]);
    v20 = _m_paddw(v17, v16);
    v21 = _m_pmullw(a1 [2], a3 [2]);
    v22 = _m_paddw(v21, v19);
    v23 = _m_psubw(v21, v19);
    v292 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v23, 0i64), (__m64)0x11500000115i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v23, 0i64), (__m64)0x11500000115i64), 8u));
    v24 = _m_paddw(v18, v23);
    v25 = v22;
    v26 = _m_paddw(v22, v20);
    v27 = _m_psubw(v25, v20);
    v28 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v24, 0i64), (__m64)0x1D9000001D9i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v24, 0i64), (__m64)0x1D9000001D9i64), 8u));
    v29 = _m_psubw(v292, v28);
    v30 = v15;
    v31 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v27, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v27, 0i64), (__m64)0x16A0000016Ai64), 8u));
    v32 = _m_psubw(
        _m_paddw(
        v28,
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v18, 0i64), (__m64)0xFD630000FD63i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v18, 0i64), (__m64)0xFD630000FD63i64), 8u))),
        v26);
    v33 = a2 [12];
    v34 = _m_psubw(v31, v32);
    v35 = _m_paddw(v29, v34);
    v36 = _m_psubw(v15, v35);
    v37 = _m_paddw(v30, v35);
    v38 = v32;
    v39 = a2 [4];
    a2 [8].m64_u64 = (unsigned __int64) v37;
    a2 [6].m64_u64 = (unsigned __int64) v36;
    m64_u64 = (__m64)a2->m64_u64;
    a2->m64_u64 = (unsigned __int64) _m_paddw(v39, v26);
    a2 [14].m64_u64 = (unsigned __int64) _m_psubw(v39, v26);
    a2 [2].m64_u64 = (unsigned __int64) _m_paddw(v33, v38);
    a2 [12].m64_u64 = (unsigned __int64) _m_psubw(v33, v38);
    v41 = _m_pmullw(a1 [5], a3 [5]);
    a2 [4].m64_u64 = (unsigned __int64) _m_paddw(m64_u64, v34);
    a2 [10].m64_u64 = (unsigned __int64) _m_psubw(m64_u64, v34);
    v42 = _m_pmullw(a1 [13], a3 [13]);
    v43 = _m_pmullw(a1 [9], a3 [9]);
    v44 = _m_paddw(v41, v42);
    v45 = _m_psubw(v41, v42);
    v46 = _m_pmullw(a1 [11], a3 [11]);
    v47 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v45, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v45, 0i64), (__m64)0x16A0000016Ai64), 8u));
    v48 = _m_pmullw(a1 [1], a3 [1]);
    v49 = _m_paddw(v48, v43);
    v50 = _m_psubw(v47, v44);
    v51 = a1 [7];
    v52 = _m_psubw(v48, v43);
    a2 [5].m64_u64 = (unsigned __int64) _m_paddw(v49, v44);
    v53 = _m_pmullw(v51, a3 [7]);
    v54 = _m_psubw(v49, v44);
    a2 [13].m64_u64 = (unsigned __int64) _m_paddw(v52, v50);
    v55 = v46;
    a2 [9].m64_u64 = (unsigned __int64) _m_psubw(v52, v50);
    v56 = _m_paddw(v46, v53);
    v57 = _m_psubw(v55, v53);
    v58 = _m_pmullw(a1 [15], a3 [15]);
    v294 = v54;
    v59 = _m_pmullw(a1 [3], a3 [3]);
    v60 = _m_paddw(v59, v58);
    v61 = _m_psubw(v59, v58);
    v62 = v60;
    v63 = _m_paddw(v60, v56);
    v64 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v57, 0i64), (__m64)0xFD630000FD63i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v57, 0i64), (__m64)0xFD630000FD63i64), 8u));
    v65 = _m_psubw(v62, v56);
    v66 = _m_paddw(v57, v61);
    v67 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v66, 0i64), (__m64)0x1D9000001D9i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v66, 0i64), (__m64)0x1D9000001D9i64), 8u));
    v68 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v61, 0i64), (__m64)0x11500000115i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v61, 0i64), (__m64)0x11500000115i64), 8u)),
        v67);
    v69 = _m_psubw(_m_paddw(v67, v64), v63);
    v70 = a2 [5];
    v71 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v65, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v65, 0i64), (__m64)0x16A0000016Ai64), 8u)),
        v69);
    v72 = _m_paddw(v70, v63);
    v73 = a2 [13];
    v74 = _m_paddw(v68, v71);
    v75 = _m_psubw(v70, v63);
    a2 [1].m64_u64 = (unsigned __int64) v72;
    v76 = a2 [9];
    v77 = _m_paddw(v294, v74);
    a2 [7].m64_u64 = (unsigned __int64) _m_psubw(v294, v74);
    a2 [3].m64_u64 = (unsigned __int64) _m_paddw(v73, v69);
    v78 = _m_psubw(v76, v71);
    a2 [5].m64_u64 = (unsigned __int64) _m_paddw(v76, v71);
    v79 = v77;
    v80 = _m_punpcklwd(v77, v78);
    v81 = _m_punpckhwd(v79, v78);
    v82 = (__m64)a2->m64_u64;
    v83 = _m_psubw(v73, v69);
    v84 = _m_punpcklwd(v83, v75);
    v85 = a2 [2];
    v86 = _m_punpckhwd(v83, v75);
    a2 [9].m64_u64 = (unsigned __int64) _m_punpckldq(v80, v84);
    a2 [11].m64_u64 = (unsigned __int64) _m_punpckhdq(v80, v84);
    a2 [13].m64_u64 = (unsigned __int64) _m_punpckldq(v81, v86);
    a2 [15].m64_u64 = (unsigned __int64) _m_punpckhdq(v81, v86);
    v87 = _m_punpckhwd(v82, v85);
    v88 = a2 [6];
    v89 = a2 [4];
    v90 = _m_punpcklwd(v82, v85);
    v91 = _m_punpcklwd(v89, v88);
    v92 = _m_punpckhwd(v89, v88);
    a2->m64_u64 = (unsigned __int64) _m_punpckldq(v90, v91);
    a2 [2].m64_u64 = (unsigned __int64) _m_punpckhdq(v90, v91);
    a2 [4].m64_u64 = (unsigned __int64) _m_punpckldq(v87, v92);
    a2 [6].m64_u64 = (unsigned __int64) _m_punpckhdq(v87, v92);
    v93 = a2 [3];
    v94 = a2 [1];
    v95 = _m_punpcklwd(v94, v93);
    v96 = _m_punpckhwd(v94, v93);
    v97 = a2 [7];
    v98 = a2 [5];
    v99 = _m_punpcklwd(v98, v97);
    v100 = _m_punpckhwd(v98, v97);
    v101 = v95;
    v102 = v96;
    v103 = _m_punpckldq(v95, v99);
    v104 = _m_punpckhdq(v101, v99);
    v105 = a2 [8];
    a2 [8].m64_u64 = (unsigned __int64) v103;
    v106 = _m_punpckldq(v96, v100);
    v107 = _m_punpckhdq(v102, v100);
    v108 = a2 [10];
    a2 [10].m64_u64 = (unsigned __int64) v104;
    v109 = v105;
    v110 = a2 [12];
    v111 = _m_punpcklwd(v105, v108);
    v112 = _m_punpckhwd(v109, v108);
    v113 = a2 [14];
    a2 [12].m64_u64 = (unsigned __int64) v106;
    v114 = v110;
    a2 [14].m64_u64 = (unsigned __int64) v107;
    v115 = _m_punpcklwd(v110, v113);
    v116 = _m_punpckhwd(v114, v113);
    a2 [1].m64_u64 = (unsigned __int64) _m_punpckldq(v111, v115);
    a2 [3].m64_u64 = (unsigned __int64) _m_punpckhdq(v111, v115);
    a2 [5].m64_u64 = (unsigned __int64) _m_punpckldq(v112, v116);
    a2 [7].m64_u64 = (unsigned __int64) _m_punpckhdq(v112, v116);
    v117 = a2 [12];
    v118 = a2 [4];
    v119 = a2 [8];
    v120 = _m_psubw(v118, v117);
    v121 = _m_paddw(v118, v117);
    v122 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v120, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v120, 0i64), (__m64)0x16A0000016Ai64), 8u));
    v123 = _m_psubw((__m64)a2->m64_u64, v119);
    v124 = _m_paddw((__m64)a2->m64_u64, v119);
    v125 = _m_psubw(v122, v121);
    a2 [4].m64_u64 = (unsigned __int64) _m_paddw(v124, v121);
    a2 [12].m64_u64 = (unsigned __int64) _m_paddw(v125, v123);
    a2->m64_u64 = (unsigned __int64) _m_psubw(v123, v125);
    v126 = a2 [6];
    v127 = a2 [10];
    v128 = _m_psubw(v127, v126);
    v129 = a2 [14];
    v130 = _m_paddw(v127, v126);
    v293 = _m_psubw(v124, v121);
    v131 = a2 [2];
    v132 = _m_psubw(v131, v129);
    v133 = _m_paddw(v128, v132);
    v134 = _m_paddw(v131, v129);
    v135 = _m_paddw(v134, v130);
    v136 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v133, 0i64), (__m64)0x1D9000001D9i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v133, 0i64), (__m64)0x1D9000001D9i64), 8u));
    v137 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v132, 0i64), (__m64)0x11500000115i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v132, 0i64), (__m64)0x11500000115i64), 8u)),
        v136);
    v138 = _m_psubw(v134, v130);
    v139 = _m_psubw(
        _m_paddw(
        v136,
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v128, 0i64), (__m64)0xFD630000FD63i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v128, 0i64), (__m64)0xFD630000FD63i64), 8u))),
        v135);
    v140 = a2 [12];
    v141 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v138, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v138, 0i64), (__m64)0x16A0000016Ai64), 8u)),
        v139);
    v142 = _m_paddw(v137, v141);
    v143 = _m_psubw(v293, v142);
    v144 = _m_paddw(v293, v142);
    v145 = v139;
    v146 = a2 [4];
    a2 [8].m64_u64 = (unsigned __int64) v144;
    a2 [6].m64_u64 = (unsigned __int64) v143;
    v147 = (__m64)a2->m64_u64;
    a2->m64_u64 = (unsigned __int64) _m_paddw(v146, v135);
    a2 [14].m64_u64 = (unsigned __int64) _m_psubw(v146, v135);
    a2 [2].m64_u64 = (unsigned __int64) _m_paddw(v140, v145);
    a2 [12].m64_u64 = (unsigned __int64) _m_psubw(v140, v145);
    v148 = a2 [5];
    a2 [4].m64_u64 = (unsigned __int64) _m_paddw(v147, v141);
    a2 [10].m64_u64 = (unsigned __int64) _m_psubw(v147, v141);
    v149 = a2 [13];
    v150 = a2 [9];
    v151 = _m_paddw(v148, v149);
    v152 = _m_psubw(v148, v149);
    v153 = a2 [1];
    v154 = _m_paddw(v153, v150);
    v155 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v152, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v152, 0i64), (__m64)0x16A0000016Ai64), 8u)),
        v151);
    v156 = _m_psubw(v153, v150);
    a2 [5].m64_u64 = (unsigned __int64) _m_paddw(v154, v151);
    a2 [13].m64_u64 = (unsigned __int64) _m_paddw(v156, v155);
    v157 = _m_psubw(v154, v151);
    a2 [9].m64_u64 = (unsigned __int64) _m_psubw(v156, v155);
    v158 = a2 [7];
    v159 = a2 [15];
    v160 = a2 [11];
    v161 = _m_paddw(v160, v158);
    v162 = _m_psubw(v160, v158);
    v163 = a2 [3];
    v164 = _m_paddw(v163, v159);
    v165 = _m_psubw(v163, v159);
    v166 = v164;
    v167 = _m_paddw(v164, v161);
    v168 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v162, 0i64), (__m64)0xFD630000FD63i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v162, 0i64), (__m64)0xFD630000FD63i64), 8u));
    v169 = _m_psubw(v166, v161);
    v170 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v169, 0i64), (__m64)0x16A0000016Ai64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v169, 0i64), (__m64)0x16A0000016Ai64), 8u));
    v171 = _m_paddw(v162, v165);
    v172 = _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v171, 0i64), (__m64)0x1D9000001D9i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v171, 0i64), (__m64)0x1D9000001D9i64), 8u));
    v173 = _m_psubw(
        _m_packssdw(
        _m_psradi(_m_pmaddwd(_m_punpcklwd(v165, 0i64), (__m64)0x11500000115i64), 8u),
        _m_psradi(_m_pmaddwd(_m_punpckhwd(v165, 0i64), (__m64)0x11500000115i64), 8u)),
        v172);
    v174 = _m_psubw(_m_paddw(v172, v168), v167);
    v175 = a2 [5];
    v176 = _m_psubw(v170, v174);
    v177 = a2 [13];
    v178 = _m_paddw(v173, v176);
    a2 [1].m64_u64 = (unsigned __int64) _m_paddw(v175, v167);
    v179 = _m_psubw(v175, v167);
    v180 = _m_paddw(v157, v178);
    v181 = a2 [9];
    a2 [7].m64_u64 = (unsigned __int64) _m_psubw(v157, v178);
    a2 [3].m64_u64 = (unsigned __int64) _m_paddw(v177, v174);
    v182 = _m_psubw(v181, v176);
    a2 [5].m64_u64 = (unsigned __int64) _m_paddw(v181, v176);
    v183 = (_BYTE*) (a5 + a4 [4]);
    v184 = v180;
    v185 = _m_punpcklwd(v180, v182);
    v186 = _m_punpckhwd(v184, v182);
    v187 = _m_psubw(v177, v174);
    v188 = (__m64)a2->m64_u64;
    v189 = _m_punpcklwd(v187, v179);
    v190 = a2 [2];
    v191 = _m_punpckhwd(v187, v179);
    v192 = v185;
    v193 = _m_psrlwi(_m_punpckldq(v185, v189), 5u);
    v183 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v193) & 0x3FF));
    v194 = _m_psrlqi(v193, 0x10u);
    v183 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v194) & 0x3FF));
    v195 = _m_psrlqi(v194, 0x10u);
    v183 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v195) & 0x3FF));
    v183 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v195, 0x10u)) & 0x3FF));
    v196 = (_BYTE*) (a5 + a4 [5]);
    v197 = _m_punpckhdq(v192, v189);
    v198 = v186;
    v199 = _m_psrlwi(v197, 5u);
    v196 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v199) & 0x3FF));
    v200 = _m_psrlqi(v199, 0x10u);
    v196 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v200) & 0x3FF));
    v201 = _m_psrlqi(v200, 0x10u);
    v196 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v201) & 0x3FF));
    v196 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v201, 0x10u)) & 0x3FF));
    v202 = (_BYTE*) (a5 + a4 [6]);
    v203 = _m_psrlwi(_m_punpckldq(v186, v191), 5u);
    v202 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v203) & 0x3FF));
    v204 = _m_psrlqi(v203, 0x10u);
    v202 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v204) & 0x3FF));
    v205 = _m_psrlqi(v204, 0x10u);
    v202 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v205) & 0x3FF));
    v202 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v205, 0x10u)) & 0x3FF));
    v206 = (_BYTE*) (a5 + a4 [7]);
    v207 = _m_psrlwi(_m_punpckhdq(v198, v191), 5u);
    v206 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v207) & 0x3FF));
    v208 = _m_psrlqi(v207, 0x10u);
    v206 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v208) & 0x3FF));
    v209 = _m_psrlqi(v208, 0x10u);
    v206 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v209) & 0x3FF));
    v206 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v209, 0x10u)) & 0x3FF));
    v210 = (_BYTE*) (a5 + *a4);
    v211 = a2 [6];
    v212 = _m_punpckhwd(v188, v190);
    v213 = _m_punpcklwd(v188, v190);
    v214 = a2 [4];
    v215 = _m_punpcklwd(v214, v211);
    v216 = _m_punpckhwd(v214, v211);
    v217 = v212;
    v218 = _m_psrlwi(_m_punpckldq(v213, v215), 5u);
    *v210 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v218) & 0x3FF));
    v219 = _m_psrlqi(v218, 0x10u);
    v210 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v219) & 0x3FF));
    v220 = _m_psrlqi(v219, 0x10u);
    v210 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v220) & 0x3FF));
    v210 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v220, 0x10u)) & 0x3FF));
    v221 = (_BYTE*) (a5 + a4 [1]);
    v222 = _m_psrlwi(_m_punpckhdq(v213, v215), 5u);
    *v221 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v222) & 0x3FF));
    v223 = _m_psrlqi(v222, 0x10u);
    v221 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v223) & 0x3FF));
    v224 = _m_psrlqi(v223, 0x10u);
    v221 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v224) & 0x3FF));
    v221 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v224, 0x10u)) & 0x3FF));
    v225 = (_BYTE*) (a5 + a4 [2]);
    v226 = _m_psrlwi(_m_punpckldq(v212, v216), 5u);
    *v225 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v226) & 0x3FF));
    v227 = _m_psrlqi(v226, 0x10u);
    v225 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v227) & 0x3FF));
    v228 = _m_psrlqi(v227, 0x10u);
    v225 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v228) & 0x3FF));
    v225 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v228, 0x10u)) & 0x3FF));
    v229 = (_BYTE*) (a5 + a4 [3]);
    v230 = _m_psrlwi(_m_punpckhdq(v217, v216), 5u);
    *v229 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v230) & 0x3FF));
    v231 = _m_psrlqi(v230, 0x10u);
    v229 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v231) & 0x3FF));
    v232 = _m_psrlqi(v231, 0x10u);
    v229 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v232) & 0x3FF));
    v229 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v232, 0x10u)) & 0x3FF));
    v233 = (_BYTE*) (a5 + a4 [4]);
    v234 = a2 [3];
    v235 = a2 [1];
    v236 = _m_punpcklwd(v235, v234);
    v237 = _m_punpckhwd(v235, v234);
    v238 = a2 [5];
    v239 = a2 [7];
    v240 = v237;
    v241 = _m_punpcklwd(v238, v239);
    v242 = _m_punpckhwd(v238, v239);
    v243 = v236;
    v244 = _m_punpckldq(v236, v241);
    v245 = _m_punpckhdq(v243, v241);
    v246 = a2 [8];
    v247 = _m_psrlwi(v244, 5u);
    *v233 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v247) & 0x3FF));
    v248 = _m_psrlqi(v247, 0x10u);
    v233 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v248) & 0x3FF));
    v249 = _m_psrlqi(v248, 0x10u);
    v233 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v249) & 0x3FF));
    v233 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v249, 0x10u)) & 0x3FF));
    v250 = (_BYTE*) (a5 + a4 [5]);
    v251 = _m_punpckldq(v237, v242);
    v252 = _m_punpckhdq(v240, v242);
    v253 = a2 [10];
    v254 = _m_psrlwi(v245, 5u);
    *v250 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v254) & 0x3FF));
    v255 = _m_psrlqi(v254, 0x10u);
    v250 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v255) & 0x3FF));
    v256 = _m_psrlqi(v255, 0x10u);
    v250 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v256) & 0x3FF));
    v250 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v256, 0x10u)) & 0x3FF));
    v257 = (_BYTE*) (a5 + a4 [6]);
    v258 = a2 [12];
    v259 = v246;
    v260 = _m_punpcklwd(v246, v253);
    v261 = _m_punpckhwd(v259, v253);
    v262 = a2 [14];
    v263 = _m_psrlwi(v251, 5u);
    *v257 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v263) & 0x3FF));
    v264 = _m_psrlqi(v263, 0x10u);
    v257 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v264) & 0x3FF));
    v265 = _m_psrlqi(v264, 0x10u);
    v257 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v265) & 0x3FF));
    v257 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v265, 0x10u)) & 0x3FF));
    v266 = (_BYTE*) (a5 + a4 [7]);
    v267 = v258;
    v268 = _m_psrlwi(v252, 5u);
    *v266 = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v268) & 0x3FF));
    v269 = _m_psrlqi(v268, 0x10u);
    v266 [1] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v269) & 0x3FF));
    v270 = _m_psrlqi(v269, 0x10u);
    v266 [2] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v270) & 0x3FF));
    v266 [3] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v270, 0x10u)) & 0x3FF));
    v271 = _m_punpcklwd(v258, v262);
    v272 = _m_punpckhwd(v267, v262);
    v273 = v260;
    v274 = v261;
    v275 = (_BYTE*) (a5 + *a4);
    v276 = _m_psrlwi(_m_punpckldq(v260, v271), 5u);
    v275 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v276) & 0x3FF));
    v277 = _m_psrlqi(v276, 0x10u);
    v275 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v277) & 0x3FF));
    v278 = _m_psrlqi(v277, 0x10u);
    v275 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v278) & 0x3FF));
    v275 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v278, 0x10u)) & 0x3FF));
    v279 = (_BYTE*) (a5 + a4 [1]);
    v280 = _m_psrlwi(_m_punpckhdq(v273, v271), 5u);
    v279 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v280) & 0x3FF));
    v281 = _m_psrlqi(v280, 0x10u);
    v279 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v281) & 0x3FF));
    v282 = _m_psrlqi(v281, 0x10u);
    v279 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v282) & 0x3FF));
    v279 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v282, 0x10u)) & 0x3FF));
    v283 = (_BYTE*) (a5 + a4 [2]);
    v284 = _m_psrlwi(_m_punpckldq(v261, v272), 5u);
    v283 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v284) & 0x3FF));
    v285 = _m_psrlqi(v284, 0x10u);
    v283 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v285) & 0x3FF));
    v286 = _m_psrlqi(v285, 0x10u);
    v283 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v286) & 0x3FF));
    v283 [7] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v286, 0x10u)) & 0x3FF));
    v287 = (_BYTE*) (a5 + a4 [3]);
    v288 = _m_psrlwi(_m_punpckhdq(v274, v272), 5u);
    v287 [4] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v288) & 0x3FF));
    v289 = _m_psrlqi(v288, 0x10u);
    v287 [5] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v289) & 0x3FF));
    v290 = _m_psrlqi(v289, 0x10u);
    v287 [6] = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(v290) & 0x3FF));
    result = *(_BYTE*) (a6 + (_mm_cvtsi64_si32(_m_psrlqi(v290, 0x10u)) & 0x3FF));
    v287 [7] = result;
    _m_empty();
    return result;
}

//----- (0045B5F5) --------------------------------------------------------
int __cdecl sub_45B5F5(int a1, int a2, int a3, int a4, _DWORD* a5, unsigned __int8** a6) {
    unsigned int v7; // edx
    unsigned int v9; // eax
    int v10; // eax
    unsigned __int8* v11; // eax
    _BYTE* v12; // ecx
    unsigned int v13; // ecx
    int v14; // ecx
    unsigned __int8* i; // eax
    int v16; // edi
    int v17; // edi
    unsigned int v18; // edi
    int v19; // eax
    char* v20; // eax
    _BYTE* v21; // edi
    char v22; // cl
    char* v23; // eax
    unsigned int v24; // ecx
    _BYTE* v25; // edi
    char v26; // cl
    bool v27; // zf
    _BYTE* v28; // edi
    char v29; // cl
    int v30; // eax
    int v32; // [esp+Ch] [ebp-14h]
    int v33; // [esp+10h] [ebp-10h]
    unsigned int v34; // [esp+14h] [ebp-Ch]
    unsigned __int8* v35; // [esp+18h] [ebp-8h]
    unsigned int v36; // [esp+1Ch] [ebp-4h]
    int v37; // [esp+28h] [ebp+8h]
    int v38; // [esp+28h] [ebp+8h]
    int v39; // [esp+28h] [ebp+8h]
    unsigned int j; // [esp+28h] [ebp+8h]
    unsigned int v41; // [esp+28h] [ebp+8h]
    unsigned int v42; // [esp+2Ch] [ebp+Ch]
    _BYTE* v43; // [esp+38h] [ebp+18h]
    unsigned int v44; // [esp+3Ch] [ebp+1Ch]

    v7 = a5 [7];
    v35 = *a6;
    v36 = (unsigned int) a6 [1];
    v44 = a5 [8];
    v9 = a5 [12];
    v43 = (_BYTE*) a5 [13];
    if((unsigned int) v43 >= v9)
        v10 = a5 [11] - (_DWORD) v43;
    else
        v10 = v9 - (_DWORD) v43 - 1;
    v34 = v10;
    v33 = dword_47A5D8 [a1];
    v32 = dword_47A5D8 [a2];
    do {
        while(v7 < 0x14) {
            --v36;
            v44 |= *v35++ << v7;
            v7 += 8;
        }
        v11 = (unsigned __int8*) (a3 + 8 * (v44 & v33));
        v37 = *v11;
        if(*v11) {
            while(1) {
                v44 >>= v11 [1];
                v7 -= v11 [1];
                if((v37 & 0x10) != 0)
                    break;
                if((v37 & 0x40) != 0) {
                    if((v37 & 0x20) != 0) {
                        v13 = (unsigned int) &a6 [1] [-v36];
                        if(v7 >> 3 < v13)
                            v13 = v7 >> 3;
                        v38 = 1;
                    }
                    else {
                        a6 [6] = "invalid literal/length code";
                        LABEL_40:
                        v13 = (unsigned int) &a6 [1] [-v36];
                        if(v7 >> 3 < v13)
                            v13 = v7 >> 3;
                        v38 = -3;
                    }
                    goto LABEL_43;
                }
                v11 += 8 * *((_DWORD*) v11 + 1) + 8 * (v44 & dword_47A5D8 [v37]);
                v37 = *v11;
                if(!*v11)
                    goto LABEL_11;
            }
            v42 = *((_DWORD*) v11 + 1) + (v44 & dword_47A5D8 [v37 & 0xF]);
            v14 = v37 & 0xF;
            v44 >>= v14;
            for(v7 -= v14; v7 < 0xF; v7 += 8) {
                --v36;
                v44 |= *v35++ << v7;
            }
            for(i = (unsigned __int8*) (a4 + 8 * (v44 & v32)); ; i += 8 * *((_DWORD*) i + 1) + 8 * (v44 & dword_47A5D8 [v39])) {
                v39 = *i;
                v44 >>= i [1];
                v7 -= i [1];
                if((v39 & 0x10) != 0)
                    break;
                if((v39 & 0x40) != 0) {
                    a6 [6] = "invalid distance code";
                    goto LABEL_40;
                }
            }
            for(j = v39 & 0xF; v7 < j; ++v35) {
                --v36;
                v16 = *v35 << v7;
                v7 += 8;
                v44 |= v16;
            }
            v17 = v44 & dword_47A5D8 [j];
            v44 >>= j;
            v18 = *((_DWORD*) i + 1) + v17;
            v34 -= v42;
            v19 = a5 [10];
            v7 -= j;
            if((unsigned int) &v43 [-v19] < v18) {
                v24 = v18 + v19 - (_DWORD) v43;
                v23 = (char*) (a5 [11] - v24);
                v41 = v24;
                if(v42 > v24) {
                    v42 -= v24;
                    do {
                        v25 = v43;
                        v26 = *v23;
                        ++v43;
                        ++v23;
                        v27 = v41-- == 1;
                        *v25 = v26;
                    }
                    while(!v27);
                    v23 = (char*) a5 [10];
                }
            }
            else {
                v20 = &v43 [-v18 + 1];
                *v43 = v43 [-v18];
                v21 = v43 + 1;
                v22 = *v20;
                v43 += 2;
                v23 = v20 + 1;
                v42 -= 2;
                *v21 = v22;
            }
            do {
                v28 = v43;
                v29 = *v23;
                ++v43;
                ++v23;
                v27 = v42-- == 1;
                *v28 = v29;
            }
            while(!v27);
        }
        else {
            LABEL_11:
            v44 >>= v11 [1];
            v7 -= v11 [1];
            v12 = v43++;
            --v34;
            *v12 = v11 [4];
        }
    }
    while(v34 >= 0x102 && v36 >= 0xA);
    v13 = (unsigned int) &a6 [1] [-v36];
    if(v7 >> 3 < v13)
        v13 = v7 >> 3;
    v38 = 0;
    LABEL_43:
    a5 [8] = v44;
    a5 [7] = v7 - 8 * v13;
    v30 = &v35 [-v13] - *a6;
    *a6 = &v35 [-v13];
    a6 [2] += v30;
    a6 [1] = (unsigned __int8*) (v36 + v13);
    a5 [13] = v43;
    return v38;
}
// 47A5D8: using guessed type int dword_47A5D8[19];

//----- (0045BA68) --------------------------------------------------------
void __thiscall sub_45BA68(void* this) {
    if(this != (void*) dword_47A630)
        report_failure();
}
// 45BA37: using guessed type void __noreturn report_failure(void);
// 47A630: using guessed type int dword_47A630;

//----- (0045BE40) --------------------------------------------------------
int __cdecl sub_45BE40(double a1, double a2) {
    return _ctrandisp2(a1, a2);
}

//----- (0045C100) --------------------------------------------------------
_DWORD* __cdecl sub_45C100(_DWORD* a1, int a2) {
    int v2; // ecx
    int v3; // ecx

    *a1 = a2;
    a1 [1] = *(_DWORD*) (_getptd(v2) + 132);
    *(_DWORD*) (_getptd(v3) + 132) = a1;
    return a1;
}
// 45C10B: variable 'v2' is possibly undefined
// 45C119: variable 'v3' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);

//----- (0045C149) --------------------------------------------------------
int __cdecl sub_45C149(int a1) {
    int v1; // ecx
    int v2; // ecx
    int result; // eax

    if(a1 == *(_DWORD*) (_getptd(v1) + 132)) {
        result = _getptd(v2);
        *(_DWORD*) (result + 132) = *(_DWORD*) (a1 + 4);
    }
    else {
        for(result = *(_DWORD*) (_getptd(v2) + 132); ; result = *(_DWORD*) (result + 4)) {
            if(!*(_DWORD*) (result + 4))
                sub_462197();
            if(a1 == *(_DWORD*) (result + 4))
                break;
        }
        *(_DWORD*) (result + 4) = *(_DWORD*) (a1 + 4);
    }
    return result;
}
// 45C14A: variable 'v1' is possibly undefined
// 45C15B: variable 'v2' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);

//----- (0045C6E8) --------------------------------------------------------
size_t __cdecl sub_45C6E8(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream) {
    size_t v5; // [esp+Ch] [ebp-1Ch]

    _lock_file(Stream);
    v5 = fread(Buffer, ElementSize, ElementCount, Stream);
    _unlock_file(Stream);
    return v5;
}

//----- (0045CB54) --------------------------------------------------------
size_t __cdecl sub_45CB54(void* Buffer, size_t ElementSize, size_t ElementCount, FILE* Stream) {
    size_t v5; // [esp+Ch] [ebp-1Ch]

    _lock_file(Stream);
    v5 = fwrite(Buffer, ElementSize, ElementCount, Stream);
    _unlock_file(Stream);
    return v5;
}

//----- (0045D30D) --------------------------------------------------------
int __cdecl sub_45D30D(FILE* Stream, char* a2, int a3) {
    int v4; // [esp+Ch] [ebp-24h]
    int v5; // [esp+10h] [ebp-20h]

    _lock_file(Stream);
    v5 = _stbuf(Stream);
    v4 = sub_45EAF5(Stream, a2, (int) &a3);
    _ftbuf(v5, Stream);
    _unlock_file(Stream);
    return v4;
}
// 463B0C: using guessed type _DWORD __cdecl _stbuf(_DWORD);
// 463B94: using guessed type _DWORD __cdecl _ftbuf(_DWORD, _DWORD);

//----- (0045D5F9) --------------------------------------------------------
int __cdecl sub_45D5F9(LPCSTR lpPathName) {
    DWORD LastError; // eax
    CHAR Buffer [264]; // [esp+0h] [ebp-110h] BYREF
    CHAR Name [2]; // [esp+108h] [ebp-8h] BYREF
    _WORD v5 [3]; // [esp+10Ah] [ebp-6h] BYREF
    unsigned int retaddr; // [esp+114h] [ebp+4h]

    *(_DWORD*) &v5 [1] = retaddr ^ dword_47A630;
    if(SetCurrentDirectoryA(lpPathName) && GetCurrentDirectoryA(0x105u, Buffer)) {
        if((Buffer [0] == 92 || Buffer [0] == 47) && Buffer [0] == Buffer [1])
            return 0;
        Name [0] = 61;
        Name [1] = _mbctoupper((unsigned __int8) Buffer [0]);
        strcpy((char*) v5, ":");
        if(SetEnvironmentVariableA(Name, Buffer))
            return 0;
    }
    LastError = GetLastError();
    _dosmaperr(LastError);
    return -1;
}
// 46323C: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 47A630: using guessed type int dword_47A630;

//----- (0045E01C) --------------------------------------------------------
int sub_45E01C() {
    int result; // eax
    int (**v1)(void); // esi
    void (**v2)(void); // esi

    if(off_47A624)
        off_47A624();
    result = 0;
    v1 = (int (**)(void)) & unk_4760A8;
    if(&unk_4760A8 >= (_UNKNOWN*) &dword_4760C0) {
        LABEL_9:
        atexit(sub_4643FB);
        v2 = (void (**)(void)) & unk_476000;
        if(&unk_476000 < (_UNKNOWN*) &dword_4760A4) {
            do {
                if(*v2)
                    (*v2)();
                ++v2;
            }
            while(v2 < &dword_4760A4);
        }
        return 0;
    }
    else {
        while(!result) {
            if(*v1)
                result = (*v1)();
            if(++v1 >= &dword_4760C0) {
                if(result)
                    return result;
                goto LABEL_9;
            }
        }
    }
    return result;
}
// 45B9C9: using guessed type _DWORD _fpmath();
// 4760A4: using guessed type void (*dword_4760A4)(void);
// 4760C0: using guessed type int (*dword_4760C0)(void);
// 47A624: using guessed type int (*off_47A624)(void);

//----- (0045E081) --------------------------------------------------------
int __cdecl sub_45E081(UINT uExitCode, int a2, int a3) {
    HANDLE CurrentProcess; // eax
    void (**v4)(void); // eax
    bool i; // cf
    void (*v6)(void); // eax
    void (**v7)(void); // edi
    void (**v8)(void); // edi

    _lock(8);
    if(dword_6E6240 == 1) {
        CurrentProcess = GetCurrentProcess();
        TerminateProcess(CurrentProcess, uExitCode);
    }
    dword_6E623C = 1;
    byte_6E6238 = a3;
    if(!a2) {
        if(Block) {
            v4 = (void (**)(void))(dword_6E79EC - 4);
            for(i = dword_6E79EC - 4 < (unsigned int) Block; ; i = dword_6E79EC - 4 < (unsigned int) Block) {
                dword_6E79EC = (int) v4;
                if(i)
                    break;
                v6 = *v4;
                if(v6)
                    v6();
                v4 = (void (**)(void))(dword_6E79EC - 4);
            }
        }
        v7 = (void (**)(void)) & unk_4760C4;
        if(&unk_4760C4 < (_UNKNOWN*) &dword_4760CC) {
            do {
                if(*v7)
                    (*v7)();
                ++v7;
            }
            while(v7 < &dword_4760CC);
        }
    }
    v8 = (void (**)(void)) & unk_4760D0;
    if(&unk_4760D0 < (_UNKNOWN*) &dword_4760D8) {
        do {
            if(*v8)
                (*v8)();
            ++v8;
        }
        while(v8 < &dword_4760D8);
    }
    if(!a3) {
        dword_6E6240 = 1;
        __crtExitProcess(uExitCode);
    }
    return _unlock(8);
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4760CC: using guessed type void (*dword_4760CC)(void);
// 4760D8: using guessed type void (*dword_4760D8)(void);
// 6E6238: using guessed type char byte_6E6238;
// 6E623C: using guessed type int dword_6E623C;
// 6E6240: using guessed type int dword_6E6240;
// 6E79EC: using guessed type int dword_6E79EC;

//----- (0045E194) --------------------------------------------------------
int __cdecl sub_45E194(int a1, int a2) {
    unsigned int v2; // esi
    LPVOID v3; // edi
    int result; // eax
    void* v5; // [esp+Ch] [ebp-20h]
    unsigned int Size; // [esp+10h] [ebp-1Ch]

    v2 = a2 * a1;
    Size = a2 * a1;
    if(!(a2 * a1))
        ++v2;
    while(1) {
        v3 = 0;
        if(v2 <= 0xFFFFFFE0) {
            if(dword_6E79E4 == 3) {
                v2 = (v2 + 15) & 0xFFFFFFF0;
                if(Size <= dword_6E79D0) {
                    _lock(4);
                    v5 = (void*) __sbh_alloc_block(Size);
                    _unlock(4);
                    v3 = v5;
                    if(!v5) {
                        LABEL_9:
                        v3 = HeapAlloc(hHeap, 8u, v2);
                        goto LABEL_10;
                    }
                    memset(v5, 0, Size);
                }
            }
            if(v3)
                return (int) v3;
            goto LABEL_9;
        }
        LABEL_10:
        if(v3 || !dword_6E639C)
            return (int) v3;
        result = _callnewh(v2);
        if(!result)
            return result;
    }
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 45FE1F: using guessed type _DWORD __cdecl __sbh_alloc_block(_DWORD);
// 6E79D0: using guessed type int dword_6E79D0;
// 6E79E4: using guessed type int dword_6E79E4;

//----- (0045E66A) --------------------------------------------------------
int __cdecl sub_45E66A(_DWORD* a1, int a2, int a3, int a4) {
    char Destination [24]; // [esp+8h] [ebp-2Ch] BYREF
    int v6 [5]; // [esp+20h] [ebp-14h] BYREF
    unsigned int retaddr; // [esp+38h] [ebp+4h]

    v6 [4] = retaddr ^ dword_47A630;
    sub_465E49(*a1, a1 [1], v6, Destination);
    _fptostr((void*) ((v6 [0] == 45) + a2 + (a3 > 0)), a3 + 1, (int) v6);
    _cftoe2(a3, a4, 0);
    return a2;
}
// 45E5BC: using guessed type _DWORD __cdecl _cftoe2(_DWORD, _DWORD, char);
// 47A630: using guessed type int dword_47A630;
// 45E66A: using guessed type char Destination[24];

//----- (0045E77A) --------------------------------------------------------
int __cdecl sub_45E77A(_DWORD* a1, int a2, size_t Size) {
    char Destination [24]; // [esp+4h] [ebp-2Ch] BYREF
    int v5 [5]; // [esp+1Ch] [ebp-14h] BYREF
    unsigned int retaddr; // [esp+34h] [ebp+4h]

    v5 [4] = retaddr ^ dword_47A630;
    sub_465E49(*a1, a1 [1], v5, Destination);
    _fptostr((void*) (a2 + (v5 [0] == 45)), Size + v5 [1], (int) v5);
    _cftof2(a2, Size, 0);
    return a2;
}
// 47A630: using guessed type int dword_47A630;
// 45E77A: using guessed type char Destination[24];

//----- (0045E7E2) --------------------------------------------------------
int __cdecl sub_45E7E2(_DWORD* a1, int a2, int Size, int a4) {
    int v4; // esi
    char* v5; // edi
    char Destination [24]; // [esp+Ch] [ebp-2Ch] BYREF
    int v8; // [esp+24h] [ebp-14h] BYREF
    int v9; // [esp+28h] [ebp-10h]
    unsigned int v10; // [esp+34h] [ebp-4h]
    unsigned int retaddr; // [esp+3Ch] [ebp+4h]

    v10 = retaddr ^ dword_47A630;
    sub_465E49(*a1, a1 [1], &v8, Destination);
    v4 = v9 - 1;
    v5 = (char*) (a2 + (v8 == 45));
    _fptostr(v5, Size, (int) &v8);
    if(v9 - 1 < -4 || v9 - 1 >= Size)
        return _cftoe2(Size, a4, 1);
    if(v4 < v9 - 1)
        v5 [strlen(v5) - 1] = 0;
    return _cftof2(a2, Size, 1);
}
// 45E5BC: using guessed type _DWORD __cdecl _cftoe2(_DWORD, _DWORD, char);
// 47A630: using guessed type int dword_47A630;
// 45E7E2: using guessed type char Destination[24];

//----- (0045EAF5) --------------------------------------------------------
int __cdecl sub_45EAF5(FILE* File, char* a2, int a3) {
    char v3; // bl
    int v4; // ecx
    char* v5; // edi
    char* v6; // edi
    int v7; // eax
    char v8; // al
    int v9; // ecx
    char* v10; // eax
    char* v11; // eax
    char* v12; // esi
    __int64 v13; // rax
    __int16* v14; // eax
    char* v15; // ecx
    int v16; // eax
    char* v17; // eax
    int v18; // ecx
    char* j; // eax
    _WORD* v20; // eax
    unsigned int v21; // ebx
    unsigned int v22; // edi
    char* i; // esi
    int v24; // eax
    unsigned __int64 v25; // rcx
    int v26; // ecx
    char* v27; // eax
    char* v28; // esi
    char v29; // bl
    int v30; // esi
    wchar_t* v31; // ebx
    int v32; // eax
    unsigned __int64 v34; // [esp-18h] [ebp-270h]
    char Str [511]; // [esp+4h] [ebp-254h] BYREF
    char v36; // [esp+203h] [ebp-55h] BYREF
    char MbCh [8]; // [esp+204h] [ebp-54h] BYREF
    int v38 [3]; // [esp+20Ch] [ebp-4Ch] BYREF
    int v39; // [esp+218h] [ebp-40h]
    int v40; // [esp+21Ch] [ebp-3Ch]
    int v41; // [esp+220h] [ebp-38h]
    int v42; // [esp+224h] [ebp-34h]
    int v43; // [esp+228h] [ebp-30h]
    void* Block; // [esp+22Ch] [ebp-2Ch]
    int v45; // [esp+230h] [ebp-28h]
    int v46; // [esp+234h] [ebp-24h]
    int v47; // [esp+238h] [ebp-20h]
    char v48; // [esp+23Ch] [ebp-1Ch]
    char v49; // [esp+23Dh] [ebp-1Bh]
    int v50; // [esp+240h] [ebp-18h]
    int v51; // [esp+244h] [ebp-14h]
    char* v52; // [esp+248h] [ebp-10h]
    int v53; // [esp+24Ch] [ebp-Ch]
    int v54; // [esp+250h] [ebp-8h]
    unsigned int v55; // [esp+254h] [ebp-4h]
    unsigned int retaddr; // [esp+25Ch] [ebp+4h]
    char* v57; // [esp+264h] [ebp+Ch]

    v55 = retaddr ^ dword_47A630;
    v51 = 0;
    v50 = 0;
    Block = 0;
    v3 = *a2;
    v4 = 0;
    if(*a2) {
        v5 = a2;
        while(1) {
            v6 = v5 + 1;
            v57 = v6;
            if(v50 < 0)
                return v50;
            if(v3 < 32 || v3 > 120)
                v7 = 0;
            else
                v7 = aIsprocessorfea [v3 + 8] & 0xF;
            v41 = byte_470090 [8 * v7 + v4] >> 4;
            switch(v41) {
                case 0:
                    goto LABEL_50;
                case 1:
                    v53 = -1;
                    v40 = 0;
                    v42 = 0;
                    v46 = 0;
                    v47 = 0;
                    v54 = 0;
                    v45 = 0;
                    goto LABEL_184;
                case 2:
                    switch(v3) {
                        case ' ':
                            v54 |= 2u;
                            break;
                        case '#':
                            LOBYTE(v54) = v54 | 0x80;
                            break;
                        case '+':
                            v54 |= 1u;
                            break;
                        case '-':
                            v54 |= 4u;
                            break;
                        case '0':
                            v54 |= 8u;
                            break;
                    }
                    goto LABEL_184;
                case 3:
                    if(v3 == 42) {
                        a3 += 4;
                        v46 = *(_DWORD*) (a3 - 4);
                        if(v46 < 0) {
                            v54 |= 4u;
                            v46 = -v46;
                        }
                    }
                    else {
                        v46 = v3 + 10 * v46 - 48;
                    }
                    goto LABEL_184;
                case 4:
                    v53 = 0;
                    goto LABEL_184;
                case 5:
                    if(v3 == 42) {
                        a3 += 4;
                        v53 = *(_DWORD*) (a3 - 4);
                        if(v53 < 0)
                            v53 = -1;
                    }
                    else {
                        v53 = v3 + 10 * v53 - 48;
                    }
                    goto LABEL_184;
                case 6:
                    switch(v3) {
                        case 'I':
                            v8 = *v6;
                            if(*v6 == 54 && v6 [1] == 52) {
                                BYTE1(v54) |= 0x80u;
                                v57 = v6 + 2;
                            }
                            else if(v8 == 51 && v6 [1] == 50) {
                                BYTE1(v54) &= ~0x80u;
                                v57 = v6 + 2;
                            }
                            else if(v8 != 100 && v8 != 105 && v8 != 111 && v8 != 117 && v8 != 120 && v8 != 88) {
                                v41 = 0;
                                LABEL_50:
                                v45 = 0;
                                if(off_47B2D8 [(unsigned __int8) v3] < 0) {
                                    write_char(File);
                                    v57 = v6 + 1;
                                }
                                write_char(File);
                            }
                            break;
                        case 'h':
                            v54 |= 0x20u;
                            break;
                        case 'l':
                            v54 |= 0x10u;
                            break;
                        case 'w':
                            BYTE1(v54) |= 8u;
                            break;
                    }
                    goto LABEL_184;
                case 7:
                    if(v3 > 103) {
                        switch(v3) {
                            case 'i':
                                goto LABEL_80;
                            case 'n':
                                a3 += 4;
                                v20 = *(_WORD**) (a3 - 4);
                                if((v54 & 0x20) != 0)
                                    *v20 = v50;
                                else
                                    *(_DWORD*) v20 = v50;
                                v42 = 1;
                                goto LABEL_182;
                            case 'o':
                                v51 = 8;
                                if((v54 & 0x80u) != 0)
                                    BYTE1(v54) |= 2u;
                                break;
                            default:
                                switch(v3) {
                                    case 'p':
                                        v53 = 8;
                                        LABEL_121:
                                        v43 = 7;
                                        break;
                                    case 's':
                                        goto LABEL_63;
                                    case 'u':
                                        goto LABEL_81;
                                    case 'x':
                                        v43 = 39;
                                        break;
                                    default:
                                        goto LABEL_159;
                                }
                                v51 = 16;
                                if((v54 & 0x80u) != 0) {
                                    v48 = 48;
                                    v49 = v43 + 81;
                                    v47 = 2;
                                }
                                break;
                        }
                        LABEL_82:
                        if((v54 & 0x8000) != 0) {
                            v13 = *(_QWORD*) a3;
                            a3 += 8;
                        }
                        else {
                            a3 += 4;
                            if((v54 & 0x20) != 0) {
                                if((v54 & 0x40) != 0)
                                    LODWORD(v13) = *(__int16*) (a3 - 4);
                                else
                                    LODWORD(v13) = *(unsigned __int16*) (a3 - 4);
                            }
                            else {
                                LODWORD(v13) = *(_DWORD*) (a3 - 4);
                                if((v54 & 0x40) == 0) {
                                    HIDWORD(v13) = 0;
                                    goto LABEL_137;
                                }
                            }
                            v13 = (int) v13;
                        }
                        LABEL_137:
                        if((v54 & 0x40) != 0 && v13 < 0) {
                            v13 = -v13;
                            BYTE1(v54) |= 1u;
                        }
                        v22 = HIDWORD(v13);
                        v21 = v13;
                        if((v54 & 0x8000) == 0)
                            v22 = 0;
                        if(v53 >= 0) {
                            v54 &= ~8u;
                            if(v53 > 512)
                                v53 = 512;
                        }
                        else {
                            v53 = 1;
                        }
                        if(!(v22 | (unsigned int) v13))
                            v47 = 0;
                        for(i = &v36; ; --i) {
                            v24 = v53--;
                            if(v24 <= 0 && !(v22 | v21))
                                break;
                            v34 = __PAIR64__(v22, v21);
                            v25 = __PAIR64__(v22, v21) % v51;
                            v26 = v25 + 48;
                            v39 = HIDWORD(v25);
                            v22 = (v34 / v51) >> 32;
                            v21 = v34 / v51;
                            if(v26 > 57)
                                LOBYTE(v26) = v43 + v26;
                            *i = v26;
                        }
                        v27 = (char*) (&v36 - i);
                        v28 = i + 1;
                        v51 = (int) v27;
                        v52 = v28;
                        if((v54 & 0x200) != 0 && (*v28 != 48 || !v27)) {
                            *--v52 = 48;
                            v16 = (int) (v27 + 1);
                            goto LABEL_158;
                        }
                        goto LABEL_159;
                    }
                    if(v3 >= 101)
                        goto LABEL_70;
                    if(v3 > 88) {
                        if(v3 == 90) {
                            a3 += 4;
                            v14 = *(__int16**) (a3 - 4);
                            if(v14 && (v15 = (char*) *((_DWORD*) v14 + 1)) != 0) {
                                v16 = *v14;
                                v52 = v15;
                                if((v54 & 0x800) != 0) {
                                    v16 /= 2;
                                    v45 = 1;
                                }
                                else {
                                    v45 = 0;
                                }
                            }
                            else {
                                v52 = off_47A734;
                                v16 = strlen(off_47A734);
                            }
                            goto LABEL_158;
                        }
                        if(v3 == 99)
                            goto LABEL_74;
                        if(v3 != 100)
                            goto LABEL_159;
                        LABEL_80:
                        v54 |= 0x40u;
                        LABEL_81:
                        v51 = 10;
                        goto LABEL_82;
                    }
                    switch(v3) {
                        case 'X':
                            goto LABEL_121;
                        case 'C':
                            if((v54 & 0x830) == 0)
                                BYTE1(v54) |= 8u;
                            LABEL_74:
                            a3 += 4;
                            if((v54 & 0x810) != 0) {
                                v51 = wctomb(Str, *(_WORD*) (a3 - 4));
                                if(v51 < 0)
                                    v42 = 1;
                            }
                            else {
                                Str [0] = *(_BYTE*) (a3 - 4);
                                v51 = 1;
                            }
                            v52 = Str;
                            goto LABEL_159;
                        case 'E':
                        case 'G':
                            v40 = 1;
                            v3 += 32;
                            LABEL_70:
                            v54 |= 0x40u;
                            v12 = Str;
                            v52 = Str;
                            if(v53 >= 0) {
                                if(v53) {
                                    if(v53 > 512)
                                        v53 = 512;
                                    if(v53 > 163) {
                                        v17 = (char*) malloc(v53 + 349);
                                        Block = v17;
                                        if(v17) {
                                            v52 = v17;
                                            v12 = v17;
                                        }
                                        else {
                                            v53 = 163;
                                        }
                                    }
                                }
                                else {
                                    v53 = v3 == 103;
                                }
                            }
                            else {
                                v53 = 6;
                            }
                            v18 = *(_DWORD*) a3;
                            v38 [1] = *(_DWORD*) (a3 + 4);
                            v38 [0] = v18;
                            off_47A71C(v38, v12, v3, v53, v40);
                            break;
                    }
                    if(v3 == 83) {
                        if((v54 & 0x830) == 0)
                            BYTE1(v54) |= 8u;
                        LABEL_63:
                        v9 = v53;
                        if(v53 == -1)
                            v9 = 0x7FFFFFFF;
                        a3 += 4;
                        v10 = *(char**) (a3 - 4);
                        v52 = v10;
                        if((v54 & 0x810) != 0) {
                            if(!v10)
                                v52 = (char*) off_47A738;
                            v11 = v52;
                            v45 = 1;
                            while(v9) {
                                --v9;
                                if(!*(_WORD*) v11)
                                    break;
                                v11 += 2;
                            }
                            v16 = (v11 - v52) >> 1;
                        }
                        else {
                            if(!v10)
                                v52 = off_47A734;
                            for(j = v52; v9; ++j) {
                                --v9;
                                if(!*j)
                                    break;
                            }
                            v16 = j - v52;
                        }
                        LABEL_158:
                        v51 = v16;
                    }
                    LABEL_159:
                    if(v42)
                        goto LABEL_182;
                    v29 = v54;
                    if((v54 & 0x40) == 0)
                        goto LABEL_168;
                    if((v54 & 0x100) != 0) {
                        v48 = 45;
                        LABEL_167:
                        v47 = 1;
                        goto LABEL_168;
                    }
                    if((v54 & 1) != 0) {
                        v48 = 43;
                        goto LABEL_167;
                    }
                    if((v54 & 2) != 0) {
                        v48 = 32;
                        goto LABEL_167;
                    }
                    LABEL_168:
                    v30 = v46 - v47 - v51;
                    if((v54 & 0xC) == 0)
                        write_multi_char(32, v46 - v47 - v51, File);
                    write_string(v47);
                    if((v29 & 8) != 0 && (v29 & 4) == 0)
                        write_multi_char(48, v30, File);
                    if(v45 && v51 > 0) {
                        v31 = (wchar_t*) v52;
                        v39 = v51;
                        do {
                            --v39;
                            v32 = wctomb(MbCh, *v31++);
                            if(v32 <= 0)
                                break;
                            write_string(v32);
                        }
                        while(v39);
                    }
                    else {
                        write_string(v51);
                    }
                    if((v54 & 4) != 0)
                        write_multi_char(32, v30, File);
                    LABEL_182:
                    if(Block) {
                        free(Block);
                        Block = 0;
                    }
                    LABEL_184:
                    v5 = v57;
                    v3 = *v57;
                    if(!*v57)
                        return v50;
                    v4 = v41;
                    break;
                default:
                    goto LABEL_184;
            }
        }
    }
    return v50;
}
// 45EABE: using guessed type int __cdecl write_string(_DWORD);
// 47A630: using guessed type int dword_47A630;
// 47A71C: using guessed type int (__cdecl *off_47A71C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 47A738: using guessed type void **off_47A738;
// 47B2D8: using guessed type __int16 *off_47B2D8;
// 45EAF5: using guessed type char MbCh[8];

//----- (0045F2E0) --------------------------------------------------------
void __cdecl __noreturn sub_45F2E0(int a1, int a2) {
    const char* v2; // edi
    int v3; // esi
    char* v4; // ebx
    void* v5; // esp
    _BYTE v6 [37]; // [esp-25h] [ebp-159h] BYREF
    char v7 [12]; // [esp+0h] [ebp-134h] BYREF
    CHAR Filename [264]; // [esp+Ch] [ebp-128h] BYREF
    char* Source; // [esp+114h] [ebp-20h]
    unsigned int v10; // [esp+118h] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+11Ch] [ebp-18h]
    unsigned int retaddr; // [esp+138h] [ebp+4h]

    v10 = retaddr ^ dword_47A630;
    if(dword_6E6244) {
        dword_6E6244(a1, a2);
        ms_exc.registration.TryLevel = -1;
    }
    else {
        if(a1 == 1) {
            v2 = "Buffer overrun detected!";
            Source = "A buffer overrun has been detected which has corrupted the program's\n"
                "internal state.  The program cannot safely continue execution and must\n"
                "now be terminated.\n";
            v3 = 185;
        }
        else {
            v2 = "Unknown security failure detected!";
            Source = "A security error of unknown cause has been detected which has\n"
                "corrupted the program's internal state.  The program cannot safely\n"
                "continue execution and must now be terminated.\n";
            v3 = 212;
        }
        Filename [260] = 0;
        if(!GetModuleFileNameA(0, Filename, 0x104u))
            strcpy(Filename, "<program name unknown>");
        v4 = Filename;
        if(strlen(Filename) + 11 > 0x3C) {
            v4 = &v6 [strlen(Filename)];
            strncpy(v4, "...", 3u);
        }
        v5 = alloca(strlen(v4) + v3 + 12);
        ms_exc.old_esp = (DWORD) v7;
        strcpy(v7, v2);
        strcat(v7, "\n\n");
        strcat(v7, "Program: ");
        strcat(v7, v4);
        strcat(v7, "\n\n");
        strcat(v7, Source);
        __crtMessageBoxA(v7, "Microsoft Visual C++ Runtime Library", 8208);
    }
    _exit(3);
}
// 4661C5: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, __int16);
// 47A630: using guessed type int dword_47A630;
// 6E6244: using guessed type int (__cdecl *dword_6E6244)(_DWORD, _DWORD);

//----- (0045F548) --------------------------------------------------------
int __cdecl sub_45F548(int a1) {
    struct _RTL_CRITICAL_SECTION* v2; // edi

    if(*(&lpCriticalSection + 2 * a1))
        return 1;
    v2 = (struct _RTL_CRITICAL_SECTION*) malloc(0x18u);
    if(!v2)
        goto LABEL_4;
    _lock(10);
    if(*(&lpCriticalSection + 2 * a1)) {
        free(v2);
    }
    else {
        if(!__crtInitCritSecAndSpinCount(v2, 4000)) {
            free(v2);
            _unlock(10);
            LABEL_4:
            *_errno() = 12;
            return 0;
        }
        *(&lpCriticalSection + 2 * a1) = v2;
    }
    _unlock(10);
    return 1;
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4663F4: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);

//----- (00461888) --------------------------------------------------------
int sub_461888() {
    DWORD* v0; // eax
    DWORD* v1; // esi
    DWORD CurrentThreadId; // eax

    if(_mtinitlocks()
       && (dwTlsIndex = TlsAlloc(), dwTlsIndex != -1)
       && (v0 = (DWORD*) sub_45E194(1, 136), (v1 = v0) != 0)
       && TlsSetValue(dwTlsIndex, v0)) {
        v1 [21] = (DWORD) &unk_47B1A8;
        v1 [5] = 1;
        CurrentThreadId = GetCurrentThreadId();
        v1 [1] = -1;
        *v1 = CurrentThreadId;
        return 1;
    }
    else {
        _mtterm();
        return 0;
    }
}
// 45F495: using guessed type int _mtinitlocks(void);
// 4617F9: using guessed type int _mtterm(void);

//----- (00461964) --------------------------------------------------------
_DWORD* __cdecl sub_461964(int a1, int a2, int a3, int a4) {
    int v4; // ecx
    int v5; // esi
    int v6; // eax
    int* v7; // ecx
    int v8; // eax
    _DWORD* result; // eax
    int v10; // ecx

    v5 = *(_DWORD*) (a1 + 8);
    v6 = _getptd(v4);
    ++* (_DWORD*) (v6 + 128);
    while(v5 != a4) {
        if(v5 <= -1 || v5 >= *(_DWORD*) (a3 + 4))
            sub_462197();
        v8 = 8 * v5;
        v7 = (int*) (8 * v5 + *(_DWORD*) (a3 + 8));
        v5 = *v7;
        if(v7 [1]) {
            *(_DWORD*) (a1 + 8) = v5;
            _CallSettingFrame(*(_DWORD*) (*(_DWORD*) (a3 + 8) + v8 + 4), a1, 259);
        }
    }
    result = (_DWORD*) _getptd(v7);
    if((int) result [32] > 0) {
        result = (_DWORD*) (_getptd(v10) + 128);
        --* result;
    }
    if(v5 != a4)
        sub_462197();
    *(_DWORD*) (a1 + 8) = v5;
    return result;
}
// 461979: variable 'v4' is possibly undefined
// 461A17: variable 'v7' is possibly undefined
// 461A25: variable 'v10' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);
// 4621D0: using guessed type _DWORD __stdcall _CallSettingFrame(_DWORD, _DWORD, _DWORD);

//----- (00461A94) --------------------------------------------------------
void* __cdecl sub_461A94(
    _DWORD* a1,
    struct EHRegistrationNode* a2,
    int a3,
    struct _s_FuncInfo* a4,
    int a5,
    unsigned int a6) {
    void* v6; // ecx
    void* v7; // ebx
    int v8; // ecx
    int v9; // ecx
    int v10; // ecx
    char v12; // al
    int v13; // [esp-8h] [ebp-64h]
    int v14; // [esp-4h] [ebp-60h]
    int v15; // [esp+24h] [ebp-38h]
    int v16; // [esp+28h] [ebp-34h]
    _DWORD* v17; // [esp+2Ch] [ebp-30h]
    int v18; // [esp+30h] [ebp-2Ch] BYREF
    __ehstate_t state; // [esp+38h] [ebp-24h]
    int v20; // [esp+3Ch] [ebp-20h]
    void* v21; // [esp+40h] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+44h] [ebp-18h]

    v7 = v6;
    v21 = v6;
    v20 = 0;
    state = a2 [-1].state;
    v17 = sub_45C100(&v18, a1 [6]);
    v16 = *(_DWORD*) (_getptd(v14) + 120);
    v15 = *(_DWORD*) (_getptd(v8) + 124);
    *(_DWORD*) (_getptd(v9) + 120) = a1;
    *(_DWORD*) (_getptd(v10) + 124) = a3;
    ms_exc.registration.TryLevel = 1;
    v21 = _CallCatchBlock2(a2, a4, v7, a5, a6);
    ms_exc.registration.TryLevel = -1;
    a2 [-1].state = state;
    sub_45C149((int) v17);
    *(_DWORD*) (_getptd(v13) + 120) = v16;
    *(_DWORD*) (_getptd(v16) + 124) = v15;
    if(*a1 == -529697949
       && a1 [4] == 3
       && a1 [5] == 429065504
       && !v20
       && v21
       && IsExceptionObjectToBeDestroyed((void*) a1 [6])) {
        v12 = _abnormal_termination();
        __DestructExceptionObject(a1, v12);
    }
    return v21;
}
// 461AA0: variable 'v6' is possibly undefined
// 461AC6: variable 'v14' is possibly undefined
// 461AD1: variable 'v8' is possibly undefined
// 461ADC: variable 'v9' is possibly undefined
// 461AE4: variable 'v10' is possibly undefined
// 461BE6: variable 'v13' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);
// 461A32: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);

//----- (00461E1E) --------------------------------------------------------
void __usercall sub_461E1E(
    unsigned __int8 a1,
    const struct _s_TryBlockMapEntry* a2,
    int a3,
    struct EHExceptionRecord* a4,
    struct EHRegistrationNode* a5,
    struct EHRegistrationNode* a6,
    struct _CONTEXT* a7,
    struct _s_FuncInfo* a8,
    int a9,
    struct _s_FuncInfo* a10,
    struct EHRegistrationNode* a11) {
    int v11; // esi
    const struct _s_TryBlockMapEntry* v12; // edi
    TypeDescriptor* pType; // ecx
    const struct _s_TryBlockMapEntry* v14; // [esp-8h] [ebp-14h]
    int v15; // [esp-4h] [ebp-10h]
    struct EHRegistrationNode* v16; // [esp+0h] [ebp-Ch]
    unsigned int v17; // [esp+4h] [ebp-8h] BYREF
    unsigned int v18; // [esp+8h] [ebp-4h] BYREF

    if(a4->ExceptionCode != -2147483645
       && (!*(_DWORD*) (_getptd(a1) + 116) || !_CallSETranslator(a4, a5, a6, a7, a8, (int) a10, a11))) {
        v11 = a9;
        v15 = a3;
        v12 = _GetRangeOfTrysToCheck(a8, (int) a10, a9, &v18, &v17);
        if(v18 < v17) {
            v14 = a2;
            do {
                if(v11 >= v12->tryLow && v11 <= v12->tryHigh) {
                    pType = v12->pHandlerArray [v12->nCatches - 1].pType;
                    if(!pType || !pType->name [0]) {
                        CatchIt(
                            a4,
                            a6,
                            a7,
                            a8,
                            a10,
                            (const struct _s_HandlerType*) a11,
                            (const struct _s_CatchableType*) 1,
                            v14,
                            v15,
                            v16,
                            v17);
                        v11 = a9;
                    }
                }
                ++v18;
                ++v12;
            }
            while(v18 < v17);
        }
    }
}
// 461E1E: could not find valid save-restore pair for ebx
// 461E1E: could not find valid save-restore pair for edi
// 461EC0: variable 'v14' is possibly undefined
// 461EC0: variable 'v15' is possibly undefined
// 461EC0: variable 'v16' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);

//----- (00461EDE) --------------------------------------------------------
void __usercall sub_461EDE(
    struct EHRegistrationNode* a1,
    int a2,
    const struct _s_ThrowInfo* a3,
    struct EHExceptionRecord* a4,
    struct EHRegistrationNode* a5,
    struct EHRegistrationNode* a6,
    struct _CONTEXT* a7,
    struct _s_FuncInfo* a8,
    char a9,
    struct _s_FuncInfo* a10,
    struct EHRegistrationNode* a11) {
    int state; // eax
    unsigned __int8 v12; // cl
    struct EHExceptionRecord* v13; // ebx
    int v14; // ecx
    struct EHExceptionRecord* v15; // esi
    int v16; // ecx
    int v17; // eax
    int v18; // esi
    const struct _s_TryBlockMapEntry* v19; // eax
    HandlerType* pHandlerArray; // esi
    int* p_nCatchableTypes; // ecx
    int* v22; // edx
    int v23; // ecx
    int v24; // edi
    unsigned __int8 v25; // [esp-10h] [ebp-34h]
    const struct _s_CatchableType* v26; // [esp-Ch] [ebp-30h]
    const struct _s_ThrowInfo* v27; // [esp-8h] [ebp-2Ch]
    struct EHRegistrationNode* v28; // [esp-4h] [ebp-28h]
    int v29; // [esp+0h] [ebp-24h]
    unsigned int v30; // [esp+4h] [ebp-20h] BYREF
    struct _s_CatchableType* v31; // [esp+8h] [ebp-1Ch]
    int v32; // [esp+Ch] [ebp-18h]
    int nCatches; // [esp+10h] [ebp-14h]
    int v34; // [esp+14h] [ebp-10h]
    int* v35; // [esp+18h] [ebp-Ch]
    unsigned int v36; // [esp+1Ch] [ebp-8h] BYREF
    const struct _s_TryBlockMapEntry* v37; // [esp+20h] [ebp-4h]

    state = a5->state;
    LOBYTE(v31) = 0;
    v32 = state;
    if(state < -1 || (v12 = (unsigned __int8) a8, state >= a8->maxState))
        sub_462197();
    v28 = a1;
    v13 = a4;
    v27 = a3;
    v26 = (const struct _s_CatchableType*) a2;
    if(a4->ExceptionCode != -529697949)
        goto LABEL_38;
    a2 = 429065504;
    if(a4->NumberParameters == 3 && a4->params.magicNumber == 429065504 && !a4->params.pThrowInfo) {
        if(!*(_DWORD*) (_getptd(a8) + 120))
            return;
        v15 = *(struct EHExceptionRecord**) (_getptd(v14) + 120);
        a4 = v15;
        a6 = *(struct EHRegistrationNode**) (_getptd(v16) + 124);
        LOBYTE(v31) = 1;
        v17 = _ValidateRead(v15, 1u);
        v12 = v25;
        if(!v17)
            sub_462197();
        if(v15->ExceptionCode != -529697949) {
            v13 = v15;
            LABEL_38:
            if(a9)
                terminate();
            sub_461E1E(v12, (const struct _s_TryBlockMapEntry*) v13, a2, v13, a5, a6, a7, a8, v32, a10, a11);
            return;
        }
        if(v15->NumberParameters == 3 && v15->params.magicNumber == 429065504 && !v15->params.pThrowInfo)
            sub_462197();
        v13 = v15;
    }
    if(v13->ExceptionCode != -529697949 || v13->NumberParameters != 3 || v13->params.magicNumber != 429065504)
        goto LABEL_38;
    v18 = v32;
    v19 = _GetRangeOfTrysToCheck(a8, (int) a10, v32, &v36, &v30);
    v37 = v19;
    if(v36 < v30) {
        while(1) {
            if(v19->tryLow <= v18 && v18 <= v19->tryHigh) {
                pHandlerArray = v19->pHandlerArray;
                nCatches = v19->nCatches;
                if(nCatches > 0) {
                    while(1) {
                        p_nCatchableTypes = &v13->params.pThrowInfo->pCatchableTypeArray->nCatchableTypes;
                        v22 = p_nCatchableTypes + 1;
                        v23 = *p_nCatchableTypes;
                        v35 = v22;
                        v34 = v23;
                        if(v23 > 0)
                            break;
                        LABEL_30:
                        --nCatches;
                        ++pHandlerArray;
                        if(nCatches <= 0)
                            goto LABEL_33;
                    }
                    while(1) {
                        v29 = *v35;
                        if(TypeMatch((const struct _s_HandlerType*) v13->params.pThrowInfo, v26, v27))
                            break;
                        --v34;
                        ++v35;
                        if(v34 <= 0) {
                            v19 = v37;
                            goto LABEL_30;
                        }
                    }
                    v24 = (int) v37;
                    CatchIt(
                        v13,
                        a6,
                        a7,
                        a8,
                        a10,
                        (const struct _s_HandlerType*) a11,
                        v31,
                        (const struct _s_TryBlockMapEntry*) v26,
                        (int) v27,
                        v28,
                        v29);
                    v13 = a4;
                    v19 = (const struct _s_TryBlockMapEntry*) v24;
                }
            }
            LABEL_33:
            ++v36;
            v37 = ++v19;
            if(v36 >= v30)
                break;
            v18 = v32;
        }
    }
    if(a9)
        __DestructExceptionObject(v13, 1);
}
// 461EDE: could not find valid save-restore pair for ebx
// 461EDE: could not find valid save-restore pair for esi
// 461F3A: variable 'v14' is possibly undefined
// 461F45: variable 'v16' is possibly undefined
// 461F5F: variable 'v25' is possibly undefined
// 462016: variable 'v26' is possibly undefined
// 462016: variable 'v27' is possibly undefined
// 46205B: variable 'v28' is possibly undefined
// 461817: using guessed type int __thiscall _getptd(_DWORD);
// 461A32: using guessed type _DWORD __cdecl __DestructExceptionObject(_DWORD, char);

//----- (00462197) --------------------------------------------------------
void __noreturn sub_462197() {
    if(off_47ABDC)
        off_47ABDC();
    terminate();
}
// 47ABDC: using guessed type int (*off_47ABDC)(void);

//----- (00462829) --------------------------------------------------------
int __cdecl sub_462829(DWORD dwExceptionCode, int a2, int a3, int a4, double a5, int a6) {
    int v6; // eax
    ULONG_PTR Arguments [16]; // [esp+1Ch] [ebp-80h] BYREF
    int v9; // [esp+5Ch] [ebp-40h]
    unsigned int v10; // [esp+98h] [ebp-4h]
    unsigned int retaddr; // [esp+A0h] [ebp+4h]

    v10 = retaddr ^ dword_47A630;
    if(!_handle_exc(dwExceptionCode, &a5, a6)) {
        v9 &= ~1u;
        _raise_exc((ULONG_PTR) Arguments, (int) &a6, dwExceptionCode, a2, (int) &a3, (int) &a5);
    }
    v6 = _errcode(dwExceptionCode);
    if(!dword_47B4E8 && v6)
        return _umatherr(v6, a2, a3, a4, COERCE_UNSIGNED_INT64(0.0), HIDWORD(COERCE_UNSIGNED_INT64(0.0)), a5, a6);
    _set_errno(v6);
    return _ctrlfp(a6, 0xFFFF);
}
// 4624C1: using guessed type _DWORD __cdecl _handle_exc(_DWORD, _DWORD, _DWORD);
// 46270B: using guessed type _DWORD __cdecl _errcode(char);
// 462A41: using guessed type _DWORD __cdecl _ctrlfp(_DWORD, _DWORD);
// 47A630: using guessed type int dword_47A630;
// 47B4E8: using guessed type int dword_47B4E8;
// 462829: using guessed type ULONG_PTR Arguments[16];

//----- (00462C92) --------------------------------------------------------
int __cdecl sub_462C92(int a1) {
    int i; // esi
    int v2; // eax
    int v3; // ecx
    int result; // eax
    int v5; // [esp+10h] [ebp-20h]
    int v6; // [esp+14h] [ebp-1Ch]

    v6 = 0;
    v5 = 0;
    _lock(1);
    for(i = 0; i < dword_6E79C0; ++i) {
        v2 = *(_DWORD*) (dword_6E69A0 + 4 * i);
        if(v2 && (*(_BYTE*) (v2 + 12) & 0x83) != 0) {
            _lock_file2(i, *(_DWORD*) (dword_6E69A0 + 4 * i));
            v3 = *(_DWORD*) (*(_DWORD*) (dword_6E69A0 + 4 * i) + 12);
            if((v3 & 0x83) != 0) {
                if(a1 == 1) {
                    if(_fflush_lk(*(_DWORD*) (dword_6E69A0 + 4 * i)) != -1)
                        ++v6;
                }
                else if(!a1 && (v3 & 2) != 0 && _fflush_lk(*(_DWORD*) (dword_6E69A0 + 4 * i)) == -1) {
                    v5 = -1;
                }
            }
            _unlock_file2(i, *(_DWORD*) (dword_6E69A0 + 4 * i));
        }
    }
    _unlock(1);
    result = v6;
    if(a1 != 1)
        return v5;
    return result;
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 462C64: using guessed type _DWORD __cdecl _fflush_lk(_DWORD);
// 462E5C: using guessed type _DWORD __cdecl _lock_file2(_DWORD, _DWORD);
// 462EAE: using guessed type _DWORD __cdecl _unlock_file2(_DWORD, _DWORD);
// 6E69A0: using guessed type int dword_6E69A0;
// 6E79C0: using guessed type int dword_6E79C0;

//----- (00462D67) --------------------------------------------------------
int sub_462D67() {
    return sub_462C92(1);
}

//----- (00463856) --------------------------------------------------------
int __cdecl sub_463856(int FileHandle, _BYTE* lpBuffer, DWORD nNumberOfBytesToWrite) {
    int v4; // esi
    int v5; // eax
    DWORD v6; // ecx
    char* v7; // eax
    char* v8; // edx
    char v9; // dl
    signed int v10; // edi
    char Buffer [1028]; // [esp+4h] [ebp-420h] BYREF
    DWORD NumberOfBytesWritten; // [esp+408h] [ebp-1Ch] BYREF
    int v13; // [esp+40Ch] [ebp-18h]
    DWORD v14; // [esp+410h] [ebp-14h]
    char* v15; // [esp+414h] [ebp-10h]
    int i; // [esp+418h] [ebp-Ch]
    DWORD LastError; // [esp+41Ch] [ebp-8h]
    unsigned int v18; // [esp+420h] [ebp-4h]
    unsigned int retaddr; // [esp+428h] [ebp+4h]

    v18 = retaddr ^ dword_47A630;
    v14 = 0;
    v13 = 0;
    if(!nNumberOfBytesToWrite)
        return 0;
    v4 = 36 * (FileHandle & 0x1F);
    if((*(_BYTE*) (dword_6E68A0 [FileHandle >> 5] + v4 + 4) & 0x20) != 0)
        _lseeki64_lk(FileHandle, 0, 0, 2u);
    v5 = v4 + dword_6E68A0 [FileHandle >> 5];
    if(*(char*) (v5 + 4) >= 0) {
        if(WriteFile(*(HANDLE*) v5, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0)) {
            LastError = 0;
            v14 = NumberOfBytesWritten;
        }
        else {
            LastError = GetLastError();
        }
    }
    else {
        v15 = lpBuffer;
        LastError = 0;
        while(1) {
            v6 = v15 - lpBuffer;
            v7 = Buffer;
            for(i = 0; i < 1024; ++i) {
                if(v6 >= nNumberOfBytesToWrite)
                    break;
                v8 = v15++;
                v9 = *v8;
                ++v6;
                if(v9 == 10) {
                    ++v13;
                    *v7++ = 13;
                    ++i;
                }
                *v7++ = v9;
            }
            v10 = v7 - Buffer;
            if(!WriteFile(
                *(HANDLE*) (dword_6E68A0 [FileHandle >> 5] + 36 * (FileHandle & 0x1F)),
                Buffer,
                v7 - Buffer,
                &NumberOfBytesWritten,
                0))
                break;
            v14 += NumberOfBytesWritten;
            if((int) NumberOfBytesWritten < v10 || v15 - lpBuffer >= nNumberOfBytesToWrite)
                goto LABEL_17;
        }
        LastError = GetLastError();
    }
    LABEL_17:
    if(v14)
        return v14 - v13;
    if(LastError) {
        if(LastError == 5) {
            *_errno() = 9;
            *__doserrno() = 5;
        }
        else {
            _dosmaperr(LastError);
        }
        return -1;
    }
    if((*(_BYTE*) (dword_6E68A0 [FileHandle >> 5] + v4 + 4) & 0x40) == 0 || *lpBuffer != 26) {
        *_errno() = 28;
        *__doserrno() = 0;
        return -1;
    }
    return 0;
}
// 4638CC: conditional instruction was optimized away because %nNumberOfBytesToWrite.4!=0
// 46323C: using guessed type _DWORD __cdecl _dosmaperr(_DWORD);
// 47A630: using guessed type int dword_47A630;
// 6E68A0: using guessed type int dword_6E68A0[];

//----- (004639FB) --------------------------------------------------------
int __cdecl sub_4639FB(int a1, _BYTE* lpBuffer, DWORD nNumberOfBytesToWrite) {
    int v3; // esi
    int v5; // [esp+Ch] [ebp-1Ch]

    if(a1 < uNumber && (v3 = 36 * (a1 & 0x1F), (*(_BYTE*) (dword_6E68A0 [a1 >> 5] + v3 + 4) & 1) != 0)) {
        sub_4672E4(a1);
        if((*(_BYTE*) (dword_6E68A0 [a1 >> 5] + v3 + 4) & 1) != 0) {
            v5 = sub_463856(a1, lpBuffer, nNumberOfBytesToWrite);
        }
        else {
            *_errno() = 9;
            *__doserrno() = 0;
            v5 = -1;
        }
        _unlock_fhandle(a1);
        return v5;
    }
    else {
        *_errno() = 9;
        *__doserrno() = 0;
        return -1;
    }
}
// 467357: using guessed type _DWORD __cdecl _unlock_fhandle(_DWORD);
// 6E68A0: using guessed type int dword_6E68A0[];

//----- (00463C43) --------------------------------------------------------
unsigned int __cdecl sub_463C43(DWORD NumberOfBytesWritten) {
    unsigned int result; // eax
    int v2; // esi
    char* v3; // edi
    size_t v4; // ebx
    void* v5; // esp
    const char** v6; // esi
    HANDLE StdHandle; // eax
    const char* v8; // [esp-10h] [ebp-128h]
    DWORD v9; // [esp-Ch] [ebp-124h]
    DWORD* p_NumberOfBytesWritten; // [esp-8h] [ebp-120h]
    int v11; // [esp-4h] [ebp-11Ch]
    char v12 [276]; // [esp+0h] [ebp-118h] BYREF
    unsigned int v13; // [esp+114h] [ebp-4h]
    int savedregs; // [esp+118h] [ebp+0h] BYREF
    unsigned int retaddr; // [esp+11Ch] [ebp+4h]

    v13 = retaddr ^ dword_47A630;
    for(result = 0; result < 0x12; ++result) {
        if(NumberOfBytesWritten == dword_47B118 [2 * result])
            break;
    }
    v2 = 2 * result;
    if(NumberOfBytesWritten == dword_47B118 [2 * result]) {
        result = dword_6E61F8;
        if(dword_6E61F8 == 1 || !dword_6E61F8 && dword_47A6F4 == 1) {
            v11 = 0;
            p_NumberOfBytesWritten = &NumberOfBytesWritten;
            v6 = (const char**) &(&off_47B11C) [v2];
            v9 = strlen(*v6);
            v8 = *v6;
            StdHandle = GetStdHandle(0xFFFFFFF4);
            return WriteFile(StdHandle, v8, v9, &NumberOfBytesWritten, 0);
        }
        else if(NumberOfBytesWritten != 252) {
            v12 [272] = 0;
            if(!GetModuleFileNameA(0, &v12 [12], 0x104u))
                strcpy(&v12 [12], "<program name unknown>");
            v3 = &v12 [12];
            if(strlen(&v12 [12]) + 1 > 0x3C) {
                v3 = (char*) &savedregs + strlen(&v12 [12]) - 327;
                strncpy(v3, "...", 3u);
            }
            v4 = strlen(v3);
            v5 = alloca(v4 + strlen((&off_47B11C) [v2]) + 28);
            strcpy(v12, "Runtime Error!\n\nProgram: ");
            strcat(v12, v3);
            strcat(v12, "\n\n");
            strcat(v12, (&off_47B11C) [v2]);
            return __crtMessageBoxA(v12, "Microsoft Visual C++ Runtime Library", 8208);
        }
    }
    return result;
}
// 4661C5: using guessed type _DWORD __cdecl __crtMessageBoxA(_DWORD, _DWORD, __int16);
// 47A630: using guessed type int dword_47A630;
// 47A6F4: using guessed type int dword_47A6F4;
// 47B118: using guessed type int dword_47B118[];
// 47B11C: using guessed type char *off_47B11C;
// 6E61F8: using guessed type int dword_6E61F8;

//----- (00463F57) --------------------------------------------------------
const char* sub_463F57() {
    _BYTE* v0; // esi
    unsigned __int8 v1; // al

    if(!dword_6E79F4)
        __initmbctable();
    v0 = (_BYTE*) dword_6E79F8;
    if(!dword_6E79F8)
        return byte_46BC09;
    if(*(_BYTE*) dword_6E79F8 != 34) {
        if(*(_BYTE*) dword_6E79F8 > 0x20u) {
            do
                ++v0;
            while(*v0 > 0x20u);
        }
        goto LABEL_18;
    }
    v0 = (_BYTE*) (dword_6E79F8 + 1);
    v1 = *(_BYTE*) (dword_6E79F8 + 1);
    if(v1 != 34) {
        do {
            if(!v1)
                break;
            if(_ismbblead(v1))
                ++v0;
            v1 = *++v0;
        }
        while(*v0 != 34);
        if(*v0 != 34)
            goto LABEL_18;
    }
    do {
        ++v0;
        LABEL_18:
        ;
    }
    while(*v0 && *v0 <= 0x20u);
    return v0;
}
// 46711F: using guessed type int __initmbctable(void);
// 6E79F4: using guessed type int dword_6E79F4;
// 6E79F8: using guessed type int dword_6E79F8;

//----- (004641F3) --------------------------------------------------------
int sub_4641F3() {
    void* v0; // eax
    int v1; // edi
    int v3; // [esp+Ch] [ebp-8h]
    int v4; // [esp+10h] [ebp-4h] BYREF

    if(!dword_6E79F4)
        __initmbctable();
    byte_6E64C4 = 0;
    GetModuleFileNameA(0, Filename, 0x104u);
    dword_6E6230 = (int) Filename;
    parse_cmdline(0, &v4);
    v0 = malloc(4 * v4 + v3);
    v1 = (int) v0;
    if(!v0)
        return -1;
    parse_cmdline(v0, &v4);
    dword_6E6214 = v4 - 1;
    dword_6E6218 = v1;
    return 0;
}
// 464257: variable 'v3' is possibly undefined
// 464087: using guessed type _DWORD __cdecl parse_cmdline(_DWORD, _DWORD);
// 46711F: using guessed type int __initmbctable(void);
// 6E6214: using guessed type int dword_6E6214;
// 6E6218: using guessed type int dword_6E6218;
// 6E6230: using guessed type int dword_6E6230;
// 6E64C4: using guessed type char byte_6E64C4;
// 6E79F4: using guessed type int dword_6E79F4;
// 6E79F8: using guessed type int dword_6E79F8;

//----- (004643B7) --------------------------------------------------------
void sub_4643B7() {
    void (**i)(void); // [esp+Ch] [ebp-1Ch]

    for(i = dword_474AB8; i < dword_474AB8; ++i) {
        if(*i)
            (*i)();
    }
}
// 474AB8: using guessed type void (*dword_474AB8[2])(void);

//----- (004643FB) --------------------------------------------------------
void __cdecl sub_4643FB() {
    void (**i)(void); // [esp+Ch] [ebp-1Ch]

    for(i = &dword_474AC0; i < &dword_474AC0; ++i) {
        if(*i)
            (*i)();
    }
}
// 474AC0: using guessed type void (*dword_474AC0)(void);

//----- (0046443F) --------------------------------------------------------
int* __cdecl sub_46443F(double* a1, double* a2, double* a3, int a4) {
    int* result; // eax
    double* v5; // esi
    double v6; // st7
    double* v7; // eax
    int v8; // [esp+4h] [ebp-24h] BYREF
    const char* v9; // [esp+8h] [ebp-20h]
    double v10; // [esp+Ch] [ebp-1Ch]
    double v11; // [esp+14h] [ebp-14h]
    double v12; // [esp+1Ch] [ebp-Ch]
    unsigned int v13; // [esp+24h] [ebp-4h]
    unsigned int retaddr; // [esp+2Ch] [ebp+4h]

    v13 = retaddr ^ dword_47A630;
    if(a4 > 161) {
        if(a4 > 1002) {
            switch(a4) {
                case 1003:
                    v9 = "atan";
                    break;
                case 1004:
                    v9 = "ceil";
                    break;
                case 1005:
                    v9 = "floor";
                    break;
                case 1006:
                    LABEL_54:
                    v9 = "pow";
                    goto LABEL_55;
                default:
                    result = (int*) (a4 - 1007);
                    if(a4 != 1007)
                        return result;
                    v9 = "modf";
                    break;
            }
        }
        else {
            if(a4 != 1002) {
                if(a4 != 162) {
                    if(a4 == 166) {
                        v8 = 3;
                        v9 = "exp10";
                        goto LABEL_45;
                    }
                    if(a4 == 170) {
                        v8 = 2;
                        v9 = "log2";
                        goto LABEL_45;
                    }
                    if(a4 != 171) {
                        if(a4 == 1000) {
                            v9 = off_46B520;
                        }
                        else {
                            result = (int*) (a4 - 1001);
                            if(a4 != 1001)
                                return result;
                            v9 = "log10";
                        }
                        goto LABEL_59;
                    }
                    v9 = "log2";
                    LABEL_55:
                    v7 = a1;
                    v5 = a3;
                    goto LABEL_60;
                }
                v8 = 4;
                LABEL_44:
                v9 = "exp2";
                goto LABEL_45;
            }
            v9 = (const char*) &unk_46D07C;
        }
        LABEL_59:
        v7 = a1;
        v5 = a3;
        *a3 = *a1;
        LABEL_60:
        v10 = *v7;
        v8 = 1;
        v11 = *a2;
        v12 = *v5;
        result = (int*) off_47B230(&v8);
        if(!result) {
            result = _errno();
            *result = 33;
        }
        goto LABEL_62;
    }
    if(a4 == 161) {
        v8 = 3;
        goto LABEL_44;
    }
    if(a4 <= 24) {
        if(a4 != 24) {
            switch(a4) {
                case 2:
                    v8 = 2;
                    v9 = off_46B520;
                    goto LABEL_45;
                case 3:
                    v9 = off_46B520;
                    break;
                case 8:
                    v8 = 2;
                    v9 = "log10";
                    goto LABEL_45;
                case 9:
                    v9 = "log10";
                    break;
                case 14:
                    v8 = 3;
                    v9 = (const char*) &unk_46D07C;
                    LABEL_45:
                    v5 = a3;
                    v10 = *a1;
                    v11 = *a2;
                    v12 = *a3;
                    result = (int*) off_47B230(&v8);
                    if(!result) {
                        result = _errno();
                        *result = 34;
                    }
                    goto LABEL_62;
                default:
                    result = (int*) (a4 - 15);
                    if(a4 != 15)
                        return result;
                    v9 = (const char*) &unk_46D07C;
                    goto LABEL_28;
            }
            goto LABEL_55;
        }
        v8 = 3;
        LABEL_18:
        v9 = "pow";
        goto LABEL_45;
    }
    if(a4 != 25) {
        if(a4 == 26) {
            result = (int*) a3;
            *a3 = 1.0;
            return result;
        }
        if(a4 == 27) {
            v8 = 2;
            goto LABEL_18;
        }
        if(a4 != 28) {
            result = (int*) (a4 - 29);
            if(a4 != 29)
                return result;
            v9 = "pow";
            goto LABEL_59;
        }
        goto LABEL_54;
    }
    v9 = "pow";
    LABEL_28:
    v5 = a3;
    v10 = *a1;
    v11 = *a2;
    v6 = *a3;
    v8 = 4;
    v12 = v6;
    result = (int*) off_47B230(&v8);
    LABEL_62:
    *v5 = v12;
    return result;
}
// 47A630: using guessed type int dword_47A630;
// 47B230: using guessed type int (__cdecl *off_47B230)(_DWORD);

//----- (00465C66) --------------------------------------------------------
int __cdecl sub_465C66(int a1, int a2) {
    return _ld12cvt(a1, a2, &unk_47B2A8);
}
// 465B0E: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00465C7C) --------------------------------------------------------
int __cdecl sub_465C7C(int a1, int a2) {
    return _ld12cvt(a1, a2, &unk_47B2C0);
}
// 465B0E: using guessed type _DWORD __cdecl _ld12cvt(_DWORD, _DWORD, _DWORD);

//----- (00465C92) --------------------------------------------------------
int __cdecl sub_465C92(int a1, char* a2) {
    char v3 [12]; // [esp+0h] [ebp-14h] BYREF
    char* v4 [2]; // [esp+Ch] [ebp-8h] BYREF
    unsigned int retaddr; // [esp+18h] [ebp+4h]

    v4 [1] = (char*) (retaddr ^ dword_47A630);
    sub_46807C((int) v3, v4, a2, 0, 0, 0, 0);
    return sub_465C66((int) v3, a1);
}
// 47A630: using guessed type int dword_47A630;

//----- (00465CD5) --------------------------------------------------------
int __cdecl sub_465CD5(int a1, char* a2) {
    char v3 [12]; // [esp+0h] [ebp-14h] BYREF
    char* v4 [2]; // [esp+Ch] [ebp-8h] BYREF
    unsigned int retaddr; // [esp+18h] [ebp+4h]

    v4 [1] = (char*) (retaddr ^ dword_47A630);
    sub_46807C((int) v3, v4, a2, 0, 0, 0, 0);
    return sub_465C7C((int) v3, a1);
}
// 47A630: using guessed type int dword_47A630;

//----- (00465E49) --------------------------------------------------------
_DWORD* __cdecl sub_465E49(char a1, int a2, _DWORD* a3, char* Destination) {
    int v4; // eax
    _DWORD* v5; // esi
    char* v6; // edi
    __int16 v8; // [esp+8h] [ebp-2Ch] BYREF
    char v9; // [esp+Ah] [ebp-2Ah]
    char Source [24]; // [esp+Ch] [ebp-28h] BYREF
    __int64 v11; // [esp+24h] [ebp-10h] BYREF
    __int16 v12; // [esp+2Ch] [ebp-8h]
    unsigned int v13; // [esp+30h] [ebp-4h]
    unsigned int retaddr; // [esp+38h] [ebp+4h]

    v13 = retaddr ^ dword_47A630;
    __dtold(&v11, &a1);
    v4 = sub_4684B6(v11, v12, 17, 0, (int) &v8);
    v5 = a3;
    v6 = Destination;
    a3 [2] = v4;
    *v5 = v9;
    v5 [1] = v8;
    strcpy(v6, Source);
    v5 [3] = v6;
    return v5;
}
// 465D8F: using guessed type _DWORD __cdecl __dtold(_DWORD, _DWORD);
// 47A630: using guessed type int dword_47A630;
// 465E49: using guessed type char Source[24];

//----- (0046647F) --------------------------------------------------------
int __cdecl sub_46647F(int a1, int a2, unsigned __int16* a3) {
    int v3; // ecx
    bool v4; // zf
    int v5; // eax
    int v6; // eax
    int v7; // eax
    int v8; // eax
    int v9; // eax
    int v10; // eax
    DWORD v11; // ebx
    int result; // eax
    int v13; // [esp-4h] [ebp-94h]
    int v14; // [esp+Ch] [ebp-84h] BYREF
    ULONG_PTR Arguments [12]; // [esp+10h] [ebp-80h] BYREF
    double v16; // [esp+40h] [ebp-50h]
    unsigned int v17; // [esp+50h] [ebp-40h]
    unsigned int v18; // [esp+8Ch] [ebp-4h]
    unsigned int retaddr; // [esp+94h] [ebp+4h]

    v18 = retaddr ^ dword_47A630;
    v3 = *a3;
    v5 = *(_DWORD*) a2 - 1;
    v4 = *(_DWORD*) a2 == 1;
    v14 = v3;
    if(v4)
        goto LABEL_13;
    v6 = v5 - 1;
    if(!v6) {
        v13 = 4;
        goto LABEL_14;
    }
    v7 = v6 - 1;
    if(!v7) {
        v13 = 17;
        goto LABEL_14;
    }
    v8 = v7 - 1;
    if(!v8) {
        v13 = 18;
        goto LABEL_14;
    }
    v9 = v8 - 1;
    if(!v9) {
        LABEL_13:
        v13 = 8;
        LABEL_14:
        v11 = v13;
        if(!_handle_exc(v13, a2 + 24, v3)) {
            if(a1 == 16 || a1 == 22 || a1 == 29) {
                v16 = *(double*) (a2 + 16);
                v17 = v17 & 0xFFFFFFE0 | 3;
            }
            else {
                v17 &= ~1u;
            }
            _raise_exc((ULONG_PTR) Arguments, (int) &v14, v11, a1, a2 + 8, a2 + 24);
        }
        goto LABEL_21;
    }
    v10 = v9 - 2;
    if(!v10) {
        *(_DWORD*) a2 = 1;
        goto LABEL_21;
    }
    if(v10 == 1) {
        v13 = 16;
        goto LABEL_14;
    }
    LABEL_21:
    _ctrlfp(v14, 0xFFFF);
    if(*(_DWORD*) a2 == 8)
        return _set_errno(*(_DWORD*) a2);
    if(dword_47B4E8)
        return _set_errno(*(_DWORD*) a2);
    result = sub_4671A5();
    if(!result)
        return _set_errno(*(_DWORD*) a2);
    return result;
}
// 4624C1: using guessed type _DWORD __cdecl _handle_exc(_DWORD, _DWORD, _DWORD);
// 462A41: using guessed type _DWORD __cdecl _ctrlfp(_DWORD, _DWORD);
// 47A630: using guessed type int dword_47A630;
// 47B4E8: using guessed type int dword_47B4E8;
// 46647F: using guessed type ULONG_PTR Arguments[12];

//----- (00466C38) --------------------------------------------------------
unsigned int sub_466C38() {
    unsigned int i; // eax
    BYTE v1; // al
    BYTE* v2; // edx
    unsigned int v3; // ecx
    BYTE* v4; // edx
    unsigned int result; // eax
    WORD v6; // cx
    char v7; // cl
    char v8; // cl
    WORD CharType [256]; // [esp+4h] [ebp-518h] BYREF
    WCHAR v10 [128]; // [esp+204h] [ebp-318h] BYREF
    WCHAR DestStr [128]; // [esp+304h] [ebp-218h] BYREF
    CHAR MultiByteStr [256]; // [esp+404h] [ebp-118h] BYREF
    struct _cpinfo CPInfo; // [esp+504h] [ebp-18h] BYREF
    unsigned int v14; // [esp+518h] [ebp-4h]
    unsigned int retaddr; // [esp+520h] [ebp+4h]

    v14 = retaddr ^ dword_47A630;
    if(GetCPInfo(CodePage, &CPInfo)) {
        for(i = 0; i < 0x100; ++i)
            MultiByteStr [i] = i;
        v1 = CPInfo.LeadByte [0];
        MultiByteStr [0] = 32;
        if(CPInfo.LeadByte [0]) {
            v2 = &CPInfo.LeadByte [1];
            do {
                v3 = *v2;
                if(v1 <= v3)
                    memset(&MultiByteStr [v1], 0x20u, v3 - v1 + 1);
                v4 = v2 + 1;
                v1 = *v4;
                v2 = v4 + 1;
            }
            while(v1);
        }
        __crtGetStringTypeA(1u, MultiByteStr, 256, CharType, CodePage, Locale, 0);
        __crtLCMapStringA(Locale, 0x100u, MultiByteStr, 256, DestStr, 256, CodePage, 0);
        __crtLCMapStringA(Locale, 0x200u, MultiByteStr, 256, v10, 256, CodePage, 0);
        result = 0;
        while(1) {
            v6 = CharType [result];
            if((v6 & 1) != 0) {
                byte_6E6661 [result] |= 0x10u;
                v7 = *((_BYTE*) DestStr + result);
            }
            else {
                if((v6 & 2) == 0) {
                    byte_6E6780 [result] = 0;
                    goto LABEL_16;
                }
                byte_6E6661 [result] |= 0x20u;
                v7 = *((_BYTE*) v10 + result);
            }
            byte_6E6780 [result] = v7;
            LABEL_16:
            if(++result >= 0x100)
                return result;
        }
    }
    for(result = 0; result < 0x100; ++result) {
        if(result >= 0x41 && result <= 0x5A) {
            byte_6E6661 [result] |= 0x10u;
            v8 = result + 32;
            LABEL_22:
            byte_6E6780 [result] = v8;
            continue;
        }
        if(result >= 0x61 && result <= 0x7A) {
            byte_6E6661 [result] |= 0x20u;
            v8 = result - 32;
            goto LABEL_22;
        }
        byte_6E6780 [result] = 0;
    }
    return result;
}
// 47A630: using guessed type int dword_47A630;
// 466C38: using guessed type CHAR MultiByteStr[256];
// 466C38: using guessed type WORD CharType[256];

//----- (00466DCA) --------------------------------------------------------
_DWORD* sub_466DCA() {
    int v0; // edi
    _DWORD* v1; // esi
    int v4; // [esp-4h] [ebp-30h]

    _lock(13);
    v0 = _getptd(v4);
    v1 = *(_DWORD**) (v0 + 96);
    if(v1 != dword_6E6654) {
        if(v1) {
            if((*v1)-- == 1)
                free(v1);
        }
        *(_DWORD*) (v0 + 96) = dword_6E6654;
        v1 = dword_6E6654;
        ++* (_DWORD*) dword_6E6654;
    }
    _unlock(13);
    return v1;
}
// 466DE2: variable 'v4' is possibly undefined
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 461817: using guessed type int __thiscall _getptd(_DWORD);

//----- (00466E39) --------------------------------------------------------
int __cdecl sub_466E39(UINT CodePage) {
    int v1; // edx
    unsigned int i; // eax
    bool v3; // cc
    BYTE* v4; // ecx
    BYTE v5; // dl
    unsigned int k; // eax
    _BYTE* v7; // ebx
    unsigned int v8; // eax
    _BYTE* j; // esi
    unsigned __int8 v10; // dl
    unsigned int v11; // edi
    char v12; // dl
    int v13; // eax
    int v14; // ecx
    _DWORD* v15; // ecx
    unsigned int m; // eax
    int v17; // ecx
    struct _cpinfo CPInfo; // [esp+Ch] [ebp-1Ch] BYREF
    unsigned int v20; // [esp+20h] [ebp-8h]
    unsigned int v21; // [esp+24h] [ebp-4h]
    unsigned int retaddr; // [esp+2Ch] [ebp+4h]

    v21 = retaddr ^ dword_47A630;
    if(CodePage) {
        v1 = 0;
        for(i = 0; i < 60; i += 12) {
            if(dword_47B3F8 [i] == CodePage) {
                memset(byte_6E6660, 0, 0x100u);
                v20 = 0;
                byte_6E6660 [256] = 0;
                v7 = (char*) &unk_47B408 + 48 * v1;
                do {
                    LOBYTE(v8) = *v7;
                    for(j = v7; (_BYTE) v8; LOBYTE(v8) = *j) {
                        v10 = j [1];
                        if(!v10)
                            break;
                        v8 = (unsigned __int8) v8;
                        v11 = v10;
                        if((unsigned __int8) v8 <= (unsigned int) v10) {
                            v12 = byte_47B3F0 [v20];
                            do
                                byte_6E6661 [v8++] |= v12;
                            while(v8 <= v11);
                        }
                        j += 2;
                    }
                    ++v20;
                    v7 += 8;
                }
                while(v20 < 4);
                ::CodePage = CodePage;
                dword_6E6658 = 1;
                v13 = CPtoLCID();
                v15 = (_DWORD*) ((char*) &unk_47B3FC + v14);
                *(_DWORD*) word_6E6770 = *v15;
                *(_DWORD*) &word_6E6770 [2] = v15 [1];
                Locale = v13;
                *(_DWORD*) &word_6E6770 [4] = v15 [2];
                goto LABEL_31;
            }
            ++v1;
        }
        if(GetCPInfo(CodePage, &CPInfo)) {
            v3 = CPInfo.MaxCharSize <= 1;
            memset(byte_6E6660, 0, 0x100u);
            byte_6E6660 [256] = 0;
            ::CodePage = CodePage;
            Locale = 0;
            if(v3) {
                dword_6E6658 = 0;
            }
            else {
                if(CPInfo.LeadByte [0]) {
                    v4 = &CPInfo.LeadByte [1];
                    do {
                        v5 = *v4;
                        if(!*v4)
                            break;
                        for(k = *(v4 - 1); k <= v5; ++k)
                            byte_6E6661 [k] |= 4u;
                        v4 += 2;
                    }
                    while(*(v4 - 1));
                }
                for(m = 1; m < 0xFF; ++m)
                    byte_6E6661 [m] |= 8u;
                Locale = CPtoLCID();
                dword_6E6658 = v17;
            }
            *(_DWORD*) word_6E6770 = 0;
            *(_DWORD*) &word_6E6770 [2] = 0;
            *(_DWORD*) &word_6E6770 [4] = 0;
            goto LABEL_31;
        }
        if(dword_6E655C)
            goto LABEL_30;
        return -1;
    }
    else {
        LABEL_30:
        setSBCS();
        LABEL_31:
        sub_466C38();
        return 0;
    }
}
// 466F3D: variable 'v14' is possibly undefined
// 466F8C: variable 'v17' is possibly undefined
// 466BE0: using guessed type int CPtoLCID(void);
// 466C0F: using guessed type int setSBCS(void);
// 47A630: using guessed type int dword_47A630;
// 47B3F8: using guessed type int dword_47B3F8[];
// 6E655C: using guessed type int dword_6E655C;
// 6E6658: using guessed type int dword_6E6658;
// 6E6770: using guessed type __int16 word_6E6770[];

//----- (00466FCF) --------------------------------------------------------
int __cdecl sub_466FCF(UINT CodePage) {
    UINT OEMCP; // eax
    _DWORD* v2; // esi
    int i; // eax
    int j; // eax
    int k; // eax
    int v7; // [esp+14h] [ebp-1Ch]
    UINT CodePagea; // [esp+38h] [ebp+8h]

    v7 = -1;
    _lock(13);
    dword_6E655C = 0;
    OEMCP = CodePage;
    switch(CodePage) {
        case 0xFFFFFFFE:
            dword_6E655C = 1;
            OEMCP = GetOEMCP();
            break;
        case 0xFFFFFFFD:
            dword_6E655C = 1;
            OEMCP = GetACP();
            break;
        case 0xFFFFFFFC:
            dword_6E655C = 1;
            OEMCP = dword_6E6530;
            break;
    }
    CodePagea = OEMCP;
    if(OEMCP == ::CodePage) {
        v7 = 0;
    }
    else {
        v2 = dword_6E6654;
        if(!dword_6E6654 || *(_DWORD*) dword_6E6654)
            v2 = malloc(0x220u);
        if(v2) {
            v7 = sub_466E39(CodePagea);
            if(!v7) {
                *v2 = 0;
                v2 [1] = ::CodePage;
                v2 [2] = dword_6E6658;
                v2 [3] = Locale;
                for(i = 0; i < 5; ++i)
                    *((_WORD*) v2 + i + 8) = word_6E6770 [i];
                for(j = 0; j < 257; ++j)
                    *((_BYTE*) v2 + j + 28) = byte_6E6660 [j];
                for(k = 0; k < 256; ++k)
                    *((_BYTE*) v2 + k + 285) = byte_6E6780 [k];
                dword_6E6654 = v2;
            }
        }
        if(v7 == -1 && v2 != dword_6E6654)
            free(v2);
    }
    _unlock(13);
    return v7;
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 6E6530: using guessed type int dword_6E6530;
// 6E655C: using guessed type int dword_6E655C;
// 6E6658: using guessed type int dword_6E6658;
// 6E6770: using guessed type __int16 word_6E6770[];

//----- (004671A5) --------------------------------------------------------
int sub_4671A5() {
    return 0;
}

//----- (004672E4) --------------------------------------------------------
int __cdecl sub_4672E4(int a1) {
    int v1; // edi
    int v2; // esi

    v1 = 36 * (a1 & 0x1F);
    v2 = v1 + dword_6E68A0 [a1 >> 5];
    if(!*(_DWORD*) (v2 + 8)) {
        _lock(10);
        if(!*(_DWORD*) (v2 + 8)) {
            if(!__crtInitCritSecAndSpinCount(v2 + 12, 4000)) {
                _unlock(10);
                return 0;
            }
            ++* (_DWORD*) (v2 + 8);
        }
        _unlock(10);
    }
    EnterCriticalSection((LPCRITICAL_SECTION) (dword_6E68A0 [a1 >> 5] + v1 + 12));
    return 1;
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4663F4: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);
// 6E68A0: using guessed type int dword_6E68A0[];

//----- (00467379) --------------------------------------------------------
int sub_467379() {
    int v0; // ebp
    int v1; // ebx
    int* v2; // edi
    unsigned int v3; // esi
    unsigned int i; // eax
    char* v5; // eax
    unsigned int j; // edx
    int v8; // [esp+4h] [ebp-8h]
    int v9; // [esp+8h] [ebp-4h]

    v0 = -1;
    if(sub_45F548(11)) {
        _lock(11);
        v1 = 0;
        v8 = 0;
        v9 = 0;
        v2 = dword_6E68A0;
        while(2) {
            v3 = *v2;
            if(*v2) {
                for(i = v3 + 1152; v3 < i; i = *v2 + 1152) {
                    if((*(_BYTE*) (v3 + 4) & 1) == 0) {
                        if(!*(_DWORD*) (v3 + 8)) {
                            _lock(10);
                            if(!*(_DWORD*) (v3 + 8)) {
                                if(!__crtInitCritSecAndSpinCount(v3 + 12, 4000)) {
                                    _unlock(10);
                                    goto LABEL_26;
                                }
                                ++* (_DWORD*) (v3 + 8);
                            }
                            _unlock(10);
                        }
                        EnterCriticalSection((LPCRITICAL_SECTION) (v3 + 12));
                        if((*(_BYTE*) (v3 + 4) & 1) == 0) {
                            *(_DWORD*) v3 = -1;
                            v0 = v9 + (int) (v3 - *v2) / 36;
                            if(v0 != -1)
                                goto LABEL_27;
                            v1 = v8;
                            break;
                        }
                        LeaveCriticalSection((LPCRITICAL_SECTION) (v3 + 12));
                        v1 = v8;
                    }
                    v3 += 36;
                }
                v9 += 32;
                ++v1;
                ++v2;
                v8 = v1;
                if((int) v2 < (int) &dword_6E69A0)
                    continue;
            }
            else {
                v5 = (char*) malloc(0x480u);
                if(v5) {
                    uNumber += 32;
                    dword_6E68A0 [v1] = (int) v5;
                    for(j = (unsigned int) (v5 + 1152); (unsigned int) v5 < j; j = dword_6E68A0 [v1] + 1152) {
                        v5 [4] = 0;
                        *(_DWORD*) v5 = -1;
                        *((_DWORD*) v5 + 2) = 0;
                        v5 [5] = 10;
                        v5 += 36;
                    }
                    v0 = 32 * v1;
                    if(!sub_4672E4(32 * v1))
                        LABEL_26:
                    v0 = -1;
                }
            }
            break;
        }
        LABEL_27:
        _unlock(11);
    }
    return v0;
}
// 45F533: using guessed type _DWORD __cdecl _unlock(_DWORD);
// 45F5C7: using guessed type _DWORD __cdecl _lock(_DWORD);
// 4663F4: using guessed type _DWORD __cdecl __crtInitCritSecAndSpinCount(_DWORD, _DWORD);
// 6E68A0: using guessed type int dword_6E68A0[];
// 6E69A0: using guessed type int dword_6E69A0;

//----- (00467DDA) --------------------------------------------------------
BOOL sub_467DDA() {
    void* v0; // esp
    char* AllocationBase; // edi
    char* v2; // esi
    int v3; // eax
    char* v4; // ebx
    PVOID BaseAddress; // ebx
    _BYTE v7 [16]; // [esp-4h] [ebp-58h] BYREF
    struct _SYSTEM_INFO SystemInfo; // [esp+Ch] [ebp-48h] BYREF
    struct _MEMORY_BASIC_INFORMATION Buffer; // [esp+30h] [ebp-24h] BYREF
    DWORD flOldProtect; // [esp+4Ch] [ebp-8h] BYREF
    SIZE_T dwSize; // [esp+50h] [ebp-4h]

    v0 = alloca(4);
    if(!VirtualQuery(v7, &Buffer, 0x1Cu))
        return 0;
    AllocationBase = (char*) Buffer.AllocationBase;
    GetSystemInfo(&SystemInfo);
    v2 = (char*) (((unsigned int) v7 & ~(SystemInfo.dwPageSize - 1)) - SystemInfo.dwPageSize);
    dwSize = SystemInfo.dwPageSize;
    v3 = dword_6E6200;
    if(v2 < &AllocationBase [dword_6E6200 != 1 ? 0x2000 : 69632])
        return 0;
    if(dword_6E6200 != 1) {
        v4 = AllocationBase;
        while(VirtualQuery(v4, &Buffer, 0x1Cu)) {
            v4 += Buffer.RegionSize;
            if((Buffer.State & 0x1000) != 0) {
                BaseAddress = Buffer.BaseAddress;
                if((Buffer.Protect & 0x100) != 0)
                    return 1;
                if(v2 >= Buffer.BaseAddress) {
                    VirtualAlloc(Buffer.BaseAddress, dwSize, 0x1000u, 4u);
                    v3 = dword_6E6200;
                    return VirtualProtect(BaseAddress, dwSize, v3 != 1 ? 260 : 1, &flOldProtect);
                }
                return 0;
            }
        }
        return 0;
    }
    BaseAddress = (PVOID) (((unsigned int) v7 & ~(SystemInfo.dwPageSize - 1)) - SystemInfo.dwPageSize);
    return VirtualProtect(BaseAddress, dwSize, v3 != 1 ? 260 : 1, &flOldProtect);
}
// 6E6200: using guessed type int dword_6E6200;

//----- (00467F98) --------------------------------------------------------
__int16 __cdecl sub_467F98(char* a1, int a2, int a3) {
    int v4; // eax
    unsigned int v5; // ecx
    unsigned __int64 v6; // kr08_8
    int v7; // eax
    __int16 result; // ax
    int v9; // [esp+Ch] [ebp-14h] BYREF
    int v10; // [esp+10h] [ebp-10h]
    int v11; // [esp+14h] [ebp-Ch]
    int v12; // [esp+18h] [ebp-8h]
    unsigned int v13; // [esp+1Ch] [ebp-4h]
    unsigned int retaddr; // [esp+24h] [ebp+4h]
    int v15; // [esp+30h] [ebp+10h]

    v13 = retaddr ^ dword_47A630;
    v12 = 16462;
    *(_DWORD*) a3 = 0;
    *(_DWORD*) (a3 + 4) = 0;
    *(_DWORD*) (a3 + 8) = 0;
    if(a2) {
        v15 = a2;
        do {
            v9 = *(_DWORD*) a3;
            v10 = *(_DWORD*) (a3 + 4);
            v11 = *(_DWORD*) (a3 + 8);
            __shl_12(a3);
            __shl_12(a3);
            __add_12(a3, &v9);
            __shl_12(a3);
            v4 = *a1;
            v10 = 0;
            v11 = 0;
            v9 = v4;
            __add_12(a3, &v9);
            ++a1;
            --v15;
        }
        while(v15);
    }
    if(!*(_DWORD*) (a3 + 8)) {
        do {
            v5 = *(_DWORD*) (a3 + 4);
            v12 += 65520;
            v6 = (unsigned __int64) v5 << 16;
            v7 = *(_DWORD*) a3 << 16;
            *(_DWORD*) (a3 + 4) = v6 | HIWORD(*(_DWORD*) a3);
            *(_DWORD*) a3 = v7;
        }
        while(is_mul_ok(0x10000u, v5));
        *(_DWORD*) (a3 + 8) = HIDWORD(v6);
    }
    while((*(_DWORD*) (a3 + 8) & 0x8000) == 0) {
        __shl_12(a3);
        v12 += 0xFFFF;
    }
    result = v12;
    *(_WORD*) (a3 + 10) = v12;
    return result;
}
// 467EDF: using guessed type _DWORD __cdecl __add_12(_DWORD, _DWORD);
// 467F3D: using guessed type _DWORD __cdecl __shl_12(_DWORD);
// 47A630: using guessed type int dword_47A630;

//----- (0046807C) --------------------------------------------------------
int __cdecl sub_46807C(int a1, char** a2, char* a3, int a4, int a5, int a6, int a7) {
    int v7; // eax
    char* v8; // edi
    char* v9; // esi
    char v10; // cl
    char v11; // bl
    char* v12; // ecx
    bool v13; // zf
    int v14; // esi
    int i; // eax
    int v16; // eax
    int v17; // eax
    __int16 v18; // dx
    int v19; // ebx
    unsigned int v20; // esi
    __int16 v21; // ax
    __int16 v22; // ax
    int result; // eax
    int v24; // [esp-4h] [ebp-68h]
    int v25; // [esp-4h] [ebp-68h]
    char v26 [23]; // [esp+Ch] [ebp-58h] BYREF
    char v27; // [esp+23h] [ebp-41h]
    _WORD v28 [3]; // [esp+28h] [ebp-3Ch] BYREF
    unsigned int v29; // [esp+2Eh] [ebp-36h]
    int v30; // [esp+32h] [ebp-32h]
    int v31; // [esp+38h] [ebp-2Ch]
    int v32; // [esp+3Ch] [ebp-28h]
    int v33; // [esp+40h] [ebp-24h]
    int v34; // [esp+44h] [ebp-20h]
    int v35; // [esp+48h] [ebp-1Ch]
    int v36; // [esp+4Ch] [ebp-18h]
    int v37; // [esp+50h] [ebp-14h]
    int v38; // [esp+54h] [ebp-10h]
    unsigned int v39; // [esp+58h] [ebp-Ch]
    char* v40; // [esp+5Ch] [ebp-8h]
    unsigned int v41; // [esp+60h] [ebp-4h]
    unsigned int retaddr; // [esp+68h] [ebp+4h]

    v41 = retaddr ^ dword_47A630;
    v7 = 0;
    v8 = a3;
    v9 = v26;
    v40 = v26;
    v31 = 0;
    v35 = 1;
    v39 = 0;
    v37 = 0;
    v32 = 0;
    v33 = 0;
    v34 = 0;
    v38 = 0;
    v36 = 0;
    while(1) {
        v10 = *v8;
        if(*v8 != 32 && v10 != 9 && v10 != 10 && v10 != 13)
            break;
        ++v8;
    }
    while(2) {
        v11 = *v8++;
        switch(v7) {
            case 0:
                if(v11 >= 49 && v11 <= 57)
                    goto LABEL_10;
                if(v11 == byte_47B2A0)
                    goto LABEL_12;
                switch(v11) {
                    case '+':
                        v31 = 0;
                        v7 = 2;
                        continue;
                    case '-':
                        v7 = 2;
                        v31 = 0x8000;
                        continue;
                    case '0':
                        goto LABEL_36;
                }
                v40 = v9;
                --v8;
                goto LABEL_72;
            case 1:
                v7 = 1;
                v37 = 1;
                if(v11 >= 49 && v11 <= 57)
                    goto LABEL_10;
                if(v11 == byte_47B2A0)
                    goto LABEL_22;
                if(v11 == 43 || v11 == 45)
                    goto LABEL_31;
                if(v11 == 48)
                    continue;
                goto LABEL_26;
            case 2:
                if(v11 >= 49 && v11 <= 57) {
                    LABEL_10:
                    v24 = 3;
                    LABEL_82:
                    v7 = v24;
                    --v8;
                    continue;
                }
                if(v11 == byte_47B2A0) {
                    LABEL_12:
                    v25 = 5;
                    LABEL_90:
                    v7 = v25;
                    continue;
                }
                if(v11 == 48) {
                    LABEL_36:
                    v7 = 1;
                    continue;
                }
                LABEL_84:
                v8 = a3;
                LABEL_71:
                v40 = v9;
                LABEL_72:
                v13 = v37 == 0;
                *a2 = v8;
                if(v13) {
                    v36 = 4;
                    LABEL_119:
                    v18 = 0;
                    v21 = 0;
                    v20 = 0;
                    v19 = 0;
                    goto LABEL_120;
                }
                if(v39 > 0x18) {
                    if(v27 >= 5)
                        ++v27;
                    --v9;
                    ++v38;
                    v39 = 24;
                }
                if(!v39)
                    goto LABEL_119;
                while(!*--v9) {
                    --v39;
                    ++v38;
                }
                sub_467F98(v26, v39, (int) v28);
                v16 = v34;
                if(v35 < 0)
                    v16 = -v34;
                v17 = v38 + v16;
                if(!v33)
                    v17 += a5;
                if(!v32)
                    v17 -= a6;
                if(v17 > 5200) {
                    v19 = 0;
                    v21 = 0x7FFF;
                    v20 = 0x80000000;
                    v18 = 0;
                    v36 = 2;
                    goto LABEL_120;
                }
                if(v17 < -5200) {
                    v36 = 1;
                    goto LABEL_119;
                }
                sub_468ED1(v28, v17, a4);
                v18 = v28 [0];
                v19 = *(_DWORD*) &v28 [1];
                v20 = v29;
                v21 = v30;
                LABEL_120:
                v22 = v31 | v21;
                *(_DWORD*) (a1 + 2) = v19;
                *(_DWORD*) (a1 + 6) = v20;
                *(_WORD*) (a1 + 10) = v22;
                result = v36;
                *(_WORD*) a1 = v18;
                return result;
            case 3:
                v37 = 1;
                while(isdigit((unsigned __int8) v11)) {
                    if(v39 >= 0x19) {
                        ++v38;
                    }
                    else {
                        ++v39;
                        *v9++ = v11 - 48;
                    }
                    v11 = *v8++;
                }
                if(v11 != byte_47B2A0)
                    goto LABEL_54;
                LABEL_22:
                v25 = 4;
                goto LABEL_90;
            case 4:
                v37 = 1;
                v32 = 1;
                if(!v39) {
                    while(v11 == 48) {
                        --v38;
                        v11 = *v8++;
                    }
                }
                while(isdigit((unsigned __int8) v11)) {
                    if(v39 < 0x19) {
                        ++v39;
                        *v9++ = v11 - 48;
                        --v38;
                    }
                    v11 = *v8++;
                }
                LABEL_54:
                if(v11 == 43 || v11 == 45) {
                    LABEL_31:
                    --v8;
                    v25 = 11;
                }
                else {
                    LABEL_26:
                    if(v11 <= 67 || v11 > 69 && (v11 <= 99 || v11 > 101)) {
                        LABEL_70:
                        --v8;
                        goto LABEL_71;
                    }
                    v25 = 6;
                }
                goto LABEL_90;
            case 5:
                v32 = 1;
                if(!isdigit((unsigned __int8) v11))
                    goto LABEL_84;
                v24 = 4;
                goto LABEL_82;
            case 6:
                v12 = v8 - 2;
                a3 = v8 - 2;
                if(v11 >= 49 && v11 <= 57)
                    goto LABEL_81;
                if(v11 == 43)
                    goto LABEL_89;
                if(v11 == 45)
                    goto LABEL_88;
                if(v11 != 48)
                    goto LABEL_94;
                LABEL_64:
                v25 = 8;
                goto LABEL_90;
            case 7:
                if(v11 >= 49 && v11 <= 57)
                    goto LABEL_81;
                if(v11 != 48)
                    goto LABEL_84;
                goto LABEL_64;
            case 8:
                v33 = 1;
                while(v11 == 48)
                    v11 = *v8++;
                if(v11 < 49 || v11 > 57)
                    goto LABEL_70;
                LABEL_81:
                v24 = 9;
                goto LABEL_82;
            case 9:
                v40 = v9;
                v33 = 1;
                v14 = 0;
                while(2) {
                    if(isdigit((unsigned __int8) v11)) {
                        v14 = v11 + 10 * v14 - 48;
                        if(v14 <= 5200) {
                            v11 = *v8++;
                            continue;
                        }
                        v14 = 5201;
                    }
                    break;
                }
                v34 = v14;
                for(i = (unsigned __int8) v11; isdigit(i); i = (unsigned __int8) i)
                    LOBYTE(i) = *v8++;
                v9 = v40;
                --v8;
                goto LABEL_72;
            case 11:
                if(a7) {
                    v12 = v8 - 1;
                    a3 = v8 - 1;
                    if(v11 == 43) {
                        LABEL_89:
                        v25 = 7;
                        goto LABEL_90;
                    }
                    if(v11 != 45) {
                        LABEL_94:
                        v40 = v9;
                        v8 = v12;
                        goto LABEL_72;
                    }
                    LABEL_88:
                    v35 = -1;
                    v7 = 7;
                }
                else {
                    v7 = 10;
                    --v8;
                    LABEL_92:
                    if(v7 == 10)
                        goto LABEL_71;
                }
                continue;
            default:
                goto LABEL_92;
        }
    }
}
// 47A630: using guessed type int dword_47A630;
// 47B2A0: using guessed type char byte_47B2A0;

//----- (004684B6) --------------------------------------------------------
int __cdecl sub_4684B6(__int64 a1, __int16 a2, int a3, char a4, int a5) {
    unsigned __int16 v5; // dx
    int v6; // esi
    int v7; // edi
    int v8; // esi
    int i; // esi
    _BYTE* v10; // eax
    char v11; // al
    _BYTE* v12; // ecx
    bool v13; // zf
    char* v14; // eax
    char v15; // cl
    char* v16; // eax
    bool v17; // cc
    char* v18; // ecx
    char v19; // al
    __int64 v21; // [esp+Ch] [ebp-30h] BYREF
    int v22; // [esp+14h] [ebp-28h]
    char v23 [12]; // [esp+18h] [ebp-24h] BYREF
    _BYTE v24 [12]; // [esp+24h] [ebp-18h] BYREF
    int v25; // [esp+30h] [ebp-Ch]
    int v26; // [esp+34h] [ebp-8h]
    unsigned int v27; // [esp+38h] [ebp-4h]
    unsigned int retaddr; // [esp+40h] [ebp+4h]
    int v29; // [esp+4Ch] [ebp+10h]
    _BYTE* v30; // [esp+4Ch] [ebp+10h]

    v27 = retaddr ^ dword_47A630;
    memset(v23, 204, 10);
    v23 [10] = -5;
    v23 [11] = 63;
    v26 = 1;
    v5 = a2 & 0x7FFF;
    if(a2 >= 0)
        *(_BYTE*) (a5 + 2) = 32;
    else
        *(_BYTE*) (a5 + 2) = 45;
    if(v5 || a1) {
        if(v5 == 0x7FFF) {
            *(_WORD*) a5 = 1;
            if(a1 != 0x8000000000000000ui64 && (a1 & 0x4000000000000000i64) == 0) {
                strcpy((char*) (a5 + 4), "1#SNAN");
                LABEL_19:
                *(_BYTE*) (a5 + 3) = 6;
                return 0;
            }
            if((a2 & 0x8000) != 0 && HIDWORD(a1) == -1073741824) {
                if(!(_DWORD) a1) {
                    strcpy((char*) (a5 + 4), "1#IND");
                    LABEL_16:
                    *(_BYTE*) (a5 + 3) = 5;
                    return 0;
                }
            }
            else if(a1 == 0x8000000000000000ui64) {
                strcpy((char*) (a5 + 4), "1#INF");
                goto LABEL_16;
            }
            strcpy((char*) (a5 + 4), "1#QNAN");
            goto LABEL_19;
        }
        *(_WORD*) v24 = 0;
        *(_QWORD*) &v24 [2] = a1;
        v6 = (77 * (HIBYTE(v5) + 2 * HIBYTE(HIDWORD(a1))) + 19728 * v5 - 323162868) >> 16;
        *(_WORD*) &v24 [10] = a2 & 0x7FFF;
        sub_468ED1(v24, -(__int16) v6, 1);
        if(*(_WORD*) &v24 [10] >= 0x3FFFu) {
            LOWORD(v6) = v6 + 1;
            sub_468C99((int) v24, (int) v23);
        }
        v7 = a3;
        *(_WORD*) a5 = v6;
        if((a4 & 1) == 0 || (v7 = (__int16) v6 + a3, v7 > 0)) {
            if(v7 > 21)
                v7 = 21;
            v8 = *(unsigned __int16*) &v24 [10] - 16382;
            *(_WORD*) &v24 [10] = 0;
            v29 = 8;
            do {
                __shl_12(v24);
                --v29;
            }
            while(v29);
            if(v8 < 0) {
                for(i = (unsigned __int8) -(char) v8; i; --i)
                    __shr_12(v24);
            }
            v10 = (_BYTE*) (a5 + 4);
            v30 = (_BYTE*) (a5 + 4);
            if(v7 + 1 > 0) {
                v25 = v7 + 1;
                do {
                    v21 = *(_QWORD*) v24;
                    v22 = *(_DWORD*) &v24 [8];
                    __shl_12(v24);
                    __shl_12(v24);
                    __add_12(v24, &v21);
                    __shl_12(v24);
                    v11 = v24 [11];
                    v12 = v30;
                    v24 [11] = 0;
                    ++v30;
                    v13 = v25-- == 1;
                    *v12 = v11 + 48;
                }
                while(!v13);
                v10 = v30;
            }
            v14 = v10 - 1;
            v15 = *v14;
            v16 = v14 - 1;
            v17 = v15 < 53;
            v18 = (char*) (a5 + 4);
            if(v17) {
                while(v16 >= v18 && *v16 == 48)
                    --v16;
                if(v16 < v18) {
                    *v18 = 48;
                    goto LABEL_51;
                }
            }
            else {
                while(v16 >= v18 && *v16 == 57)
                    *v16-- = 48;
                if(v16 < v18) {
                    ++v16;
                    ++* (_WORD*) a5;
                }
                ++* v16;
            }
            v19 = (_BYTE) v16 - a5 - 3;
            *(_BYTE*) (a5 + 3) = v19;
            *(_BYTE*) (v19 + a5 + 4) = 0;
            return v26;
        }
    }
    *(_BYTE*) (a5 + 4) = 48;
    LABEL_51:
    *(_WORD*) a5 = 0;
    *(_BYTE*) (a5 + 5) = 0;
    *(_BYTE*) (a5 + 2) = 32;
    *(_BYTE*) (a5 + 3) = 1;
    return 1;
}
// 467EDF: using guessed type _DWORD __cdecl __add_12(_DWORD, _DWORD);
// 467F3D: using guessed type _DWORD __cdecl __shl_12(_DWORD);
// 467F6B: using guessed type _DWORD __cdecl __shr_12(_DWORD);
// 47A630: using guessed type int dword_47A630;

//----- (004688F1) --------------------------------------------------------
int __cdecl sub_4688F1(LCID Locale) {
    CHAR LCData [8]; // [esp+0h] [ebp-Ch] BYREF
    unsigned int v3; // [esp+8h] [ebp-4h]
    unsigned int retaddr; // [esp+10h] [ebp+4h]

    LCData [6] = 0;
    v3 = retaddr ^ dword_47A630;
    if(GetLocaleInfoA(Locale, 0x1004u, LCData, 6))
        return atol(LCData);
    else
        return -1;
}
// 47A630: using guessed type int dword_47A630;

//----- (0046893A) --------------------------------------------------------
void* __cdecl sub_46893A(UINT CodePage, UINT a2, LPCCH lpMultiByteStr, int* a4, LPSTR a5, int a6) {
    int v6; // ebx
    size_t v7; // esi
    void* v8; // esp
    WCHAR* v9; // ebx
    void* v11; // eax
    int v12; // eax
    _BYTE v13 [12]; // [esp+0h] [ebp-54h] BYREF
    WCHAR* v14; // [esp+Ch] [ebp-48h]
    size_t v15; // [esp+10h] [ebp-44h]
    struct _cpinfo CPInfo; // [esp+14h] [ebp-40h] BYREF
    int v17; // [esp+28h] [ebp-2Ch]
    int cbMultiByte; // [esp+2Ch] [ebp-28h]
    int v19; // [esp+30h] [ebp-24h]
    void* Block; // [esp+34h] [ebp-20h]
    unsigned int v21; // [esp+38h] [ebp-1Ch]
    CPPEH_RECORD ms_exc; // [esp+3Ch] [ebp-18h]
    unsigned int retaddr; // [esp+58h] [ebp+4h]

    v21 = retaddr ^ dword_47A630;
    Block = 0;
    v19 = 0;
    v6 = *a4;
    cbMultiByte = *a4;
    v17 = 0;
    if(CodePage == a2) {
        v9 = v14;
    }
    else {
        if(GetCPInfo(CodePage, &CPInfo) && CPInfo.MaxCharSize == 1 && GetCPInfo(a2, &CPInfo) && CPInfo.MaxCharSize == 1)
            v17 = 1;
        if(v17) {
            if(v6 == -1)
                v7 = strlen(lpMultiByteStr) + 1;
            else
                v7 = v6;
            v15 = v7;
        }
        else {
            v7 = v15;
        }
        if(!v17) {
            v7 = MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, v6, 0, 0);
            v15 = v7;
            if(!v7)
                return 0;
        }
        v8 = alloca(2 * v7);
        ms_exc.old_esp = (DWORD) v13;
        v9 = (WCHAR*) v13;
        v14 = (WCHAR*) v13;
        memset(v13, 0, 2 * v7);
        ms_exc.registration.TryLevel = -1;
        if(!v13) {
            v9 = (WCHAR*) sub_45E194(2, v7);
            if(!v9)
                return 0;
            v19 = 1;
        }
        if(MultiByteToWideChar(CodePage, 1u, lpMultiByteStr, cbMultiByte, v9, v7)) {
            if(a5) {
                if(WideCharToMultiByte(a2, 0, v9, v7, a5, a6, 0, 0))
                    Block = a5;
            }
            else if(v17 || (v7 = WideCharToMultiByte(a2, 0, v9, v7, 0, 0, 0, 0)) != 0) {
                v11 = (void*) sub_45E194(1, v7);
                Block = v11;
                if(v11) {
                    v12 = WideCharToMultiByte(a2, 0, v9, v7, (LPSTR) v11, v7, 0, 0);
                    if(v12) {
                        if(cbMultiByte != -1)
                            *a4 = v12;
                    }
                    else {
                        free(Block);
                        Block = 0;
                    }
                }
            }
        }
    }
    if(v19)
        free(v9);
    return Block;
}
// 47A630: using guessed type int dword_47A630;

//----- (00468B5E) --------------------------------------------------------
int __cdecl sub_468B5E(int FileHandle, LONG lDistanceToMove) {
    int v2; // esi
    int v3; // eax
    int v4; // edi
    DWORD v5; // eax
    int v6; // eax
    void* osfhandle; // eax
    BOOL v8; // eax
    unsigned int* v9; // edi
    char Buffer [4096]; // [esp+8h] [ebp-100Ch] BYREF
    int v12; // [esp+1008h] [ebp-Ch]
    LONG v13; // [esp+100Ch] [ebp-8h]
    unsigned int v14; // [esp+1010h] [ebp-4h]
    unsigned int retaddr; // [esp+1018h] [ebp+4h]

    v2 = 0;
    v14 = retaddr ^ dword_47A630;
    v13 = _lseek_lk(FileHandle, 0, 1u);
    if(v13 == -1)
        return -1;
    v3 = _lseek_lk(FileHandle, 0, 2u);
    if(v3 == -1)
        return -1;
    v4 = lDistanceToMove - v3;
    if(lDistanceToMove - v3 <= 0) {
        if(lDistanceToMove - v3 < 0) {
            _lseek_lk(FileHandle, lDistanceToMove, 0);
            osfhandle = (void*) _get_osfhandle(FileHandle);
            v8 = SetEndOfFile(osfhandle);
            v2 = v8 - 1;
            if(!v8) {
                *_errno() = 13;
                v9 = __doserrno();
                *v9 = GetLastError();
            }
        }
    }
    else {
        memset(Buffer, 0, sizeof(Buffer));
        v12 = _setmode_lk(FileHandle, 0x8000);
        while(1) {
            v5 = 4096;
            if(v4 < 4096)
                v5 = v4;
            v6 = sub_463856(FileHandle, Buffer, v5);
            if(v6 == -1)
                break;
            v4 -= v6;
            if(v4 <= 0)
                goto LABEL_13;
        }
        if(*__doserrno() == 5)
            *_errno() = 13;
        v2 = -1;
        LABEL_13:
        _setmode_lk(FileHandle, v12);
    }
    _lseek_lk(FileHandle, v13, 0);
    return v2;
}
// 468FC1: using guessed type _DWORD __cdecl _setmode_lk(_DWORD, _DWORD);
// 47A630: using guessed type int dword_47A630;

//----- (00468C99) --------------------------------------------------------
int __cdecl sub_468C99(int a1, int a2) {
    __int16 v3; // cx
    __int16 v5; // ax
    __int16 v6; // di
    int v7; // ecx
    __int16 v8; // di
    int result; // eax
    int v10; // edi
    unsigned __int16 v11; // dx
    int v12; // ebx
    int v13 [3]; // [esp+Ch] [ebp-28h] BYREF
    int v14; // [esp+18h] [ebp-1Ch]
    int v15; // [esp+1Ch] [ebp-18h]
    int v16; // [esp+20h] [ebp-14h]
    unsigned __int16* v17; // [esp+24h] [ebp-10h]
    unsigned __int16* v18; // [esp+28h] [ebp-Ch]
    int* v19; // [esp+2Ch] [ebp-8h]
    unsigned int v20; // [esp+30h] [ebp-4h]
    unsigned int retaddr; // [esp+38h] [ebp+4h]
    int v22; // [esp+3Ch] [ebp+8h]
    int v23; // [esp+3Ch] [ebp+8h]
    int i; // [esp+40h] [ebp+Ch]

    v20 = retaddr ^ dword_47A630;
    v3 = *(_WORD*) (a2 + 10);
    v15 = 0;
    memset(v13, 0, sizeof(v13));
    v5 = *(_WORD*) (a1 + 10);
    v6 = v3;
    v7 = v3 & 0x7FFF;
    v8 = v5 ^ v6;
    result = v5 & 0x7FFF;
    v10 = v8 & 0x8000;
    v11 = v7 + result;
    v22 = v7 + result;
    if((unsigned __int16) result < 0x7FFFu && (unsigned __int16) v7 < 0x7FFFu && v11 <= 0xBFFDu) {
        if(v11 <= 0x3FBFu) {
            result = 0;
            LABEL_16:
            *(_DWORD*) (a1 + 8) = 0;
            *(_DWORD*) (a1 + 4) = 0;
            *(_DWORD*) a1 = 0;
            return result;
        }
        if((_WORD) result) {
            result = 0;
        }
        else {
            ++v22;
            result = 0;
            if((*(_DWORD*) (a1 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD*) (a1 + 4) && !*(_DWORD*) a1)
                goto LABEL_45;
        }
        if(!(_WORD) v7) {
            ++v22;
            if((*(_DWORD*) (a2 + 8) & 0x7FFFFFFF) == 0 && !*(_DWORD*) (a2 + 4) && !*(_DWORD*) a2)
                goto LABEL_16;
        }
        v16 = 0;
        v19 = &v13 [1];
        for(i = 5; i > 0; --i) {
            v18 = (unsigned __int16*) (a1 + 2 * v16);
            v17 = (unsigned __int16*) (a2 + 8);
            v14 = i;
            do {
                if(__addl(*(v19 - 1), *v18 * *v17, v19 - 1))
                    ++* (_WORD*) v19;
                ++v18;
                --v17;
                --v14;
            }
            while(v14);
            v19 = (int*) ((char*) v19 + 2);
            ++v16;
        }
        v23 = v22 + 49154;
        if((__int16) v23 <= 0)
            goto LABEL_49;
        do {
            if(v13 [2] < 0)
                break;
            __shl_12(v13);
            v23 += 0xFFFF;
        }
        while((__int16) v23 > 0);
        if((__int16) v23 <= 0) {
            LABEL_49:
            v23 += 0xFFFF;
            if((v23 & 0x8000u) != 0) {
                v12 = (unsigned __int16) -(__int16) v23;
                v23 += v12;
                do {
                    if((v13 [0] & 1) != 0)
                        ++v15;
                    __shr_12(v13);
                    --v12;
                }
                while(v12);
                if(v15)
                    LOBYTE(v13 [0]) |= 1u;
            }
        }
        if(LOWORD(v13 [0]) > 0x8000u || (v13 [0] & 0x1FFFF) == 98304) {
            if(*(int*) ((char*) v13 + 2) == -1) {
                *(int*) ((char*) v13 + 2) = 0;
                if(*(int*) ((char*) &v13 [1] + 2) == -1) {
                    *(int*) ((char*) &v13 [1] + 2) = 0;
                    if(HIWORD(v13 [2]) == 0xFFFF) {
                        ++v23;
                        HIWORD(v13 [2]) = 0x8000;
                    }
                    else {
                        ++HIWORD(v13 [2]);
                    }
                }
                else {
                    ++* (int*) ((char*) &v13 [1] + 2);
                }
            }
            else {
                ++* (int*) ((char*) v13 + 2);
            }
        }
        result = v23;
        if((unsigned __int16) v23 < 0x7FFFu) {
            *(_WORD*) a1 = HIWORD(v13 [0]);
            *(_DWORD*) (a1 + 2) = v13 [1];
            *(_DWORD*) (a1 + 6) = v13 [2];
            result = v10 | v23;
            LABEL_45:
            *(_WORD*) (a1 + 10) = result;
            return result;
        }
    }
    *(_DWORD*) (a1 + 4) = 0;
    *(_DWORD*) a1 = 0;
    *(_DWORD*) (a1 + 8) = (_WORD) v10 != 0 ? -32768 : 2147450880;
    return result;
}
// 468D6F: conditional instruction was optimized away because %arg_4.4>=1
// 467EBE: using guessed type _DWORD __cdecl __addl(_DWORD, _DWORD, _DWORD);
// 467F3D: using guessed type _DWORD __cdecl __shl_12(_DWORD);
// 467F6B: using guessed type _DWORD __cdecl __shr_12(_DWORD);
// 47A630: using guessed type int dword_47A630;

//----- (00468ED1) --------------------------------------------------------
unsigned int __cdecl sub_468ED1(_WORD* a1, int a2, int a3) {
    unsigned int result; // eax
    char* v4; // ebx
    char v5; // al
    char* v6; // esi
    _DWORD* v7; // esi
    __int64 v8; // [esp+4h] [ebp-10h] BYREF
    int v9; // [esp+Ch] [ebp-8h]
    unsigned int v10; // [esp+10h] [ebp-4h]
    unsigned int retaddr; // [esp+18h] [ebp+4h]

    result = retaddr ^ dword_47A630;
    v4 = (char*) &unk_47B610 - 96;
    v10 = retaddr ^ dword_47A630;
    if(a2) {
        if(a2 < 0) {
            a2 = -a2;
            v4 = (char*) &unk_47B770 - 96;
        }
        if(!a3) {
            result = (unsigned int) a1;
            *a1 = 0;
        }
        while(a2) {
            v5 = a2;
            a2 >>= 3;
            result = v5 & 7;
            v4 += 84;
            if(result) {
                v6 = &v4 [12 * result];
                if(*(_WORD*) v6 >= 0x8000u) {
                    LODWORD(v8) = *(_DWORD*) v6;
                    v7 = v6 + 4;
                    HIDWORD(v8) = *v7;
                    v9 = v7 [1];
                    --* (_DWORD*) ((char*) &v8 + 2);
                    v6 = (char*) &v8;
                }
                result = sub_468C99((int) a1, (int) v6);
            }
        }
    }
    return result;
}
// 47A630: using guessed type int dword_47A630;

//----- (00469900) --------------------------------------------------------
int sub_469900() {
    return sub_41C790((int) &unk_487AAC);
}

//----- (00469910) --------------------------------------------------------
int sub_469910() {
    return sub_41C790((int) &unk_47B8E0);
}

//----- (00469920) --------------------------------------------------------
int sub_469920() {
    return sub_41C790((int) &unk_487ACC);
}

//----- (00469930) --------------------------------------------------------
int sub_469930() {
    return sub_41C790((int) &unk_487E24);
}

//----- (00469940) --------------------------------------------------------
int sub_469940() {
    return sub_41C790((int) &unk_487AF0);
}

//----- (00469950) --------------------------------------------------------
int sub_469950() {
    return sub_41C790((int) &unk_487E04);
}

//----- (00469960) --------------------------------------------------------
int sub_469960() {
    return sub_41C790((int) &unk_487FBC);
}

//----- (00469970) --------------------------------------------------------
int sub_469970() {
    return sub_41C790((int) &unk_4B7964);
}

//----- (00469980) --------------------------------------------------------
int sub_469980() {
    return sub_41C790((int) &unk_4B7984);
}

//----- (00469990) --------------------------------------------------------
int sub_469990() {
    return sub_41C790((int) &unk_5A5FB4);
}

//----- (004699A0) --------------------------------------------------------
int sub_4699A0() {
    return sub_41C790((int) &unk_4B79A8);
}

//----- (004699B0) --------------------------------------------------------
int sub_4699B0() {
    return sub_41C790((int) &unk_69BC10);
}

//----- (004699C0) --------------------------------------------------------
int sub_4699C0() {
    return sub_41C790((int) &unk_5A5FD8);
}

//----- (004699CF) --------------------------------------------------------
int sub_4699CF() {
    return sub_41C790((int) &unk_69BC7C);
}

//----- (004699DE) --------------------------------------------------------
int sub_4699DE() {
    return sub_41C790((int) &unk_69BC5C);
}

//----- (004699ED) --------------------------------------------------------
int sub_4699ED() {
    return sub_41C790((int) &unk_69D720);
}

//----- (004699FC) --------------------------------------------------------
int sub_4699FC() {
    return sub_41C790((int) &unk_69D740);
}

//----- (00469A10) --------------------------------------------------------
int sub_469A10() {
    return sub_41C6D0(byte_69D918);
}

//----- (00469A20) --------------------------------------------------------
void sub_469A20() {
    ;
}

//----- (00469A30) --------------------------------------------------------
void sub_469A30() {
    ;
}

//----- (00469A40) --------------------------------------------------------
int sub_469A40() {
    return sub_41C790((int) &unk_6C6BB4);
}

//----- (00469A50) --------------------------------------------------------
int sub_469A50() {
    return sub_41C790((int) &unk_69E248);
}

// nfuncs=1358 queued=1041 decompiled=1041 lumina nreq=0 worse=0 better=0
// ALL OK, 1041 function(s) have been successfully decompiled